// vim:foldmethod=marker,foldmarker={{{,}}}:
 
 /**
  * Create a new Blob. Pass either an array of integers (each one in the range
  * [0,255]) to create a blob of those bytes, or pass a single integer to
  * pre-allocate that many bytes to zero.
  *
  * @param lengthOrArray number of bytes to preallocate; or array of initial
  * bytes.
  * 
  * @class
  * Binary data storage class.
  *
  * <br /><br />
  *
  *
  * Javascript strings are stored as UTF8 bytes. This makes storing and processing
  * strings in other encodings or random binary data (such as images) hard. 
  * 
  * <br /><br />
  * To make this easier to handle, we've created the Blob class.
  * 
  * <br /><br />
  * You can treat a Blob similar to an array with its {@link #length} property
  * and array sub-script accessors, but if you are using large blobs it is
  * worth mentioning that each extra property you access this way requires
  * extra memory from Spidermonkey. In this case its highly recomended you use
  * {@link #get} and {@link #set} instead.
  *
  * @see cURL
  *
  *
  * @name Blob
  */

// Constructor Methods {{{
/**#@+
 * @methodOfBlob
 */

  /**
   * Create a blob from the UTF-8 byte sequence of str.
   * @name fromUtf8
   * @type Blob
   *
   * @param {string} str data
   */

  /**
   * Create a blob from the UTF-16 (machine specific endianness) representation
   * of str.
   * @name fromUtf16
   * @type Blob
   *
   * @param {string} str data
   */

/**#@- }}} */

// Instance Methods {{{
/**#@+
 * @methodOf Blob.prototype
 */

  /**
   * Append data from another blob into this one.
   * @name append
   * @type Blob
   *
   * @param {Blob} blob blob to append to this.
   */

  /**
   * Return an Array of bytes
   * @name toArray
   * @type Array
   */

  /**
   * Return a new Blob instance containing a copy of the current contents.
   * @name clone
   * @type Blob
   */

  /**
   * Extract a portion of the data into a new Blob. Either parameter can be
   * negative, in which case it counts backwards from
   * the last byte: 
   *
   * @param {int} from start index
   * @param {int} [to] end index
   *
   * @name slice
   * @type Blob
   */

  /**
   * Convert to a UTF-8 string. This method treats the bytes as a UTF-8 byte
   * sequence.
   *
   * @example 
   * (new Blob([66,66])).asUtf8(); // "BB"
   * (new Blob([66,0xC3,0xE9])).asUtf8(); // "Bé"
   * (new Blob([66,200,200])).asUtf8(); // TypeError
   *
   * @name asUtf8
   * @type string
   * @throws TypeError If the blob contains an invalid UTF-8 sequence
   */

  /**
   * Convert to a UTF-16 string. Similar to {@link #asUtf8}, but instead treat
   * the bytes as a UTF-16 byte sequence.
   *
   * <br /><br /> 
   * Since spidermonkey currently does not handle UTF-16 surrogates (i.e. any
   * characters outside of hte Basic-Multi-Lingual plane) this method shouldn't
   * throw a TypeError.
   *
   * @example
   * (new Blob([66,0,66,0]).asUtf16(); // "BB"
   * (new Blob([66,0,0xE9,0]).asUtf16(); // "Bé"
   *
   * @name asUtf16
   * @type string
   */

  /**
   * Get a byte of data. Provided as alternative means to access data in large
   * blobs without memory bloat.
   *
   * @name get
   *
   * @param int idx byte index
   */

  /**
   * Set a byte of data. idx must be less than the current {@link #length}
   *
   * @name set

   * @param int idx byte index
   */

/**#@- }}}*/

// Instance properties {{{
/**#@+
 * @fieldOf Blob.prototype
 */

  /**
   * Array like access. Cannot change the length of the blob.
   * @name []
   */

  /**
   * Length of the blob in bytes. Setting this value will resize the blob, with
   * new entries initalized to 0.
   *
   * @name length
   */

  /**
   * Iterator that returns values instead of array indicies.
   *
   * @example for (var byte in blob.values) { ... }
   *
   * @name values
   */

  /**
   * Iterator that returns [index,byte] pairs.
   *
   * @example for (var [idx,byte] in blob.pairs) { ... }
   *
   * @name pairs
   */

/**#@- }}} /
