
#define SQLITE_CORE 1 
#define SQLITE_AMALGAMATION 1 
#ifndef SQLITE_PRIVATE 
#define SQLITE_PRIVATE static 
#endif 
#ifndef SQLITE_API 
#define SQLITE_API 
#endif 
#ifndef _SQLITEINT_H_ 
#define _SQLITEINT_H_ 
#ifdef _HAVE_SQLITE_CONFIG_H 
#include "config.h" 
#endif 
#ifndef SQLITE_MAX_LENGTH 
#define SQLITE_MAX_LENGTH 1000000000 
#endif 
#ifndef SQLITE_MAX_COLUMN 
#define SQLITE_MAX_COLUMN 2000 
#endif 
#ifndef SQLITE_MAX_SQL_LENGTH 
#define SQLITE_MAX_SQL_LENGTH 1000000000 
#endif 
#ifndef SQLITE_MAX_EXPR_DEPTH 
#define SQLITE_MAX_EXPR_DEPTH 1000 
#endif 
#ifndef SQLITE_MAX_COMPOUND_SELECT 
#define SQLITE_MAX_COMPOUND_SELECT 500 
#endif 
#ifndef SQLITE_MAX_VDBE_OP 
#define SQLITE_MAX_VDBE_OP 25000 
#endif 
#ifndef SQLITE_MAX_FUNCTION_ARG 
#define SQLITE_MAX_FUNCTION_ARG 100 
#endif 
#ifndef SQLITE_DEFAULT_CACHE_SIZE 
#define SQLITE_DEFAULT_CACHE_SIZE 2000 
#endif 
#ifndef SQLITE_DEFAULT_TEMP_CACHE_SIZE 
#define SQLITE_DEFAULT_TEMP_CACHE_SIZE 500 
#endif 
#ifndef SQLITE_MAX_ATTACHED 
#define SQLITE_MAX_ATTACHED 10 
#endif 
#ifndef SQLITE_MAX_VARIABLE_NUMBER 
#define SQLITE_MAX_VARIABLE_NUMBER 999 
#endif 
#ifndef SQLITE_MAX_PAGE_SIZE 
#define SQLITE_MAX_PAGE_SIZE 32768 
#endif 
#ifndef SQLITE_DEFAULT_PAGE_SIZE 
#define SQLITE_DEFAULT_PAGE_SIZE 1024 
#endif 
#if SQLITE_DEFAULT_PAGE_SIZE>SQLITE_MAX_PAGE_SIZE 
#undef SQLITE_DEFAULT_PAGE_SIZE 
#define SQLITE_DEFAULT_PAGE_SIZE SQLITE_MAX_PAGE_SIZE 
#endif 
#ifndef SQLITE_MAX_DEFAULT_PAGE_SIZE 
#define SQLITE_MAX_DEFAULT_PAGE_SIZE 8192 
#endif 
#if SQLITE_MAX_DEFAULT_PAGE_SIZE>SQLITE_MAX_PAGE_SIZE 
#undef SQLITE_MAX_DEFAULT_PAGE_SIZE 
#define SQLITE_MAX_DEFAULT_PAGE_SIZE SQLITE_MAX_PAGE_SIZE 
#endif 
#ifndef SQLITE_MAX_PAGE_COUNT 
#define SQLITE_MAX_PAGE_COUNT 1073741823 
#endif 
#ifndef SQLITE_MAX_LIKE_PATTERN_LENGTH 
#define SQLITE_MAX_LIKE_PATTERN_LENGTH 50000 
#endif 
#if defined(__BORLANDC__) 
#pragma warn -rch 
#pragma warn -ccc 
#pragma warn -aus 
#pragma warn -csu 
#pragma warn -spa 
#endif 
#ifndef _GNU_SOURCE 
#define _GNU_SOURCE 
#endif 
#ifdef HAVE_STDINT_H 
#include <stdint.h> 
#endif 
#ifdef HAVE_INTTYPES_H 
#include <inttypes.h> 
#endif 
#ifdef SQLITE_COVERAGE_TEST 
SQLITE_PRIVATE void sqlite3Coverage(int); 
#define testcase(X) if( X ){ sqlite3Coverage(__LINE__); } 
#else 
#define testcase(X) 
#endif 
#ifdef SQLITE_COVERAGE_TEST 
#define ALWAYS(X) (1) 
#define NEVER(X) (0) 
#else 
#define ALWAYS(X) (X) 
#define NEVER(X) (X) 
#endif 
#if defined(__GNUC__) && 0 
#define likely(X) __builtin_expect((X),1) 
#define unlikely(X) __builtin_expect((X),0) 
#else 
#define likely(X) !!(X) 
#define unlikely(X) !!(X) 
#endif 
#define SQLITE_INT_TO_PTR(X) ((void*)&((char*)0)[X]) 
#define SQLITE_PTR_TO_INT(X) ((int)(((char*)X)-(char*)0)) 
#ifndef SQLITE_DISABLE_LFS 
#define _LARGE_FILE 1 
#ifndef _FILE_OFFSET_BITS 
#define _FILE_OFFSET_BITS 64 
#endif 
#define _LARGEFILE_SOURCE 1 
#endif 
#if !defined(SQLITE_THREADSAFE) 
#if defined(THREADSAFE) 
#define SQLITE_THREADSAFE THREADSAFE 
#else 
#define SQLITE_THREADSAFE 1 
#endif 
#endif 
#if !defined(SQLITE_DEFAULT_MEMSTATUS) 
#define SQLITE_DEFAULT_MEMSTATUS 1 
#endif 
#if defined(SQLITE_SYSTEM_MALLOC)+defined(SQLITE_MEMDEBUG)+ defined(SQLITE_MEMORY_SIZE)+defined(SQLITE_MMAP_HEAP_SIZE)+ defined(SQLITE_POW2_MEMORY_SIZE)>1 
#error "At most one of the following compile-time configuration options is allows: SQLITE_SYSTEM_MALLOC, SQLITE_MEMDEBUG, SQLITE_MEMORY_SIZE, SQLITE_MMAP_HEAP_SIZE, SQLITE_POW2_MEMORY_SIZE" 
#endif 
#if defined(SQLITE_SYSTEM_MALLOC)+defined(SQLITE_MEMDEBUG)+ defined(SQLITE_MEMORY_SIZE)+defined(SQLITE_MMAP_HEAP_SIZE)+ defined(SQLITE_POW2_MEMORY_SIZE)==0 
#define SQLITE_SYSTEM_MALLOC 1 
#endif 
#if defined(SQLITE_POW2_MEMORY_SIZE) && !defined(SQLITE_MALLOC_SOFT_LIMIT) 
#define SQLITE_MALLOC_SOFT_LIMIT 1024 
#endif 
#if !defined(_XOPEN_SOURCE) && !defined(__DARWIN__) && !defined(__APPLE__) && SQLITE_THREADSAFE 
#define _XOPEN_SOURCE 500 
#endif 
#if defined(SQLITE_TCL) || defined(TCLSH) 
#include <tcl.h> 
#endif 
#if !defined(NDEBUG) && !defined(SQLITE_DEBUG) 
#define NDEBUG 1 
#endif 
#ifndef _SQLITE3_H_ 
#define _SQLITE3_H_ 
#include <stdarg.h> 
#if 0 
extern "C" { 
#endif 
#ifndef SQLITE_EXTERN 
#define SQLITE_EXTERN extern 
#endif 
#define SQLITE_DEPRECATED 
#define SQLITE_EXPERIMENTAL 
#ifdef SQLITE_VERSION 
#undef SQLITE_VERSION 
#endif 
#ifdef SQLITE_VERSION_NUMBER 
#undef SQLITE_VERSION_NUMBER 
#endif 
#define SQLITE_VERSION "3.6.6.2" 
#define SQLITE_VERSION_NUMBER 3006006 
SQLITE_API const char sqlite3_version[]; SQLITE_API const char *sqlite3_libversion(void); SQLITE_API int sqlite3_libversion_number(void); SQLITE_API int sqlite3_threadsafe(void); typedef struct sqlite3 sqlite3; 
#ifdef SQLITE_INT64_TYPE 
 typedef SQLITE_INT64_TYPE sqlite_int64; typedef unsigned SQLITE_INT64_TYPE sqlite_uint64; 
#elif defined(_MSC_VER) || defined(__BORLANDC__) 
 typedef __int64 sqlite_int64; typedef unsigned __int64 sqlite_uint64; 
#else 
 typedef long long int sqlite_int64; typedef unsigned long long int sqlite_uint64; 
#endif 
typedef sqlite_int64 sqlite3_int64; typedef sqlite_uint64 sqlite3_uint64; 
#ifdef SQLITE_OMIT_FLOATING_POINT 
#define double sqlite3_int64 
#endif 
SQLITE_API int sqlite3_close(sqlite3 *); typedef int (*sqlite3_callback)(void*,int,char**, char**); SQLITE_API int sqlite3_exec( sqlite3*, const char *sql, int (*callback)(void*,int,char**,char**), void *, char **errmsg ); 
#define SQLITE_OK 0 
#define SQLITE_ERROR 1 
#define SQLITE_INTERNAL 2 
#define SQLITE_PERM 3 
#define SQLITE_ABORT 4 
#define SQLITE_BUSY 5 
#define SQLITE_LOCKED 6 
#define SQLITE_NOMEM 7 
#define SQLITE_READONLY 8 
#define SQLITE_INTERRUPT 9 
#define SQLITE_IOERR 10 
#define SQLITE_CORRUPT 11 
#define SQLITE_NOTFOUND 12 
#define SQLITE_FULL 13 
#define SQLITE_CANTOPEN 14 
#define SQLITE_PROTOCOL 15 
#define SQLITE_EMPTY 16 
#define SQLITE_SCHEMA 17 
#define SQLITE_TOOBIG 18 
#define SQLITE_CONSTRAINT 19 
#define SQLITE_MISMATCH 20 
#define SQLITE_MISUSE 21 
#define SQLITE_NOLFS 22 
#define SQLITE_AUTH 23 
#define SQLITE_FORMAT 24 
#define SQLITE_RANGE 25 
#define SQLITE_NOTADB 26 
#define SQLITE_ROW 100 
#define SQLITE_DONE 101 
#define SQLITE_IOERR_READ (SQLITE_IOERR | (1<<8)) 
#define SQLITE_IOERR_SHORT_READ (SQLITE_IOERR | (2<<8)) 
#define SQLITE_IOERR_WRITE (SQLITE_IOERR | (3<<8)) 
#define SQLITE_IOERR_FSYNC (SQLITE_IOERR | (4<<8)) 
#define SQLITE_IOERR_DIR_FSYNC (SQLITE_IOERR | (5<<8)) 
#define SQLITE_IOERR_TRUNCATE (SQLITE_IOERR | (6<<8)) 
#define SQLITE_IOERR_FSTAT (SQLITE_IOERR | (7<<8)) 
#define SQLITE_IOERR_UNLOCK (SQLITE_IOERR | (8<<8)) 
#define SQLITE_IOERR_RDLOCK (SQLITE_IOERR | (9<<8)) 
#define SQLITE_IOERR_DELETE (SQLITE_IOERR | (10<<8)) 
#define SQLITE_IOERR_BLOCKED (SQLITE_IOERR | (11<<8)) 
#define SQLITE_IOERR_NOMEM (SQLITE_IOERR | (12<<8)) 
#define SQLITE_IOERR_ACCESS (SQLITE_IOERR | (13<<8)) 
#define SQLITE_IOERR_CHECKRESERVEDLOCK (SQLITE_IOERR | (14<<8)) 
#define SQLITE_IOERR_LOCK (SQLITE_IOERR | (15<<8)) 
#define SQLITE_OPEN_READONLY 0x00000001 
#define SQLITE_OPEN_READWRITE 0x00000002 
#define SQLITE_OPEN_CREATE 0x00000004 
#define SQLITE_OPEN_DELETEONCLOSE 0x00000008 
#define SQLITE_OPEN_EXCLUSIVE 0x00000010 
#define SQLITE_OPEN_MAIN_DB 0x00000100 
#define SQLITE_OPEN_TEMP_DB 0x00000200 
#define SQLITE_OPEN_TRANSIENT_DB 0x00000400 
#define SQLITE_OPEN_MAIN_JOURNAL 0x00000800 
#define SQLITE_OPEN_TEMP_JOURNAL 0x00001000 
#define SQLITE_OPEN_SUBJOURNAL 0x00002000 
#define SQLITE_OPEN_MASTER_JOURNAL 0x00004000 
#define SQLITE_OPEN_NOMUTEX 0x00008000 
#define SQLITE_OPEN_FULLMUTEX 0x00010000 
#define SQLITE_IOCAP_ATOMIC 0x00000001 
#define SQLITE_IOCAP_ATOMIC512 0x00000002 
#define SQLITE_IOCAP_ATOMIC1K 0x00000004 
#define SQLITE_IOCAP_ATOMIC2K 0x00000008 
#define SQLITE_IOCAP_ATOMIC4K 0x00000010 
#define SQLITE_IOCAP_ATOMIC8K 0x00000020 
#define SQLITE_IOCAP_ATOMIC16K 0x00000040 
#define SQLITE_IOCAP_ATOMIC32K 0x00000080 
#define SQLITE_IOCAP_ATOMIC64K 0x00000100 
#define SQLITE_IOCAP_SAFE_APPEND 0x00000200 
#define SQLITE_IOCAP_SEQUENTIAL 0x00000400 
#define SQLITE_LOCK_NONE 0 
#define SQLITE_LOCK_SHARED 1 
#define SQLITE_LOCK_RESERVED 2 
#define SQLITE_LOCK_PENDING 3 
#define SQLITE_LOCK_EXCLUSIVE 4 
#define SQLITE_SYNC_NORMAL 0x00002 
#define SQLITE_SYNC_FULL 0x00003 
#define SQLITE_SYNC_DATAONLY 0x00010 
typedef struct sqlite3_file sqlite3_file; struct sqlite3_file { const struct sqlite3_io_methods *pMethods; }; typedef struct sqlite3_io_methods sqlite3_io_methods; struct sqlite3_io_methods { int iVersion; int (*xClose)(sqlite3_file*); int (*xRead)(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst); int (*xWrite)(sqlite3_file*, const void*, int iAmt, sqlite3_int64 iOfst); int (*xTruncate)(sqlite3_file*, sqlite3_int64 size); int (*xSync)(sqlite3_file*, int flags); int (*xFileSize)(sqlite3_file*, sqlite3_int64 *pSize); int (*xLock)(sqlite3_file*, int); int (*xUnlock)(sqlite3_file*, int); int (*xCheckReservedLock)(sqlite3_file*, int *pResOut); int (*xFileControl)(sqlite3_file*, int op, void *pArg); int (*xSectorSize)(sqlite3_file*); int (*xDeviceCharacteristics)(sqlite3_file*); }; 
#define SQLITE_FCNTL_LOCKSTATE 1 
typedef struct sqlite3_mutex sqlite3_mutex; typedef struct sqlite3_vfs sqlite3_vfs; struct sqlite3_vfs { int iVersion; int szOsFile; int mxPathname; sqlite3_vfs *pNext; const char *zName; void *pAppData; int (*xOpen)(sqlite3_vfs*, const char *zName, sqlite3_file*, int flags, int *pOutFlags); int (*xDelete)(sqlite3_vfs*, const char *zName, int syncDir); int (*xAccess)(sqlite3_vfs*, const char *zName, int flags, int *pResOut); int (*xFullPathname)(sqlite3_vfs*, const char *zName, int nOut, char *zOut); void *(*xDlOpen)(sqlite3_vfs*, const char *zFilename); void (*xDlError)(sqlite3_vfs*, int nByte, char *zErrMsg); void *(*xDlSym)(sqlite3_vfs*,void*, const char *zSymbol); void (*xDlClose)(sqlite3_vfs*, void*); int (*xRandomness)(sqlite3_vfs*, int nByte, char *zOut); int (*xSleep)(sqlite3_vfs*, int microseconds); int (*xCurrentTime)(sqlite3_vfs*, double*); int (*xGetLastError)(sqlite3_vfs*, int, char *); }; 
#define SQLITE_ACCESS_EXISTS 0 
#define SQLITE_ACCESS_READWRITE 1 
#define SQLITE_ACCESS_READ 2 
SQLITE_API int sqlite3_initialize(void); SQLITE_API int sqlite3_shutdown(void); SQLITE_API int sqlite3_os_init(void); SQLITE_API int sqlite3_os_end(void); SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_config(int, ...); SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_db_config(sqlite3*, int op, ...); typedef struct sqlite3_mem_methods sqlite3_mem_methods; struct sqlite3_mem_methods { void *(*xMalloc)(int); void (*xFree)(void*); void *(*xRealloc)(void*,int); int (*xSize)(void*); int (*xRoundup)(int); int (*xInit)(void*); void (*xShutdown)(void*); void *pAppData; }; 
#define SQLITE_CONFIG_SINGLETHREAD 1 
#define SQLITE_CONFIG_MULTITHREAD 2 
#define SQLITE_CONFIG_SERIALIZED 3 
#define SQLITE_CONFIG_MALLOC 4 
#define SQLITE_CONFIG_GETMALLOC 5 
#define SQLITE_CONFIG_SCRATCH 6 
#define SQLITE_CONFIG_PAGECACHE 7 
#define SQLITE_CONFIG_HEAP 8 
#define SQLITE_CONFIG_MEMSTATUS 9 
#define SQLITE_CONFIG_MUTEX 10 
#define SQLITE_CONFIG_GETMUTEX 11 
 
#define SQLITE_CONFIG_LOOKASIDE 13 
#define SQLITE_CONFIG_PCACHE 14 
#define SQLITE_CONFIG_GETPCACHE 15 
#define SQLITE_DBCONFIG_LOOKASIDE 1001 
SQLITE_API int sqlite3_extended_result_codes(sqlite3*, int onoff); SQLITE_API sqlite3_int64 sqlite3_last_insert_rowid(sqlite3*); SQLITE_API int sqlite3_changes(sqlite3*); SQLITE_API int sqlite3_total_changes(sqlite3*); SQLITE_API void sqlite3_interrupt(sqlite3*); SQLITE_API int sqlite3_complete(const char *sql); SQLITE_API int sqlite3_complete16(const void *sql); SQLITE_API int sqlite3_busy_handler(sqlite3*, int(*)(void*,int), void*); SQLITE_API int sqlite3_busy_timeout(sqlite3*, int ms); SQLITE_API int sqlite3_get_table( sqlite3 *db, const char *zSql, char ***pazResult, int *pnRow, int *pnColumn, char **pzErrmsg ); SQLITE_API void sqlite3_free_table(char **result); SQLITE_API char *sqlite3_mprintf(const char*,...); SQLITE_API char *sqlite3_vmprintf(const char*, va_list); SQLITE_API char *sqlite3_snprintf(int,char*,const char*, ...); SQLITE_API void *sqlite3_malloc(int); SQLITE_API void *sqlite3_realloc(void*, int); SQLITE_API void sqlite3_free(void*); SQLITE_API sqlite3_int64 sqlite3_memory_used(void); SQLITE_API sqlite3_int64 sqlite3_memory_highwater(int resetFlag); SQLITE_API void sqlite3_randomness(int N, void *P); SQLITE_API int sqlite3_set_authorizer( sqlite3*, int (*xAuth)(void*,int,const char*,const char*,const char*,const char*), void *pUserData ); 
#define SQLITE_DENY 1 
#define SQLITE_IGNORE 2 
#define SQLITE_CREATE_INDEX 1 
#define SQLITE_CREATE_TABLE 2 
#define SQLITE_CREATE_TEMP_INDEX 3 
#define SQLITE_CREATE_TEMP_TABLE 4 
#define SQLITE_CREATE_TEMP_TRIGGER 5 
#define SQLITE_CREATE_TEMP_VIEW 6 
#define SQLITE_CREATE_TRIGGER 7 
#define SQLITE_CREATE_VIEW 8 
#define SQLITE_DELETE 9 
#define SQLITE_DROP_INDEX 10 
#define SQLITE_DROP_TABLE 11 
#define SQLITE_DROP_TEMP_INDEX 12 
#define SQLITE_DROP_TEMP_TABLE 13 
#define SQLITE_DROP_TEMP_TRIGGER 14 
#define SQLITE_DROP_TEMP_VIEW 15 
#define SQLITE_DROP_TRIGGER 16 
#define SQLITE_DROP_VIEW 17 
#define SQLITE_INSERT 18 
#define SQLITE_PRAGMA 19 
#define SQLITE_READ 20 
#define SQLITE_SELECT 21 
#define SQLITE_TRANSACTION 22 
#define SQLITE_UPDATE 23 
#define SQLITE_ATTACH 24 
#define SQLITE_DETACH 25 
#define SQLITE_ALTER_TABLE 26 
#define SQLITE_REINDEX 27 
#define SQLITE_ANALYZE 28 
#define SQLITE_CREATE_VTABLE 29 
#define SQLITE_DROP_VTABLE 30 
#define SQLITE_FUNCTION 31 
#define SQLITE_COPY 0 
SQLITE_API SQLITE_EXPERIMENTAL void *sqlite3_trace(sqlite3*, void(*xTrace)(void*,const char*), void*); SQLITE_API SQLITE_EXPERIMENTAL void *sqlite3_profile(sqlite3*, void(*xProfile)(void*,const char*,sqlite3_uint64), void*); SQLITE_API void sqlite3_progress_handler(sqlite3*, int, int(*)(void*), void*); SQLITE_API int sqlite3_open( const char *filename, sqlite3 **ppDb ); SQLITE_API int sqlite3_open16( const void *filename, sqlite3 **ppDb ); SQLITE_API int sqlite3_open_v2( const char *filename, sqlite3 **ppDb, int flags, const char *zVfs ); SQLITE_API int sqlite3_errcode(sqlite3 *db); SQLITE_API int sqlite3_extended_errcode(sqlite3 *db); SQLITE_API const char *sqlite3_errmsg(sqlite3*); SQLITE_API const void *sqlite3_errmsg16(sqlite3*); typedef struct sqlite3_stmt sqlite3_stmt; SQLITE_API int sqlite3_limit(sqlite3*, int id, int newVal); 
#define SQLITE_LIMIT_LENGTH 0 
#define SQLITE_LIMIT_SQL_LENGTH 1 
#define SQLITE_LIMIT_COLUMN 2 
#define SQLITE_LIMIT_EXPR_DEPTH 3 
#define SQLITE_LIMIT_COMPOUND_SELECT 4 
#define SQLITE_LIMIT_VDBE_OP 5 
#define SQLITE_LIMIT_FUNCTION_ARG 6 
#define SQLITE_LIMIT_ATTACHED 7 
#define SQLITE_LIMIT_LIKE_PATTERN_LENGTH 8 
#define SQLITE_LIMIT_VARIABLE_NUMBER 9 
SQLITE_API int sqlite3_prepare( sqlite3 *db, const char *zSql, int nByte, sqlite3_stmt **ppStmt, const char **pzTail ); SQLITE_API int sqlite3_prepare_v2( sqlite3 *db, const char *zSql, int nByte, sqlite3_stmt **ppStmt, const char **pzTail ); SQLITE_API int sqlite3_prepare16( sqlite3 *db, const void *zSql, int nByte, sqlite3_stmt **ppStmt, const void **pzTail ); SQLITE_API int sqlite3_prepare16_v2( sqlite3 *db, const void *zSql, int nByte, sqlite3_stmt **ppStmt, const void **pzTail ); SQLITE_API const char *sqlite3_sql(sqlite3_stmt *pStmt); typedef struct Mem sqlite3_value; typedef struct sqlite3_context sqlite3_context; SQLITE_API int sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*)); SQLITE_API int sqlite3_bind_double(sqlite3_stmt*, int, double); SQLITE_API int sqlite3_bind_int(sqlite3_stmt*, int, int); SQLITE_API int sqlite3_bind_int64(sqlite3_stmt*, int, sqlite3_int64); SQLITE_API int sqlite3_bind_null(sqlite3_stmt*, int); SQLITE_API int sqlite3_bind_text(sqlite3_stmt*, int, const char*, int n, void(*)(void*)); SQLITE_API int sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int, void(*)(void*)); SQLITE_API int sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*); SQLITE_API int sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n); SQLITE_API int sqlite3_bind_parameter_count(sqlite3_stmt*); SQLITE_API const char *sqlite3_bind_parameter_name(sqlite3_stmt*, int); SQLITE_API int sqlite3_bind_parameter_index(sqlite3_stmt*, const char *zName); SQLITE_API int sqlite3_clear_bindings(sqlite3_stmt*); SQLITE_API int sqlite3_column_count(sqlite3_stmt *pStmt); SQLITE_API const char *sqlite3_column_name(sqlite3_stmt*, int N); SQLITE_API const void *sqlite3_column_name16(sqlite3_stmt*, int N); SQLITE_API const char *sqlite3_column_database_name(sqlite3_stmt*,int); SQLITE_API const void *sqlite3_column_database_name16(sqlite3_stmt*,int); SQLITE_API const char *sqlite3_column_table_name(sqlite3_stmt*,int); SQLITE_API const void *sqlite3_column_table_name16(sqlite3_stmt*,int); SQLITE_API const char *sqlite3_column_origin_name(sqlite3_stmt*,int); SQLITE_API const void *sqlite3_column_origin_name16(sqlite3_stmt*,int); SQLITE_API const char *sqlite3_column_decltype(sqlite3_stmt*,int); SQLITE_API const void *sqlite3_column_decltype16(sqlite3_stmt*,int); SQLITE_API int sqlite3_step(sqlite3_stmt*); SQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt); 
#define SQLITE_INTEGER 1 
#define SQLITE_FLOAT 2 
#define SQLITE_BLOB 4 
#define SQLITE_NULL 5 
#ifdef SQLITE_TEXT 
#undef SQLITE_TEXT 
#else 
#define SQLITE_TEXT 3 
#endif 
#define SQLITE3_TEXT 3 
SQLITE_API const void *sqlite3_column_blob(sqlite3_stmt*, int iCol); SQLITE_API int sqlite3_column_bytes(sqlite3_stmt*, int iCol); SQLITE_API int sqlite3_column_bytes16(sqlite3_stmt*, int iCol); SQLITE_API double sqlite3_column_double(sqlite3_stmt*, int iCol); SQLITE_API int sqlite3_column_int(sqlite3_stmt*, int iCol); SQLITE_API sqlite3_int64 sqlite3_column_int64(sqlite3_stmt*, int iCol); SQLITE_API const unsigned char *sqlite3_column_text(sqlite3_stmt*, int iCol); SQLITE_API const void *sqlite3_column_text16(sqlite3_stmt*, int iCol); SQLITE_API int sqlite3_column_type(sqlite3_stmt*, int iCol); SQLITE_API sqlite3_value *sqlite3_column_value(sqlite3_stmt*, int iCol); SQLITE_API int sqlite3_finalize(sqlite3_stmt *pStmt); SQLITE_API int sqlite3_reset(sqlite3_stmt *pStmt); SQLITE_API int sqlite3_create_function( sqlite3 *db, const char *zFunctionName, int nArg, int eTextRep, void *pApp, void (*xFunc)(sqlite3_context*,int,sqlite3_value**), void (*xStep)(sqlite3_context*,int,sqlite3_value**), void (*xFinal)(sqlite3_context*) ); SQLITE_API int sqlite3_create_function16( sqlite3 *db, const void *zFunctionName, int nArg, int eTextRep, void *pApp, void (*xFunc)(sqlite3_context*,int,sqlite3_value**), void (*xStep)(sqlite3_context*,int,sqlite3_value**), void (*xFinal)(sqlite3_context*) ); 
#define SQLITE_UTF8 1 
#define SQLITE_UTF16LE 2 
#define SQLITE_UTF16BE 3 
#define SQLITE_UTF16 4 
#define SQLITE_ANY 5 
#define SQLITE_UTF16_ALIGNED 8 
#ifndef SQLITE_OMIT_DEPRECATED 
SQLITE_API SQLITE_DEPRECATED int sqlite3_aggregate_count(sqlite3_context*); SQLITE_API SQLITE_DEPRECATED int sqlite3_expired(sqlite3_stmt*); SQLITE_API SQLITE_DEPRECATED int sqlite3_transfer_bindings(sqlite3_stmt*, sqlite3_stmt*); SQLITE_API SQLITE_DEPRECATED int sqlite3_global_recover(void); SQLITE_API SQLITE_DEPRECATED void sqlite3_thread_cleanup(void); SQLITE_API SQLITE_DEPRECATED int sqlite3_memory_alarm(void(*)(void*,sqlite3_int64,int),void*,sqlite3_int64); 
#endif 
SQLITE_API const void *sqlite3_value_blob(sqlite3_value*); SQLITE_API int sqlite3_value_bytes(sqlite3_value*); SQLITE_API int sqlite3_value_bytes16(sqlite3_value*); SQLITE_API double sqlite3_value_double(sqlite3_value*); SQLITE_API int sqlite3_value_int(sqlite3_value*); SQLITE_API sqlite3_int64 sqlite3_value_int64(sqlite3_value*); SQLITE_API const unsigned char *sqlite3_value_text(sqlite3_value*); SQLITE_API const void *sqlite3_value_text16(sqlite3_value*); SQLITE_API const void *sqlite3_value_text16le(sqlite3_value*); SQLITE_API const void *sqlite3_value_text16be(sqlite3_value*); SQLITE_API int sqlite3_value_type(sqlite3_value*); SQLITE_API int sqlite3_value_numeric_type(sqlite3_value*); SQLITE_API void *sqlite3_aggregate_context(sqlite3_context*, int nBytes); SQLITE_API void *sqlite3_user_data(sqlite3_context*); SQLITE_API sqlite3 *sqlite3_context_db_handle(sqlite3_context*); SQLITE_API void *sqlite3_get_auxdata(sqlite3_context*, int N); SQLITE_API void sqlite3_set_auxdata(sqlite3_context*, int N, void*, void (*)(void*)); typedef void (*sqlite3_destructor_type)(void*); 
#define SQLITE_STATIC ((sqlite3_destructor_type)0) 
#define SQLITE_TRANSIENT ((sqlite3_destructor_type)-1) 
SQLITE_API void sqlite3_result_blob(sqlite3_context*, const void*, int, void(*)(void*)); SQLITE_API void sqlite3_result_double(sqlite3_context*, double); SQLITE_API void sqlite3_result_error(sqlite3_context*, const char*, int); SQLITE_API void sqlite3_result_error16(sqlite3_context*, const void*, int); SQLITE_API void sqlite3_result_error_toobig(sqlite3_context*); SQLITE_API void sqlite3_result_error_nomem(sqlite3_context*); SQLITE_API void sqlite3_result_error_code(sqlite3_context*, int); SQLITE_API void sqlite3_result_int(sqlite3_context*, int); SQLITE_API void sqlite3_result_int64(sqlite3_context*, sqlite3_int64); SQLITE_API void sqlite3_result_null(sqlite3_context*); SQLITE_API void sqlite3_result_text(sqlite3_context*, const char*, int, void(*)(void*)); SQLITE_API void sqlite3_result_text16(sqlite3_context*, const void*, int, void(*)(void*)); SQLITE_API void sqlite3_result_text16le(sqlite3_context*, const void*, int,void(*)(void*)); SQLITE_API void sqlite3_result_text16be(sqlite3_context*, const void*, int,void(*)(void*)); SQLITE_API void sqlite3_result_value(sqlite3_context*, sqlite3_value*); SQLITE_API void sqlite3_result_zeroblob(sqlite3_context*, int n); SQLITE_API int sqlite3_create_collation( sqlite3*, const char *zName, int eTextRep, void*, int(*xCompare)(void*,int,const void*,int,const void*) ); SQLITE_API int sqlite3_create_collation_v2( sqlite3*, const char *zName, int eTextRep, void*, int(*xCompare)(void*,int,const void*,int,const void*), void(*xDestroy)(void*) ); SQLITE_API int sqlite3_create_collation16( sqlite3*, const void *zName, int eTextRep, void*, int(*xCompare)(void*,int,const void*,int,const void*) ); SQLITE_API int sqlite3_collation_needed( sqlite3*, void*, void(*)(void*,sqlite3*,int eTextRep,const char*) ); SQLITE_API int sqlite3_collation_needed16( sqlite3*, void*, void(*)(void*,sqlite3*,int eTextRep,const void*) ); SQLITE_API int sqlite3_key( sqlite3 *db, const void *pKey, int nKey ); SQLITE_API int sqlite3_rekey( sqlite3 *db, const void *pKey, int nKey ); SQLITE_API int sqlite3_sleep(int); SQLITE_API char *sqlite3_temp_directory; SQLITE_API int sqlite3_get_autocommit(sqlite3*); SQLITE_API sqlite3 *sqlite3_db_handle(sqlite3_stmt*); SQLITE_API sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt); SQLITE_API void *sqlite3_commit_hook(sqlite3*, int(*)(void*), void*); SQLITE_API void *sqlite3_rollback_hook(sqlite3*, void(*)(void *), void*); SQLITE_API void *sqlite3_update_hook( sqlite3*, void(*)(void *,int ,char const *,char const *,sqlite3_int64), void* ); SQLITE_API int sqlite3_enable_shared_cache(int); SQLITE_API int sqlite3_release_memory(int); SQLITE_API void sqlite3_soft_heap_limit(int); SQLITE_API int sqlite3_table_column_metadata( sqlite3 *db, const char *zDbName, const char *zTableName, const char *zColumnName, char const **pzDataType, char const **pzCollSeq, int *pNotNull, int *pPrimaryKey, int *pAutoinc ); SQLITE_API int sqlite3_load_extension( sqlite3 *db, const char *zFile, const char *zProc, char **pzErrMsg ); SQLITE_API int sqlite3_enable_load_extension(sqlite3 *db, int onoff); SQLITE_API int sqlite3_auto_extension(void *xEntryPoint); SQLITE_API void sqlite3_reset_auto_extension(void); typedef struct sqlite3_vtab sqlite3_vtab; typedef struct sqlite3_index_info sqlite3_index_info; typedef struct sqlite3_vtab_cursor sqlite3_vtab_cursor; typedef struct sqlite3_module sqlite3_module; struct sqlite3_module { int iVersion; int (*xCreate)(sqlite3*, void *pAux, int argc, const char *const*argv, sqlite3_vtab **ppVTab, char**); int (*xConnect)(sqlite3*, void *pAux, int argc, const char *const*argv, sqlite3_vtab **ppVTab, char**); int (*xBestIndex)(sqlite3_vtab *pVTab, sqlite3_index_info*); int (*xDisconnect)(sqlite3_vtab *pVTab); int (*xDestroy)(sqlite3_vtab *pVTab); int (*xOpen)(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor); int (*xClose)(sqlite3_vtab_cursor*); int (*xFilter)(sqlite3_vtab_cursor*, int idxNum, const char *idxStr, int argc, sqlite3_value **argv); int (*xNext)(sqlite3_vtab_cursor*); int (*xEof)(sqlite3_vtab_cursor*); int (*xColumn)(sqlite3_vtab_cursor*, sqlite3_context*, int); int (*xRowid)(sqlite3_vtab_cursor*, sqlite3_int64 *pRowid); int (*xUpdate)(sqlite3_vtab *, int, sqlite3_value **, sqlite3_int64 *); int (*xBegin)(sqlite3_vtab *pVTab); int (*xSync)(sqlite3_vtab *pVTab); int (*xCommit)(sqlite3_vtab *pVTab); int (*xRollback)(sqlite3_vtab *pVTab); int (*xFindFunction)(sqlite3_vtab *pVtab, int nArg, const char *zName, void (**pxFunc)(sqlite3_context*,int,sqlite3_value**), void **ppArg); int (*xRename)(sqlite3_vtab *pVtab, const char *zNew); }; struct sqlite3_index_info { int nConstraint; struct sqlite3_index_constraint { int iColumn; unsigned char op; unsigned char usable; int iTermOffset; } *aConstraint; int nOrderBy; struct sqlite3_index_orderby { int iColumn; unsigned char desc; } *aOrderBy; struct sqlite3_index_constraint_usage { int argvIndex; unsigned char omit; } *aConstraintUsage; int idxNum; char *idxStr; int needToFreeIdxStr; int orderByConsumed; double estimatedCost; }; 
#define SQLITE_INDEX_CONSTRAINT_EQ 2 
#define SQLITE_INDEX_CONSTRAINT_GT 4 
#define SQLITE_INDEX_CONSTRAINT_LE 8 
#define SQLITE_INDEX_CONSTRAINT_LT 16 
#define SQLITE_INDEX_CONSTRAINT_GE 32 
#define SQLITE_INDEX_CONSTRAINT_MATCH 64 
SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_create_module( sqlite3 *db, const char *zName, const sqlite3_module *, void * ); SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_create_module_v2( sqlite3 *db, const char *zName, const sqlite3_module *, void *, void(*xDestroy)(void*) ); struct sqlite3_vtab { const sqlite3_module *pModule; int nRef; char *zErrMsg; }; struct sqlite3_vtab_cursor { sqlite3_vtab *pVtab; }; SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_declare_vtab(sqlite3*, const char *zCreateTable); SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_overload_function(sqlite3*, const char *zFuncName, int nArg); typedef struct sqlite3_blob sqlite3_blob; SQLITE_API int sqlite3_blob_open( sqlite3*, const char *zDb, const char *zTable, const char *zColumn, sqlite3_int64 iRow, int flags, sqlite3_blob **ppBlob ); SQLITE_API int sqlite3_blob_close(sqlite3_blob *); SQLITE_API int sqlite3_blob_bytes(sqlite3_blob *); SQLITE_API int sqlite3_blob_read(sqlite3_blob *, void *Z, int N, int iOffset); SQLITE_API int sqlite3_blob_write(sqlite3_blob *, const void *z, int n, int iOffset); SQLITE_API sqlite3_vfs *sqlite3_vfs_find(const char *zVfsName); SQLITE_API int sqlite3_vfs_register(sqlite3_vfs*, int makeDflt); SQLITE_API int sqlite3_vfs_unregister(sqlite3_vfs*); SQLITE_API sqlite3_mutex *sqlite3_mutex_alloc(int); SQLITE_API void sqlite3_mutex_free(sqlite3_mutex*); SQLITE_API void sqlite3_mutex_enter(sqlite3_mutex*); SQLITE_API int sqlite3_mutex_try(sqlite3_mutex*); SQLITE_API void sqlite3_mutex_leave(sqlite3_mutex*); typedef struct sqlite3_mutex_methods sqlite3_mutex_methods; struct sqlite3_mutex_methods { int (*xMutexInit)(void); int (*xMutexEnd)(void); sqlite3_mutex *(*xMutexAlloc)(int); void (*xMutexFree)(sqlite3_mutex *); void (*xMutexEnter)(sqlite3_mutex *); int (*xMutexTry)(sqlite3_mutex *); void (*xMutexLeave)(sqlite3_mutex *); int (*xMutexHeld)(sqlite3_mutex *); int (*xMutexNotheld)(sqlite3_mutex *); }; SQLITE_API int sqlite3_mutex_held(sqlite3_mutex*); SQLITE_API int sqlite3_mutex_notheld(sqlite3_mutex*); 
#define SQLITE_MUTEX_FAST 0 
#define SQLITE_MUTEX_RECURSIVE 1 
#define SQLITE_MUTEX_STATIC_MASTER 2 
#define SQLITE_MUTEX_STATIC_MEM 3 
#define SQLITE_MUTEX_STATIC_MEM2 4 
#define SQLITE_MUTEX_STATIC_PRNG 5 
#define SQLITE_MUTEX_STATIC_LRU 6 
#define SQLITE_MUTEX_STATIC_LRU2 7 
SQLITE_API sqlite3_mutex *sqlite3_db_mutex(sqlite3*); SQLITE_API int sqlite3_file_control(sqlite3*, const char *zDbName, int op, void*); SQLITE_API int sqlite3_test_control(int op, ...); 
#define SQLITE_TESTCTRL_PRNG_SAVE 5 
#define SQLITE_TESTCTRL_PRNG_RESTORE 6 
#define SQLITE_TESTCTRL_PRNG_RESET 7 
#define SQLITE_TESTCTRL_BITVEC_TEST 8 
#define SQLITE_TESTCTRL_FAULT_INSTALL 9 
#define SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS 10 
SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetFlag); 
#define SQLITE_STATUS_MEMORY_USED 0 
#define SQLITE_STATUS_PAGECACHE_USED 1 
#define SQLITE_STATUS_PAGECACHE_OVERFLOW 2 
#define SQLITE_STATUS_SCRATCH_USED 3 
#define SQLITE_STATUS_SCRATCH_OVERFLOW 4 
#define SQLITE_STATUS_MALLOC_SIZE 5 
#define SQLITE_STATUS_PARSER_STACK 6 
#define SQLITE_STATUS_PAGECACHE_SIZE 7 
#define SQLITE_STATUS_SCRATCH_SIZE 8 
SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_db_status(sqlite3*, int op, int *pCur, int *pHiwtr, int resetFlg); 
#define SQLITE_DBSTATUS_LOOKASIDE_USED 0 
SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_stmt_status(sqlite3_stmt*, int op,int resetFlg); 
#define SQLITE_STMTSTATUS_FULLSCAN_STEP 1 
#define SQLITE_STMTSTATUS_SORT 2 
typedef struct sqlite3_pcache sqlite3_pcache; typedef struct sqlite3_pcache_methods sqlite3_pcache_methods; struct sqlite3_pcache_methods { void *pArg; int (*xInit)(void*); void (*xShutdown)(void*); sqlite3_pcache *(*xCreate)(int szPage, int bPurgeable); void (*xCachesize)(sqlite3_pcache*, int nCachesize); int (*xPagecount)(sqlite3_pcache*); void *(*xFetch)(sqlite3_pcache*, unsigned key, int createFlag); void (*xUnpin)(sqlite3_pcache*, void*, int discard); void (*xRekey)(sqlite3_pcache*, void*, unsigned oldKey, unsigned newKey); void (*xTruncate)(sqlite3_pcache*, unsigned iLimit); void (*xDestroy)(sqlite3_pcache*); }; 
#ifdef SQLITE_OMIT_FLOATING_POINT 
#undef double 
#endif 
#if 0 
} 
#endif 
#endif 
#ifndef _SQLITE_HASH_H_ 
#define _SQLITE_HASH_H_ 
typedef struct Hash Hash; typedef struct HashElem HashElem; struct Hash { unsigned int copyKey: 1; unsigned int htsize : 31; unsigned int count; HashElem *first; struct _ht { int count; HashElem *chain; } *ht; }; struct HashElem { HashElem *next, *prev; void *data; void *pKey; int nKey; }; SQLITE_PRIVATE void sqlite3HashInit(Hash*, int copyKey); SQLITE_PRIVATE void *sqlite3HashInsert(Hash*, const void *pKey, int nKey, void *pData); SQLITE_PRIVATE void *sqlite3HashFind(const Hash*, const void *pKey, int nKey); SQLITE_PRIVATE HashElem *sqlite3HashFindElem(const Hash*, const void *pKey, int nKey); SQLITE_PRIVATE void sqlite3HashClear(Hash*); 
#define sqliteHashFirst(H) ((H)->first) 
#define sqliteHashNext(E) ((E)->next) 
#define sqliteHashData(E) ((E)->data) 
#define sqliteHashKey(E) ((E)->pKey) 
#define sqliteHashKeysize(E) ((E)->nKey) 
#define sqliteHashCount(H) ((H)->count) 
#endif 
#define TK_SEMI 1 
#define TK_EXPLAIN 2 
#define TK_QUERY 3 
#define TK_PLAN 4 
#define TK_BEGIN 5 
#define TK_TRANSACTION 6 
#define TK_DEFERRED 7 
#define TK_IMMEDIATE 8 
#define TK_EXCLUSIVE 9 
#define TK_COMMIT 10 
#define TK_END 11 
#define TK_ROLLBACK 12 
#define TK_CREATE 13 
#define TK_TABLE 14 
#define TK_IF 15 
#define TK_NOT 16 
#define TK_EXISTS 17 
#define TK_TEMP 18 
#define TK_LP 19 
#define TK_RP 20 
#define TK_AS 21 
#define TK_COMMA 22 
#define TK_ID 23 
#define TK_ABORT 24 
#define TK_AFTER 25 
#define TK_ANALYZE 26 
#define TK_ASC 27 
#define TK_ATTACH 28 
#define TK_BEFORE 29 
#define TK_CASCADE 30 
#define TK_CAST 31 
#define TK_CONFLICT 32 
#define TK_DATABASE 33 
#define TK_DESC 34 
#define TK_DETACH 35 
#define TK_EACH 36 
#define TK_FAIL 37 
#define TK_FOR 38 
#define TK_IGNORE 39 
#define TK_INITIALLY 40 
#define TK_INSTEAD 41 
#define TK_LIKE_KW 42 
#define TK_MATCH 43 
#define TK_KEY 44 
#define TK_OF 45 
#define TK_OFFSET 46 
#define TK_PRAGMA 47 
#define TK_RAISE 48 
#define TK_REPLACE 49 
#define TK_RESTRICT 50 
#define TK_ROW 51 
#define TK_TRIGGER 52 
#define TK_VACUUM 53 
#define TK_VIEW 54 
#define TK_VIRTUAL 55 
#define TK_REINDEX 56 
#define TK_RENAME 57 
#define TK_CTIME_KW 58 
#define TK_ANY 59 
#define TK_OR 60 
#define TK_AND 61 
#define TK_IS 62 
#define TK_BETWEEN 63 
#define TK_IN 64 
#define TK_ISNULL 65 
#define TK_NOTNULL 66 
#define TK_NE 67 
#define TK_EQ 68 
#define TK_GT 69 
#define TK_LE 70 
#define TK_LT 71 
#define TK_GE 72 
#define TK_ESCAPE 73 
#define TK_BITAND 74 
#define TK_BITOR 75 
#define TK_LSHIFT 76 
#define TK_RSHIFT 77 
#define TK_PLUS 78 
#define TK_MINUS 79 
#define TK_STAR 80 
#define TK_SLASH 81 
#define TK_REM 82 
#define TK_CONCAT 83 
#define TK_COLLATE 84 
#define TK_UMINUS 85 
#define TK_UPLUS 86 
#define TK_BITNOT 87 
#define TK_STRING 88 
#define TK_JOIN_KW 89 
#define TK_CONSTRAINT 90 
#define TK_DEFAULT 91 
#define TK_NULL 92 
#define TK_PRIMARY 93 
#define TK_UNIQUE 94 
#define TK_CHECK 95 
#define TK_REFERENCES 96 
#define TK_AUTOINCR 97 
#define TK_ON 98 
#define TK_DELETE 99 
#define TK_UPDATE 100 
#define TK_INSERT 101 
#define TK_SET 102 
#define TK_DEFERRABLE 103 
#define TK_FOREIGN 104 
#define TK_DROP 105 
#define TK_UNION 106 
#define TK_ALL 107 
#define TK_EXCEPT 108 
#define TK_INTERSECT 109 
#define TK_SELECT 110 
#define TK_DISTINCT 111 
#define TK_DOT 112 
#define TK_FROM 113 
#define TK_JOIN 114 
#define TK_INDEXED 115 
#define TK_BY 116 
#define TK_USING 117 
#define TK_ORDER 118 
#define TK_GROUP 119 
#define TK_HAVING 120 
#define TK_LIMIT 121 
#define TK_WHERE 122 
#define TK_INTO 123 
#define TK_VALUES 124 
#define TK_INTEGER 125 
#define TK_FLOAT 126 
#define TK_BLOB 127 
#define TK_REGISTER 128 
#define TK_VARIABLE 129 
#define TK_CASE 130 
#define TK_WHEN 131 
#define TK_THEN 132 
#define TK_ELSE 133 
#define TK_INDEX 134 
#define TK_ALTER 135 
#define TK_TO 136 
#define TK_ADD 137 
#define TK_COLUMNKW 138 
#define TK_TO_TEXT 139 
#define TK_TO_BLOB 140 
#define TK_TO_NUMERIC 141 
#define TK_TO_INT 142 
#define TK_TO_REAL 143 
#define TK_END_OF_FILE 144 
#define TK_ILLEGAL 145 
#define TK_SPACE 146 
#define TK_UNCLOSED_STRING 147 
#define TK_FUNCTION 148 
#define TK_COLUMN 149 
#define TK_AGG_FUNCTION 150 
#define TK_AGG_COLUMN 151 
#define TK_CONST_FUNC 152 
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
#include <assert.h> 
#include <stddef.h> 
#ifdef SQLITE_OMIT_FLOATING_POINT 
#define double sqlite_int64 
#define LONGDOUBLE_TYPE sqlite_int64 
#ifndef SQLITE_BIG_DBL 
#define SQLITE_BIG_DBL (0x7fffffffffffffff) 
#endif 
#define SQLITE_OMIT_DATETIME_FUNCS 1 
#define SQLITE_OMIT_TRACE 1 
#undef SQLITE_MIXED_ENDIAN_64BIT_FLOAT 
#endif 
#ifndef SQLITE_BIG_DBL 
#define SQLITE_BIG_DBL (1e99) 
#endif 
#ifdef SQLITE_OMIT_TEMPDB 
#define OMIT_TEMPDB 1 
#else 
#define OMIT_TEMPDB 0 
#endif 
#define NULL_DISTINCT_FOR_UNIQUE 1 
#define SQLITE_MAX_FILE_FORMAT 4 
#ifndef SQLITE_DEFAULT_FILE_FORMAT 
#define SQLITE_DEFAULT_FILE_FORMAT 1 
#endif 
#ifndef SQLITE_TEMP_STORE 
#define SQLITE_TEMP_STORE 1 
#endif 
#ifndef offsetof 
#define offsetof(STRUCTURE,FIELD) ((int)((char*)&((STRUCTURE*)0)->FIELD)) 
#endif 
#if 'A' == '\301' 
#define SQLITE_EBCDIC 1 
#else 
#define SQLITE_ASCII 1 
#endif 
#ifndef UINT32_TYPE 
#ifdef HAVE_UINT32_T 
#define UINT32_TYPE uint32_t 
#else 
#define UINT32_TYPE unsigned int 
#endif 
#endif 
#ifndef UINT16_TYPE 
#ifdef HAVE_UINT16_T 
#define UINT16_TYPE uint16_t 
#else 
#define UINT16_TYPE unsigned short int 
#endif 
#endif 
#ifndef INT16_TYPE 
#ifdef HAVE_INT16_T 
#define INT16_TYPE int16_t 
#else 
#define INT16_TYPE short int 
#endif 
#endif 
#ifndef UINT8_TYPE 
#ifdef HAVE_UINT8_T 
#define UINT8_TYPE uint8_t 
#else 
#define UINT8_TYPE unsigned char 
#endif 
#endif 
#ifndef INT8_TYPE 
#ifdef HAVE_INT8_T 
#define INT8_TYPE int8_t 
#else 
#define INT8_TYPE signed char 
#endif 
#endif 
#ifndef LONGDOUBLE_TYPE 
#define LONGDOUBLE_TYPE long double 
#endif 
typedef sqlite_int64 i64; typedef sqlite_uint64 u64; typedef UINT32_TYPE u32; typedef UINT16_TYPE u16; typedef INT16_TYPE i16; typedef UINT8_TYPE u8; typedef INT8_TYPE i8; 
#ifdef SQLITE_AMALGAMATION 
SQLITE_PRIVATE const int sqlite3one; 
#else 
SQLITE_PRIVATE const int sqlite3one; 
#endif 
#if defined(i386) || defined(__i386__) || defined(_M_IX86) || defined(__x86_64) || defined(__x86_64__) 
#define SQLITE_BIGENDIAN 0 
#define SQLITE_LITTLEENDIAN 1 
#define SQLITE_UTF16NATIVE SQLITE_UTF16LE 
#else 
#define SQLITE_BIGENDIAN (*(char *)(&sqlite3one)==0) 
#define SQLITE_LITTLEENDIAN (*(char *)(&sqlite3one)==1) 
#define SQLITE_UTF16NATIVE (SQLITE_BIGENDIAN?SQLITE_UTF16BE:SQLITE_UTF16LE) 
#endif 
#define LARGEST_INT64 (0xffffffff|(((i64)0x7fffffff)<<32)) 
#define SMALLEST_INT64 (((i64)-1) - LARGEST_INT64) 
typedef struct BusyHandler BusyHandler; struct BusyHandler { int (*xFunc)(void *,int); void *pArg; int nBusy; }; 
#define MASTER_NAME "sqlite_master" 
#define TEMP_MASTER_NAME "sqlite_temp_master" 
#define MASTER_ROOT 1 
#define SCHEMA_TABLE(x) ((!OMIT_TEMPDB)&&(x==1)?TEMP_MASTER_NAME:MASTER_NAME) 
#define ArraySize(X) ((int)(sizeof(X)/sizeof(X[0]))) 
#define SQLITE_DYNAMIC ((sqlite3_destructor_type)sqlite3DbFree) 
#ifdef SQLITE_OMIT_WSD 
#define SQLITE_WSD const 
#define GLOBAL(t,v) (*(t*)sqlite3_wsd_find((void*)&(v), sizeof(v))) 
#define sqlite3GlobalConfig GLOBAL(struct Sqlite3Config, sqlite3Config) 
SQLITE_API int sqlite3_wsd_init(int N, int J); SQLITE_API void *sqlite3_wsd_find(void *K, int L); 
#else 
#define SQLITE_WSD 
#define GLOBAL(t,v) v 
#define sqlite3GlobalConfig sqlite3Config 
#endif 
#define UNUSED_PARAMETER(x) (void)(x) 
#define UNUSED_PARAMETER2(x,y) UNUSED_PARAMETER(x),UNUSED_PARAMETER(y) 
typedef struct AggInfo AggInfo; typedef struct AuthContext AuthContext; typedef struct Bitvec Bitvec; typedef struct CollSeq CollSeq; typedef struct Column Column; typedef struct Db Db; typedef struct Schema Schema; typedef struct Expr Expr; typedef struct ExprList ExprList; typedef struct FKey FKey; typedef struct FuncDef FuncDef; typedef struct FuncDefHash FuncDefHash; typedef struct IdList IdList; typedef struct Index Index; typedef struct KeyClass KeyClass; typedef struct KeyInfo KeyInfo; typedef struct Lookaside Lookaside; typedef struct LookasideSlot LookasideSlot; typedef struct Module Module; typedef struct NameContext NameContext; typedef struct Parse Parse; typedef struct Select Select; typedef struct SrcList SrcList; typedef struct StrAccum StrAccum; typedef struct Table Table; typedef struct TableLock TableLock; typedef struct Token Token; typedef struct TriggerStack TriggerStack; typedef struct TriggerStep TriggerStep; typedef struct Trigger Trigger; typedef struct UnpackedRecord UnpackedRecord; typedef struct Walker Walker; typedef struct WhereInfo WhereInfo; typedef struct WhereLevel WhereLevel; 
#ifndef _BTREE_H_ 
#define _BTREE_H_ 
#define SQLITE_N_BTREE_META 10 
#ifndef SQLITE_DEFAULT_AUTOVACUUM 
#define SQLITE_DEFAULT_AUTOVACUUM 0 
#endif 
#define BTREE_AUTOVACUUM_NONE 0 
#define BTREE_AUTOVACUUM_FULL 1 
#define BTREE_AUTOVACUUM_INCR 2 
typedef struct Btree Btree; typedef struct BtCursor BtCursor; typedef struct BtShared BtShared; typedef struct BtreeMutexArray BtreeMutexArray; struct BtreeMutexArray { int nMutex; Btree *aBtree[SQLITE_MAX_ATTACHED+1]; }; SQLITE_PRIVATE int sqlite3BtreeOpen( const char *zFilename, sqlite3 *db, Btree **, int flags, int vfsFlags ); 
#define BTREE_OMIT_JOURNAL 1 
#define BTREE_NO_READLOCK 2 
#define BTREE_MEMORY 4 
#define BTREE_READONLY 8 
#define BTREE_READWRITE 16 
#define BTREE_CREATE 32 
SQLITE_PRIVATE int sqlite3BtreeClose(Btree*); SQLITE_PRIVATE int sqlite3BtreeSetCacheSize(Btree*,int); SQLITE_PRIVATE int sqlite3BtreeSetSafetyLevel(Btree*,int,int); SQLITE_PRIVATE int sqlite3BtreeSyncDisabled(Btree*); SQLITE_PRIVATE int sqlite3BtreeSetPageSize(Btree*,int,int); SQLITE_PRIVATE int sqlite3BtreeGetPageSize(Btree*); SQLITE_PRIVATE int sqlite3BtreeMaxPageCount(Btree*,int); SQLITE_PRIVATE int sqlite3BtreeGetReserve(Btree*); SQLITE_PRIVATE int sqlite3BtreeSetAutoVacuum(Btree *, int); SQLITE_PRIVATE int sqlite3BtreeGetAutoVacuum(Btree *); SQLITE_PRIVATE int sqlite3BtreeBeginTrans(Btree*,int); SQLITE_PRIVATE int sqlite3BtreeCommitPhaseOne(Btree*, const char *zMaster); SQLITE_PRIVATE int sqlite3BtreeCommitPhaseTwo(Btree*); SQLITE_PRIVATE int sqlite3BtreeCommit(Btree*); SQLITE_PRIVATE int sqlite3BtreeRollback(Btree*); SQLITE_PRIVATE int sqlite3BtreeBeginStmt(Btree*); SQLITE_PRIVATE int sqlite3BtreeCommitStmt(Btree*); SQLITE_PRIVATE int sqlite3BtreeRollbackStmt(Btree*); SQLITE_PRIVATE int sqlite3BtreeCreateTable(Btree*, int*, int flags); SQLITE_PRIVATE int sqlite3BtreeIsInTrans(Btree*); SQLITE_PRIVATE int sqlite3BtreeIsInStmt(Btree*); SQLITE_PRIVATE int sqlite3BtreeIsInReadTrans(Btree*); SQLITE_PRIVATE void *sqlite3BtreeSchema(Btree *, int, void(*)(void *)); SQLITE_PRIVATE int sqlite3BtreeSchemaLocked(Btree *); SQLITE_PRIVATE int sqlite3BtreeLockTable(Btree *, int, u8); SQLITE_PRIVATE const char *sqlite3BtreeGetFilename(Btree *); SQLITE_PRIVATE const char *sqlite3BtreeGetDirname(Btree *); SQLITE_PRIVATE const char *sqlite3BtreeGetJournalname(Btree *); SQLITE_PRIVATE int sqlite3BtreeCopyFile(Btree *, Btree *); SQLITE_PRIVATE int sqlite3BtreeIncrVacuum(Btree *); 
#define BTREE_INTKEY 1 
#define BTREE_ZERODATA 2 
#define BTREE_LEAFDATA 4 
SQLITE_PRIVATE int sqlite3BtreeDropTable(Btree*, int, int*); SQLITE_PRIVATE int sqlite3BtreeClearTable(Btree*, int, int*); SQLITE_PRIVATE int sqlite3BtreeGetMeta(Btree*, int idx, u32 *pValue); SQLITE_PRIVATE int sqlite3BtreeUpdateMeta(Btree*, int idx, u32 value); SQLITE_PRIVATE void sqlite3BtreeTripAllCursors(Btree*, int); SQLITE_PRIVATE int sqlite3BtreeCursor( Btree*, int iTable, int wrFlag, struct KeyInfo*, BtCursor *pCursor ); SQLITE_PRIVATE int sqlite3BtreeCursorSize(void); SQLITE_PRIVATE int sqlite3BtreeCloseCursor(BtCursor*); SQLITE_PRIVATE int sqlite3BtreeMoveto( BtCursor*, const void *pKey, i64 nKey, int bias, int *pRes ); SQLITE_PRIVATE int sqlite3BtreeMovetoUnpacked( BtCursor*, UnpackedRecord *pUnKey, i64 intKey, int bias, int *pRes ); SQLITE_PRIVATE int sqlite3BtreeCursorHasMoved(BtCursor*, int*); SQLITE_PRIVATE int sqlite3BtreeDelete(BtCursor*); SQLITE_PRIVATE int sqlite3BtreeInsert(BtCursor*, const void *pKey, i64 nKey, const void *pData, int nData, int nZero, int bias); SQLITE_PRIVATE int sqlite3BtreeFirst(BtCursor*, int *pRes); SQLITE_PRIVATE int sqlite3BtreeLast(BtCursor*, int *pRes); SQLITE_PRIVATE int sqlite3BtreeNext(BtCursor*, int *pRes); SQLITE_PRIVATE int sqlite3BtreeEof(BtCursor*); SQLITE_PRIVATE int sqlite3BtreeFlags(BtCursor*); SQLITE_PRIVATE int sqlite3BtreePrevious(BtCursor*, int *pRes); SQLITE_PRIVATE int sqlite3BtreeKeySize(BtCursor*, i64 *pSize); SQLITE_PRIVATE int sqlite3BtreeKey(BtCursor*, u32 offset, u32 amt, void*); SQLITE_PRIVATE sqlite3 *sqlite3BtreeCursorDb(const BtCursor*); SQLITE_PRIVATE const void *sqlite3BtreeKeyFetch(BtCursor*, int *pAmt); SQLITE_PRIVATE const void *sqlite3BtreeDataFetch(BtCursor*, int *pAmt); SQLITE_PRIVATE int sqlite3BtreeDataSize(BtCursor*, u32 *pSize); SQLITE_PRIVATE int sqlite3BtreeData(BtCursor*, u32 offset, u32 amt, void*); SQLITE_PRIVATE char *sqlite3BtreeIntegrityCheck(Btree*, int *aRoot, int nRoot, int, int*); SQLITE_PRIVATE struct Pager *sqlite3BtreePager(Btree*); SQLITE_PRIVATE int sqlite3BtreePutData(BtCursor*, u32 offset, u32 amt, void*); SQLITE_PRIVATE void sqlite3BtreeCacheOverflow(BtCursor *); SQLITE_PRIVATE void sqlite3BtreeClearCursor(BtCursor *); 
#ifdef SQLITE_TEST 
SQLITE_PRIVATE int sqlite3BtreeCursorInfo(BtCursor*, int*, int); SQLITE_PRIVATE void sqlite3BtreeCursorList(Btree*); 
#endif 
#if !defined(SQLITE_OMIT_SHARED_CACHE) && SQLITE_THREADSAFE 
SQLITE_PRIVATE void sqlite3BtreeEnter(Btree*); SQLITE_PRIVATE void sqlite3BtreeLeave(Btree*); 
#ifndef NDEBUG 
 SQLITE_PRIVATE int sqlite3BtreeHoldsMutex(Btree*); 
#endif 
SQLITE_PRIVATE void sqlite3BtreeEnterCursor(BtCursor*); SQLITE_PRIVATE void sqlite3BtreeLeaveCursor(BtCursor*); SQLITE_PRIVATE void sqlite3BtreeEnterAll(sqlite3*); SQLITE_PRIVATE void sqlite3BtreeLeaveAll(sqlite3*); 
#ifndef NDEBUG 
 SQLITE_PRIVATE int sqlite3BtreeHoldsAllMutexes(sqlite3*); 
#endif 
SQLITE_PRIVATE void sqlite3BtreeMutexArrayEnter(BtreeMutexArray*); SQLITE_PRIVATE void sqlite3BtreeMutexArrayLeave(BtreeMutexArray*); SQLITE_PRIVATE void sqlite3BtreeMutexArrayInsert(BtreeMutexArray*, Btree*); 
#else 
#define sqlite3BtreeEnter(X) 
#define sqlite3BtreeLeave(X) 
#ifndef NDEBUG 
 
#define sqlite3BtreeHoldsMutex(X) 1 
#endif 
#define sqlite3BtreeEnterCursor(X) 
#define sqlite3BtreeLeaveCursor(X) 
#define sqlite3BtreeEnterAll(X) 
#define sqlite3BtreeLeaveAll(X) 
#ifndef NDEBUG 
 
#define sqlite3BtreeHoldsAllMutexes(X) 1 
#endif 
#define sqlite3BtreeMutexArrayEnter(X) 
#define sqlite3BtreeMutexArrayLeave(X) 
#define sqlite3BtreeMutexArrayInsert(X,Y) 
#endif 
#endif 
#ifndef _SQLITE_VDBE_H_ 
#define _SQLITE_VDBE_H_ 
typedef struct Vdbe Vdbe; typedef struct VdbeFunc VdbeFunc; typedef struct Mem Mem; struct VdbeOp { u8 opcode; signed char p4type; u8 opflags; u8 p5; int p1; int p2; int p3; union { int i; void *p; char *z; i64 *pI64; double *pReal; FuncDef *pFunc; VdbeFunc *pVdbeFunc; CollSeq *pColl; Mem *pMem; sqlite3_vtab *pVtab; KeyInfo *pKeyInfo; int *ai; } p4; 
#ifdef SQLITE_DEBUG 
 char *zComment; 
#endif 
#ifdef VDBE_PROFILE 
 int cnt; u64 cycles; 
#endif 
}; typedef struct VdbeOp VdbeOp; struct VdbeOpList { u8 opcode; signed char p1; signed char p2; signed char p3; }; typedef struct VdbeOpList VdbeOpList; 
#define P4_NOTUSED 0 
#define P4_DYNAMIC (-1) 
#define P4_STATIC (-2) 
#define P4_COLLSEQ (-4) 
#define P4_FUNCDEF (-5) 
#define P4_KEYINFO (-6) 
#define P4_VDBEFUNC (-7) 
#define P4_MEM (-8) 
#define P4_TRANSIENT (-9) 
#define P4_VTAB (-10) 
#define P4_MPRINTF (-11) 
#define P4_REAL (-12) 
#define P4_INT64 (-13) 
#define P4_INT32 (-14) 
#define P4_INTARRAY (-15) 
#define P4_KEYINFO_HANDOFF (-16) 
#define P4_KEYINFO_STATIC (-17) 
#define COLNAME_NAME 0 
#define COLNAME_DECLTYPE 1 
#define COLNAME_DATABASE 2 
#define COLNAME_TABLE 3 
#define COLNAME_COLUMN 4 
#ifdef SQLITE_ENABLE_COLUMN_METADATA 
#define COLNAME_N 5 
#else 
#ifdef SQLITE_OMIT_DECLTYPE 
#define COLNAME_N 1 
#else 
#define COLNAME_N 2 
#endif 
#endif 
#define ADDR(X) (-1-(X)) 
#define OP_VNext 1 
#define OP_Affinity 2 
#define OP_Column 3 
#define OP_SetCookie 4 
#define OP_Real 126 
#define OP_Sequence 5 
#define OP_MoveGt 6 
#define OP_Ge 72 
#define OP_RowKey 7 
#define OP_SCopy 8 
#define OP_Eq 68 
#define OP_OpenWrite 9 
#define OP_NotNull 66 
#define OP_If 10 
#define OP_ToInt 142 
#define OP_String8 88 
#define OP_VRowid 11 
#define OP_CollSeq 12 
#define OP_OpenRead 13 
#define OP_Expire 14 
#define OP_AutoCommit 15 
#define OP_Gt 69 
#define OP_Pagecount 17 
#define OP_IntegrityCk 18 
#define OP_Sort 19 
#define OP_Copy 20 
#define OP_Trace 21 
#define OP_Function 22 
#define OP_IfNeg 23 
#define OP_And 61 
#define OP_Subtract 79 
#define OP_Noop 24 
#define OP_Return 25 
#define OP_Remainder 82 
#define OP_NewRowid 26 
#define OP_Multiply 80 
#define OP_Variable 27 
#define OP_String 28 
#define OP_RealAffinity 29 
#define OP_VRename 30 
#define OP_ParseSchema 31 
#define OP_VOpen 32 
#define OP_Close 33 
#define OP_CreateIndex 34 
#define OP_IsUnique 35 
#define OP_NotFound 36 
#define OP_Int64 37 
#define OP_MustBeInt 38 
#define OP_Halt 39 
#define OP_Rowid 40 
#define OP_IdxLT 41 
#define OP_AddImm 42 
#define OP_Statement 43 
#define OP_RowData 44 
#define OP_MemMax 45 
#define OP_Or 60 
#define OP_NotExists 46 
#define OP_Gosub 47 
#define OP_Divide 81 
#define OP_Integer 48 
#define OP_ToNumeric 141 
#define OP_Prev 49 
#define OP_Concat 83 
#define OP_BitAnd 74 
#define OP_VColumn 50 
#define OP_CreateTable 51 
#define OP_Last 52 
#define OP_IsNull 65 
#define OP_IncrVacuum 53 
#define OP_IdxRowid 54 
#define OP_ShiftRight 77 
#define OP_ResetCount 55 
#define OP_FifoWrite 56 
#define OP_ContextPush 57 
#define OP_Yield 58 
#define OP_DropTrigger 59 
#define OP_DropIndex 62 
#define OP_IdxGE 63 
#define OP_IdxDelete 64 
#define OP_Vacuum 73 
#define OP_MoveLe 84 
#define OP_IfNot 85 
#define OP_DropTable 86 
#define OP_MakeRecord 89 
#define OP_ToBlob 140 
#define OP_ResultRow 90 
#define OP_Delete 91 
#define OP_AggFinal 92 
#define OP_Compare 93 
#define OP_ShiftLeft 76 
#define OP_Goto 94 
#define OP_TableLock 95 
#define OP_FifoRead 96 
#define OP_Clear 97 
#define OP_MoveLt 98 
#define OP_Le 70 
#define OP_VerifyCookie 99 
#define OP_AggStep 100 
#define OP_ToText 139 
#define OP_Not 16 
#define OP_ToReal 143 
#define OP_SetNumColumns 101 
#define OP_Transaction 102 
#define OP_VFilter 103 
#define OP_Ne 67 
#define OP_VDestroy 104 
#define OP_ContextPop 105 
#define OP_BitOr 75 
#define OP_Next 106 
#define OP_IdxInsert 107 
#define OP_Lt 71 
#define OP_Insert 108 
#define OP_Destroy 109 
#define OP_ReadCookie 110 
#define OP_ForceInt 111 
#define OP_LoadAnalysis 112 
#define OP_Explain 113 
#define OP_OpenPseudo 114 
#define OP_OpenEphemeral 115 
#define OP_Null 116 
#define OP_Move 117 
#define OP_Blob 118 
#define OP_Add 78 
#define OP_Rewind 119 
#define OP_MoveGe 120 
#define OP_VBegin 121 
#define OP_VUpdate 122 
#define OP_IfZero 123 
#define OP_BitNot 87 
#define OP_VCreate 124 
#define OP_Found 125 
#define OP_IfPos 127 
#define OP_NullRow 128 
#define OP_Jump 129 
#define OP_Permutation 130 
#define OP_NotUsed_131 131 
#define OP_NotUsed_132 132 
#define OP_NotUsed_133 133 
#define OP_NotUsed_134 134 
#define OP_NotUsed_135 135 
#define OP_NotUsed_136 136 
#define OP_NotUsed_137 137 
#define OP_NotUsed_138 138 
#define OPFLG_JUMP 0x0001 
#define OPFLG_OUT2_PRERELEASE 0x0002 
#define OPFLG_IN1 0x0004 
#define OPFLG_IN2 0x0008 
#define OPFLG_IN3 0x0010 
#define OPFLG_OUT3 0x0020 
#define OPFLG_INITIALIZER { 0x00, 0x01, 0x00, 0x00, 0x10, 0x02, 0x11, 0x00, 0x00, 0x00, 0x05, 0x02, 0x00, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x04, 0x02, 0x02, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x11, 0x11, 0x02, 0x05, 0x00, 0x02, 0x11, 0x04, 0x00, 0x00, 0x0c, 0x11, 0x01, 0x02, 0x01, 0x00, 0x02, 0x01, 0x01, 0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 0x2c, 0x2c, 0x00, 0x11, 0x00, 0x05, 0x05, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x00, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x11, 0x05, 0x00, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x08, 0x00, 0x02, 0x02, 0x05, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x01, 0x11, 0x00, 0x00, 0x05, 0x00, 0x11, 0x02, 0x05, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x04, 0x04, 0x04, } 
SQLITE_PRIVATE Vdbe *sqlite3VdbeCreate(sqlite3*); SQLITE_PRIVATE int sqlite3VdbeAddOp0(Vdbe*,int); SQLITE_PRIVATE int sqlite3VdbeAddOp1(Vdbe*,int,int); SQLITE_PRIVATE int sqlite3VdbeAddOp2(Vdbe*,int,int,int); SQLITE_PRIVATE int sqlite3VdbeAddOp3(Vdbe*,int,int,int,int); SQLITE_PRIVATE int sqlite3VdbeAddOp4(Vdbe*,int,int,int,int,const char *zP4,int); SQLITE_PRIVATE int sqlite3VdbeAddOpList(Vdbe*, int nOp, VdbeOpList const *aOp); SQLITE_PRIVATE void sqlite3VdbeChangeP1(Vdbe*, int addr, int P1); SQLITE_PRIVATE void sqlite3VdbeChangeP2(Vdbe*, int addr, int P2); SQLITE_PRIVATE void sqlite3VdbeChangeP3(Vdbe*, int addr, int P3); SQLITE_PRIVATE void sqlite3VdbeChangeP5(Vdbe*, u8 P5); SQLITE_PRIVATE void sqlite3VdbeJumpHere(Vdbe*, int addr); SQLITE_PRIVATE void sqlite3VdbeChangeToNoop(Vdbe*, int addr, int N); SQLITE_PRIVATE void sqlite3VdbeChangeP4(Vdbe*, int addr, const char *zP4, int N); SQLITE_PRIVATE void sqlite3VdbeUsesBtree(Vdbe*, int); SQLITE_PRIVATE VdbeOp *sqlite3VdbeGetOp(Vdbe*, int); SQLITE_PRIVATE int sqlite3VdbeMakeLabel(Vdbe*); SQLITE_PRIVATE void sqlite3VdbeDelete(Vdbe*); SQLITE_PRIVATE void sqlite3VdbeMakeReady(Vdbe*,int,int,int,int); SQLITE_PRIVATE int sqlite3VdbeFinalize(Vdbe*); SQLITE_PRIVATE void sqlite3VdbeResolveLabel(Vdbe*, int); SQLITE_PRIVATE int sqlite3VdbeCurrentAddr(Vdbe*); 
#ifdef SQLITE_DEBUG 
SQLITE_PRIVATE void sqlite3VdbeTrace(Vdbe*,FILE*); 
#endif 
SQLITE_PRIVATE void sqlite3VdbeResetStepResult(Vdbe*); SQLITE_PRIVATE int sqlite3VdbeReset(Vdbe*); SQLITE_PRIVATE void sqlite3VdbeSetNumCols(Vdbe*,int); SQLITE_PRIVATE int sqlite3VdbeSetColName(Vdbe*, int, int, const char *, void(*)(void*)); SQLITE_PRIVATE void sqlite3VdbeCountChanges(Vdbe*); SQLITE_PRIVATE sqlite3 *sqlite3VdbeDb(Vdbe*); SQLITE_PRIVATE void sqlite3VdbeSetSql(Vdbe*, const char *z, int n); SQLITE_PRIVATE void sqlite3VdbeSwap(Vdbe*,Vdbe*); 
#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT 
SQLITE_PRIVATE int sqlite3VdbeReleaseMemory(int); 
#endif 
SQLITE_PRIVATE UnpackedRecord *sqlite3VdbeRecordUnpack(KeyInfo*,int,const void*, UnpackedRecord*,int); SQLITE_PRIVATE void sqlite3VdbeDeleteUnpackedRecord(UnpackedRecord*); SQLITE_PRIVATE int sqlite3VdbeRecordCompare(int,const void*,UnpackedRecord*); 
#ifndef NDEBUG 
SQLITE_PRIVATE void sqlite3VdbeComment(Vdbe*, const char*, ...); 
#define VdbeComment(X) sqlite3VdbeComment X 
SQLITE_PRIVATE void sqlite3VdbeNoopComment(Vdbe*, const char*, ...); 
#define VdbeNoopComment(X) sqlite3VdbeNoopComment X 
#else 
#define VdbeComment(X) 
#define VdbeNoopComment(X) 
#endif 
#endif 
#ifndef _PAGER_H_ 
#define _PAGER_H_ 
#ifndef SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT 
#define SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT -1 
#endif 
typedef u32 Pgno; typedef struct Pager Pager; typedef struct PgHdr DbPage; 
#define PAGER_OMIT_JOURNAL 0x0001 
#define PAGER_NO_READLOCK 0x0002 
#define PAGER_LOCKINGMODE_QUERY -1 
#define PAGER_LOCKINGMODE_NORMAL 0 
#define PAGER_LOCKINGMODE_EXCLUSIVE 1 
#define PAGER_JOURNALMODE_QUERY -1 
#define PAGER_JOURNALMODE_DELETE 0 
#define PAGER_JOURNALMODE_PERSIST 1 
#define PAGER_JOURNALMODE_OFF 2 
#define PAGER_JOURNALMODE_TRUNCATE 3 
#define PAGER_JOURNALMODE_MEMORY 4 
SQLITE_PRIVATE int sqlite3PagerOpen(sqlite3_vfs *, Pager **ppPager, const char*, int,int,int); SQLITE_PRIVATE void sqlite3PagerSetBusyhandler(Pager*, int(*)(void *), void *); SQLITE_PRIVATE void sqlite3PagerSetReiniter(Pager*, void(*)(DbPage*)); SQLITE_PRIVATE int sqlite3PagerSetPagesize(Pager*, u16*); SQLITE_PRIVATE int sqlite3PagerMaxPageCount(Pager*, int); SQLITE_PRIVATE int sqlite3PagerReadFileheader(Pager*, int, unsigned char*); SQLITE_PRIVATE void sqlite3PagerSetCachesize(Pager*, int); SQLITE_PRIVATE int sqlite3PagerClose(Pager *pPager); SQLITE_PRIVATE int sqlite3PagerAcquire(Pager *pPager, Pgno pgno, DbPage **ppPage, int clrFlag); 
#define sqlite3PagerGet(A,B,C) sqlite3PagerAcquire(A,B,C,0) 
SQLITE_PRIVATE DbPage *sqlite3PagerLookup(Pager *pPager, Pgno pgno); SQLITE_PRIVATE int sqlite3PagerPageRefcount(DbPage*); SQLITE_PRIVATE int sqlite3PagerRef(DbPage*); SQLITE_PRIVATE int sqlite3PagerUnref(DbPage*); SQLITE_PRIVATE int sqlite3PagerWrite(DbPage*); SQLITE_PRIVATE int sqlite3PagerPagecount(Pager*, int*); SQLITE_PRIVATE int sqlite3PagerTruncate(Pager*,Pgno); SQLITE_PRIVATE int sqlite3PagerBegin(DbPage*, int exFlag); SQLITE_PRIVATE int sqlite3PagerCommitPhaseOne(Pager*,const char *zMaster, Pgno, int); SQLITE_PRIVATE int sqlite3PagerCommitPhaseTwo(Pager*); SQLITE_PRIVATE int sqlite3PagerRollback(Pager*); SQLITE_PRIVATE int sqlite3PagerIsreadonly(Pager*); SQLITE_PRIVATE int sqlite3PagerStmtBegin(Pager*); SQLITE_PRIVATE int sqlite3PagerStmtCommit(Pager*); SQLITE_PRIVATE int sqlite3PagerStmtRollback(Pager*); SQLITE_PRIVATE void sqlite3PagerDontRollback(DbPage*); SQLITE_PRIVATE int sqlite3PagerDontWrite(DbPage*); SQLITE_PRIVATE int sqlite3PagerRefcount(Pager*); SQLITE_PRIVATE void sqlite3PagerSetSafetyLevel(Pager*,int,int); SQLITE_PRIVATE const char *sqlite3PagerFilename(Pager*); SQLITE_PRIVATE const sqlite3_vfs *sqlite3PagerVfs(Pager*); SQLITE_PRIVATE sqlite3_file *sqlite3PagerFile(Pager*); SQLITE_PRIVATE const char *sqlite3PagerDirname(Pager*); SQLITE_PRIVATE const char *sqlite3PagerJournalname(Pager*); SQLITE_PRIVATE int sqlite3PagerNosync(Pager*); SQLITE_PRIVATE int sqlite3PagerMovepage(Pager*,DbPage*,Pgno,int); SQLITE_PRIVATE void *sqlite3PagerGetData(DbPage *); SQLITE_PRIVATE void *sqlite3PagerGetExtra(DbPage *); SQLITE_PRIVATE int sqlite3PagerLockingMode(Pager *, int); SQLITE_PRIVATE int sqlite3PagerJournalMode(Pager *, int); SQLITE_PRIVATE i64 sqlite3PagerJournalSizeLimit(Pager *, i64); SQLITE_PRIVATE void *sqlite3PagerTempSpace(Pager*); SQLITE_PRIVATE int sqlite3PagerSync(Pager *pPager); 
#ifdef SQLITE_HAS_CODEC 
SQLITE_PRIVATE void sqlite3PagerSetCodec(Pager*,void*(*)(void*,void*,Pgno,int),void*); 
#endif 
#if !defined(NDEBUG) || defined(SQLITE_TEST) 
SQLITE_PRIVATE Pgno sqlite3PagerPagenumber(DbPage*); SQLITE_PRIVATE int sqlite3PagerIswriteable(DbPage*); 
#endif 
#ifdef SQLITE_TEST 
SQLITE_PRIVATE int *sqlite3PagerStats(Pager*); SQLITE_PRIVATE void sqlite3PagerRefdump(Pager*); SQLITE_PRIVATE int sqlite3PagerIsMemdb(Pager*); 
#endif 
#ifdef SQLITE_TEST 
void disable_simulated_io_errors(void); void enable_simulated_io_errors(void); 
#else 
#define disable_simulated_io_errors() 
#define enable_simulated_io_errors() 
#endif 
#endif 
#ifndef _PCACHE_H_ 
typedef struct PgHdr PgHdr; typedef struct PCache PCache; struct PgHdr { void *pData; void *pExtra; PgHdr *pDirty; Pgno pgno; Pager *pPager; 
#ifdef SQLITE_CHECK_PAGES 
 u32 pageHash; 
#endif 
 u16 flags; i16 nRef; PCache *pCache; PgHdr *pDirtyNext; PgHdr *pDirtyPrev; }; 
#define PGHDR_DIRTY 0x002 
#define PGHDR_NEED_SYNC 0x004 
#define PGHDR_NEED_READ 0x008 
#define PGHDR_REUSE_UNLIKELY 0x010 
#define PGHDR_DONT_WRITE 0x020 
SQLITE_PRIVATE int sqlite3PcacheInitialize(void); SQLITE_PRIVATE void sqlite3PcacheShutdown(void); SQLITE_PRIVATE void sqlite3PCacheBufferSetup(void *, int sz, int n); SQLITE_PRIVATE void sqlite3PcacheOpen( int szPage, int szExtra, int bPurgeable, int (*xStress)(void*, PgHdr*), void *pStress, PCache *pToInit ); SQLITE_PRIVATE void sqlite3PcacheSetPageSize(PCache *, int); SQLITE_PRIVATE int sqlite3PcacheSize(void); SQLITE_PRIVATE int sqlite3PcacheFetch(PCache*, Pgno, int createFlag, PgHdr**); SQLITE_PRIVATE void sqlite3PcacheRelease(PgHdr*); SQLITE_PRIVATE void sqlite3PcacheDrop(PgHdr*); SQLITE_PRIVATE void sqlite3PcacheMakeDirty(PgHdr*); SQLITE_PRIVATE void sqlite3PcacheMakeClean(PgHdr*); SQLITE_PRIVATE void sqlite3PcacheCleanAll(PCache*); SQLITE_PRIVATE void sqlite3PcacheMove(PgHdr*, Pgno); SQLITE_PRIVATE void sqlite3PcacheTruncate(PCache*, Pgno x); SQLITE_PRIVATE PgHdr *sqlite3PcacheDirtyList(PCache*); SQLITE_PRIVATE void sqlite3PcacheClose(PCache*); SQLITE_PRIVATE void sqlite3PcacheClearSyncFlags(PCache *); SQLITE_PRIVATE int sqlite3PcacheClear(PCache*); SQLITE_PRIVATE int sqlite3PcacheRefCount(PCache*); SQLITE_PRIVATE void sqlite3PcacheRef(PgHdr*); SQLITE_PRIVATE int sqlite3PcachePageRefcount(PgHdr*); SQLITE_PRIVATE int sqlite3PcachePagecount(PCache*); 
#ifdef SQLITE_CHECK_PAGES 
SQLITE_PRIVATE void sqlite3PcacheIterateDirty(PCache *pCache, void (*xIter)(PgHdr *)); 
#endif 
SQLITE_PRIVATE void sqlite3PcacheSetCachesize(PCache *, int); 
#ifdef SQLITE_TEST 
SQLITE_PRIVATE int sqlite3PcacheGetCachesize(PCache *); 
#endif 
#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT 
SQLITE_PRIVATE int sqlite3PcacheReleaseMemory(int); 
#endif 
#ifdef SQLITE_TEST 
SQLITE_PRIVATE void sqlite3PcacheStats(int*,int*,int*,int*); 
#endif 
SQLITE_PRIVATE void sqlite3PCacheSetDefault(void); 
#endif 
#ifndef _SQLITE_OS_H_ 
#define _SQLITE_OS_H_ 
#if defined(SQLITE_OS_OTHER) 
#if SQLITE_OS_OTHER==1 
#undef SQLITE_OS_UNIX 
#define SQLITE_OS_UNIX 0 
#undef SQLITE_OS_WIN 
#define SQLITE_OS_WIN 0 
#undef SQLITE_OS_OS2 
#define SQLITE_OS_OS2 0 
#else 
#undef SQLITE_OS_OTHER 
#endif 
#endif 
#if !defined(SQLITE_OS_UNIX) && !defined(SQLITE_OS_OTHER) 
#define SQLITE_OS_OTHER 0 
#ifndef SQLITE_OS_WIN 
#if defined(_WIN32) || defined(WIN32) || defined(__CYGWIN__) || defined(__MINGW32__) || defined(__BORLANDC__) 
#define SQLITE_OS_WIN 1 
#define SQLITE_OS_UNIX 0 
#define SQLITE_OS_OS2 0 
#elif defined(__EMX__) || defined(_OS2) || defined(OS2) || defined(_OS2_) || defined(__OS2__) 
#define SQLITE_OS_WIN 0 
#define SQLITE_OS_UNIX 0 
#define SQLITE_OS_OS2 1 
#else 
#define SQLITE_OS_WIN 0 
#define SQLITE_OS_UNIX 1 
#define SQLITE_OS_OS2 0 
#endif 
#else 
#define SQLITE_OS_UNIX 0 
#define SQLITE_OS_OS2 0 
#endif 
#else 
#ifndef SQLITE_OS_WIN 
#define SQLITE_OS_WIN 0 
#endif 
#endif 
#if defined(_WIN32_WCE) 
#define SQLITE_OS_WINCE 1 
#else 
#define SQLITE_OS_WINCE 0 
#endif 
#if SQLITE_OS_WIN 
#include <windows.h> 
#define SQLITE_TEMPNAME_SIZE (MAX_PATH+50) 
#elif SQLITE_OS_OS2 
#if (__GNUC__ > 3 || __GNUC__ == 3 && __GNUC_MINOR__ >= 3) && defined(OS2_HIGH_MEMORY) 
#include <os2safe.h> 
#endif 
#define INCL_DOSDATETIME 
#define INCL_DOSFILEMGR 
#define INCL_DOSERRORS 
#define INCL_DOSMISC 
#define INCL_DOSPROCESS 
#define INCL_DOSMODULEMGR 
#define INCL_DOSSEMAPHORES 
#include <os2.h> 
#include <uconv.h> 
#define SQLITE_TEMPNAME_SIZE (CCHMAXPATHCOMP) 
#else 
#define SQLITE_TEMPNAME_SIZE 200 
#endif 
#ifndef SET_FULLSYNC 
#define SET_FULLSYNC(x,y) 
#endif 
#ifndef SQLITE_DEFAULT_SECTOR_SIZE 
#define SQLITE_DEFAULT_SECTOR_SIZE 512 
#endif 
#ifndef SQLITE_TEMP_FILE_PREFIX 
#define SQLITE_TEMP_FILE_PREFIX "etilqs_" 
#endif 
#define NO_LOCK 0 
#define SHARED_LOCK 1 
#define RESERVED_LOCK 2 
#define PENDING_LOCK 3 
#define EXCLUSIVE_LOCK 4 
#ifndef SQLITE_TEST 
#define PENDING_BYTE 0x40000000 
#else 
SQLITE_API extern unsigned int sqlite3_pending_byte; 
#define PENDING_BYTE sqlite3_pending_byte 
#endif 
#define RESERVED_BYTE (PENDING_BYTE+1) 
#define SHARED_FIRST (PENDING_BYTE+2) 
#define SHARED_SIZE 510 
SQLITE_PRIVATE int sqlite3OsClose(sqlite3_file*); SQLITE_PRIVATE int sqlite3OsRead(sqlite3_file*, void*, int amt, i64 offset); SQLITE_PRIVATE int sqlite3OsWrite(sqlite3_file*, const void*, int amt, i64 offset); SQLITE_PRIVATE int sqlite3OsTruncate(sqlite3_file*, i64 size); SQLITE_PRIVATE int sqlite3OsSync(sqlite3_file*, int); SQLITE_PRIVATE int sqlite3OsFileSize(sqlite3_file*, i64 *pSize); SQLITE_PRIVATE int sqlite3OsLock(sqlite3_file*, int); SQLITE_PRIVATE int sqlite3OsUnlock(sqlite3_file*, int); SQLITE_PRIVATE int sqlite3OsCheckReservedLock(sqlite3_file *id, int *pResOut); SQLITE_PRIVATE int sqlite3OsFileControl(sqlite3_file*,int,void*); SQLITE_PRIVATE int sqlite3OsSectorSize(sqlite3_file *id); SQLITE_PRIVATE int sqlite3OsDeviceCharacteristics(sqlite3_file *id); SQLITE_PRIVATE int sqlite3OsOpen(sqlite3_vfs *, const char *, sqlite3_file*, int, int *); SQLITE_PRIVATE int sqlite3OsDelete(sqlite3_vfs *, const char *, int); SQLITE_PRIVATE int sqlite3OsAccess(sqlite3_vfs *, const char *, int, int *pResOut); SQLITE_PRIVATE int sqlite3OsFullPathname(sqlite3_vfs *, const char *, int, char *); 
#ifndef SQLITE_OMIT_LOAD_EXTENSION 
SQLITE_PRIVATE void *sqlite3OsDlOpen(sqlite3_vfs *, const char *); SQLITE_PRIVATE void sqlite3OsDlError(sqlite3_vfs *, int, char *); SQLITE_PRIVATE void *sqlite3OsDlSym(sqlite3_vfs *, void *, const char *); SQLITE_PRIVATE void sqlite3OsDlClose(sqlite3_vfs *, void *); 
#endif 
SQLITE_PRIVATE int sqlite3OsRandomness(sqlite3_vfs *, int, char *); SQLITE_PRIVATE int sqlite3OsSleep(sqlite3_vfs *, int); SQLITE_PRIVATE int sqlite3OsCurrentTime(sqlite3_vfs *, double*); SQLITE_PRIVATE int sqlite3OsOpenMalloc(sqlite3_vfs *, const char *, sqlite3_file **, int,int*); SQLITE_PRIVATE int sqlite3OsCloseFree(sqlite3_file *); 
#endif 
#if !SQLITE_THREADSAFE 
#define SQLITE_MUTEX_OMIT 
#endif 
#if SQLITE_THREADSAFE && !defined(SQLITE_MUTEX_NOOP) 
#if SQLITE_OS_UNIX 
#define SQLITE_MUTEX_PTHREADS 
#elif SQLITE_OS_WIN 
#define SQLITE_MUTEX_W32 
#elif SQLITE_OS_OS2 
#define SQLITE_MUTEX_OS2 
#else 
#define SQLITE_MUTEX_NOOP 
#endif 
#endif 
#ifdef SQLITE_MUTEX_OMIT 
#define sqlite3_mutex_alloc(X) ((sqlite3_mutex*)8) 
#define sqlite3_mutex_free(X) 
#define sqlite3_mutex_enter(X) 
#define sqlite3_mutex_try(X) SQLITE_OK 
#define sqlite3_mutex_leave(X) 
#define sqlite3_mutex_held(X) 1 
#define sqlite3_mutex_notheld(X) 1 
#define sqlite3MutexAlloc(X) ((sqlite3_mutex*)8) 
#define sqlite3MutexInit() SQLITE_OK 
#define sqlite3MutexEnd() 
#endif 
struct Db { char *zName; Btree *pBt; u8 inTrans; u8 safety_level; void *pAux; void (*xFreeAux)(void*); Schema *pSchema; }; struct Schema { int schema_cookie; Hash tblHash; Hash idxHash; Hash trigHash; Hash aFKey; Table *pSeqTab; u8 file_format; u8 enc; u16 flags; int cache_size; 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 sqlite3 *db; 
#endif 
}; 
#define DbHasProperty(D,I,P) (((D)->aDb[I].pSchema->flags&(P))==(P)) 
#define DbHasAnyProperty(D,I,P) (((D)->aDb[I].pSchema->flags&(P))!=0) 
#define DbSetProperty(D,I,P) (D)->aDb[I].pSchema->flags|=(P) 
#define DbClearProperty(D,I,P) (D)->aDb[I].pSchema->flags&=~(P) 
#define DB_SchemaLoaded 0x0001 
#define DB_UnresetViews 0x0002 
#define DB_Empty 0x0004 
#define SQLITE_N_LIMIT (SQLITE_LIMIT_VARIABLE_NUMBER+1) 
struct Lookaside { u16 sz; u8 bEnabled; u8 bMalloced; int nOut; int mxOut; LookasideSlot *pFree; void *pStart; void *pEnd; }; struct LookasideSlot { LookasideSlot *pNext; }; struct FuncDefHash { FuncDef *a[23]; }; struct sqlite3 { sqlite3_vfs *pVfs; int nDb; Db *aDb; int flags; int openFlags; int errCode; int errMask; u8 autoCommit; u8 temp_store; u8 mallocFailed; u8 dfltLockMode; u8 dfltJournalMode; signed char nextAutovac; int nextPagesize; int nTable; CollSeq *pDfltColl; i64 lastRowid; i64 priorNewRowid; u32 magic; int nChange; int nTotalChange; sqlite3_mutex *mutex; int aLimit[SQLITE_N_LIMIT]; struct sqlite3InitInfo { int iDb; int newTnum; u8 busy; } init; int nExtension; void **aExtension; struct Vdbe *pVdbe; int activeVdbeCnt; int writeVdbeCnt; void (*xTrace)(void*,const char*); void *pTraceArg; void (*xProfile)(void*,const char*,u64); void *pProfileArg; void *pCommitArg; int (*xCommitCallback)(void*); void *pRollbackArg; void (*xRollbackCallback)(void*); void *pUpdateArg; void (*xUpdateCallback)(void*,int, const char*,const char*,sqlite_int64); void(*xCollNeeded)(void*,sqlite3*,int eTextRep,const char*); void(*xCollNeeded16)(void*,sqlite3*,int eTextRep,const void*); void *pCollNeededArg; sqlite3_value *pErr; char *zErrMsg; char *zErrMsg16; union { volatile int isInterrupted; double notUsed1; } u1; Lookaside lookaside; 
#ifndef SQLITE_OMIT_AUTHORIZATION 
 int (*xAuth)(void*,int,const char*,const char*,const char*,const char*); void *pAuthArg; 
#endif 
#ifndef SQLITE_OMIT_PROGRESS_CALLBACK 
 int (*xProgress)(void *); void *pProgressArg; int nProgressOps; 
#endif 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 Hash aModule; Table *pVTab; sqlite3_vtab **aVTrans; int nVTrans; 
#endif 
 FuncDefHash aFunc; Hash aCollSeq; BusyHandler busyHandler; int busyTimeout; Db aDbStatic[2]; 
#ifdef SQLITE_SSE 
 sqlite3_stmt *pFetch; 
#endif 
}; 
#define ENC(db) ((db)->aDb[0].pSchema->enc) 
#define SQLITE_VdbeTrace 0x00000001 
#define SQLITE_InTrans 0x00000008 
#define SQLITE_InternChanges 0x00000010 
#define SQLITE_FullColNames 0x00000020 
#define SQLITE_ShortColNames 0x00000040 
#define SQLITE_CountRows 0x00000080 
 
#define SQLITE_NullCallback 0x00000100 
 
#define SQLITE_SqlTrace 0x00000200 
#define SQLITE_VdbeListing 0x00000400 
#define SQLITE_WriteSchema 0x00000800 
#define SQLITE_NoReadlock 0x00001000 
#define SQLITE_IgnoreChecks 0x00002000 
#define SQLITE_ReadUncommitted 0x00004000 
#define SQLITE_LegacyFileFmt 0x00008000 
#define SQLITE_FullFSync 0x00010000 
#define SQLITE_LoadExtension 0x00020000 
#define SQLITE_RecoveryMode 0x00040000 
#define SQLITE_SharedCache 0x00080000 
#define SQLITE_Vtab 0x00100000 
#define SQLITE_MAGIC_OPEN 0xa029a697 
#define SQLITE_MAGIC_CLOSED 0x9f3c2d33 
#define SQLITE_MAGIC_SICK 0x4b771290 
#define SQLITE_MAGIC_BUSY 0xf03b7906 
#define SQLITE_MAGIC_ERROR 0xb5357930 
struct FuncDef { i16 nArg; u8 iPrefEnc; u8 flags; void *pUserData; FuncDef *pNext; void (*xFunc)(sqlite3_context*,int,sqlite3_value**); void (*xStep)(sqlite3_context*,int,sqlite3_value**); void (*xFinalize)(sqlite3_context*); char *zName; FuncDef *pHash; }; 
#define SQLITE_FUNC_LIKE 0x01 
#define SQLITE_FUNC_CASE 0x02 
#define SQLITE_FUNC_EPHEM 0x04 
#define SQLITE_FUNC_NEEDCOLL 0x08 
#define FUNCTION(zName, nArg, iArg, bNC, xFunc) {nArg, SQLITE_UTF8, bNC*8, SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, 0, #zName, 0} 
#define STR_FUNCTION(zName, nArg, pArg, bNC, xFunc) {nArg, SQLITE_UTF8, bNC*8, pArg, 0, xFunc, 0, 0, #zName, 0} 
#define LIKEFUNC(zName, nArg, arg, flags) {nArg, SQLITE_UTF8, flags, (void *)arg, 0, likeFunc, 0, 0, #zName, 0} 
#define AGGREGATE(zName, nArg, arg, nc, xStep, xFinal) {nArg, SQLITE_UTF8, nc*8, SQLITE_INT_TO_PTR(arg), 0, 0, xStep,xFinal,#zName,0} 
struct Module { const sqlite3_module *pModule; const char *zName; void *pAux; void (*xDestroy)(void *); }; struct Column { char *zName; Expr *pDflt; char *zType; char *zColl; u8 notNull; u8 isPrimKey; char affinity; 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 u8 isHidden; 
#endif 
}; struct CollSeq { char *zName; u8 enc; u8 type; void *pUser; int (*xCmp)(void*,int, const void*, int, const void*); void (*xDel)(void*); }; 
#define SQLITE_COLL_BINARY 1 
#define SQLITE_COLL_NOCASE 2 
#define SQLITE_COLL_REVERSE 3 
#define SQLITE_COLL_USER 0 
#define SQLITE_SO_ASC 0 
#define SQLITE_SO_DESC 1 
#define SQLITE_AFF_TEXT 'a' 
#define SQLITE_AFF_NONE 'b' 
#define SQLITE_AFF_NUMERIC 'c' 
#define SQLITE_AFF_INTEGER 'd' 
#define SQLITE_AFF_REAL 'e' 
#define sqlite3IsNumericAffinity(X) ((X)>=SQLITE_AFF_NUMERIC) 
#define SQLITE_AFF_MASK 0x67 
#define SQLITE_JUMPIFNULL 0x08 
#define SQLITE_STOREP2 0x10 
struct Table { sqlite3 *db; char *zName; int iPKey; int nCol; Column *aCol; Index *pIndex; int tnum; Select *pSelect; u16 nRef; u8 tabFlags; u8 keyConf; Trigger *pTrigger; FKey *pFKey; char *zColAff; 
#ifndef SQLITE_OMIT_CHECK 
 Expr *pCheck; 
#endif 
#ifndef SQLITE_OMIT_ALTERTABLE 
 int addColOffset; 
#endif 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 Module *pMod; sqlite3_vtab *pVtab; int nModuleArg; char **azModuleArg; 
#endif 
 Schema *pSchema; Table *pNextZombie; }; 
#define TF_Readonly 0x01 
#define TF_Ephemeral 0x02 
#define TF_HasPrimaryKey 0x04 
#define TF_Autoincrement 0x08 
#define TF_Virtual 0x10 
#define TF_NeedMetadata 0x20 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
#define IsVirtual(X) (((X)->tabFlags & TF_Virtual)!=0) 
#define IsHiddenColumn(X) ((X)->isHidden) 
#else 
#define IsVirtual(X) 0 
#define IsHiddenColumn(X) 0 
#endif 
struct FKey { Table *pFrom; FKey *pNextFrom; char *zTo; FKey *pNextTo; int nCol; struct sColMap { int iFrom; char *zCol; } *aCol; u8 isDeferred; u8 updateConf; u8 deleteConf; u8 insertConf; }; 
#define OE_None 0 
#define OE_Rollback 1 
#define OE_Abort 2 
#define OE_Fail 3 
#define OE_Ignore 4 
#define OE_Replace 5 
#define OE_Restrict 6 
#define OE_SetNull 7 
#define OE_SetDflt 8 
#define OE_Cascade 9 
#define OE_Default 99 
struct KeyInfo { sqlite3 *db; u8 enc; u16 nField; u8 *aSortOrder; CollSeq *aColl[1]; }; struct UnpackedRecord { KeyInfo *pKeyInfo; u16 nField; u16 flags; Mem *aMem; }; 
#define UNPACKED_NEED_FREE 0x0001 
#define UNPACKED_NEED_DESTROY 0x0002 
#define UNPACKED_IGNORE_ROWID 0x0004 
#define UNPACKED_INCRKEY 0x0008 
#define UNPACKED_PREFIX_MATCH 0x0010 
struct Index { char *zName; int nColumn; int *aiColumn; unsigned *aiRowEst; Table *pTable; int tnum; u8 onError; u8 autoIndex; char *zColAff; Index *pNext; Schema *pSchema; u8 *aSortOrder; char **azColl; }; struct Token { const unsigned char *z; unsigned dyn : 1; unsigned n : 31; }; struct AggInfo { u8 directMode; u8 useSortingIdx; int sortingIdx; ExprList *pGroupBy; int nSortingColumn; struct AggInfo_col { Table *pTab; int iTable; int iColumn; int iSorterColumn; int iMem; Expr *pExpr; } *aCol; int nColumn; int nColumnAlloc; int nAccumulator; struct AggInfo_func { Expr *pExpr; FuncDef *pFunc; int iMem; int iDistinct; } *aFunc; int nFunc; int nFuncAlloc; }; struct Expr { u8 op; char affinity; u16 flags; CollSeq *pColl; Expr *pLeft, *pRight; ExprList *pList; Token token; Token span; int iTable, iColumn; AggInfo *pAggInfo; int iAgg; int iRightJoinTable; Select *pSelect; Table *pTab; 
#if SQLITE_MAX_EXPR_DEPTH>0 
 int nHeight; 
#endif 
}; 
#define EP_FromJoin 0x0001 
#define EP_Agg 0x0002 
#define EP_Resolved 0x0004 
#define EP_Error 0x0008 
#define EP_Distinct 0x0010 
#define EP_VarSelect 0x0020 
#define EP_Dequoted 0x0040 
#define EP_InfixFunc 0x0080 
#define EP_ExpCollate 0x0100 
#define EP_AnyAff 0x0200 
#define EP_FixedDest 0x0400 
#define EP_IntValue 0x0800 
#define ExprHasProperty(E,P) (((E)->flags&(P))==(P)) 
#define ExprHasAnyProperty(E,P) (((E)->flags&(P))!=0) 
#define ExprSetProperty(E,P) (E)->flags|=(P) 
#define ExprClearProperty(E,P) (E)->flags&=~(P) 
struct ExprList { int nExpr; int nAlloc; int iECursor; struct ExprList_item { Expr *pExpr; char *zName; u8 sortOrder; u8 done; u16 iCol; u16 iAlias; } *a; }; struct IdList { struct IdList_item { char *zName; int idx; } *a; int nId; int nAlloc; }; typedef u64 Bitmask; 
#define BMS ((int)(sizeof(Bitmask)*8)) 
struct SrcList { i16 nSrc; i16 nAlloc; struct SrcList_item { char *zDatabase; char *zName; char *zAlias; Table *pTab; Select *pSelect; u8 isPopulated; u8 jointype; int iCursor; Expr *pOn; IdList *pUsing; Bitmask colUsed; u8 notIndexed; char *zIndex; Index *pIndex; } a[1]; }; 
#define JT_INNER 0x0001 
#define JT_CROSS 0x0002 
#define JT_NATURAL 0x0004 
#define JT_LEFT 0x0008 
#define JT_RIGHT 0x0010 
#define JT_OUTER 0x0020 
#define JT_ERROR 0x0040 
struct WhereLevel { int iFrom; int flags; int iMem; int iLeftJoin; Index *pIdx; int iTabCur; int iIdxCur; int brk; int nxt; int cont; int top; int op, p1, p2, p5; int nEq; int nIn; struct InLoop { int iCur; int topAddr; } *aInLoop; sqlite3_index_info *pBestIdx; sqlite3_index_info *pIdxInfo; }; 
#define WHERE_ORDERBY_NORMAL 0 
#define WHERE_ORDERBY_MIN 1 
#define WHERE_ORDERBY_MAX 2 
#define WHERE_ONEPASS_DESIRED 4 
struct WhereInfo { Parse *pParse; u8 okOnePass; SrcList *pTabList; int iTop; int iContinue; int iBreak; int nLevel; sqlite3_index_info **apInfo; WhereLevel a[1]; }; struct NameContext { Parse *pParse; SrcList *pSrcList; ExprList *pEList; int nRef; int nErr; u8 allowAgg; u8 hasAgg; u8 isCheck; int nDepth; AggInfo *pAggInfo; NameContext *pNext; }; struct Select { ExprList *pEList; u8 op; char affinity; u16 selFlags; SrcList *pSrc; Expr *pWhere; ExprList *pGroupBy; Expr *pHaving; ExprList *pOrderBy; Select *pPrior; Select *pNext; Select *pRightmost; Expr *pLimit; Expr *pOffset; int iLimit, iOffset; int addrOpenEphm[3]; }; 
#define SF_Distinct 0x0001 
#define SF_Resolved 0x0002 
#define SF_Aggregate 0x0004 
#define SF_UsesEphemeral 0x0008 
#define SF_Expanded 0x0010 
#define SF_HasTypeInfo 0x0020 
#define SRT_Union 1 
#define SRT_Except 2 
#define SRT_Exists 3 
#define SRT_Discard 4 
#define IgnorableOrderby(X) ((X->eDest)<=SRT_Discard) 
#define SRT_Output 5 
#define SRT_Mem 6 
#define SRT_Set 7 
#define SRT_Table 8 
#define SRT_EphemTab 9 
#define SRT_Coroutine 10 
typedef struct SelectDest SelectDest; struct SelectDest { u8 eDest; u8 affinity; int iParm; int iMem; int nMem; }; struct Parse { sqlite3 *db; int rc; char *zErrMsg; Vdbe *pVdbe; u8 colNamesSet; u8 nameClash; u8 checkSchema; u8 nested; u8 parseError; u8 nTempReg; u8 nTempInUse; int aTempReg[8]; int nRangeReg; int iRangeReg; int nErr; int nTab; int nMem; int nSet; int ckBase; int disableColCache; int nColCache; int iColCache; struct yColCache { int iTable; int iColumn; char affChange; int iReg; } aColCache[10]; u32 writeMask; u32 cookieMask; int cookieGoto; int cookieValue[SQLITE_MAX_ATTACHED+2]; 
#ifndef SQLITE_OMIT_SHARED_CACHE 
 int nTableLock; TableLock *aTableLock; 
#endif 
 int regRowid; int regRoot; int nVar; int nVarExpr; int nVarExprAlloc; Expr **apVarExpr; int nAlias; int *aAlias; u8 explain; Token sErrToken; Token sNameToken; Token sLastToken; const char *zSql; const char *zTail; Table *pNewTable; Trigger *pNewTrigger; TriggerStack *trigStack; const char *zAuthContext; 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 Token sArg; u8 declareVtab; int nVtabLock; Table **apVtabLock; 
#endif 
 int nHeight; Table *pZombieTab; }; 
#ifdef SQLITE_OMIT_VIRTUALTABLE 
#define IN_DECLARE_VTAB 0 
#else 
#define IN_DECLARE_VTAB (pParse->declareVtab) 
#endif 
struct AuthContext { const char *zAuthContext; Parse *pParse; }; 
#define OPFLAG_NCHANGE 1 
#define OPFLAG_LASTROWID 2 
#define OPFLAG_ISUPDATE 4 
#define OPFLAG_APPEND 8 
struct Trigger { char *name; char *table; u8 op; u8 tr_tm; Expr *pWhen; IdList *pColumns; Token nameToken; Schema *pSchema; Schema *pTabSchema; TriggerStep *step_list; Trigger *pNext; }; 
#define TRIGGER_BEFORE 1 
#define TRIGGER_AFTER 2 
struct TriggerStep { int op; int orconf; Trigger *pTrig; Select *pSelect; Token target; Expr *pWhere; ExprList *pExprList; IdList *pIdList; TriggerStep *pNext; TriggerStep *pLast; }; struct TriggerStack { Table *pTab; int newIdx; int oldIdx; u32 newColMask; u32 oldColMask; int orconf; int ignoreJump; Trigger *pTrigger; TriggerStack *pNext; }; typedef struct DbFixer DbFixer; struct DbFixer { Parse *pParse; const char *zDb; const char *zType; const Token *pName; }; struct StrAccum { sqlite3 *db; char *zBase; char *zText; int nChar; int nAlloc; int mxAlloc; u8 mallocFailed; u8 useMalloc; u8 tooBig; }; typedef struct { sqlite3 *db; int iDb; char **pzErrMsg; int rc; } InitData; struct Sqlite3Config { int bMemstat; int bCoreMutex; int bFullMutex; int mxStrlen; int szLookaside; int nLookaside; sqlite3_mem_methods m; sqlite3_mutex_methods mutex; sqlite3_pcache_methods pcache; void *pHeap; int nHeap; int mnReq, mxReq; void *pScratch; int szScratch; int nScratch; void *pPage; int szPage; int nPage; int isInit; int inProgress; int isMallocInit; sqlite3_mutex *pInitMutex; int nRefInitMutex; int mxParserStack; int sharedCacheEnabled; }; struct Walker { int (*xExprCallback)(Walker*, Expr*); int (*xSelectCallback)(Walker*,Select*); Parse *pParse; union { NameContext *pNC; int i; } u; }; SQLITE_PRIVATE int sqlite3WalkExpr(Walker*, Expr*); SQLITE_PRIVATE int sqlite3WalkExprList(Walker*, ExprList*); SQLITE_PRIVATE int sqlite3WalkSelect(Walker*, Select*); SQLITE_PRIVATE int sqlite3WalkSelectExpr(Walker*, Select*); SQLITE_PRIVATE int sqlite3WalkSelectFrom(Walker*, Select*); 
#define WRC_Continue 0 
#define WRC_Prune 1 
#define WRC_Abort 2 
#define SQLITE_SKIP_UTF8(zIn) { if( (*(zIn++))>=0xc0 ){ while( (*zIn & 0xc0)==0x80 ){ zIn++; } } } 
#ifdef SQLITE_DEBUG 
SQLITE_PRIVATE int sqlite3Corrupt(void); 
#define SQLITE_CORRUPT_BKPT sqlite3Corrupt() 
#else 
#define SQLITE_CORRUPT_BKPT SQLITE_CORRUPT 
#endif 
SQLITE_PRIVATE int sqlite3StrICmp(const char *, const char *); SQLITE_PRIVATE int sqlite3StrNICmp(const char *, const char *, int); SQLITE_PRIVATE int sqlite3IsNumber(const char*, int*, u8); SQLITE_PRIVATE int sqlite3Strlen(sqlite3*, const char*); SQLITE_PRIVATE int sqlite3MallocInit(void); SQLITE_PRIVATE void sqlite3MallocEnd(void); SQLITE_PRIVATE void *sqlite3Malloc(int); SQLITE_PRIVATE void *sqlite3MallocZero(int); SQLITE_PRIVATE void *sqlite3DbMallocZero(sqlite3*, int); SQLITE_PRIVATE void *sqlite3DbMallocRaw(sqlite3*, int); SQLITE_PRIVATE char *sqlite3DbStrDup(sqlite3*,const char*); SQLITE_PRIVATE char *sqlite3DbStrNDup(sqlite3*,const char*, int); SQLITE_PRIVATE void *sqlite3Realloc(void*, int); SQLITE_PRIVATE void *sqlite3DbReallocOrFree(sqlite3 *, void *, int); SQLITE_PRIVATE void *sqlite3DbRealloc(sqlite3 *, void *, int); SQLITE_PRIVATE void sqlite3DbFree(sqlite3*, void*); SQLITE_PRIVATE int sqlite3MallocSize(void*); SQLITE_PRIVATE int sqlite3DbMallocSize(sqlite3*, void*); SQLITE_PRIVATE void *sqlite3ScratchMalloc(int); SQLITE_PRIVATE void sqlite3ScratchFree(void*); SQLITE_PRIVATE void *sqlite3PageMalloc(int); SQLITE_PRIVATE void sqlite3PageFree(void*); SQLITE_PRIVATE void sqlite3MemSetDefault(void); SQLITE_PRIVATE void sqlite3BenignMallocHooks(void (*)(void), void (*)(void)); SQLITE_PRIVATE int sqlite3MemoryAlarm(void (*)(void*, sqlite3_int64, int), void*, sqlite3_int64); 
#ifdef SQLITE_ENABLE_MEMSYS3 
SQLITE_PRIVATE const sqlite3_mem_methods *sqlite3MemGetMemsys3(void); 
#endif 
#ifdef SQLITE_ENABLE_MEMSYS5 
SQLITE_PRIVATE const sqlite3_mem_methods *sqlite3MemGetMemsys5(void); 
#endif 
#ifndef SQLITE_MUTEX_OMIT 
SQLITE_PRIVATE sqlite3_mutex_methods *sqlite3DefaultMutex(void); SQLITE_PRIVATE sqlite3_mutex *sqlite3MutexAlloc(int); SQLITE_PRIVATE int sqlite3MutexInit(void); SQLITE_PRIVATE int sqlite3MutexEnd(void); 
#endif 
SQLITE_PRIVATE int sqlite3StatusValue(int); SQLITE_PRIVATE void sqlite3StatusAdd(int, int); SQLITE_PRIVATE void sqlite3StatusSet(int, int); SQLITE_PRIVATE int sqlite3IsNaN(double); SQLITE_PRIVATE void sqlite3VXPrintf(StrAccum*, int, const char*, va_list); SQLITE_PRIVATE char *sqlite3MPrintf(sqlite3*,const char*, ...); SQLITE_PRIVATE char *sqlite3VMPrintf(sqlite3*,const char*, va_list); SQLITE_PRIVATE char *sqlite3MAppendf(sqlite3*,char*,const char*,...); 
#if defined(SQLITE_TEST) || defined(SQLITE_DEBUG) 
SQLITE_PRIVATE void sqlite3DebugPrintf(const char*, ...); 
#endif 
#if defined(SQLITE_TEST) 
SQLITE_PRIVATE void *sqlite3TestTextToPtr(const char*); 
#endif 
SQLITE_PRIVATE void sqlite3SetString(char **, sqlite3*, const char*, ...); SQLITE_PRIVATE void sqlite3ErrorMsg(Parse*, const char*, ...); SQLITE_PRIVATE void sqlite3ErrorClear(Parse*); SQLITE_PRIVATE void sqlite3Dequote(char*); SQLITE_PRIVATE void sqlite3DequoteExpr(sqlite3*, Expr*); SQLITE_PRIVATE int sqlite3KeywordCode(const unsigned char*, int); SQLITE_PRIVATE int sqlite3RunParser(Parse*, const char*, char **); SQLITE_PRIVATE void sqlite3FinishCoding(Parse*); SQLITE_PRIVATE int sqlite3GetTempReg(Parse*); SQLITE_PRIVATE void sqlite3ReleaseTempReg(Parse*,int); SQLITE_PRIVATE int sqlite3GetTempRange(Parse*,int); SQLITE_PRIVATE void sqlite3ReleaseTempRange(Parse*,int,int); SQLITE_PRIVATE Expr *sqlite3Expr(sqlite3*, int, Expr*, Expr*, const Token*); SQLITE_PRIVATE Expr *sqlite3PExpr(Parse*, int, Expr*, Expr*, const Token*); SQLITE_PRIVATE Expr *sqlite3RegisterExpr(Parse*,Token*); SQLITE_PRIVATE Expr *sqlite3ExprAnd(sqlite3*,Expr*, Expr*); SQLITE_PRIVATE void sqlite3ExprSpan(Expr*,Token*,Token*); SQLITE_PRIVATE Expr *sqlite3ExprFunction(Parse*,ExprList*, Token*); SQLITE_PRIVATE void sqlite3ExprAssignVarNumber(Parse*, Expr*); SQLITE_PRIVATE void sqlite3ExprClear(sqlite3*, Expr*); SQLITE_PRIVATE void sqlite3ExprDelete(sqlite3*, Expr*); SQLITE_PRIVATE ExprList *sqlite3ExprListAppend(Parse*,ExprList*,Expr*,Token*); SQLITE_PRIVATE void sqlite3ExprListDelete(sqlite3*, ExprList*); SQLITE_PRIVATE int sqlite3Init(sqlite3*, char**); SQLITE_PRIVATE int sqlite3InitCallback(void*, int, char**, char**); SQLITE_PRIVATE void sqlite3Pragma(Parse*,Token*,Token*,Token*,int); SQLITE_PRIVATE void sqlite3ResetInternalSchema(sqlite3*, int); SQLITE_PRIVATE void sqlite3BeginParse(Parse*,int); SQLITE_PRIVATE void sqlite3CommitInternalChanges(sqlite3*); SQLITE_PRIVATE Table *sqlite3ResultSetOfSelect(Parse*,Select*); SQLITE_PRIVATE void sqlite3OpenMasterTable(Parse *, int); SQLITE_PRIVATE void sqlite3StartTable(Parse*,Token*,Token*,int,int,int,int); SQLITE_PRIVATE void sqlite3AddColumn(Parse*,Token*); SQLITE_PRIVATE void sqlite3AddNotNull(Parse*, int); SQLITE_PRIVATE void sqlite3AddPrimaryKey(Parse*, ExprList*, int, int, int); SQLITE_PRIVATE void sqlite3AddCheckConstraint(Parse*, Expr*); SQLITE_PRIVATE void sqlite3AddColumnType(Parse*,Token*); SQLITE_PRIVATE void sqlite3AddDefaultValue(Parse*,Expr*); SQLITE_PRIVATE void sqlite3AddCollateType(Parse*, Token*); SQLITE_PRIVATE void sqlite3EndTable(Parse*,Token*,Token*,Select*); SQLITE_PRIVATE Bitvec *sqlite3BitvecCreate(u32); SQLITE_PRIVATE int sqlite3BitvecTest(Bitvec*, u32); SQLITE_PRIVATE int sqlite3BitvecSet(Bitvec*, u32); SQLITE_PRIVATE void sqlite3BitvecClear(Bitvec*, u32); SQLITE_PRIVATE void sqlite3BitvecDestroy(Bitvec*); SQLITE_PRIVATE int sqlite3BitvecBuiltinTest(int,int*); SQLITE_PRIVATE void sqlite3CreateView(Parse*,Token*,Token*,Token*,Select*,int,int); 
#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE) 
SQLITE_PRIVATE int sqlite3ViewGetColumnNames(Parse*,Table*); 
#else 
#define sqlite3ViewGetColumnNames(A,B) 0 
#endif 
SQLITE_PRIVATE void sqlite3DropTable(Parse*, SrcList*, int, int); SQLITE_PRIVATE void sqlite3DeleteTable(Table*); SQLITE_PRIVATE void sqlite3Insert(Parse*, SrcList*, ExprList*, Select*, IdList*, int); SQLITE_PRIVATE void *sqlite3ArrayAllocate(sqlite3*,void*,int,int,int*,int*,int*); SQLITE_PRIVATE IdList *sqlite3IdListAppend(sqlite3*, IdList*, Token*); SQLITE_PRIVATE int sqlite3IdListIndex(IdList*,const char*); SQLITE_PRIVATE SrcList *sqlite3SrcListEnlarge(sqlite3*, SrcList*, int, int); SQLITE_PRIVATE SrcList *sqlite3SrcListAppend(sqlite3*, SrcList*, Token*, Token*); SQLITE_PRIVATE SrcList *sqlite3SrcListAppendFromTerm(Parse*, SrcList*, Token*, Token*, Token*, Select*, Expr*, IdList*); SQLITE_PRIVATE void sqlite3SrcListIndexedBy(Parse *, SrcList *, Token *); SQLITE_PRIVATE int sqlite3IndexedByLookup(Parse *, struct SrcList_item *); SQLITE_PRIVATE void sqlite3SrcListShiftJoinType(SrcList*); SQLITE_PRIVATE void sqlite3SrcListAssignCursors(Parse*, SrcList*); SQLITE_PRIVATE void sqlite3IdListDelete(sqlite3*, IdList*); SQLITE_PRIVATE void sqlite3SrcListDelete(sqlite3*, SrcList*); SQLITE_PRIVATE void sqlite3CreateIndex(Parse*,Token*,Token*,SrcList*,ExprList*,int,Token*, Token*, int, int); SQLITE_PRIVATE void sqlite3DropIndex(Parse*, SrcList*, int); SQLITE_PRIVATE int sqlite3Select(Parse*, Select*, SelectDest*); SQLITE_PRIVATE Select *sqlite3SelectNew(Parse*,ExprList*,SrcList*,Expr*,ExprList*, Expr*,ExprList*,int,Expr*,Expr*); SQLITE_PRIVATE void sqlite3SelectDelete(sqlite3*, Select*); SQLITE_PRIVATE Table *sqlite3SrcListLookup(Parse*, SrcList*); SQLITE_PRIVATE int sqlite3IsReadOnly(Parse*, Table*, int); SQLITE_PRIVATE void sqlite3OpenTable(Parse*, int iCur, int iDb, Table*, int); 
#if defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) && !defined(SQLITE_OMIT_SUBQUERY) 
SQLITE_PRIVATE Expr *sqlite3LimitWhere(Parse *, SrcList *, Expr *, ExprList *, Expr *, Expr *, char *); 
#endif 
SQLITE_PRIVATE void sqlite3DeleteFrom(Parse*, SrcList*, Expr*); SQLITE_PRIVATE void sqlite3Update(Parse*, SrcList*, ExprList*, Expr*, int); SQLITE_PRIVATE WhereInfo *sqlite3WhereBegin(Parse*, SrcList*, Expr*, ExprList**, u8); SQLITE_PRIVATE void sqlite3WhereEnd(WhereInfo*); SQLITE_PRIVATE int sqlite3ExprCodeGetColumn(Parse*, Table*, int, int, int, int); SQLITE_PRIVATE void sqlite3ExprCodeMove(Parse*, int, int, int); SQLITE_PRIVATE void sqlite3ExprCodeCopy(Parse*, int, int, int); SQLITE_PRIVATE void sqlite3ExprClearColumnCache(Parse*, int); SQLITE_PRIVATE void sqlite3ExprCacheAffinityChange(Parse*, int, int); SQLITE_PRIVATE int sqlite3ExprWritableRegister(Parse*,int,int); SQLITE_PRIVATE void sqlite3ExprHardCopy(Parse*,int,int); SQLITE_PRIVATE int sqlite3ExprCode(Parse*, Expr*, int); SQLITE_PRIVATE int sqlite3ExprCodeTemp(Parse*, Expr*, int*); SQLITE_PRIVATE int sqlite3ExprCodeTarget(Parse*, Expr*, int); SQLITE_PRIVATE int sqlite3ExprCodeAndCache(Parse*, Expr*, int); SQLITE_PRIVATE void sqlite3ExprCodeConstants(Parse*, Expr*); SQLITE_PRIVATE int sqlite3ExprCodeExprList(Parse*, ExprList*, int, int); SQLITE_PRIVATE void sqlite3ExprIfTrue(Parse*, Expr*, int, int); SQLITE_PRIVATE void sqlite3ExprIfFalse(Parse*, Expr*, int, int); SQLITE_PRIVATE Table *sqlite3FindTable(sqlite3*,const char*, const char*); SQLITE_PRIVATE Table *sqlite3LocateTable(Parse*,int isView,const char*, const char*); SQLITE_PRIVATE Index *sqlite3FindIndex(sqlite3*,const char*, const char*); SQLITE_PRIVATE void sqlite3UnlinkAndDeleteTable(sqlite3*,int,const char*); SQLITE_PRIVATE void sqlite3UnlinkAndDeleteIndex(sqlite3*,int,const char*); SQLITE_PRIVATE void sqlite3Vacuum(Parse*); SQLITE_PRIVATE int sqlite3RunVacuum(char**, sqlite3*); SQLITE_PRIVATE char *sqlite3NameFromToken(sqlite3*, Token*); SQLITE_PRIVATE int sqlite3ExprCompare(Expr*, Expr*); SQLITE_PRIVATE void sqlite3ExprAnalyzeAggregates(NameContext*, Expr*); SQLITE_PRIVATE void sqlite3ExprAnalyzeAggList(NameContext*,ExprList*); SQLITE_PRIVATE Vdbe *sqlite3GetVdbe(Parse*); SQLITE_PRIVATE Expr *sqlite3CreateIdExpr(Parse *, const char*); SQLITE_PRIVATE void sqlite3PrngSaveState(void); SQLITE_PRIVATE void sqlite3PrngRestoreState(void); SQLITE_PRIVATE void sqlite3PrngResetState(void); SQLITE_PRIVATE void sqlite3RollbackAll(sqlite3*); SQLITE_PRIVATE void sqlite3CodeVerifySchema(Parse*, int); SQLITE_PRIVATE void sqlite3BeginTransaction(Parse*, int); SQLITE_PRIVATE void sqlite3CommitTransaction(Parse*); SQLITE_PRIVATE void sqlite3RollbackTransaction(Parse*); SQLITE_PRIVATE int sqlite3ExprIsConstant(Expr*); SQLITE_PRIVATE int sqlite3ExprIsConstantNotJoin(Expr*); SQLITE_PRIVATE int sqlite3ExprIsConstantOrFunction(Expr*); SQLITE_PRIVATE int sqlite3ExprIsInteger(Expr*, int*); SQLITE_PRIVATE int sqlite3IsRowid(const char*); SQLITE_PRIVATE void sqlite3GenerateRowDelete(Parse*, Table*, int, int, int); SQLITE_PRIVATE void sqlite3GenerateRowIndexDelete(Parse*, Table*, int, int*); SQLITE_PRIVATE int sqlite3GenerateIndexKey(Parse*, Index*, int, int, int); SQLITE_PRIVATE void sqlite3GenerateConstraintChecks(Parse*,Table*,int,int, int*,int,int,int,int); SQLITE_PRIVATE void sqlite3CompleteInsertion(Parse*, Table*, int, int, int*, int, int, int); SQLITE_PRIVATE int sqlite3OpenTableAndIndices(Parse*, Table*, int, int); SQLITE_PRIVATE void sqlite3BeginWriteOperation(Parse*, int, int); SQLITE_PRIVATE Expr *sqlite3ExprDup(sqlite3*,Expr*); SQLITE_PRIVATE void sqlite3TokenCopy(sqlite3*,Token*, Token*); SQLITE_PRIVATE ExprList *sqlite3ExprListDup(sqlite3*,ExprList*); SQLITE_PRIVATE SrcList *sqlite3SrcListDup(sqlite3*,SrcList*); SQLITE_PRIVATE IdList *sqlite3IdListDup(sqlite3*,IdList*); SQLITE_PRIVATE Select *sqlite3SelectDup(sqlite3*,Select*); SQLITE_PRIVATE void sqlite3FuncDefInsert(FuncDefHash*, FuncDef*); SQLITE_PRIVATE FuncDef *sqlite3FindFunction(sqlite3*,const char*,int,int,u8,int); SQLITE_PRIVATE void sqlite3RegisterBuiltinFunctions(sqlite3*); SQLITE_PRIVATE void sqlite3RegisterDateTimeFunctions(void); SQLITE_PRIVATE void sqlite3RegisterGlobalFunctions(void); 
#ifdef SQLITE_DEBUG 
SQLITE_PRIVATE int sqlite3SafetyOn(sqlite3*); SQLITE_PRIVATE int sqlite3SafetyOff(sqlite3*); 
#else 
#define sqlite3SafetyOn(A) 0 
#define sqlite3SafetyOff(A) 0 
#endif 
SQLITE_PRIVATE int sqlite3SafetyCheckOk(sqlite3*); SQLITE_PRIVATE int sqlite3SafetyCheckSickOrOk(sqlite3*); SQLITE_PRIVATE void sqlite3ChangeCookie(Parse*, int); 
#if !defined(SQLITE_OMIT_VIEW) && !defined(SQLITE_OMIT_TRIGGER) 
SQLITE_PRIVATE void sqlite3MaterializeView(Parse*, Table*, Expr*, int); 
#endif 
#ifndef SQLITE_OMIT_TRIGGER 
SQLITE_PRIVATE void sqlite3BeginTrigger(Parse*, Token*,Token*,int,int,IdList*,SrcList*, Expr*,int, int); SQLITE_PRIVATE void sqlite3FinishTrigger(Parse*, TriggerStep*, Token*); SQLITE_PRIVATE void sqlite3DropTrigger(Parse*, SrcList*, int); SQLITE_PRIVATE void sqlite3DropTriggerPtr(Parse*, Trigger*); SQLITE_PRIVATE int sqlite3TriggersExist(Table*, int, ExprList*); SQLITE_PRIVATE int sqlite3CodeRowTrigger(Parse*, int, ExprList*, int, Table *, int, int, int, int, u32*, u32*); void sqliteViewTriggers(Parse*, Table*, Expr*, int, ExprList*); SQLITE_PRIVATE void sqlite3DeleteTriggerStep(sqlite3*, TriggerStep*); SQLITE_PRIVATE TriggerStep *sqlite3TriggerSelectStep(sqlite3*,Select*); SQLITE_PRIVATE TriggerStep *sqlite3TriggerInsertStep(sqlite3*,Token*, IdList*, ExprList*,Select*,int); SQLITE_PRIVATE TriggerStep *sqlite3TriggerUpdateStep(sqlite3*,Token*,ExprList*, Expr*, int); SQLITE_PRIVATE TriggerStep *sqlite3TriggerDeleteStep(sqlite3*,Token*, Expr*); SQLITE_PRIVATE void sqlite3DeleteTrigger(sqlite3*, Trigger*); SQLITE_PRIVATE void sqlite3UnlinkAndDeleteTrigger(sqlite3*,int,const char*); 
#else 
#define sqlite3TriggersExist(B,C,D,E,F) 0 
#define sqlite3DeleteTrigger(A,B) 
#define sqlite3DropTriggerPtr(A,B) 
#define sqlite3UnlinkAndDeleteTrigger(A,B,C) 
#define sqlite3CodeRowTrigger(A,B,C,D,E,F,G,H,I,J,K) 0 
#endif 
SQLITE_PRIVATE int sqlite3JoinType(Parse*, Token*, Token*, Token*); SQLITE_PRIVATE void sqlite3CreateForeignKey(Parse*, ExprList*, Token*, ExprList*, int); SQLITE_PRIVATE void sqlite3DeferForeignKey(Parse*, int); 
#ifndef SQLITE_OMIT_AUTHORIZATION 
SQLITE_PRIVATE void sqlite3AuthRead(Parse*,Expr*,Schema*,SrcList*); SQLITE_PRIVATE int sqlite3AuthCheck(Parse*,int, const char*, const char*, const char*); SQLITE_PRIVATE void sqlite3AuthContextPush(Parse*, AuthContext*, const char*); SQLITE_PRIVATE void sqlite3AuthContextPop(AuthContext*); 
#else 
#define sqlite3AuthRead(a,b,c,d) 
#define sqlite3AuthCheck(a,b,c,d,e) SQLITE_OK 
#define sqlite3AuthContextPush(a,b,c) 
#define sqlite3AuthContextPop(a) ((void)(a)) 
#endif 
SQLITE_PRIVATE void sqlite3Attach(Parse*, Expr*, Expr*, Expr*); SQLITE_PRIVATE void sqlite3Detach(Parse*, Expr*); SQLITE_PRIVATE int sqlite3BtreeFactory(const sqlite3 *db, const char *zFilename, int omitJournal, int nCache, int flags, Btree **ppBtree); SQLITE_PRIVATE int sqlite3FixInit(DbFixer*, Parse*, int, const char*, const Token*); SQLITE_PRIVATE int sqlite3FixSrcList(DbFixer*, SrcList*); SQLITE_PRIVATE int sqlite3FixSelect(DbFixer*, Select*); SQLITE_PRIVATE int sqlite3FixExpr(DbFixer*, Expr*); SQLITE_PRIVATE int sqlite3FixExprList(DbFixer*, ExprList*); SQLITE_PRIVATE int sqlite3FixTriggerStep(DbFixer*, TriggerStep*); SQLITE_PRIVATE int sqlite3AtoF(const char *z, double*); SQLITE_PRIVATE int sqlite3GetInt32(const char *, int*); SQLITE_PRIVATE int sqlite3FitsIn64Bits(const char *, int); SQLITE_PRIVATE int sqlite3Utf16ByteLen(const void *pData, int nChar); SQLITE_PRIVATE int sqlite3Utf8CharLen(const char *pData, int nByte); SQLITE_PRIVATE int sqlite3Utf8Read(const u8*, const u8*, const u8**); SQLITE_PRIVATE int sqlite3PutVarint(unsigned char*, u64); SQLITE_PRIVATE int sqlite3PutVarint32(unsigned char*, u32); SQLITE_PRIVATE int sqlite3GetVarint(const unsigned char *, u64 *); SQLITE_PRIVATE int sqlite3GetVarint32(const unsigned char *, u32 *); SQLITE_PRIVATE int sqlite3VarintLen(u64 v); 
#define getVarint32(A,B) ((*(A)<(unsigned char)0x80) ? ((B) = (u32)*(A)),1 : sqlite3GetVarint32((A), (u32 *)&(B))) 
#define putVarint32(A,B) (((u32)(B)<(u32)0x80) ? (*(A) = (unsigned char)(B)),1 : sqlite3PutVarint32((A), (B))) 
#define getVarint sqlite3GetVarint 
#define putVarint sqlite3PutVarint 
SQLITE_PRIVATE void sqlite3IndexAffinityStr(Vdbe *, Index *); SQLITE_PRIVATE void sqlite3TableAffinityStr(Vdbe *, Table *); SQLITE_PRIVATE char sqlite3CompareAffinity(Expr *pExpr, char aff2); SQLITE_PRIVATE int sqlite3IndexAffinityOk(Expr *pExpr, char idx_affinity); SQLITE_PRIVATE char sqlite3ExprAffinity(Expr *pExpr); SQLITE_PRIVATE int sqlite3Atoi64(const char*, i64*); SQLITE_PRIVATE void sqlite3Error(sqlite3*, int, const char*,...); SQLITE_PRIVATE void *sqlite3HexToBlob(sqlite3*, const char *z, int n); SQLITE_PRIVATE int sqlite3TwoPartName(Parse *, Token *, Token *, Token **); SQLITE_PRIVATE const char *sqlite3ErrStr(int); SQLITE_PRIVATE int sqlite3ReadSchema(Parse *pParse); SQLITE_PRIVATE CollSeq *sqlite3FindCollSeq(sqlite3*,u8 enc, const char *,int,int); SQLITE_PRIVATE CollSeq *sqlite3LocateCollSeq(Parse *pParse, const char *zName, int nName); SQLITE_PRIVATE CollSeq *sqlite3ExprCollSeq(Parse *pParse, Expr *pExpr); SQLITE_PRIVATE Expr *sqlite3ExprSetColl(Parse *pParse, Expr *, Token *); SQLITE_PRIVATE int sqlite3CheckCollSeq(Parse *, CollSeq *); SQLITE_PRIVATE int sqlite3CheckObjectName(Parse *, const char *); SQLITE_PRIVATE void sqlite3VdbeSetChanges(sqlite3 *, int); SQLITE_PRIVATE const void *sqlite3ValueText(sqlite3_value*, u8); SQLITE_PRIVATE int sqlite3ValueBytes(sqlite3_value*, u8); SQLITE_PRIVATE void sqlite3ValueSetStr(sqlite3_value*, int, const void *,u8, void(*)(void*)); SQLITE_PRIVATE void sqlite3ValueFree(sqlite3_value*); SQLITE_PRIVATE sqlite3_value *sqlite3ValueNew(sqlite3 *); SQLITE_PRIVATE char *sqlite3Utf16to8(sqlite3 *, const void*, int); SQLITE_PRIVATE int sqlite3ValueFromExpr(sqlite3 *, Expr *, u8, u8, sqlite3_value **); SQLITE_PRIVATE void sqlite3ValueApplyAffinity(sqlite3_value *, u8, u8); 
#ifndef SQLITE_AMALGAMATION 
SQLITE_PRIVATE const unsigned char sqlite3UpperToLower[]; SQLITE_PRIVATE SQLITE_WSD struct Sqlite3Config sqlite3Config; SQLITE_PRIVATE SQLITE_WSD FuncDefHash sqlite3GlobalFunctions; 
#endif 
SQLITE_PRIVATE void sqlite3RootPageMoved(Db*, int, int); SQLITE_PRIVATE void sqlite3Reindex(Parse*, Token*, Token*); SQLITE_PRIVATE void sqlite3AlterFunctions(sqlite3*); SQLITE_PRIVATE void sqlite3AlterRenameTable(Parse*, SrcList*, Token*); SQLITE_PRIVATE int sqlite3GetToken(const unsigned char *, int *); SQLITE_PRIVATE void sqlite3NestedParse(Parse*, const char*, ...); SQLITE_PRIVATE void sqlite3ExpirePreparedStatements(sqlite3*); SQLITE_PRIVATE void sqlite3CodeSubselect(Parse *, Expr *, int, int); SQLITE_PRIVATE void sqlite3SelectPrep(Parse*, Select*, NameContext*); SQLITE_PRIVATE int sqlite3ResolveExprNames(NameContext*, Expr*); SQLITE_PRIVATE void sqlite3ResolveSelectNames(Parse*, Select*, NameContext*); SQLITE_PRIVATE int sqlite3ResolveOrderGroupBy(Parse*, Select*, ExprList*, const char*); SQLITE_PRIVATE void sqlite3ColumnDefault(Vdbe *, Table *, int); SQLITE_PRIVATE void sqlite3AlterFinishAddColumn(Parse *, Token *); SQLITE_PRIVATE void sqlite3AlterBeginAddColumn(Parse *, SrcList *); SQLITE_PRIVATE CollSeq *sqlite3GetCollSeq(sqlite3*, CollSeq *, const char *, int); SQLITE_PRIVATE char sqlite3AffinityType(const Token*); SQLITE_PRIVATE void sqlite3Analyze(Parse*, Token*, Token*); SQLITE_PRIVATE int sqlite3InvokeBusyHandler(BusyHandler*); SQLITE_PRIVATE int sqlite3FindDb(sqlite3*, Token*); SQLITE_PRIVATE int sqlite3AnalysisLoad(sqlite3*,int iDB); SQLITE_PRIVATE void sqlite3DefaultRowEst(Index*); SQLITE_PRIVATE void sqlite3RegisterLikeFunctions(sqlite3*, int); SQLITE_PRIVATE int sqlite3IsLikeFunction(sqlite3*,Expr*,int*,char*); SQLITE_PRIVATE void sqlite3MinimumFileFormat(Parse*, int, int); SQLITE_PRIVATE void sqlite3SchemaFree(void *); SQLITE_PRIVATE Schema *sqlite3SchemaGet(sqlite3 *, Btree *); SQLITE_PRIVATE int sqlite3SchemaToIndex(sqlite3 *db, Schema *); SQLITE_PRIVATE KeyInfo *sqlite3IndexKeyinfo(Parse *, Index *); SQLITE_PRIVATE int sqlite3CreateFunc(sqlite3 *, const char *, int, int, void *, void (*)(sqlite3_context*,int,sqlite3_value **), void (*)(sqlite3_context*,int,sqlite3_value **), void (*)(sqlite3_context*)); SQLITE_PRIVATE int sqlite3ApiExit(sqlite3 *db, int); SQLITE_PRIVATE int sqlite3OpenTempDatabase(Parse *); SQLITE_PRIVATE void sqlite3StrAccumInit(StrAccum*, char*, int, int); SQLITE_PRIVATE void sqlite3StrAccumAppend(StrAccum*,const char*,int); SQLITE_PRIVATE char *sqlite3StrAccumFinish(StrAccum*); SQLITE_PRIVATE void sqlite3StrAccumReset(StrAccum*); SQLITE_PRIVATE void sqlite3SelectDestInit(SelectDest*,int,int); SQLITE_PRIVATE void *sqlite3ParserAlloc(void*(*)(size_t)); SQLITE_PRIVATE void sqlite3ParserFree(void*, void(*)(void*)); SQLITE_PRIVATE void sqlite3Parser(void*, int, Token, Parse*); 
#ifdef YYTRACKMAXSTACKDEPTH 
SQLITE_PRIVATE int sqlite3ParserStackPeak(void*); 
#endif 
SQLITE_PRIVATE int sqlite3AutoLoadExtensions(sqlite3*); 
#ifndef SQLITE_OMIT_LOAD_EXTENSION 
SQLITE_PRIVATE void sqlite3CloseExtensions(sqlite3*); 
#else 
#define sqlite3CloseExtensions(X) 
#endif 
#ifndef SQLITE_OMIT_SHARED_CACHE 
SQLITE_PRIVATE void sqlite3TableLock(Parse *, int, int, u8, const char *); 
#else 
#define sqlite3TableLock(v,w,x,y,z) 
#endif 
#ifdef SQLITE_TEST 
SQLITE_PRIVATE int sqlite3Utf8To8(unsigned char*); 
#endif 
#ifdef SQLITE_OMIT_VIRTUALTABLE 
#define sqlite3VtabClear(X) 
#define sqlite3VtabSync(X,Y) SQLITE_OK 
#define sqlite3VtabRollback(X) 
#define sqlite3VtabCommit(X) 
#define sqlite3VtabInSync(db) 0 
#else 
SQLITE_PRIVATE void sqlite3VtabClear(Table*); SQLITE_PRIVATE int sqlite3VtabSync(sqlite3 *db, char **); SQLITE_PRIVATE int sqlite3VtabRollback(sqlite3 *db); SQLITE_PRIVATE int sqlite3VtabCommit(sqlite3 *db); 
#define sqlite3VtabInSync(db) ((db)->nVTrans>0 && (db)->aVTrans==0) 
#endif 
SQLITE_PRIVATE void sqlite3VtabMakeWritable(Parse*,Table*); SQLITE_PRIVATE void sqlite3VtabLock(sqlite3_vtab*); SQLITE_PRIVATE void sqlite3VtabUnlock(sqlite3*, sqlite3_vtab*); SQLITE_PRIVATE void sqlite3VtabBeginParse(Parse*, Token*, Token*, Token*); SQLITE_PRIVATE void sqlite3VtabFinishParse(Parse*, Token*); SQLITE_PRIVATE void sqlite3VtabArgInit(Parse*); SQLITE_PRIVATE void sqlite3VtabArgExtend(Parse*, Token*); SQLITE_PRIVATE int sqlite3VtabCallCreate(sqlite3*, int, const char *, char **); SQLITE_PRIVATE int sqlite3VtabCallConnect(Parse*, Table*); SQLITE_PRIVATE int sqlite3VtabCallDestroy(sqlite3*, int, const char *); SQLITE_PRIVATE int sqlite3VtabBegin(sqlite3 *, sqlite3_vtab *); SQLITE_PRIVATE FuncDef *sqlite3VtabOverloadFunction(sqlite3 *,FuncDef*, int nArg, Expr*); SQLITE_PRIVATE void sqlite3InvalidFunction(sqlite3_context*,int,sqlite3_value**); SQLITE_PRIVATE int sqlite3TransferBindings(sqlite3_stmt *, sqlite3_stmt *); SQLITE_PRIVATE int sqlite3Reprepare(Vdbe*); SQLITE_PRIVATE void sqlite3ExprListCheckLength(Parse*, ExprList*, const char*); SQLITE_PRIVATE CollSeq *sqlite3BinaryCompareCollSeq(Parse *, Expr *, Expr *); 
#define SQLITE_FAULTINJECTOR_MALLOC 0 
#define SQLITE_FAULTINJECTOR_COUNT 1 
#ifndef SQLITE_OMIT_BUILTIN_TEST 
SQLITE_PRIVATE void sqlite3BeginBenignMalloc(void); SQLITE_PRIVATE void sqlite3EndBenignMalloc(void); 
#else 
#define sqlite3BeginBenignMalloc() 
#define sqlite3EndBenignMalloc() 
#endif 
#define IN_INDEX_ROWID 1 
#define IN_INDEX_EPH 2 
#define IN_INDEX_INDEX 3 
SQLITE_PRIVATE int sqlite3FindInIndex(Parse *, Expr *, int*); 
#ifdef SQLITE_ENABLE_ATOMIC_WRITE 
SQLITE_PRIVATE int sqlite3JournalOpen(sqlite3_vfs *, const char *, sqlite3_file *, int, int); SQLITE_PRIVATE int sqlite3JournalSize(sqlite3_vfs *); SQLITE_PRIVATE int sqlite3JournalCreate(sqlite3_file *); 
#else 
#define sqlite3JournalSize(pVfs) ((pVfs)->szOsFile) 
#endif 
SQLITE_PRIVATE void sqlite3MemJournalOpen(sqlite3_file *); SQLITE_PRIVATE int sqlite3MemJournalSize(); SQLITE_PRIVATE int sqlite3IsMemJournal(sqlite3_file *); 
#if SQLITE_MAX_EXPR_DEPTH>0 
SQLITE_PRIVATE void sqlite3ExprSetHeight(Parse *pParse, Expr *p); SQLITE_PRIVATE int sqlite3SelectExprHeight(Select *); SQLITE_PRIVATE int sqlite3ExprCheckHeight(Parse*, int); 
#else 
#define sqlite3ExprSetHeight(x,y) 
#define sqlite3SelectExprHeight(x) 0 
#define sqlite3ExprCheckHeight(x,y) 
#endif 
SQLITE_PRIVATE u32 sqlite3Get4byte(const u8*); SQLITE_PRIVATE void sqlite3Put4byte(u8*, u32); 
#ifdef SQLITE_SSE 
#include "sseInt.h" 
#endif 
#ifdef SQLITE_DEBUG 
SQLITE_PRIVATE void sqlite3ParserTrace(FILE*, char *); 
#endif 
#ifdef SQLITE_ENABLE_IOTRACE 
#define IOTRACE(A) if( sqlite3IoTrace ){ sqlite3IoTrace A; } 
SQLITE_PRIVATE void sqlite3VdbeIOTraceSql(Vdbe*); SQLITE_PRIVATE void (*sqlite3IoTrace)(const char*,...); 
#else 
#define IOTRACE(A) 
#define sqlite3VdbeIOTraceSql(X) 
#endif 
#endif 
SQLITE_PRIVATE const unsigned char sqlite3UpperToLower[] = { 
#ifdef SQLITE_ASCII 
 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 97, 98, 99,100,101,102,103, 104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121, 122, 91, 92, 93, 94, 95, 96, 97, 98, 99,100,101,102,103,104,105,106,107, 108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125, 126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143, 144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161, 162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179, 180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197, 198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215, 216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233, 234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251, 252,253,254,255 
#endif 
#ifdef SQLITE_EBCDIC 
 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 66, 67, 68, 69, 70, 71, 72, 73,106,107,108,109,110,111, 112, 81, 82, 83, 84, 85, 86, 87, 88, 89,122,123,124,125,126,127, 128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143, 144,145,146,147,148,149,150,151,152,153,154,155,156,157,156,159, 160,161,162,163,164,165,166,167,168,169,170,171,140,141,142,175, 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191, 192,129,130,131,132,133,134,135,136,137,202,203,204,205,206,207, 208,145,146,147,148,149,150,151,152,153,218,219,220,221,222,223, 224,225,162,163,164,165,166,167,168,169,232,203,204,205,206,207, 239,240,241,242,243,244,245,246,247,248,249,219,220,221,222,255, 
#endif 
}; SQLITE_PRIVATE SQLITE_WSD struct Sqlite3Config sqlite3Config = { SQLITE_DEFAULT_MEMSTATUS, 1, SQLITE_THREADSAFE==1, 0x7ffffffe, 100, 500, }; SQLITE_PRIVATE SQLITE_WSD FuncDefHash sqlite3GlobalFunctions; typedef struct sqlite3StatType sqlite3StatType; static SQLITE_WSD struct sqlite3StatType { int nowValue[9]; int mxValue[9]; } sqlite3Stat = { {0,}, {0,} }; 
#ifdef SQLITE_OMIT_WSD 
#define wsdStatInit sqlite3StatType *x = &GLOBAL(sqlite3StatType,sqlite3Stat) 
#define wsdStat x[0] 
#else 
#define wsdStatInit 
#define wsdStat sqlite3Stat 
#endif 
SQLITE_PRIVATE int sqlite3StatusValue(int op){ wsdStatInit; assert( op>=0 && op<ArraySize(wsdStat.nowValue) ); return wsdStat.nowValue[op]; } SQLITE_PRIVATE void sqlite3StatusAdd(int op, int N){ wsdStatInit; assert( op>=0 && op<ArraySize(wsdStat.nowValue) ); wsdStat.nowValue[op] += N; if( wsdStat.nowValue[op]>wsdStat.mxValue[op] ){ wsdStat.mxValue[op] = wsdStat.nowValue[op]; } } SQLITE_PRIVATE void sqlite3StatusSet(int op, int X){ wsdStatInit; assert( op>=0 && op<ArraySize(wsdStat.nowValue) ); wsdStat.nowValue[op] = X; if( wsdStat.nowValue[op]>wsdStat.mxValue[op] ){ wsdStat.mxValue[op] = wsdStat.nowValue[op]; } } SQLITE_API int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetFlag){ wsdStatInit; if( op<0 || op>=ArraySize(wsdStat.nowValue) ){ return SQLITE_MISUSE; } *pCurrent = wsdStat.nowValue[op]; *pHighwater = wsdStat.mxValue[op]; if( resetFlag ){ wsdStat.mxValue[op] = wsdStat.nowValue[op]; } return SQLITE_OK; } SQLITE_API int sqlite3_db_status( sqlite3 *db, int op, int *pCurrent, int *pHighwater, int resetFlag ){ switch( op ){ case SQLITE_DBSTATUS_LOOKASIDE_USED: { *pCurrent = db->lookaside.nOut; *pHighwater = db->lookaside.mxOut; if( resetFlag ){ db->lookaside.mxOut = db->lookaside.nOut; } break; } default: { return SQLITE_ERROR; } } return SQLITE_OK; } 
#include <ctype.h> 
#include <time.h> 
#ifndef SQLITE_OMIT_DATETIME_FUNCS 
#if !defined(HAVE_LOCALTIME_R) && !defined(HAVE_LOCALTIME_S) && defined(_MSC_VER) && defined(_CRT_INSECURE_DEPRECATE) 
#define HAVE_LOCALTIME_S 1 
#endif 
typedef struct DateTime DateTime; struct DateTime { sqlite3_int64 iJD; int Y, M, D; int h, m; int tz; double s; char validYMD; char validHMS; char validJD; char validTZ; }; static int getDigits(const char *zDate, ...){ va_list ap; int val; int N; int min; int max; int nextC; int *pVal; int cnt = 0; va_start(ap, zDate); do{ N = va_arg(ap, int); min = va_arg(ap, int); max = va_arg(ap, int); nextC = va_arg(ap, int); pVal = va_arg(ap, int*); val = 0; while( N-- ){ if( !isdigit(*(u8*)zDate) ){ goto end_getDigits; } val = val*10 + *zDate - '0'; zDate++; } if( val<min || val>max || (nextC!=0 && nextC!=*zDate) ){ goto end_getDigits; } *pVal = val; zDate++; cnt++; }while( nextC ); end_getDigits: va_end(ap); return cnt; } 
#define getValue sqlite3AtoF 
static int parseTimezone(const char *zDate, DateTime *p){ int sgn = 0; int nHr, nMn; int c; while( isspace(*(u8*)zDate) ){ zDate++; } p->tz = 0; c = *zDate; if( c=='-' ){ sgn = -1; }else if( c=='+' ){ sgn = +1; }else if( c=='Z' || c=='z' ){ zDate++; goto zulu_time; }else{ return c!=0; } zDate++; if( getDigits(zDate, 2, 0, 14, ':', &nHr, 2, 0, 59, 0, &nMn)!=2 ){ return 1; } zDate += 5; p->tz = sgn*(nMn + nHr*60); zulu_time: while( isspace(*(u8*)zDate) ){ zDate++; } return *zDate!=0; } static int parseHhMmSs(const char *zDate, DateTime *p){ int h, m, s; double ms = 0.0; if( getDigits(zDate, 2, 0, 24, ':', &h, 2, 0, 59, 0, &m)!=2 ){ return 1; } zDate += 5; if( *zDate==':' ){ zDate++; if( getDigits(zDate, 2, 0, 59, 0, &s)!=1 ){ return 1; } zDate += 2; if( *zDate=='.' && isdigit((u8)zDate[1]) ){ double rScale = 1.0; zDate++; while( isdigit(*(u8*)zDate) ){ ms = ms*10.0 + *zDate - '0'; rScale *= 10.0; zDate++; } ms /= rScale; } }else{ s = 0; } p->validJD = 0; p->validHMS = 1; p->h = h; p->m = m; p->s = s + ms; if( parseTimezone(zDate, p) ) return 1; p->validTZ = p->tz!=0; return 0; } static void computeJD(DateTime *p){ int Y, M, D, A, B, X1, X2; if( p->validJD ) return; if( p->validYMD ){ Y = p->Y; M = p->M; D = p->D; }else{ Y = 2000; M = 1; D = 1; } if( M<=2 ){ Y--; M += 12; } A = Y/100; B = 2 - A + (A/4); X1 = 365.25*(Y+4716); X2 = 30.6001*(M+1); p->iJD = (X1 + X2 + D + B - 1524.5)*86400000; p->validJD = 1; if( p->validHMS ){ p->iJD += p->h*3600000 + p->m*60000 + p->s*1000; if( p->validTZ ){ p->iJD -= p->tz*60000; p->validYMD = 0; p->validHMS = 0; p->validTZ = 0; } } } static int parseYyyyMmDd(const char *zDate, DateTime *p){ int Y, M, D, neg; if( zDate[0]=='-' ){ zDate++; neg = 1; }else{ neg = 0; } if( getDigits(zDate,4,0,9999,'-',&Y,2,1,12,'-',&M,2,1,31,0,&D)!=3 ){ return 1; } zDate += 10; while( isspace(*(u8*)zDate) || 'T'==*(u8*)zDate ){ zDate++; } if( parseHhMmSs(zDate, p)==0 ){ }else if( *zDate==0 ){ p->validHMS = 0; }else{ return 1; } p->validJD = 0; p->validYMD = 1; p->Y = neg ? -Y : Y; p->M = M; p->D = D; if( p->validTZ ){ computeJD(p); } return 0; } static void setDateTimeToCurrent(sqlite3_context *context, DateTime *p){ double r; sqlite3 *db = sqlite3_context_db_handle(context); sqlite3OsCurrentTime(db->pVfs, &r); p->iJD = (sqlite3_int64)(r*86400000.0 + 0.5); p->validJD = 1; } static int parseDateOrTime( sqlite3_context *context, const char *zDate, DateTime *p ){ if( parseYyyyMmDd(zDate,p)==0 ){ return 0; }else if( parseHhMmSs(zDate, p)==0 ){ return 0; }else if( sqlite3StrICmp(zDate,"now")==0){ setDateTimeToCurrent(context, p); return 0; }else if( sqlite3IsNumber(zDate, 0, SQLITE_UTF8) ){ double r; getValue(zDate, &r); p->iJD = (sqlite3_int64)(r*86400000.0 + 0.5); p->validJD = 1; return 0; } return 1; } static void computeYMD(DateTime *p){ int Z, A, B, C, D, E, X1; if( p->validYMD ) return; if( !p->validJD ){ p->Y = 2000; p->M = 1; p->D = 1; }else{ Z = (p->iJD + 43200000)/86400000; A = (Z - 1867216.25)/36524.25; A = Z + 1 + A - (A/4); B = A + 1524; C = (B - 122.1)/365.25; D = 365.25*C; E = (B-D)/30.6001; X1 = 30.6001*E; p->D = B - D - X1; p->M = E<14 ? E-1 : E-13; p->Y = p->M>2 ? C - 4716 : C - 4715; } p->validYMD = 1; } static void computeHMS(DateTime *p){ int s; if( p->validHMS ) return; computeJD(p); s = (p->iJD + 43200000) % 86400000; p->s = s/1000.0; s = p->s; p->s -= s; p->h = s/3600; s -= p->h*3600; p->m = s/60; p->s += s - p->m*60; p->validHMS = 1; } static void computeYMD_HMS(DateTime *p){ computeYMD(p); computeHMS(p); } static void clearYMD_HMS_TZ(DateTime *p){ p->validYMD = 0; p->validHMS = 0; p->validTZ = 0; } 
#ifndef SQLITE_OMIT_LOCALTIME 
static int localtimeOffset(DateTime *p){ DateTime x, y; time_t t; x = *p; computeYMD_HMS(&x); if( x.Y<1971 || x.Y>=2038 ){ x.Y = 2000; x.M = 1; x.D = 1; x.h = 0; x.m = 0; x.s = 0.0; } else { int s = x.s + 0.5; x.s = s; } x.tz = 0; x.validJD = 0; computeJD(&x); t = x.iJD/1000 - 2440587.5*86400.0; 
#ifdef HAVE_LOCALTIME_R 
 { struct tm sLocal; localtime_r(&t, &sLocal); y.Y = sLocal.tm_year + 1900; y.M = sLocal.tm_mon + 1; y.D = sLocal.tm_mday; y.h = sLocal.tm_hour; y.m = sLocal.tm_min; y.s = sLocal.tm_sec; } 
#elif defined(HAVE_LOCALTIME_S) 
 { struct tm sLocal; localtime_s(&sLocal, &t); y.Y = sLocal.tm_year + 1900; y.M = sLocal.tm_mon + 1; y.D = sLocal.tm_mday; y.h = sLocal.tm_hour; y.m = sLocal.tm_min; y.s = sLocal.tm_sec; } 
#else 
 { struct tm *pTm; sqlite3_mutex_enter(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER)); pTm = localtime(&t); y.Y = pTm->tm_year + 1900; y.M = pTm->tm_mon + 1; y.D = pTm->tm_mday; y.h = pTm->tm_hour; y.m = pTm->tm_min; y.s = pTm->tm_sec; sqlite3_mutex_leave(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER)); } 
#endif 
 y.validYMD = 1; y.validHMS = 1; y.validJD = 0; y.validTZ = 0; computeJD(&y); return y.iJD - x.iJD; } 
#endif 
static int parseModifier(const char *zMod, DateTime *p){ int rc = 1; int n; double r; char *z, zBuf[30]; z = zBuf; for(n=0; n<ArraySize(zBuf)-1 && zMod[n]; n++){ z[n] = tolower(zMod[n]); } z[n] = 0; switch( z[0] ){ 
#ifndef SQLITE_OMIT_LOCALTIME 
 case 'l': { if( strcmp(z, "localtime")==0 ){ computeJD(p); p->iJD += localtimeOffset(p); clearYMD_HMS_TZ(p); rc = 0; } break; } 
#endif 
 case 'u': { if( strcmp(z, "unixepoch")==0 && p->validJD ){ p->iJD = p->iJD/86400.0 + 2440587.5*86400000.0; clearYMD_HMS_TZ(p); rc = 0; } 
#ifndef SQLITE_OMIT_LOCALTIME 
 else if( strcmp(z, "utc")==0 ){ int c1; computeJD(p); c1 = localtimeOffset(p); p->iJD -= c1; clearYMD_HMS_TZ(p); p->iJD += c1 - localtimeOffset(p); rc = 0; } 
#endif 
 break; } case 'w': { if( strncmp(z, "weekday ", 8)==0 && getValue(&z[8],&r)>0 && (n=r)==r && n>=0 && r<7 ){ sqlite3_int64 Z; computeYMD_HMS(p); p->validTZ = 0; p->validJD = 0; computeJD(p); Z = ((p->iJD + 129600000)/86400000) % 7; if( Z>n ) Z -= 7; p->iJD += (n - Z)*86400000; clearYMD_HMS_TZ(p); rc = 0; } break; } case 's': { if( strncmp(z, "start of ", 9)!=0 ) break; z += 9; computeYMD(p); p->validHMS = 1; p->h = p->m = 0; p->s = 0.0; p->validTZ = 0; p->validJD = 0; if( strcmp(z,"month")==0 ){ p->D = 1; rc = 0; }else if( strcmp(z,"year")==0 ){ computeYMD(p); p->M = 1; p->D = 1; rc = 0; }else if( strcmp(z,"day")==0 ){ rc = 0; } break; } case '+': case '-': case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': { n = getValue(z, &r); assert( n>=1 ); if( z[n]==':' ){ const char *z2 = z; DateTime tx; sqlite3_int64 day; if( !isdigit(*(u8*)z2) ) z2++; memset(&tx, 0, sizeof(tx)); if( parseHhMmSs(z2, &tx) ) break; computeJD(&tx); tx.iJD -= 43200000; day = tx.iJD/86400000; tx.iJD -= day*86400000; if( z[0]=='-' ) tx.iJD = -tx.iJD; computeJD(p); clearYMD_HMS_TZ(p); p->iJD += tx.iJD; rc = 0; break; } z += n; while( isspace(*(u8*)z) ) z++; n = strlen(z); if( n>10 || n<3 ) break; if( z[n-1]=='s' ){ z[n-1] = 0; n--; } computeJD(p); rc = 0; if( n==3 && strcmp(z,"day")==0 ){ p->iJD += r*86400000.0 + 0.5; }else if( n==4 && strcmp(z,"hour")==0 ){ p->iJD += r*(86400000.0/24.0) + 0.5; }else if( n==6 && strcmp(z,"minute")==0 ){ p->iJD += r*(86400000.0/(24.0*60.0)) + 0.5; }else if( n==6 && strcmp(z,"second")==0 ){ p->iJD += r*(86400000.0/(24.0*60.0*60.0)) + 0.5; }else if( n==5 && strcmp(z,"month")==0 ){ int x, y; computeYMD_HMS(p); p->M += r; x = p->M>0 ? (p->M-1)/12 : (p->M-12)/12; p->Y += x; p->M -= x*12; p->validJD = 0; computeJD(p); y = r; if( y!=r ){ p->iJD += (r - y)*30.0*86400000.0 + 0.5; } }else if( n==4 && strcmp(z,"year")==0 ){ computeYMD_HMS(p); p->Y += r; p->validJD = 0; computeJD(p); }else{ rc = 1; } clearYMD_HMS_TZ(p); break; } default: { break; } } return rc; } static int isDate( sqlite3_context *context, int argc, sqlite3_value **argv, DateTime *p ){ int i; const unsigned char *z; int eType; memset(p, 0, sizeof(*p)); if( argc==0 ){ setDateTimeToCurrent(context, p); }else if( (eType = sqlite3_value_type(argv[0]))==SQLITE_FLOAT || eType==SQLITE_INTEGER ){ p->iJD = sqlite3_value_double(argv[0])*86400000.0 + 0.5; p->validJD = 1; }else{ z = sqlite3_value_text(argv[0]); if( !z || parseDateOrTime(context, (char*)z, p) ){ return 1; } } for(i=1; i<argc; i++){ if( (z = sqlite3_value_text(argv[i]))==0 || parseModifier((char*)z, p) ){ return 1; } } return 0; } static void juliandayFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){ DateTime x; if( isDate(context, argc, argv, &x)==0 ){ computeJD(&x); sqlite3_result_double(context, x.iJD/86400000.0); } } static void datetimeFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){ DateTime x; if( isDate(context, argc, argv, &x)==0 ){ char zBuf[100]; computeYMD_HMS(&x); sqlite3_snprintf(sizeof(zBuf), zBuf, "%04d-%02d-%02d %02d:%02d:%02d", x.Y, x.M, x.D, x.h, x.m, (int)(x.s)); sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT); } } static void timeFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){ DateTime x; if( isDate(context, argc, argv, &x)==0 ){ char zBuf[100]; computeHMS(&x); sqlite3_snprintf(sizeof(zBuf), zBuf, "%02d:%02d:%02d", x.h, x.m, (int)x.s); sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT); } } static void dateFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){ DateTime x; if( isDate(context, argc, argv, &x)==0 ){ char zBuf[100]; computeYMD(&x); sqlite3_snprintf(sizeof(zBuf), zBuf, "%04d-%02d-%02d", x.Y, x.M, x.D); sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT); } } static void strftimeFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){ DateTime x; u64 n; int i, j; char *z; sqlite3 *db; const char *zFmt = (const char*)sqlite3_value_text(argv[0]); char zBuf[100]; if( zFmt==0 || isDate(context, argc-1, argv+1, &x) ) return; db = sqlite3_context_db_handle(context); for(i=0, n=1; zFmt[i]; i++, n++){ if( zFmt[i]=='%' ){ switch( zFmt[i+1] ){ case 'd': case 'H': case 'm': case 'M': case 'S': case 'W': n++; case 'w': case '%': break; case 'f': n += 8; break; case 'j': n += 3; break; case 'Y': n += 8; break; case 's': case 'J': n += 50; break; default: return; } i++; } } if( n<sizeof(zBuf) ){ z = zBuf; }else if( n>(u64)db->aLimit[SQLITE_LIMIT_LENGTH] ){ sqlite3_result_error_toobig(context); return; }else{ z = sqlite3DbMallocRaw(db, n); if( z==0 ){ sqlite3_result_error_nomem(context); return; } } computeJD(&x); computeYMD_HMS(&x); for(i=j=0; zFmt[i]; i++){ if( zFmt[i]!='%' ){ z[j++] = zFmt[i]; }else{ i++; switch( zFmt[i] ){ case 'd': sqlite3_snprintf(3, &z[j],"%02d",x.D); j+=2; break; case 'f': { double s = x.s; if( s>59.999 ) s = 59.999; sqlite3_snprintf(7, &z[j],"%06.3f", s); j += strlen(&z[j]); break; } case 'H': sqlite3_snprintf(3, &z[j],"%02d",x.h); j+=2; break; case 'W': case 'j': { int nDay; DateTime y = x; y.validJD = 0; y.M = 1; y.D = 1; computeJD(&y); nDay = (x.iJD - y.iJD)/86400000.0 + 0.5; if( zFmt[i]=='W' ){ int wd; wd = ((x.iJD+43200000)/86400000) % 7; sqlite3_snprintf(3, &z[j],"%02d",(nDay+7-wd)/7); j += 2; }else{ sqlite3_snprintf(4, &z[j],"%03d",nDay+1); j += 3; } break; } case 'J': { sqlite3_snprintf(20, &z[j],"%.16g",x.iJD/86400000.0); j+=strlen(&z[j]); break; } case 'm': sqlite3_snprintf(3, &z[j],"%02d",x.M); j+=2; break; case 'M': sqlite3_snprintf(3, &z[j],"%02d",x.m); j+=2; break; case 's': { sqlite3_snprintf(30,&z[j],"%d", (int)(x.iJD/1000.0 - 210866760000.0)); j += strlen(&z[j]); break; } case 'S': sqlite3_snprintf(3,&z[j],"%02d",(int)x.s); j+=2; break; case 'w': z[j++] = (((x.iJD+129600000)/86400000) % 7) + '0'; break; case 'Y': sqlite3_snprintf(5,&z[j],"%04d",x.Y); j+=strlen(&z[j]);break; default: z[j++] = '%'; break; } } } z[j] = 0; sqlite3_result_text(context, z, -1, z==zBuf ? SQLITE_TRANSIENT : SQLITE_DYNAMIC); } static void ctimeFunc( sqlite3_context *context, int NotUsed, sqlite3_value **NotUsed2 ){ UNUSED_PARAMETER2(NotUsed, NotUsed2); timeFunc(context, 0, 0); } static void cdateFunc( sqlite3_context *context, int NotUsed, sqlite3_value **NotUsed2 ){ UNUSED_PARAMETER2(NotUsed, NotUsed2); dateFunc(context, 0, 0); } static void ctimestampFunc( sqlite3_context *context, int NotUsed, sqlite3_value **NotUsed2 ){ UNUSED_PARAMETER2(NotUsed, NotUsed2); datetimeFunc(context, 0, 0); } 
#endif 
#ifdef SQLITE_OMIT_DATETIME_FUNCS 
static void currentTimeFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){ time_t t; char *zFormat = (char *)sqlite3_user_data(context); sqlite3 *db; double rT; char zBuf[20]; db = sqlite3_context_db_handle(context); sqlite3OsCurrentTime(db->pVfs, &rT); t = 86400.0*(rT - 2440587.5) + 0.5; 
#ifdef HAVE_GMTIME_R 
 { struct tm sNow; gmtime_r(&t, &sNow); strftime(zBuf, 20, zFormat, &sNow); } 
#else 
 { struct tm *pTm; sqlite3_mutex_enter(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER)); pTm = gmtime(&t); strftime(zBuf, 20, zFormat, pTm); sqlite3_mutex_leave(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER)); } 
#endif 
 sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT); } 
#endif 
SQLITE_PRIVATE void sqlite3RegisterDateTimeFunctions(void){ static SQLITE_WSD FuncDef aDateTimeFuncs[] = { 
#ifndef SQLITE_OMIT_DATETIME_FUNCS 
 FUNCTION(julianday, -1, 0, 0, juliandayFunc ), FUNCTION(date, -1, 0, 0, dateFunc ), FUNCTION(time, -1, 0, 0, timeFunc ), FUNCTION(datetime, -1, 0, 0, datetimeFunc ), FUNCTION(strftime, -1, 0, 0, strftimeFunc ), FUNCTION(current_time, 0, 0, 0, ctimeFunc ), FUNCTION(current_timestamp, 0, 0, 0, ctimestampFunc), FUNCTION(current_date, 0, 0, 0, cdateFunc ), 
#else 
 STR_FUNCTION(current_time, 0, "%H:%M:%S", 0, currentTimeFunc), STR_FUNCTION(current_timestamp, 0, "%Y-%m-%d", 0, currentTimeFunc), STR_FUNCTION(current_date, 0, "%Y-%m-%d %H:%M:%S", 0, currentTimeFunc), 
#endif 
 }; int i; FuncDefHash *pHash = &GLOBAL(FuncDefHash, sqlite3GlobalFunctions); FuncDef *aFunc = (FuncDef*)&GLOBAL(FuncDef, aDateTimeFuncs); for(i=0; i<ArraySize(aDateTimeFuncs); i++){ sqlite3FuncDefInsert(pHash, &aFunc[i]); } } 
#define _SQLITE_OS_C_ 1 
#undef _SQLITE_OS_C_ 
#if defined(SQLITE_TEST) && (SQLITE_OS_WIN==0) 
#define DO_OS_MALLOC_TEST if (1) { void *pTstAlloc = sqlite3Malloc(10); if (!pTstAlloc) return SQLITE_IOERR_NOMEM; sqlite3_free(pTstAlloc); } 
#else 
#define DO_OS_MALLOC_TEST 
#endif 
SQLITE_PRIVATE int sqlite3OsClose(sqlite3_file *pId){ int rc = SQLITE_OK; if( pId->pMethods ){ rc = pId->pMethods->xClose(pId); pId->pMethods = 0; } return rc; } SQLITE_PRIVATE int sqlite3OsRead(sqlite3_file *id, void *pBuf, int amt, i64 offset){ DO_OS_MALLOC_TEST; return id->pMethods->xRead(id, pBuf, amt, offset); } SQLITE_PRIVATE int sqlite3OsWrite(sqlite3_file *id, const void *pBuf, int amt, i64 offset){ DO_OS_MALLOC_TEST; return id->pMethods->xWrite(id, pBuf, amt, offset); } SQLITE_PRIVATE int sqlite3OsTruncate(sqlite3_file *id, i64 size){ return id->pMethods->xTruncate(id, size); } SQLITE_PRIVATE int sqlite3OsSync(sqlite3_file *id, int flags){ DO_OS_MALLOC_TEST; return id->pMethods->xSync(id, flags); } SQLITE_PRIVATE int sqlite3OsFileSize(sqlite3_file *id, i64 *pSize){ DO_OS_MALLOC_TEST; return id->pMethods->xFileSize(id, pSize); } SQLITE_PRIVATE int sqlite3OsLock(sqlite3_file *id, int lockType){ DO_OS_MALLOC_TEST; return id->pMethods->xLock(id, lockType); } SQLITE_PRIVATE int sqlite3OsUnlock(sqlite3_file *id, int lockType){ return id->pMethods->xUnlock(id, lockType); } SQLITE_PRIVATE int sqlite3OsCheckReservedLock(sqlite3_file *id, int *pResOut){ DO_OS_MALLOC_TEST; return id->pMethods->xCheckReservedLock(id, pResOut); } SQLITE_PRIVATE int sqlite3OsFileControl(sqlite3_file *id, int op, void *pArg){ return id->pMethods->xFileControl(id, op, pArg); } SQLITE_PRIVATE int sqlite3OsSectorSize(sqlite3_file *id){ int (*xSectorSize)(sqlite3_file*) = id->pMethods->xSectorSize; return (xSectorSize ? xSectorSize(id) : SQLITE_DEFAULT_SECTOR_SIZE); } SQLITE_PRIVATE int sqlite3OsDeviceCharacteristics(sqlite3_file *id){ return id->pMethods->xDeviceCharacteristics(id); } SQLITE_PRIVATE int sqlite3OsOpen( sqlite3_vfs *pVfs, const char *zPath, sqlite3_file *pFile, int flags, int *pFlagsOut ){ DO_OS_MALLOC_TEST; return pVfs->xOpen(pVfs, zPath, pFile, flags, pFlagsOut); } SQLITE_PRIVATE int sqlite3OsDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){ return pVfs->xDelete(pVfs, zPath, dirSync); } SQLITE_PRIVATE int sqlite3OsAccess( sqlite3_vfs *pVfs, const char *zPath, int flags, int *pResOut ){ DO_OS_MALLOC_TEST; return pVfs->xAccess(pVfs, zPath, flags, pResOut); } SQLITE_PRIVATE int sqlite3OsFullPathname( sqlite3_vfs *pVfs, const char *zPath, int nPathOut, char *zPathOut ){ return pVfs->xFullPathname(pVfs, zPath, nPathOut, zPathOut); } 
#ifndef SQLITE_OMIT_LOAD_EXTENSION 
SQLITE_PRIVATE void *sqlite3OsDlOpen(sqlite3_vfs *pVfs, const char *zPath){ return pVfs->xDlOpen(pVfs, zPath); } SQLITE_PRIVATE void sqlite3OsDlError(sqlite3_vfs *pVfs, int nByte, char *zBufOut){ pVfs->xDlError(pVfs, nByte, zBufOut); } SQLITE_PRIVATE void *sqlite3OsDlSym(sqlite3_vfs *pVfs, void *pHandle, const char *zSymbol){ return pVfs->xDlSym(pVfs, pHandle, zSymbol); } SQLITE_PRIVATE void sqlite3OsDlClose(sqlite3_vfs *pVfs, void *pHandle){ pVfs->xDlClose(pVfs, pHandle); } 
#endif 
SQLITE_PRIVATE int sqlite3OsRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){ return pVfs->xRandomness(pVfs, nByte, zBufOut); } SQLITE_PRIVATE int sqlite3OsSleep(sqlite3_vfs *pVfs, int nMicro){ return pVfs->xSleep(pVfs, nMicro); } SQLITE_PRIVATE int sqlite3OsCurrentTime(sqlite3_vfs *pVfs, double *pTimeOut){ return pVfs->xCurrentTime(pVfs, pTimeOut); } SQLITE_PRIVATE int sqlite3OsOpenMalloc( sqlite3_vfs *pVfs, const char *zFile, sqlite3_file **ppFile, int flags, int *pOutFlags ){ int rc = SQLITE_NOMEM; sqlite3_file *pFile; pFile = (sqlite3_file *)sqlite3Malloc(pVfs->szOsFile); if( pFile ){ rc = sqlite3OsOpen(pVfs, zFile, pFile, flags, pOutFlags); if( rc!=SQLITE_OK ){ sqlite3_free(pFile); }else{ *ppFile = pFile; } } return rc; } SQLITE_PRIVATE int sqlite3OsCloseFree(sqlite3_file *pFile){ int rc = SQLITE_OK; assert( pFile ); rc = sqlite3OsClose(pFile); sqlite3_free(pFile); return rc; } static sqlite3_vfs * SQLITE_WSD vfsList = 0; 
#define vfsList GLOBAL(sqlite3_vfs *, vfsList) 
SQLITE_API sqlite3_vfs *sqlite3_vfs_find(const char *zVfs){ sqlite3_vfs *pVfs = 0; 
#if SQLITE_THREADSAFE 
 sqlite3_mutex *mutex; 
#endif 
#ifndef SQLITE_OMIT_AUTOINIT 
 int rc = sqlite3_initialize(); if( rc ) return 0; 
#endif 
#if SQLITE_THREADSAFE 
 mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER); 
#endif 
 sqlite3_mutex_enter(mutex); for(pVfs = vfsList; pVfs; pVfs=pVfs->pNext){ if( zVfs==0 ) break; if( strcmp(zVfs, pVfs->zName)==0 ) break; } sqlite3_mutex_leave(mutex); return pVfs; } static void vfsUnlink(sqlite3_vfs *pVfs){ assert( sqlite3_mutex_held(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER)) ); if( pVfs==0 ){ }else if( vfsList==pVfs ){ vfsList = pVfs->pNext; }else if( vfsList ){ sqlite3_vfs *p = vfsList; while( p->pNext && p->pNext!=pVfs ){ p = p->pNext; } if( p->pNext==pVfs ){ p->pNext = pVfs->pNext; } } } SQLITE_API int sqlite3_vfs_register(sqlite3_vfs *pVfs, int makeDflt){ sqlite3_mutex *mutex = 0; 
#ifndef SQLITE_OMIT_AUTOINIT 
 int rc = sqlite3_initialize(); if( rc ) return rc; 
#endif 
 mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER); sqlite3_mutex_enter(mutex); vfsUnlink(pVfs); if( makeDflt || vfsList==0 ){ pVfs->pNext = vfsList; vfsList = pVfs; }else{ pVfs->pNext = vfsList->pNext; vfsList->pNext = pVfs; } assert(vfsList); sqlite3_mutex_leave(mutex); return SQLITE_OK; } SQLITE_API int sqlite3_vfs_unregister(sqlite3_vfs *pVfs){ 
#if SQLITE_THREADSAFE 
 sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER); 
#endif 
 sqlite3_mutex_enter(mutex); vfsUnlink(pVfs); sqlite3_mutex_leave(mutex); return SQLITE_OK; } 
#ifndef SQLITE_OMIT_BUILTIN_TEST 
typedef struct BenignMallocHooks BenignMallocHooks; static SQLITE_WSD struct BenignMallocHooks { void (*xBenignBegin)(void); void (*xBenignEnd)(void); } sqlite3Hooks = { 0, 0 }; 
#ifdef SQLITE_OMIT_WSD 
#define wsdHooksInit BenignMallocHooks *x = &GLOBAL(BenignMallocHooks,sqlite3Hooks) 
#define wsdHooks x[0] 
#else 
#define wsdHooksInit 
#define wsdHooks sqlite3Hooks 
#endif 
SQLITE_PRIVATE void sqlite3BenignMallocHooks( void (*xBenignBegin)(void), void (*xBenignEnd)(void) ){ wsdHooksInit; wsdHooks.xBenignBegin = xBenignBegin; wsdHooks.xBenignEnd = xBenignEnd; } SQLITE_PRIVATE void sqlite3BeginBenignMalloc(void){ wsdHooksInit; if( wsdHooks.xBenignBegin ){ wsdHooks.xBenignBegin(); } } SQLITE_PRIVATE void sqlite3EndBenignMalloc(void){ wsdHooksInit; if( wsdHooks.xBenignEnd ){ wsdHooks.xBenignEnd(); } } 
#endif 
#ifdef SQLITE_ZERO_MALLOC 
static void *sqlite3MemMalloc(int nByte){ return 0; } static void sqlite3MemFree(void *pPrior){ return; } static void *sqlite3MemRealloc(void *pPrior, int nByte){ return 0; } static int sqlite3MemSize(void *pPrior){ return 0; } static int sqlite3MemRoundup(int n){ return n; } static int sqlite3MemInit(void *NotUsed){ return SQLITE_OK; } static void sqlite3MemShutdown(void *NotUsed){ return; } SQLITE_PRIVATE void sqlite3MemSetDefault(void){ static const sqlite3_mem_methods defaultMethods = { sqlite3MemMalloc, sqlite3MemFree, sqlite3MemRealloc, sqlite3MemSize, sqlite3MemRoundup, sqlite3MemInit, sqlite3MemShutdown, 0 }; sqlite3_config(SQLITE_CONFIG_MALLOC, &defaultMethods); } 
#endif 
#ifdef SQLITE_SYSTEM_MALLOC 
static void *sqlite3MemMalloc(int nByte){ sqlite3_int64 *p; assert( nByte>0 ); nByte = (nByte+7)&~7; p = malloc( nByte+8 ); if( p ){ p[0] = nByte; p++; } return (void *)p; } static void sqlite3MemFree(void *pPrior){ sqlite3_int64 *p = (sqlite3_int64*)pPrior; assert( pPrior!=0 ); p--; free(p); } static void *sqlite3MemRealloc(void *pPrior, int nByte){ sqlite3_int64 *p = (sqlite3_int64*)pPrior; assert( pPrior!=0 && nByte>0 ); nByte = (nByte+7)&~7; p = (sqlite3_int64*)pPrior; p--; p = realloc(p, nByte+8 ); if( p ){ p[0] = nByte; p++; } return (void*)p; } static int sqlite3MemSize(void *pPrior){ sqlite3_int64 *p; if( pPrior==0 ) return 0; p = (sqlite3_int64*)pPrior; p--; return p[0]; } static int sqlite3MemRoundup(int n){ return (n+7) & ~7; } static int sqlite3MemInit(void *NotUsed){ UNUSED_PARAMETER(NotUsed); return SQLITE_OK; } static void sqlite3MemShutdown(void *NotUsed){ UNUSED_PARAMETER(NotUsed); return; } SQLITE_PRIVATE void sqlite3MemSetDefault(void){ static const sqlite3_mem_methods defaultMethods = { sqlite3MemMalloc, sqlite3MemFree, sqlite3MemRealloc, sqlite3MemSize, sqlite3MemRoundup, sqlite3MemInit, sqlite3MemShutdown, 0 }; sqlite3_config(SQLITE_CONFIG_MALLOC, &defaultMethods); } 
#endif 
#ifdef SQLITE_MEMDEBUG 
#ifdef __GLIBC__ 
 extern int backtrace(void**,int); extern void backtrace_symbols_fd(void*const*,int,int); 
#else 
#define backtrace(A,B) 1 
#define backtrace_symbols_fd(A,B,C) 
#endif 
struct MemBlockHdr { i64 iSize; struct MemBlockHdr *pNext, *pPrev; char nBacktrace; char nBacktraceSlots; short nTitle; int iForeGuard; }; 
#define FOREGUARD 0x80F5E153 
#define REARGUARD 0xE4676B53 
#define NCSIZE 1000 
static struct { sqlite3_mutex *mutex; struct MemBlockHdr *pFirst; struct MemBlockHdr *pLast; int nBacktrace; void (*xBacktrace)(int, int, void **); int nTitle; char zTitle[100]; int disallow; int nAlloc[NCSIZE]; int nCurrent[NCSIZE]; int mxCurrent[NCSIZE]; } mem; static void adjustStats(int iSize, int increment){ int i = ((iSize+7)&~7)/8; if( i>NCSIZE-1 ){ i = NCSIZE - 1; } if( increment>0 ){ mem.nAlloc[i]++; mem.nCurrent[i]++; if( mem.nCurrent[i]>mem.mxCurrent[i] ){ mem.mxCurrent[i] = mem.nCurrent[i]; } }else{ mem.nCurrent[i]--; assert( mem.nCurrent[i]>=0 ); } } static struct MemBlockHdr *sqlite3MemsysGetHeader(void *pAllocation){ struct MemBlockHdr *p; int *pInt; u8 *pU8; int nReserve; p = (struct MemBlockHdr*)pAllocation; p--; assert( p->iForeGuard==FOREGUARD ); nReserve = (p->iSize+7)&~7; pInt = (int*)pAllocation; pU8 = (u8*)pAllocation; assert( pInt[nReserve/sizeof(int)]==REARGUARD ); assert( (nReserve-0)<=p->iSize || pU8[nReserve-1]==0x65 ); assert( (nReserve-1)<=p->iSize || pU8[nReserve-2]==0x65 ); assert( (nReserve-2)<=p->iSize || pU8[nReserve-3]==0x65 ); return p; } static int sqlite3MemSize(void *p){ struct MemBlockHdr *pHdr; if( !p ){ return 0; } pHdr = sqlite3MemsysGetHeader(p); return pHdr->iSize; } static int sqlite3MemInit(void *NotUsed){ if( !sqlite3GlobalConfig.bMemstat ){ mem.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MEM); } return SQLITE_OK; } static void sqlite3MemShutdown(void *NotUsed){ mem.mutex = 0; } static int sqlite3MemRoundup(int n){ return (n+7) & ~7; } static void *sqlite3MemMalloc(int nByte){ struct MemBlockHdr *pHdr; void **pBt; char *z; int *pInt; void *p = 0; int totalSize; int nReserve; sqlite3_mutex_enter(mem.mutex); assert( mem.disallow==0 ); nReserve = (nByte+7)&~7; totalSize = nReserve + sizeof(*pHdr) + sizeof(int) + mem.nBacktrace*sizeof(void*) + mem.nTitle; p = malloc(totalSize); if( p ){ z = p; pBt = (void**)&z[mem.nTitle]; pHdr = (struct MemBlockHdr*)&pBt[mem.nBacktrace]; pHdr->pNext = 0; pHdr->pPrev = mem.pLast; if( mem.pLast ){ mem.pLast->pNext = pHdr; }else{ mem.pFirst = pHdr; } mem.pLast = pHdr; pHdr->iForeGuard = FOREGUARD; pHdr->nBacktraceSlots = mem.nBacktrace; pHdr->nTitle = mem.nTitle; if( mem.nBacktrace ){ void *aAddr[40]; pHdr->nBacktrace = backtrace(aAddr, mem.nBacktrace+1)-1; memcpy(pBt, &aAddr[1], pHdr->nBacktrace*sizeof(void*)); if( mem.xBacktrace ){ mem.xBacktrace(nByte, pHdr->nBacktrace-1, &aAddr[1]); } }else{ pHdr->nBacktrace = 0; } if( mem.nTitle ){ memcpy(z, mem.zTitle, mem.nTitle); } pHdr->iSize = nByte; adjustStats(nByte, +1); pInt = (int*)&pHdr[1]; pInt[nReserve/sizeof(int)] = REARGUARD; memset(pInt, 0x65, nReserve); p = (void*)pInt; } sqlite3_mutex_leave(mem.mutex); return p; } static void sqlite3MemFree(void *pPrior){ struct MemBlockHdr *pHdr; void **pBt; char *z; assert( sqlite3GlobalConfig.bMemstat || mem.mutex!=0 ); pHdr = sqlite3MemsysGetHeader(pPrior); pBt = (void**)pHdr; pBt -= pHdr->nBacktraceSlots; sqlite3_mutex_enter(mem.mutex); if( pHdr->pPrev ){ assert( pHdr->pPrev->pNext==pHdr ); pHdr->pPrev->pNext = pHdr->pNext; }else{ assert( mem.pFirst==pHdr ); mem.pFirst = pHdr->pNext; } if( pHdr->pNext ){ assert( pHdr->pNext->pPrev==pHdr ); pHdr->pNext->pPrev = pHdr->pPrev; }else{ assert( mem.pLast==pHdr ); mem.pLast = pHdr->pPrev; } z = (char*)pBt; z -= pHdr->nTitle; adjustStats(pHdr->iSize, -1); memset(z, 0x2b, sizeof(void*)*pHdr->nBacktraceSlots + sizeof(*pHdr) + pHdr->iSize + sizeof(int) + pHdr->nTitle); free(z); sqlite3_mutex_leave(mem.mutex); } static void *sqlite3MemRealloc(void *pPrior, int nByte){ struct MemBlockHdr *pOldHdr; void *pNew; assert( mem.disallow==0 ); pOldHdr = sqlite3MemsysGetHeader(pPrior); pNew = sqlite3MemMalloc(nByte); if( pNew ){ memcpy(pNew, pPrior, nByte<pOldHdr->iSize ? nByte : pOldHdr->iSize); if( nByte>pOldHdr->iSize ){ memset(&((char*)pNew)[pOldHdr->iSize], 0x2b, nByte - pOldHdr->iSize); } sqlite3MemFree(pPrior); } return pNew; } SQLITE_PRIVATE void sqlite3MemSetDefault(void){ static const sqlite3_mem_methods defaultMethods = { sqlite3MemMalloc, sqlite3MemFree, sqlite3MemRealloc, sqlite3MemSize, sqlite3MemRoundup, sqlite3MemInit, sqlite3MemShutdown, 0 }; sqlite3_config(SQLITE_CONFIG_MALLOC, &defaultMethods); } SQLITE_PRIVATE void sqlite3MemdebugBacktrace(int depth){ if( depth<0 ){ depth = 0; } if( depth>20 ){ depth = 20; } depth = (depth+1)&0xfe; mem.nBacktrace = depth; } SQLITE_PRIVATE void sqlite3MemdebugBacktraceCallback(void (*xBacktrace)(int, int, void **)){ mem.xBacktrace = xBacktrace; } SQLITE_PRIVATE void sqlite3MemdebugSettitle(const char *zTitle){ int n = strlen(zTitle) + 1; sqlite3_mutex_enter(mem.mutex); if( n>=sizeof(mem.zTitle) ) n = sizeof(mem.zTitle)-1; memcpy(mem.zTitle, zTitle, n); mem.zTitle[n] = 0; mem.nTitle = (n+7)&~7; sqlite3_mutex_leave(mem.mutex); } SQLITE_PRIVATE void sqlite3MemdebugSync(){ struct MemBlockHdr *pHdr; for(pHdr=mem.pFirst; pHdr; pHdr=pHdr->pNext){ void **pBt = (void**)pHdr; pBt -= pHdr->nBacktraceSlots; mem.xBacktrace(pHdr->iSize, pHdr->nBacktrace-1, &pBt[1]); } } SQLITE_PRIVATE void sqlite3MemdebugDump(const char *zFilename){ FILE *out; struct MemBlockHdr *pHdr; void **pBt; int i; out = fopen(zFilename, "w"); if( out==0 ){ fprintf(stderr, "** Unable to output memory debug output log: %s **\n", zFilename); return; } for(pHdr=mem.pFirst; pHdr; pHdr=pHdr->pNext){ char *z = (char*)pHdr; z -= pHdr->nBacktraceSlots*sizeof(void*) + pHdr->nTitle; fprintf(out, "**** %lld bytes at %p from %s ****\n", pHdr->iSize, &pHdr[1], pHdr->nTitle ? z : "???"); if( pHdr->nBacktrace ){ fflush(out); pBt = (void**)pHdr; pBt -= pHdr->nBacktraceSlots; backtrace_symbols_fd(pBt, pHdr->nBacktrace, fileno(out)); fprintf(out, "\n"); } } fprintf(out, "COUNTS:\n"); for(i=0; i<NCSIZE-1; i++){ if( mem.nAlloc[i] ){ fprintf(out, " %5d: %10d %10d %10d\n", i*8, mem.nAlloc[i], mem.nCurrent[i], mem.mxCurrent[i]); } } if( mem.nAlloc[NCSIZE-1] ){ fprintf(out, " %5d: %10d %10d %10d\n", NCSIZE*8-8, mem.nAlloc[NCSIZE-1], mem.nCurrent[NCSIZE-1], mem.mxCurrent[NCSIZE-1]); } fclose(out); } SQLITE_PRIVATE int sqlite3MemdebugMallocCount(){ int i; int nTotal = 0; for(i=0; i<NCSIZE; i++){ nTotal += mem.nAlloc[i]; } return nTotal; } 
#endif 
#ifdef SQLITE_ENABLE_MEMSYS3 
#define MX_SMALL 10 
#define N_HASH 61 
typedef struct Mem3Block Mem3Block; struct Mem3Block { union { struct { u32 prevSize; u32 size4x; } hdr; struct { u32 next; u32 prev; } list; } u; }; static SQLITE_WSD struct Mem3Global { u32 nPool; Mem3Block *aPool; int alarmBusy; sqlite3_mutex *mutex; u32 mnMaster; u32 iMaster; u32 szMaster; u32 aiSmall[MX_SMALL-1]; u32 aiHash[N_HASH]; } mem3 = { 97535575 }; 
#define mem3 GLOBAL(struct Mem3Global, mem3) 
static void memsys3UnlinkFromList(u32 i, u32 *pRoot){ u32 next = mem3.aPool[i].u.list.next; u32 prev = mem3.aPool[i].u.list.prev; assert( sqlite3_mutex_held(mem3.mutex) ); if( prev==0 ){ *pRoot = next; }else{ mem3.aPool[prev].u.list.next = next; } if( next ){ mem3.aPool[next].u.list.prev = prev; } mem3.aPool[i].u.list.next = 0; mem3.aPool[i].u.list.prev = 0; } static void memsys3Unlink(u32 i){ u32 size, hash; assert( sqlite3_mutex_held(mem3.mutex) ); assert( (mem3.aPool[i-1].u.hdr.size4x & 1)==0 ); assert( i>=1 ); size = mem3.aPool[i-1].u.hdr.size4x/4; assert( size==mem3.aPool[i+size-1].u.hdr.prevSize ); assert( size>=2 ); if( size <= MX_SMALL ){ memsys3UnlinkFromList(i, &mem3.aiSmall[size-2]); }else{ hash = size % N_HASH; memsys3UnlinkFromList(i, &mem3.aiHash[hash]); } } static void memsys3LinkIntoList(u32 i, u32 *pRoot){ assert( sqlite3_mutex_held(mem3.mutex) ); mem3.aPool[i].u.list.next = *pRoot; mem3.aPool[i].u.list.prev = 0; if( *pRoot ){ mem3.aPool[*pRoot].u.list.prev = i; } *pRoot = i; } static void memsys3Link(u32 i){ u32 size, hash; assert( sqlite3_mutex_held(mem3.mutex) ); assert( i>=1 ); assert( (mem3.aPool[i-1].u.hdr.size4x & 1)==0 ); size = mem3.aPool[i-1].u.hdr.size4x/4; assert( size==mem3.aPool[i+size-1].u.hdr.prevSize ); assert( size>=2 ); if( size <= MX_SMALL ){ memsys3LinkIntoList(i, &mem3.aiSmall[size-2]); }else{ hash = size % N_HASH; memsys3LinkIntoList(i, &mem3.aiHash[hash]); } } static void memsys3Enter(void){ if( sqlite3GlobalConfig.bMemstat==0 && mem3.mutex==0 ){ mem3.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MEM); } sqlite3_mutex_enter(mem3.mutex); } static void memsys3Leave(void){ sqlite3_mutex_leave(mem3.mutex); } static void memsys3OutOfMemory(int nByte){ if( !mem3.alarmBusy ){ mem3.alarmBusy = 1; assert( sqlite3_mutex_held(mem3.mutex) ); sqlite3_mutex_leave(mem3.mutex); sqlite3_release_memory(nByte); sqlite3_mutex_enter(mem3.mutex); mem3.alarmBusy = 0; } } static void *memsys3Checkout(u32 i, u32 nBlock){ u32 x; assert( sqlite3_mutex_held(mem3.mutex) ); assert( i>=1 ); assert( mem3.aPool[i-1].u.hdr.size4x/4==nBlock ); assert( mem3.aPool[i+nBlock-1].u.hdr.prevSize==nBlock ); x = mem3.aPool[i-1].u.hdr.size4x; mem3.aPool[i-1].u.hdr.size4x = nBlock*4 | 1 | (x&2); mem3.aPool[i+nBlock-1].u.hdr.prevSize = nBlock; mem3.aPool[i+nBlock-1].u.hdr.size4x |= 2; return &mem3.aPool[i]; } static void *memsys3FromMaster(u32 nBlock){ assert( sqlite3_mutex_held(mem3.mutex) ); assert( mem3.szMaster>=nBlock ); if( nBlock>=mem3.szMaster-1 ){ void *p = memsys3Checkout(mem3.iMaster, mem3.szMaster); mem3.iMaster = 0; mem3.szMaster = 0; mem3.mnMaster = 0; return p; }else{ u32 newi, x; newi = mem3.iMaster + mem3.szMaster - nBlock; assert( newi > mem3.iMaster+1 ); mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.prevSize = nBlock; mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.size4x |= 2; mem3.aPool[newi-1].u.hdr.size4x = nBlock*4 + 1; mem3.szMaster -= nBlock; mem3.aPool[newi-1].u.hdr.prevSize = mem3.szMaster; x = mem3.aPool[mem3.iMaster-1].u.hdr.size4x & 2; mem3.aPool[mem3.iMaster-1].u.hdr.size4x = mem3.szMaster*4 | x; if( mem3.szMaster < mem3.mnMaster ){ mem3.mnMaster = mem3.szMaster; } return (void*)&mem3.aPool[newi]; } } static void memsys3Merge(u32 *pRoot){ u32 iNext, prev, size, i, x; assert( sqlite3_mutex_held(mem3.mutex) ); for(i=*pRoot; i>0; i=iNext){ iNext = mem3.aPool[i].u.list.next; size = mem3.aPool[i-1].u.hdr.size4x; assert( (size&1)==0 ); if( (size&2)==0 ){ memsys3UnlinkFromList(i, pRoot); assert( i > mem3.aPool[i-1].u.hdr.prevSize ); prev = i - mem3.aPool[i-1].u.hdr.prevSize; if( prev==iNext ){ iNext = mem3.aPool[prev].u.list.next; } memsys3Unlink(prev); size = i + size/4 - prev; x = mem3.aPool[prev-1].u.hdr.size4x & 2; mem3.aPool[prev-1].u.hdr.size4x = size*4 | x; mem3.aPool[prev+size-1].u.hdr.prevSize = size; memsys3Link(prev); i = prev; }else{ size /= 4; } if( size>mem3.szMaster ){ mem3.iMaster = i; mem3.szMaster = size; } } } static void *memsys3MallocUnsafe(int nByte){ u32 i; u32 nBlock; u32 toFree; assert( sqlite3_mutex_held(mem3.mutex) ); assert( sizeof(Mem3Block)==8 ); if( nByte<=12 ){ nBlock = 2; }else{ nBlock = (nByte + 11)/8; } assert( nBlock>=2 ); if( nBlock <= MX_SMALL ){ i = mem3.aiSmall[nBlock-2]; if( i>0 ){ memsys3UnlinkFromList(i, &mem3.aiSmall[nBlock-2]); return memsys3Checkout(i, nBlock); } }else{ int hash = nBlock % N_HASH; for(i=mem3.aiHash[hash]; i>0; i=mem3.aPool[i].u.list.next){ if( mem3.aPool[i-1].u.hdr.size4x/4==nBlock ){ memsys3UnlinkFromList(i, &mem3.aiHash[hash]); return memsys3Checkout(i, nBlock); } } } if( mem3.szMaster>=nBlock ){ return memsys3FromMaster(nBlock); } for(toFree=nBlock*16; toFree<(mem3.nPool*16); toFree *= 2){ memsys3OutOfMemory(toFree); if( mem3.iMaster ){ memsys3Link(mem3.iMaster); mem3.iMaster = 0; mem3.szMaster = 0; } for(i=0; i<N_HASH; i++){ memsys3Merge(&mem3.aiHash[i]); } for(i=0; i<MX_SMALL-1; i++){ memsys3Merge(&mem3.aiSmall[i]); } if( mem3.szMaster ){ memsys3Unlink(mem3.iMaster); if( mem3.szMaster>=nBlock ){ return memsys3FromMaster(nBlock); } } } return 0; } void memsys3FreeUnsafe(void *pOld){ Mem3Block *p = (Mem3Block*)pOld; int i; u32 size, x; assert( sqlite3_mutex_held(mem3.mutex) ); assert( p>mem3.aPool && p<&mem3.aPool[mem3.nPool] ); i = p - mem3.aPool; assert( (mem3.aPool[i-1].u.hdr.size4x&1)==1 ); size = mem3.aPool[i-1].u.hdr.size4x/4; assert( i+size<=mem3.nPool+1 ); mem3.aPool[i-1].u.hdr.size4x &= ~1; mem3.aPool[i+size-1].u.hdr.prevSize = size; mem3.aPool[i+size-1].u.hdr.size4x &= ~2; memsys3Link(i); if( mem3.iMaster ){ while( (mem3.aPool[mem3.iMaster-1].u.hdr.size4x&2)==0 ){ size = mem3.aPool[mem3.iMaster-1].u.hdr.prevSize; mem3.iMaster -= size; mem3.szMaster += size; memsys3Unlink(mem3.iMaster); x = mem3.aPool[mem3.iMaster-1].u.hdr.size4x & 2; mem3.aPool[mem3.iMaster-1].u.hdr.size4x = mem3.szMaster*4 | x; mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.prevSize = mem3.szMaster; } x = mem3.aPool[mem3.iMaster-1].u.hdr.size4x & 2; while( (mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.size4x&1)==0 ){ memsys3Unlink(mem3.iMaster+mem3.szMaster); mem3.szMaster += mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.size4x/4; mem3.aPool[mem3.iMaster-1].u.hdr.size4x = mem3.szMaster*4 | x; mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.prevSize = mem3.szMaster; } } } static int memsys3Size(void *p){ Mem3Block *pBlock; if( p==0 ) return 0; pBlock = (Mem3Block*)p; assert( (pBlock[-1].u.hdr.size4x&1)!=0 ); return (pBlock[-1].u.hdr.size4x&~3)*2 - 4; } static int memsys3Roundup(int n){ if( n<=12 ){ return 12; }else{ return ((n+11)&~7) - 4; } } static void *memsys3Malloc(int nBytes){ sqlite3_int64 *p; assert( nBytes>0 ); memsys3Enter(); p = memsys3MallocUnsafe(nBytes); memsys3Leave(); return (void*)p; } void memsys3Free(void *pPrior){ assert( pPrior ); memsys3Enter(); memsys3FreeUnsafe(pPrior); memsys3Leave(); } void *memsys3Realloc(void *pPrior, int nBytes){ int nOld; void *p; if( pPrior==0 ){ return sqlite3_malloc(nBytes); } if( nBytes<=0 ){ sqlite3_free(pPrior); return 0; } nOld = memsys3Size(pPrior); if( nBytes<=nOld && nBytes>=nOld-128 ){ return pPrior; } memsys3Enter(); p = memsys3MallocUnsafe(nBytes); if( p ){ if( nOld<nBytes ){ memcpy(p, pPrior, nOld); }else{ memcpy(p, pPrior, nBytes); } memsys3FreeUnsafe(pPrior); } memsys3Leave(); return p; } static int memsys3Init(void *NotUsed){ UNUSED_PARAMETER(NotUsed); if( !sqlite3GlobalConfig.pHeap ){ return SQLITE_ERROR; } assert( sizeof(Mem3Block)==8 ); mem3.aPool = (Mem3Block *)sqlite3GlobalConfig.pHeap; mem3.nPool = (sqlite3GlobalConfig.nHeap / sizeof(Mem3Block)) - 2; mem3.szMaster = mem3.nPool; mem3.mnMaster = mem3.szMaster; mem3.iMaster = 1; mem3.aPool[0].u.hdr.size4x = (mem3.szMaster<<2) + 2; mem3.aPool[mem3.nPool].u.hdr.prevSize = mem3.nPool; mem3.aPool[mem3.nPool].u.hdr.size4x = 1; return SQLITE_OK; } static void memsys3Shutdown(void *NotUsed){ UNUSED_PARAMETER(NotUsed); return; } SQLITE_PRIVATE void sqlite3Memsys3Dump(const char *zFilename){ 
#ifdef SQLITE_DEBUG 
 FILE *out; u32 i, j; u32 size; if( zFilename==0 || zFilename[0]==0 ){ out = stdout; }else{ out = fopen(zFilename, "w"); if( out==0 ){ fprintf(stderr, "** Unable to output memory debug output log: %s **\n", zFilename); return; } } memsys3Enter(); fprintf(out, "CHUNKS:\n"); for(i=1; i<=mem3.nPool; i+=size/4){ size = mem3.aPool[i-1].u.hdr.size4x; if( size/4<=1 ){ fprintf(out, "%p size error\n", &mem3.aPool[i]); assert( 0 ); break; } if( (size&1)==0 && mem3.aPool[i+size/4-1].u.hdr.prevSize!=size/4 ){ fprintf(out, "%p tail size does not match\n", &mem3.aPool[i]); assert( 0 ); break; } if( ((mem3.aPool[i+size/4-1].u.hdr.size4x&2)>>1)!=(size&1) ){ fprintf(out, "%p tail checkout bit is incorrect\n", &mem3.aPool[i]); assert( 0 ); break; } if( size&1 ){ fprintf(out, "%p %6d bytes checked out\n", &mem3.aPool[i], (size/4)*8-8); }else{ fprintf(out, "%p %6d bytes free%s\n", &mem3.aPool[i], (size/4)*8-8, i==mem3.iMaster ? " **master**" : ""); } } for(i=0; i<MX_SMALL-1; i++){ if( mem3.aiSmall[i]==0 ) continue; fprintf(out, "small(%2d):", i); for(j = mem3.aiSmall[i]; j>0; j=mem3.aPool[j].u.list.next){ fprintf(out, " %p(%d)", &mem3.aPool[j], (mem3.aPool[j-1].u.hdr.size4x/4)*8-8); } fprintf(out, "\n"); } for(i=0; i<N_HASH; i++){ if( mem3.aiHash[i]==0 ) continue; fprintf(out, "hash(%2d):", i); for(j = mem3.aiHash[i]; j>0; j=mem3.aPool[j].u.list.next){ fprintf(out, " %p(%d)", &mem3.aPool[j], (mem3.aPool[j-1].u.hdr.size4x/4)*8-8); } fprintf(out, "\n"); } fprintf(out, "master=%d\n", mem3.iMaster); fprintf(out, "nowUsed=%d\n", mem3.nPool*8 - mem3.szMaster*8); fprintf(out, "mxUsed=%d\n", mem3.nPool*8 - mem3.mnMaster*8); sqlite3_mutex_leave(mem3.mutex); if( out==stdout ){ fflush(stdout); }else{ fclose(out); } 
#else 
 UNUSED_PARAMETER(zFilename); 
#endif 
} SQLITE_PRIVATE const sqlite3_mem_methods *sqlite3MemGetMemsys3(void){ static const sqlite3_mem_methods mempoolMethods = { memsys3Malloc, memsys3Free, memsys3Realloc, memsys3Size, memsys3Roundup, memsys3Init, memsys3Shutdown, 0 }; return &mempoolMethods; } 
#endif 
#ifdef SQLITE_ENABLE_MEMSYS5 
typedef struct Mem5Link Mem5Link; struct Mem5Link { int next; int prev; }; 
#define LOGMAX 30 
#define CTRL_LOGSIZE 0x1f 
#define CTRL_FREE 0x20 
static SQLITE_WSD struct Mem5Global { int nAtom; int nBlock; u8 *zPool; sqlite3_mutex *mutex; u64 nAlloc; u64 totalAlloc; u64 totalExcess; u32 currentOut; u32 currentCount; u32 maxOut; u32 maxCount; u32 maxRequest; int aiFreelist[LOGMAX+1]; u8 *aCtrl; } mem5 = { 19804167 }; 
#define mem5 GLOBAL(struct Mem5Global, mem5) 
#define MEM5LINK(idx) ((Mem5Link *)(&mem5.zPool[(idx)*mem5.nAtom])) 
static void memsys5Unlink(int i, int iLogsize){ int next, prev; assert( i>=0 && i<mem5.nBlock ); assert( iLogsize>=0 && iLogsize<=LOGMAX ); assert( (mem5.aCtrl[i] & CTRL_LOGSIZE)==iLogsize ); next = MEM5LINK(i)->next; prev = MEM5LINK(i)->prev; if( prev<0 ){ mem5.aiFreelist[iLogsize] = next; }else{ MEM5LINK(prev)->next = next; } if( next>=0 ){ MEM5LINK(next)->prev = prev; } } static void memsys5Link(int i, int iLogsize){ int x; assert( sqlite3_mutex_held(mem5.mutex) ); assert( i>=0 && i<mem5.nBlock ); assert( iLogsize>=0 && iLogsize<=LOGMAX ); assert( (mem5.aCtrl[i] & CTRL_LOGSIZE)==iLogsize ); x = MEM5LINK(i)->next = mem5.aiFreelist[iLogsize]; MEM5LINK(i)->prev = -1; if( x>=0 ){ assert( x<mem5.nBlock ); MEM5LINK(x)->prev = i; } mem5.aiFreelist[iLogsize] = i; } static void memsys5Enter(void){ if( sqlite3GlobalConfig.bMemstat==0 && mem5.mutex==0 ){ mem5.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MEM); } sqlite3_mutex_enter(mem5.mutex); } static void memsys5Leave(void){ sqlite3_mutex_leave(mem5.mutex); } static int memsys5Size(void *p){ int iSize = 0; if( p ){ int i = ((u8 *)p-mem5.zPool)/mem5.nAtom; assert( i>=0 && i<mem5.nBlock ); iSize = mem5.nAtom * (1 << (mem5.aCtrl[i]&CTRL_LOGSIZE)); } return iSize; } static int memsys5UnlinkFirst(int iLogsize){ int i; int iFirst; assert( iLogsize>=0 && iLogsize<=LOGMAX ); i = iFirst = mem5.aiFreelist[iLogsize]; assert( iFirst>=0 ); while( i>0 ){ if( i<iFirst ) iFirst = i; i = MEM5LINK(i)->next; } memsys5Unlink(iFirst, iLogsize); return iFirst; } static void *memsys5MallocUnsafe(int nByte){ int i; int iBin; int iFullSz; int iLogsize; if( (u32)nByte>mem5.maxRequest ){ mem5.maxRequest = nByte; } for(iFullSz=mem5.nAtom, iLogsize=0; iFullSz<nByte; iFullSz *= 2, iLogsize++){} for(iBin=iLogsize; mem5.aiFreelist[iBin]<0 && iBin<=LOGMAX; iBin++){} if( iBin>LOGMAX ) return 0; i = memsys5UnlinkFirst(iBin); while( iBin>iLogsize ){ int newSize; iBin--; newSize = 1 << iBin; mem5.aCtrl[i+newSize] = CTRL_FREE | iBin; memsys5Link(i+newSize, iBin); } mem5.aCtrl[i] = iLogsize; mem5.nAlloc++; mem5.totalAlloc += iFullSz; mem5.totalExcess += iFullSz - nByte; mem5.currentCount++; mem5.currentOut += iFullSz; if( mem5.maxCount<mem5.currentCount ) mem5.maxCount = mem5.currentCount; if( mem5.maxOut<mem5.currentOut ) mem5.maxOut = mem5.currentOut; return (void*)&mem5.zPool[i*mem5.nAtom]; } static void memsys5FreeUnsafe(void *pOld){ u32 size, iLogsize; int iBlock; iBlock = ((u8 *)pOld-mem5.zPool)/mem5.nAtom; assert( iBlock>=0 && iBlock<mem5.nBlock ); assert( ((u8 *)pOld-mem5.zPool)%mem5.nAtom==0 ); assert( (mem5.aCtrl[iBlock] & CTRL_FREE)==0 ); iLogsize = mem5.aCtrl[iBlock] & CTRL_LOGSIZE; size = 1<<iLogsize; assert( iBlock+size-1<(u32)mem5.nBlock ); mem5.aCtrl[iBlock] |= CTRL_FREE; mem5.aCtrl[iBlock+size-1] |= CTRL_FREE; assert( mem5.currentCount>0 ); assert( mem5.currentOut>=(size*mem5.nAtom) ); mem5.currentCount--; mem5.currentOut -= size*mem5.nAtom; assert( mem5.currentOut>0 || mem5.currentCount==0 ); assert( mem5.currentCount>0 || mem5.currentOut==0 ); mem5.aCtrl[iBlock] = CTRL_FREE | iLogsize; while( iLogsize<LOGMAX ){ int iBuddy; if( (iBlock>>iLogsize) & 1 ){ iBuddy = iBlock - size; }else{ iBuddy = iBlock + size; } assert( iBuddy>=0 ); if( (iBuddy+(1<<iLogsize))>mem5.nBlock ) break; if( mem5.aCtrl[iBuddy]!=(CTRL_FREE | iLogsize) ) break; memsys5Unlink(iBuddy, iLogsize); iLogsize++; if( iBuddy<iBlock ){ mem5.aCtrl[iBuddy] = CTRL_FREE | iLogsize; mem5.aCtrl[iBlock] = 0; iBlock = iBuddy; }else{ mem5.aCtrl[iBlock] = CTRL_FREE | iLogsize; mem5.aCtrl[iBuddy] = 0; } size *= 2; } memsys5Link(iBlock, iLogsize); } static void *memsys5Malloc(int nBytes){ sqlite3_int64 *p = 0; if( nBytes>0 ){ memsys5Enter(); p = memsys5MallocUnsafe(nBytes); memsys5Leave(); } return (void*)p; } static void memsys5Free(void *pPrior){ if( pPrior==0 ){ assert(0); return; } memsys5Enter(); memsys5FreeUnsafe(pPrior); memsys5Leave(); } static void *memsys5Realloc(void *pPrior, int nBytes){ int nOld; void *p; if( pPrior==0 ){ return memsys5Malloc(nBytes); } if( nBytes<=0 ){ memsys5Free(pPrior); return 0; } nOld = memsys5Size(pPrior); if( nBytes<=nOld ){ return pPrior; } memsys5Enter(); p = memsys5MallocUnsafe(nBytes); if( p ){ memcpy(p, pPrior, nOld); memsys5FreeUnsafe(pPrior); } memsys5Leave(); return p; } static int memsys5Roundup(int n){ int iFullSz; for(iFullSz=mem5.nAtom; iFullSz<n; iFullSz *= 2); return iFullSz; } static int memsys5Log(int iValue){ int iLog; for(iLog=0; (1<<iLog)<iValue; iLog++); return iLog; } static int memsys5Init(void *NotUsed){ int ii; int nByte = sqlite3GlobalConfig.nHeap; u8 *zByte = (u8 *)sqlite3GlobalConfig.pHeap; int nMinLog; int iOffset; UNUSED_PARAMETER(NotUsed); if( !zByte ){ return SQLITE_ERROR; } nMinLog = memsys5Log(sqlite3GlobalConfig.mnReq); mem5.nAtom = (1<<nMinLog); while( (int)sizeof(Mem5Link)>mem5.nAtom ){ mem5.nAtom = mem5.nAtom << 1; } mem5.nBlock = (nByte / (mem5.nAtom+sizeof(u8))); mem5.zPool = zByte; mem5.aCtrl = (u8 *)&mem5.zPool[mem5.nBlock*mem5.nAtom]; for(ii=0; ii<=LOGMAX; ii++){ mem5.aiFreelist[ii] = -1; } iOffset = 0; for(ii=LOGMAX; ii>=0; ii--){ int nAlloc = (1<<ii); if( (iOffset+nAlloc)<=mem5.nBlock ){ mem5.aCtrl[iOffset] = ii | CTRL_FREE; memsys5Link(iOffset, ii); iOffset += nAlloc; } assert((iOffset+nAlloc)>mem5.nBlock); } return SQLITE_OK; } static void memsys5Shutdown(void *NotUsed){ UNUSED_PARAMETER(NotUsed); return; } SQLITE_PRIVATE void sqlite3Memsys5Dump(const char *zFilename){ 
#ifdef SQLITE_DEBUG 
 FILE *out; int i, j, n; int nMinLog; if( zFilename==0 || zFilename[0]==0 ){ out = stdout; }else{ out = fopen(zFilename, "w"); if( out==0 ){ fprintf(stderr, "** Unable to output memory debug output log: %s **\n", zFilename); return; } } memsys5Enter(); nMinLog = memsys5Log(mem5.nAtom); for(i=0; i<=LOGMAX && i+nMinLog<32; i++){ for(n=0, j=mem5.aiFreelist[i]; j>=0; j = MEM5LINK(j)->next, n++){} fprintf(out, "freelist items of size %d: %d\n", mem5.nAtom << i, n); } fprintf(out, "mem5.nAlloc = %llu\n", mem5.nAlloc); fprintf(out, "mem5.totalAlloc = %llu\n", mem5.totalAlloc); fprintf(out, "mem5.totalExcess = %llu\n", mem5.totalExcess); fprintf(out, "mem5.currentOut = %u\n", mem5.currentOut); fprintf(out, "mem5.currentCount = %u\n", mem5.currentCount); fprintf(out, "mem5.maxOut = %u\n", mem5.maxOut); fprintf(out, "mem5.maxCount = %u\n", mem5.maxCount); fprintf(out, "mem5.maxRequest = %u\n", mem5.maxRequest); memsys5Leave(); if( out==stdout ){ fflush(stdout); }else{ fclose(out); } 
#else 
 UNUSED_PARAMETER(zFilename); 
#endif 
} SQLITE_PRIVATE const sqlite3_mem_methods *sqlite3MemGetMemsys5(void){ static const sqlite3_mem_methods memsys5Methods = { memsys5Malloc, memsys5Free, memsys5Realloc, memsys5Size, memsys5Roundup, memsys5Init, memsys5Shutdown, 0 }; return &memsys5Methods; } 
#endif 
#ifndef SQLITE_MUTEX_OMIT 
SQLITE_PRIVATE int sqlite3MutexInit(void){ int rc = SQLITE_OK; if( sqlite3GlobalConfig.bCoreMutex ){ if( !sqlite3GlobalConfig.mutex.xMutexAlloc ){ sqlite3_mutex_methods *p = sqlite3DefaultMutex(); sqlite3_mutex *pMaster = 0; rc = p->xMutexInit(); if( rc==SQLITE_OK ){ pMaster = p->xMutexAlloc(SQLITE_MUTEX_STATIC_MASTER); assert(pMaster); p->xMutexEnter(pMaster); assert( sqlite3GlobalConfig.mutex.xMutexAlloc==0 || sqlite3GlobalConfig.mutex.xMutexAlloc==p->xMutexAlloc ); if( !sqlite3GlobalConfig.mutex.xMutexAlloc ){ sqlite3GlobalConfig.mutex = *p; } p->xMutexLeave(pMaster); } }else{ rc = sqlite3GlobalConfig.mutex.xMutexInit(); } } return rc; } SQLITE_PRIVATE int sqlite3MutexEnd(void){ int rc = SQLITE_OK; rc = sqlite3GlobalConfig.mutex.xMutexEnd(); return rc; } SQLITE_API sqlite3_mutex *sqlite3_mutex_alloc(int id){ 
#ifndef SQLITE_OMIT_AUTOINIT 
 if( sqlite3_initialize() ) return 0; 
#endif 
 return sqlite3GlobalConfig.mutex.xMutexAlloc(id); } SQLITE_PRIVATE sqlite3_mutex *sqlite3MutexAlloc(int id){ if( !sqlite3GlobalConfig.bCoreMutex ){ return 0; } return sqlite3GlobalConfig.mutex.xMutexAlloc(id); } SQLITE_API void sqlite3_mutex_free(sqlite3_mutex *p){ if( p ){ sqlite3GlobalConfig.mutex.xMutexFree(p); } } SQLITE_API void sqlite3_mutex_enter(sqlite3_mutex *p){ if( p ){ sqlite3GlobalConfig.mutex.xMutexEnter(p); } } SQLITE_API int sqlite3_mutex_try(sqlite3_mutex *p){ int rc = SQLITE_OK; if( p ){ return sqlite3GlobalConfig.mutex.xMutexTry(p); } return rc; } SQLITE_API void sqlite3_mutex_leave(sqlite3_mutex *p){ if( p ){ sqlite3GlobalConfig.mutex.xMutexLeave(p); } } 
#ifndef NDEBUG 
SQLITE_API int sqlite3_mutex_held(sqlite3_mutex *p){ return p==0 || sqlite3GlobalConfig.mutex.xMutexHeld(p); } SQLITE_API int sqlite3_mutex_notheld(sqlite3_mutex *p){ return p==0 || sqlite3GlobalConfig.mutex.xMutexNotheld(p); } 
#endif 
#endif 
#if defined(SQLITE_MUTEX_NOOP) && !defined(SQLITE_DEBUG) 
static int noopMutexHeld(sqlite3_mutex *p){ return 1; } static int noopMutexNotheld(sqlite3_mutex *p){ return 1; } static int noopMutexInit(void){ return SQLITE_OK; } static int noopMutexEnd(void){ return SQLITE_OK; } static sqlite3_mutex *noopMutexAlloc(int id){ return (sqlite3_mutex*)8; } static void noopMutexFree(sqlite3_mutex *p){ return; } static void noopMutexEnter(sqlite3_mutex *p){ return; } static int noopMutexTry(sqlite3_mutex *p){ return SQLITE_OK; } static void noopMutexLeave(sqlite3_mutex *p){ return; } SQLITE_PRIVATE sqlite3_mutex_methods *sqlite3DefaultMutex(void){ static sqlite3_mutex_methods sMutex = { noopMutexInit, noopMutexEnd, noopMutexAlloc, noopMutexFree, noopMutexEnter, noopMutexTry, noopMutexLeave, noopMutexHeld, noopMutexNotheld }; return &sMutex; } 
#endif 
#if defined(SQLITE_MUTEX_NOOP) && defined(SQLITE_DEBUG) 
struct sqlite3_mutex { int id; int cnt; }; static int debugMutexHeld(sqlite3_mutex *p){ return p==0 || p->cnt>0; } static int debugMutexNotheld(sqlite3_mutex *p){ return p==0 || p->cnt==0; } static int debugMutexInit(void){ return SQLITE_OK; } static int debugMutexEnd(void){ return SQLITE_OK; } static sqlite3_mutex *debugMutexAlloc(int id){ static sqlite3_mutex aStatic[6]; sqlite3_mutex *pNew = 0; switch( id ){ case SQLITE_MUTEX_FAST: case SQLITE_MUTEX_RECURSIVE: { pNew = sqlite3Malloc(sizeof(*pNew)); if( pNew ){ pNew->id = id; pNew->cnt = 0; } break; } default: { assert( id-2 >= 0 ); assert( id-2 < sizeof(aStatic)/sizeof(aStatic[0]) ); pNew = &aStatic[id-2]; pNew->id = id; break; } } return pNew; } static void debugMutexFree(sqlite3_mutex *p){ assert( p->cnt==0 ); assert( p->id==SQLITE_MUTEX_FAST || p->id==SQLITE_MUTEX_RECURSIVE ); sqlite3_free(p); } static void debugMutexEnter(sqlite3_mutex *p){ assert( p->id==SQLITE_MUTEX_RECURSIVE || debugMutexNotheld(p) ); p->cnt++; } static int debugMutexTry(sqlite3_mutex *p){ assert( p->id==SQLITE_MUTEX_RECURSIVE || debugMutexNotheld(p) ); p->cnt++; return SQLITE_OK; } static void debugMutexLeave(sqlite3_mutex *p){ assert( debugMutexHeld(p) ); p->cnt--; assert( p->id==SQLITE_MUTEX_RECURSIVE || debugMutexNotheld(p) ); } SQLITE_PRIVATE sqlite3_mutex_methods *sqlite3DefaultMutex(void){ static sqlite3_mutex_methods sMutex = { debugMutexInit, debugMutexEnd, debugMutexAlloc, debugMutexFree, debugMutexEnter, debugMutexTry, debugMutexLeave, debugMutexHeld, debugMutexNotheld }; return &sMutex; } 
#endif 
#ifdef SQLITE_MUTEX_OS2 
struct sqlite3_mutex { HMTX mutex; int id; int nRef; TID owner; }; 
#define OS2_MUTEX_INITIALIZER 0,0,0,0 
static int os2MutexInit(void){ return SQLITE_OK; } static int os2MutexEnd(void){ return SQLITE_OK; } static sqlite3_mutex *os2MutexAlloc(int iType){ sqlite3_mutex *p = NULL; switch( iType ){ case SQLITE_MUTEX_FAST: case SQLITE_MUTEX_RECURSIVE: { p = sqlite3MallocZero( sizeof(*p) ); if( p ){ p->id = iType; if( DosCreateMutexSem( 0, &p->mutex, 0, FALSE ) != NO_ERROR ){ sqlite3_free( p ); p = NULL; } } break; } default: { static volatile int isInit = 0; static sqlite3_mutex staticMutexes[] = { { OS2_MUTEX_INITIALIZER, }, { OS2_MUTEX_INITIALIZER, }, { OS2_MUTEX_INITIALIZER, }, { OS2_MUTEX_INITIALIZER, }, { OS2_MUTEX_INITIALIZER, }, { OS2_MUTEX_INITIALIZER, }, }; if ( !isInit ){ APIRET rc; PTIB ptib; PPIB ppib; HMTX mutex; char name[32]; DosGetInfoBlocks( &ptib, &ppib ); sqlite3_snprintf( sizeof(name), name, "\\SEM32\\SQLITE%04x", ppib->pib_ulpid ); while( !isInit ){ mutex = 0; rc = DosCreateMutexSem( name, &mutex, 0, FALSE); if( rc == NO_ERROR ){ int i; if( !isInit ){ for( i = 0; i < sizeof(staticMutexes)/sizeof(staticMutexes[0]); i++ ){ DosCreateMutexSem( 0, &staticMutexes[i].mutex, 0, FALSE ); } isInit = 1; } DosCloseMutexSem( mutex ); }else if( rc == ERROR_DUPLICATE_NAME ){ DosSleep( 1 ); }else{ return p; } } } assert( iType-2 >= 0 ); assert( iType-2 < sizeof(staticMutexes)/sizeof(staticMutexes[0]) ); p = &staticMutexes[iType-2]; p->id = iType; break; } } return p; } static void os2MutexFree(sqlite3_mutex *p){ if( p==0 ) return; assert( p->nRef==0 ); assert( p->id==SQLITE_MUTEX_FAST || p->id==SQLITE_MUTEX_RECURSIVE ); DosCloseMutexSem( p->mutex ); sqlite3_free( p ); } static void os2MutexEnter(sqlite3_mutex *p){ TID tid; PID holder1; ULONG holder2; if( p==0 ) return; assert( p->id==SQLITE_MUTEX_RECURSIVE || os2MutexNotheld(p) ); DosRequestMutexSem(p->mutex, SEM_INDEFINITE_WAIT); DosQueryMutexSem(p->mutex, &holder1, &tid, &holder2); p->owner = tid; p->nRef++; } static int os2MutexTry(sqlite3_mutex *p){ int rc; TID tid; PID holder1; ULONG holder2; if( p==0 ) return SQLITE_OK; assert( p->id==SQLITE_MUTEX_RECURSIVE || os2MutexNotheld(p) ); if( DosRequestMutexSem(p->mutex, SEM_IMMEDIATE_RETURN) == NO_ERROR) { DosQueryMutexSem(p->mutex, &holder1, &tid, &holder2); p->owner = tid; p->nRef++; rc = SQLITE_OK; } else { rc = SQLITE_BUSY; } return rc; } static void os2MutexLeave(sqlite3_mutex *p){ TID tid; PID holder1; ULONG holder2; if( p==0 ) return; assert( p->nRef>0 ); DosQueryMutexSem(p->mutex, &holder1, &tid, &holder2); assert( p->owner==tid ); p->nRef--; assert( p->nRef==0 || p->id==SQLITE_MUTEX_RECURSIVE ); DosReleaseMutexSem(p->mutex); } 
#ifdef SQLITE_DEBUG 
static int os2MutexHeld(sqlite3_mutex *p){ TID tid; PID pid; ULONG ulCount; PTIB ptib; if( p!=0 ) { DosQueryMutexSem(p->mutex, &pid, &tid, &ulCount); } else { DosGetInfoBlocks(&ptib, NULL); tid = ptib->tib_ptib2->tib2_ultid; } return p==0 || (p->nRef!=0 && p->owner==tid); } static int os2MutexNotheld(sqlite3_mutex *p){ TID tid; PID pid; ULONG ulCount; PTIB ptib; if( p!= 0 ) { DosQueryMutexSem(p->mutex, &pid, &tid, &ulCount); } else { DosGetInfoBlocks(&ptib, NULL); tid = ptib->tib_ptib2->tib2_ultid; } return p==0 || p->nRef==0 || p->owner!=tid; } 
#endif 
SQLITE_PRIVATE sqlite3_mutex_methods *sqlite3DefaultMutex(void){ static sqlite3_mutex_methods sMutex = { os2MutexInit, os2MutexEnd, os2MutexAlloc, os2MutexFree, os2MutexEnter, os2MutexTry, os2MutexLeave, 
#ifdef SQLITE_DEBUG 
 os2MutexHeld, os2MutexNotheld 
#endif 
 }; return &sMutex; } 
#endif 
#ifdef SQLITE_MUTEX_PTHREADS 
#include <pthread.h> 
struct sqlite3_mutex { pthread_mutex_t mutex; int id; int nRef; pthread_t owner; 
#ifdef SQLITE_DEBUG 
 int trace; 
#endif 
}; 
#ifdef SQLITE_DEBUG 
#define SQLITE3_MUTEX_INITIALIZER { PTHREAD_MUTEX_INITIALIZER, 0, 0, (pthread_t)0, 0 } 
#else 
#define SQLITE3_MUTEX_INITIALIZER { PTHREAD_MUTEX_INITIALIZER, 0, 0, (pthread_t)0 } 
#endif 
#if !defined(NDEBUG) || defined(SQLITE_DEBUG) 
static int pthreadMutexHeld(sqlite3_mutex *p){ return (p->nRef!=0 && pthread_equal(p->owner, pthread_self())); } static int pthreadMutexNotheld(sqlite3_mutex *p){ return p->nRef==0 || pthread_equal(p->owner, pthread_self())==0; } 
#endif 
static int pthreadMutexInit(void){ return SQLITE_OK; } static int pthreadMutexEnd(void){ return SQLITE_OK; } static sqlite3_mutex *pthreadMutexAlloc(int iType){ static sqlite3_mutex staticMutexes[] = { SQLITE3_MUTEX_INITIALIZER, SQLITE3_MUTEX_INITIALIZER, SQLITE3_MUTEX_INITIALIZER, SQLITE3_MUTEX_INITIALIZER, SQLITE3_MUTEX_INITIALIZER, SQLITE3_MUTEX_INITIALIZER }; sqlite3_mutex *p; switch( iType ){ case SQLITE_MUTEX_RECURSIVE: { p = sqlite3MallocZero( sizeof(*p) ); if( p ){ 
#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX 
 pthread_mutex_init(&p->mutex, 0); 
#else 
 pthread_mutexattr_t recursiveAttr; pthread_mutexattr_init(&recursiveAttr); pthread_mutexattr_settype(&recursiveAttr, PTHREAD_MUTEX_RECURSIVE); pthread_mutex_init(&p->mutex, &recursiveAttr); pthread_mutexattr_destroy(&recursiveAttr); 
#endif 
 p->id = iType; } break; } case SQLITE_MUTEX_FAST: { p = sqlite3MallocZero( sizeof(*p) ); if( p ){ p->id = iType; pthread_mutex_init(&p->mutex, 0); } break; } default: { assert( iType-2 >= 0 ); assert( iType-2 < ArraySize(staticMutexes) ); p = &staticMutexes[iType-2]; p->id = iType; break; } } return p; } static void pthreadMutexFree(sqlite3_mutex *p){ assert( p->nRef==0 ); assert( p->id==SQLITE_MUTEX_FAST || p->id==SQLITE_MUTEX_RECURSIVE ); pthread_mutex_destroy(&p->mutex); sqlite3_free(p); } static void pthreadMutexEnter(sqlite3_mutex *p){ assert( p->id==SQLITE_MUTEX_RECURSIVE || pthreadMutexNotheld(p) ); 
#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX 
 { pthread_t self = pthread_self(); if( p->nRef>0 && pthread_equal(p->owner, self) ){ p->nRef++; }else{ pthread_mutex_lock(&p->mutex); assert( p->nRef==0 ); p->owner = self; p->nRef = 1; } } 
#else 
 pthread_mutex_lock(&p->mutex); p->owner = pthread_self(); p->nRef++; 
#endif 
#ifdef SQLITE_DEBUG 
 if( p->trace ){ printf("enter mutex %p (%d) with nRef=%d\n", p, p->trace, p->nRef); } 
#endif 
} static int pthreadMutexTry(sqlite3_mutex *p){ int rc; assert( p->id==SQLITE_MUTEX_RECURSIVE || pthreadMutexNotheld(p) ); 
#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX 
 { pthread_t self = pthread_self(); if( p->nRef>0 && pthread_equal(p->owner, self) ){ p->nRef++; rc = SQLITE_OK; }else if( pthread_mutex_trylock(&p->mutex)==0 ){ assert( p->nRef==0 ); p->owner = self; p->nRef = 1; rc = SQLITE_OK; }else{ rc = SQLITE_BUSY; } } 
#else 
 if( pthread_mutex_trylock(&p->mutex)==0 ){ p->owner = pthread_self(); p->nRef++; rc = SQLITE_OK; }else{ rc = SQLITE_BUSY; } 
#endif 
#ifdef SQLITE_DEBUG 
 if( rc==SQLITE_OK && p->trace ){ printf("enter mutex %p (%d) with nRef=%d\n", p, p->trace, p->nRef); } 
#endif 
 return rc; } static void pthreadMutexLeave(sqlite3_mutex *p){ assert( pthreadMutexHeld(p) ); p->nRef--; assert( p->nRef==0 || p->id==SQLITE_MUTEX_RECURSIVE ); 
#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX 
 if( p->nRef==0 ){ pthread_mutex_unlock(&p->mutex); } 
#else 
 pthread_mutex_unlock(&p->mutex); 
#endif 
#ifdef SQLITE_DEBUG 
 if( p->trace ){ printf("leave mutex %p (%d) with nRef=%d\n", p, p->trace, p->nRef); } 
#endif 
} SQLITE_PRIVATE sqlite3_mutex_methods *sqlite3DefaultMutex(void){ static sqlite3_mutex_methods sMutex = { pthreadMutexInit, pthreadMutexEnd, pthreadMutexAlloc, pthreadMutexFree, pthreadMutexEnter, pthreadMutexTry, pthreadMutexLeave, 
#ifdef SQLITE_DEBUG 
 pthreadMutexHeld, pthreadMutexNotheld 
#endif 
 }; return &sMutex; } 
#endif 
#ifdef SQLITE_MUTEX_W32 
struct sqlite3_mutex { CRITICAL_SECTION mutex; int id; int nRef; DWORD owner; }; 
#if 0 
#if SQLITE_OS_WINCE 
#define mutexIsNT() (1) 
#else 
 static int mutexIsNT(void){ static int osType = 0; if( osType==0 ){ OSVERSIONINFO sInfo; sInfo.dwOSVersionInfoSize = sizeof(sInfo); GetVersionEx(&sInfo); osType = sInfo.dwPlatformId==VER_PLATFORM_WIN32_NT ? 2 : 1; } return osType==2; } 
#endif 
#endif 
#ifdef SQLITE_DEBUG 
static int winMutexHeld(sqlite3_mutex *p){ return p->nRef!=0 && p->owner==GetCurrentThreadId(); } static int winMutexNotheld(sqlite3_mutex *p){ return p->nRef==0 || p->owner!=GetCurrentThreadId(); } 
#endif 
static int winMutexInit(void){ return SQLITE_OK; } static int winMutexEnd(void){ return SQLITE_OK; } static sqlite3_mutex *winMutexAlloc(int iType){ sqlite3_mutex *p; switch( iType ){ case SQLITE_MUTEX_FAST: case SQLITE_MUTEX_RECURSIVE: { p = sqlite3MallocZero( sizeof(*p) ); if( p ){ p->id = iType; InitializeCriticalSection(&p->mutex); } break; } default: { static sqlite3_mutex staticMutexes[6]; static int isInit = 0; while( !isInit ){ static long lock = 0; if( InterlockedIncrement(&lock)==1 ){ int i; for(i=0; i<sizeof(staticMutexes)/sizeof(staticMutexes[0]); i++){ InitializeCriticalSection(&staticMutexes[i].mutex); } isInit = 1; }else{ Sleep(1); } } assert( iType-2 >= 0 ); assert( iType-2 < sizeof(staticMutexes)/sizeof(staticMutexes[0]) ); p = &staticMutexes[iType-2]; p->id = iType; break; } } return p; } static void winMutexFree(sqlite3_mutex *p){ assert( p ); assert( p->nRef==0 ); assert( p->id==SQLITE_MUTEX_FAST || p->id==SQLITE_MUTEX_RECURSIVE ); DeleteCriticalSection(&p->mutex); sqlite3_free(p); } static void winMutexEnter(sqlite3_mutex *p){ assert( p->id==SQLITE_MUTEX_RECURSIVE || winMutexNotheld(p) ); EnterCriticalSection(&p->mutex); p->owner = GetCurrentThreadId(); p->nRef++; } static int winMutexTry(sqlite3_mutex *p){ int rc = SQLITE_BUSY; assert( p->id==SQLITE_MUTEX_RECURSIVE || winMutexNotheld(p) ); 
#if 0 
 if( mutexIsNT() && TryEnterCriticalSection(&p->mutex) ){ p->owner = GetCurrentThreadId(); p->nRef++; rc = SQLITE_OK; } 
#endif 
 return rc; } static void winMutexLeave(sqlite3_mutex *p){ assert( p->nRef>0 ); assert( p->owner==GetCurrentThreadId() ); p->nRef--; assert( p->nRef==0 || p->id==SQLITE_MUTEX_RECURSIVE ); LeaveCriticalSection(&p->mutex); } SQLITE_PRIVATE sqlite3_mutex_methods *sqlite3DefaultMutex(void){ static sqlite3_mutex_methods sMutex = { winMutexInit, winMutexEnd, winMutexAlloc, winMutexFree, winMutexEnter, winMutexTry, winMutexLeave, 
#ifdef SQLITE_DEBUG 
 winMutexHeld, winMutexNotheld 
#endif 
 }; return &sMutex; } 
#endif 
static void softHeapLimitEnforcer( void *NotUsed, sqlite3_int64 NotUsed2, int allocSize ){ UNUSED_PARAMETER2(NotUsed, NotUsed2); sqlite3_release_memory(allocSize); } SQLITE_API void sqlite3_soft_heap_limit(int n){ sqlite3_uint64 iLimit; int overage; if( n<0 ){ iLimit = 0; }else{ iLimit = n; } sqlite3_initialize(); if( iLimit>0 ){ sqlite3MemoryAlarm(softHeapLimitEnforcer, 0, iLimit); }else{ sqlite3MemoryAlarm(0, 0, 0); } overage = sqlite3_memory_used() - n; if( overage>0 ){ sqlite3_release_memory(overage); } } SQLITE_API int sqlite3_release_memory(int n){ 
#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT 
 int nRet = 0; 
#if 0 
 nRet += sqlite3VdbeReleaseMemory(n); 
#endif 
 nRet += sqlite3PcacheReleaseMemory(n-nRet); return nRet; 
#else 
 UNUSED_PARAMETER(n); return SQLITE_OK; 
#endif 
} static SQLITE_WSD struct Mem0Global { u32 nScratchFree; u32 nPageFree; sqlite3_mutex *mutex; sqlite3_int64 alarmThreshold; void (*alarmCallback)(void*, sqlite3_int64,int); void *alarmArg; int alarmBusy; u32 *aScratchFree; u32 *aPageFree; } mem0 = { 62560955, 0, 0, 0, 0, 0, 0, 0, 0 }; 
#define mem0 GLOBAL(struct Mem0Global, mem0) 
SQLITE_PRIVATE int sqlite3MallocInit(void){ if( sqlite3GlobalConfig.m.xMalloc==0 ){ sqlite3MemSetDefault(); } memset(&mem0, 0, sizeof(mem0)); if( sqlite3GlobalConfig.bCoreMutex ){ mem0.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MEM); } if( sqlite3GlobalConfig.pScratch && sqlite3GlobalConfig.szScratch>=100 && sqlite3GlobalConfig.nScratch>=0 ){ int i; sqlite3GlobalConfig.szScratch -= 4; mem0.aScratchFree = (u32*)&((char*)sqlite3GlobalConfig.pScratch) [sqlite3GlobalConfig.szScratch*sqlite3GlobalConfig.nScratch]; for(i=0; i<sqlite3GlobalConfig.nScratch; i++){ mem0.aScratchFree[i] = i; } mem0.nScratchFree = sqlite3GlobalConfig.nScratch; }else{ sqlite3GlobalConfig.pScratch = 0; sqlite3GlobalConfig.szScratch = 0; } if( sqlite3GlobalConfig.pPage && sqlite3GlobalConfig.szPage>=512 && sqlite3GlobalConfig.nPage>=1 ){ int i; int overhead; int sz = sqlite3GlobalConfig.szPage; int n = sqlite3GlobalConfig.nPage; overhead = (4*n + sz - 1)/sz; sqlite3GlobalConfig.nPage -= overhead; mem0.aPageFree = (u32*)&((char*)sqlite3GlobalConfig.pPage) [sqlite3GlobalConfig.szPage*sqlite3GlobalConfig.nPage]; for(i=0; i<sqlite3GlobalConfig.nPage; i++){ mem0.aPageFree[i] = i; } mem0.nPageFree = sqlite3GlobalConfig.nPage; }else{ sqlite3GlobalConfig.pPage = 0; sqlite3GlobalConfig.szPage = 0; } return sqlite3GlobalConfig.m.xInit(sqlite3GlobalConfig.m.pAppData); } SQLITE_PRIVATE void sqlite3MallocEnd(void){ sqlite3GlobalConfig.m.xShutdown(sqlite3GlobalConfig.m.pAppData); memset(&mem0, 0, sizeof(mem0)); } SQLITE_API sqlite3_int64 sqlite3_memory_used(void){ int n, mx; sqlite3_int64 res; sqlite3_status(SQLITE_STATUS_MEMORY_USED, &n, &mx, 0); res = (sqlite3_int64)n; return res; } SQLITE_API sqlite3_int64 sqlite3_memory_highwater(int resetFlag){ int n, mx; sqlite3_int64 res; sqlite3_status(SQLITE_STATUS_MEMORY_USED, &n, &mx, resetFlag); res = (sqlite3_int64)mx; return res; } SQLITE_PRIVATE int sqlite3MemoryAlarm( void(*xCallback)(void *pArg, sqlite3_int64 used,int N), void *pArg, sqlite3_int64 iThreshold ){ sqlite3_mutex_enter(mem0.mutex); mem0.alarmCallback = xCallback; mem0.alarmArg = pArg; mem0.alarmThreshold = iThreshold; sqlite3_mutex_leave(mem0.mutex); return SQLITE_OK; } 
#ifndef SQLITE_OMIT_DEPRECATED 
SQLITE_API int sqlite3_memory_alarm( void(*xCallback)(void *pArg, sqlite3_int64 used,int N), void *pArg, sqlite3_int64 iThreshold ){ return sqlite3MemoryAlarm(xCallback, pArg, iThreshold); } 
#endif 
static void sqlite3MallocAlarm(int nByte){ void (*xCallback)(void*,sqlite3_int64,int); sqlite3_int64 nowUsed; void *pArg; if( mem0.alarmCallback==0 || mem0.alarmBusy ) return; mem0.alarmBusy = 1; xCallback = mem0.alarmCallback; nowUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED); pArg = mem0.alarmArg; sqlite3_mutex_leave(mem0.mutex); xCallback(pArg, nowUsed, nByte); sqlite3_mutex_enter(mem0.mutex); mem0.alarmBusy = 0; } static int mallocWithAlarm(int n, void **pp){ int nFull; void *p; assert( sqlite3_mutex_held(mem0.mutex) ); nFull = sqlite3GlobalConfig.m.xRoundup(n); sqlite3StatusSet(SQLITE_STATUS_MALLOC_SIZE, n); if( mem0.alarmCallback!=0 ){ int nUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED); if( nUsed+nFull >= mem0.alarmThreshold ){ sqlite3MallocAlarm(nFull); } } p = sqlite3GlobalConfig.m.xMalloc(nFull); if( p==0 && mem0.alarmCallback ){ sqlite3MallocAlarm(nFull); p = sqlite3GlobalConfig.m.xMalloc(nFull); } if( p ){ nFull = sqlite3MallocSize(p); sqlite3StatusAdd(SQLITE_STATUS_MEMORY_USED, nFull); } *pp = p; return nFull; } SQLITE_PRIVATE void *sqlite3Malloc(int n){ void *p; if( n<=0 ){ p = 0; }else if( sqlite3GlobalConfig.bMemstat ){ sqlite3_mutex_enter(mem0.mutex); mallocWithAlarm(n, &p); sqlite3_mutex_leave(mem0.mutex); }else{ p = sqlite3GlobalConfig.m.xMalloc(n); } return p; } SQLITE_API void *sqlite3_malloc(int n){ 
#ifndef SQLITE_OMIT_AUTOINIT 
 if( sqlite3_initialize() ) return 0; 
#endif 
 return sqlite3Malloc(n); } 
#if SQLITE_THREADSAFE==0 && !defined(NDEBUG) 
static int scratchAllocOut = 0; 
#endif 
SQLITE_PRIVATE void *sqlite3ScratchMalloc(int n){ void *p; assert( n>0 ); 
#if SQLITE_THREADSAFE==0 && !defined(NDEBUG) 
 assert( scratchAllocOut==0 ); 
#endif 
 if( sqlite3GlobalConfig.szScratch<n ){ goto scratch_overflow; }else{ sqlite3_mutex_enter(mem0.mutex); if( mem0.nScratchFree==0 ){ sqlite3_mutex_leave(mem0.mutex); goto scratch_overflow; }else{ int i; i = mem0.aScratchFree[--mem0.nScratchFree]; i *= sqlite3GlobalConfig.szScratch; sqlite3StatusAdd(SQLITE_STATUS_SCRATCH_USED, 1); sqlite3StatusSet(SQLITE_STATUS_SCRATCH_SIZE, n); sqlite3_mutex_leave(mem0.mutex); p = (void*)&((char*)sqlite3GlobalConfig.pScratch)[i]; } } 
#if SQLITE_THREADSAFE==0 && !defined(NDEBUG) 
 scratchAllocOut = p!=0; 
#endif 
 return p; scratch_overflow: if( sqlite3GlobalConfig.bMemstat ){ sqlite3_mutex_enter(mem0.mutex); sqlite3StatusSet(SQLITE_STATUS_SCRATCH_SIZE, n); n = mallocWithAlarm(n, &p); if( p ) sqlite3StatusAdd(SQLITE_STATUS_SCRATCH_OVERFLOW, n); sqlite3_mutex_leave(mem0.mutex); }else{ p = sqlite3GlobalConfig.m.xMalloc(n); } 
#if SQLITE_THREADSAFE==0 && !defined(NDEBUG) 
 scratchAllocOut = p!=0; 
#endif 
 return p; } SQLITE_PRIVATE void sqlite3ScratchFree(void *p){ if( p ){ 
#if SQLITE_THREADSAFE==0 && !defined(NDEBUG) 
 assert( scratchAllocOut==1 ); scratchAllocOut = 0; 
#endif 
 if( sqlite3GlobalConfig.pScratch==0 || p<sqlite3GlobalConfig.pScratch || p>=(void*)mem0.aScratchFree ){ if( sqlite3GlobalConfig.bMemstat ){ int iSize = sqlite3MallocSize(p); sqlite3_mutex_enter(mem0.mutex); sqlite3StatusAdd(SQLITE_STATUS_SCRATCH_OVERFLOW, -iSize); sqlite3StatusAdd(SQLITE_STATUS_MEMORY_USED, -iSize); sqlite3GlobalConfig.m.xFree(p); sqlite3_mutex_leave(mem0.mutex); }else{ sqlite3GlobalConfig.m.xFree(p); } }else{ int i; i = (u8 *)p - (u8 *)sqlite3GlobalConfig.pScratch; i /= sqlite3GlobalConfig.szScratch; assert( i>=0 && i<sqlite3GlobalConfig.nScratch ); sqlite3_mutex_enter(mem0.mutex); assert( mem0.nScratchFree<(u32)sqlite3GlobalConfig.nScratch ); mem0.aScratchFree[mem0.nScratchFree++] = i; sqlite3StatusAdd(SQLITE_STATUS_SCRATCH_USED, -1); sqlite3_mutex_leave(mem0.mutex); } } } 
#if 0 
SQLITE_PRIVATE void *sqlite3PageMalloc(int n){ void *p; assert( n>0 ); assert( (n & (n-1))==0 ); assert( n>=512 && n<=32768 ); if( sqlite3GlobalConfig.szPage<n ){ goto page_overflow; }else{ sqlite3_mutex_enter(mem0.mutex); if( mem0.nPageFree==0 ){ sqlite3_mutex_leave(mem0.mutex); goto page_overflow; }else{ int i; i = mem0.aPageFree[--mem0.nPageFree]; sqlite3_mutex_leave(mem0.mutex); i *= sqlite3GlobalConfig.szPage; sqlite3StatusSet(SQLITE_STATUS_PAGECACHE_SIZE, n); sqlite3StatusAdd(SQLITE_STATUS_PAGECACHE_USED, 1); p = (void*)&((char*)sqlite3GlobalConfig.pPage)[i]; } } return p; page_overflow: if( sqlite3GlobalConfig.bMemstat ){ sqlite3_mutex_enter(mem0.mutex); sqlite3StatusSet(SQLITE_STATUS_PAGECACHE_SIZE, n); n = mallocWithAlarm(n, &p); if( p ) sqlite3StatusAdd(SQLITE_STATUS_PAGECACHE_OVERFLOW, n); sqlite3_mutex_leave(mem0.mutex); }else{ p = sqlite3GlobalConfig.m.xMalloc(n); } return p; } SQLITE_PRIVATE void sqlite3PageFree(void *p){ if( p ){ if( sqlite3GlobalConfig.pPage==0 || p<sqlite3GlobalConfig.pPage || p>=(void*)mem0.aPageFree ){ if( sqlite3GlobalConfig.bMemstat ){ int iSize = sqlite3MallocSize(p); sqlite3_mutex_enter(mem0.mutex); sqlite3StatusAdd(SQLITE_STATUS_PAGECACHE_OVERFLOW, -iSize); sqlite3StatusAdd(SQLITE_STATUS_MEMORY_USED, -iSize); sqlite3GlobalConfig.m.xFree(p); sqlite3_mutex_leave(mem0.mutex); }else{ sqlite3GlobalConfig.m.xFree(p); } }else{ int i; i = (u8 *)p - (u8 *)sqlite3GlobalConfig.pPage; i /= sqlite3GlobalConfig.szPage; assert( i>=0 && i<sqlite3GlobalConfig.nPage ); sqlite3_mutex_enter(mem0.mutex); assert( mem0.nPageFree<sqlite3GlobalConfig.nPage ); mem0.aPageFree[mem0.nPageFree++] = i; sqlite3StatusAdd(SQLITE_STATUS_PAGECACHE_USED, -1); sqlite3_mutex_leave(mem0.mutex); 
#if !defined(NDEBUG) && 0 
 for(i=0; i<mem0.nPageFree-1; i++){ assert( mem0.aPageFree[i]!=mem0.aPageFree[mem0.nPageFree-1] ); } 
#endif 
 } } } 
#endif 
#ifndef SQLITE_OMIT_LOOKASIDE 
static int isLookaside(sqlite3 *db, void *p){ return db && p && p>=db->lookaside.pStart && p<db->lookaside.pEnd; } 
#else 
#define isLookaside(A,B) 0 
#endif 
SQLITE_PRIVATE int sqlite3MallocSize(void *p){ return sqlite3GlobalConfig.m.xSize(p); } SQLITE_PRIVATE int sqlite3DbMallocSize(sqlite3 *db, void *p){ if( isLookaside(db, p) ){ return db->lookaside.sz; }else{ return sqlite3GlobalConfig.m.xSize(p); } } SQLITE_API void sqlite3_free(void *p){ if( p==0 ) return; if( sqlite3GlobalConfig.bMemstat ){ sqlite3_mutex_enter(mem0.mutex); sqlite3StatusAdd(SQLITE_STATUS_MEMORY_USED, -sqlite3MallocSize(p)); sqlite3GlobalConfig.m.xFree(p); sqlite3_mutex_leave(mem0.mutex); }else{ sqlite3GlobalConfig.m.xFree(p); } } SQLITE_PRIVATE void sqlite3DbFree(sqlite3 *db, void *p){ if( isLookaside(db, p) ){ LookasideSlot *pBuf = (LookasideSlot*)p; pBuf->pNext = db->lookaside.pFree; db->lookaside.pFree = pBuf; db->lookaside.nOut--; }else{ sqlite3_free(p); } } SQLITE_PRIVATE void *sqlite3Realloc(void *pOld, int nBytes){ int nOld, nNew; void *pNew; if( pOld==0 ){ return sqlite3Malloc(nBytes); } if( nBytes<=0 ){ sqlite3_free(pOld); return 0; } nOld = sqlite3MallocSize(pOld); if( sqlite3GlobalConfig.bMemstat ){ sqlite3_mutex_enter(mem0.mutex); sqlite3StatusSet(SQLITE_STATUS_MALLOC_SIZE, nBytes); nNew = sqlite3GlobalConfig.m.xRoundup(nBytes); if( nOld==nNew ){ pNew = pOld; }else{ if( sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED)+nNew-nOld >= mem0.alarmThreshold ){ sqlite3MallocAlarm(nNew-nOld); } pNew = sqlite3GlobalConfig.m.xRealloc(pOld, nNew); if( pNew==0 && mem0.alarmCallback ){ sqlite3MallocAlarm(nBytes); pNew = sqlite3GlobalConfig.m.xRealloc(pOld, nNew); } if( pNew ){ nNew = sqlite3MallocSize(pNew); sqlite3StatusAdd(SQLITE_STATUS_MEMORY_USED, nNew-nOld); } } sqlite3_mutex_leave(mem0.mutex); }else{ pNew = sqlite3GlobalConfig.m.xRealloc(pOld, nBytes); } return pNew; } SQLITE_API void *sqlite3_realloc(void *pOld, int n){ 
#ifndef SQLITE_OMIT_AUTOINIT 
 if( sqlite3_initialize() ) return 0; 
#endif 
 return sqlite3Realloc(pOld, n); } SQLITE_PRIVATE void *sqlite3MallocZero(int n){ void *p = sqlite3Malloc(n); if( p ){ memset(p, 0, n); } return p; } SQLITE_PRIVATE void *sqlite3DbMallocZero(sqlite3 *db, int n){ void *p = sqlite3DbMallocRaw(db, n); if( p ){ memset(p, 0, n); } return p; } SQLITE_PRIVATE void *sqlite3DbMallocRaw(sqlite3 *db, int n){ void *p; 
#ifndef SQLITE_OMIT_LOOKASIDE 
 if( db ){ LookasideSlot *pBuf; if( db->mallocFailed ){ return 0; } if( db->lookaside.bEnabled && n<=db->lookaside.sz && (pBuf = db->lookaside.pFree)!=0 ){ db->lookaside.pFree = pBuf->pNext; db->lookaside.nOut++; if( db->lookaside.nOut>db->lookaside.mxOut ){ db->lookaside.mxOut = db->lookaside.nOut; } return (void*)pBuf; } } 
#else 
 if( db && db->mallocFailed ){ return 0; } 
#endif 
 p = sqlite3Malloc(n); if( !p && db ){ db->mallocFailed = 1; } return p; } SQLITE_PRIVATE void *sqlite3DbRealloc(sqlite3 *db, void *p, int n){ void *pNew = 0; if( db->mallocFailed==0 ){ if( p==0 ){ return sqlite3DbMallocRaw(db, n); } if( isLookaside(db, p) ){ if( n<=db->lookaside.sz ){ return p; } pNew = sqlite3DbMallocRaw(db, n); if( pNew ){ memcpy(pNew, p, db->lookaside.sz); sqlite3DbFree(db, p); } }else{ pNew = sqlite3_realloc(p, n); if( !pNew ){ db->mallocFailed = 1; } } } return pNew; } SQLITE_PRIVATE void *sqlite3DbReallocOrFree(sqlite3 *db, void *p, int n){ void *pNew; pNew = sqlite3DbRealloc(db, p, n); if( !pNew ){ sqlite3DbFree(db, p); } return pNew; } SQLITE_PRIVATE char *sqlite3DbStrDup(sqlite3 *db, const char *z){ char *zNew; size_t n; if( z==0 ){ return 0; } n = strlen(z)+1; assert( (n&0x7fffffff)==n ); zNew = sqlite3DbMallocRaw(db, (int)n); if( zNew ){ memcpy(zNew, z, n); } return zNew; } SQLITE_PRIVATE char *sqlite3DbStrNDup(sqlite3 *db, const char *z, int n){ char *zNew; if( z==0 ){ return 0; } assert( (n&0x7fffffff)==n ); zNew = sqlite3DbMallocRaw(db, n+1); if( zNew ){ memcpy(zNew, z, n); zNew[n] = 0; } return zNew; } SQLITE_PRIVATE void sqlite3SetString(char **pz, sqlite3 *db, const char *zFormat, ...){ va_list ap; char *z; va_start(ap, zFormat); z = sqlite3VMPrintf(db, zFormat, ap); va_end(ap); sqlite3DbFree(db, *pz); *pz = z; } SQLITE_PRIVATE int sqlite3ApiExit(sqlite3* db, int rc){ assert( !db || sqlite3_mutex_held(db->mutex) ); if( db && (db->mallocFailed || rc==SQLITE_IOERR_NOMEM) ){ sqlite3Error(db, SQLITE_NOMEM, 0); db->mallocFailed = 0; rc = SQLITE_NOMEM; } return rc & (db ? db->errMask : 0xff); } 
#define etRADIX 1 
#define etFLOAT 2 
#define etEXP 3 
#define etGENERIC 4 
#define etSIZE 5 
#define etSTRING 6 
#define etDYNSTRING 7 
#define etPERCENT 8 
#define etCHARX 9 
#define etSQLESCAPE 10 
#define etSQLESCAPE2 11 
#define etTOKEN 12 
#define etSRCLIST 13 
#define etPOINTER 14 
#define etSQLESCAPE3 15 
#define etORDINAL 16 
typedef unsigned char etByte; typedef struct et_info { char fmttype; etByte base; etByte flags; etByte type; etByte charset; etByte prefix; } et_info; 
#define FLAG_SIGNED 1 
#define FLAG_INTERN 2 
#define FLAG_STRING 4 
static const char aDigits[] = "0123456789ABCDEF0123456789abcdef"; static const char aPrefix[] = "-x0\000X0"; static const et_info fmtinfo[] = { { 'd', 10, 1, etRADIX, 0, 0 }, { 's', 0, 4, etSTRING, 0, 0 }, { 'g', 0, 1, etGENERIC, 30, 0 }, { 'z', 0, 4, etDYNSTRING, 0, 0 }, { 'q', 0, 4, etSQLESCAPE, 0, 0 }, { 'Q', 0, 4, etSQLESCAPE2, 0, 0 }, { 'w', 0, 4, etSQLESCAPE3, 0, 0 }, { 'c', 0, 0, etCHARX, 0, 0 }, { 'o', 8, 0, etRADIX, 0, 2 }, { 'u', 10, 0, etRADIX, 0, 0 }, { 'x', 16, 0, etRADIX, 16, 1 }, { 'X', 16, 0, etRADIX, 0, 4 }, 
#ifndef SQLITE_OMIT_FLOATING_POINT 
 { 'f', 0, 1, etFLOAT, 0, 0 }, { 'e', 0, 1, etEXP, 30, 0 }, { 'E', 0, 1, etEXP, 14, 0 }, { 'G', 0, 1, etGENERIC, 14, 0 }, 
#endif 
 { 'i', 10, 1, etRADIX, 0, 0 }, { 'n', 0, 0, etSIZE, 0, 0 }, { '%', 0, 0, etPERCENT, 0, 0 }, { 'p', 16, 0, etPOINTER, 0, 1 }, { 'T', 0, 2, etTOKEN, 0, 0 }, { 'S', 0, 2, etSRCLIST, 0, 0 }, { 'r', 10, 3, etORDINAL, 0, 0 }, }; 
#ifndef SQLITE_OMIT_FLOATING_POINT 
static int et_getdigit(LONGDOUBLE_TYPE *val, int *cnt){ int digit; LONGDOUBLE_TYPE d; if( (*cnt)++ >= 16 ) return '0'; digit = (int)*val; d = digit; digit += '0'; *val = (*val - d)*10.0; return digit; } 
#endif 
static void appendSpace(StrAccum *pAccum, int N){ static const char zSpaces[] = " "; while( N>=(int)sizeof(zSpaces)-1 ){ sqlite3StrAccumAppend(pAccum, zSpaces, sizeof(zSpaces)-1); N -= sizeof(zSpaces)-1; } if( N>0 ){ sqlite3StrAccumAppend(pAccum, zSpaces, N); } } 
#ifndef SQLITE_PRINT_BUF_SIZE 
#define SQLITE_PRINT_BUF_SIZE 350 
#endif 
#define etBUFSIZE SQLITE_PRINT_BUF_SIZE 
SQLITE_PRIVATE void sqlite3VXPrintf( StrAccum *pAccum, int useExtended, const char *fmt, va_list ap ){ int c; char *bufpt; int precision; int length; int idx; int width; etByte flag_leftjustify; etByte flag_plussign; etByte flag_blanksign; etByte flag_alternateform; etByte flag_altform2; etByte flag_zeropad; etByte flag_long; etByte flag_longlong; etByte done; sqlite_uint64 longvalue; LONGDOUBLE_TYPE realvalue; const et_info *infop; char buf[etBUFSIZE]; char prefix; etByte xtype; char *zExtra; 
#ifndef SQLITE_OMIT_FLOATING_POINT 
 int exp, e2; double rounder; etByte flag_dp; etByte flag_rtz; etByte flag_exp; int nsd; 
#endif 
 length = 0; bufpt = 0; for(; (c=(*fmt))!=0; ++fmt){ if( c!='%' ){ int amt; bufpt = (char *)fmt; amt = 1; while( (c=(*++fmt))!='%' && c!=0 ) amt++; sqlite3StrAccumAppend(pAccum, bufpt, amt); if( c==0 ) break; } if( (c=(*++fmt))==0 ){ sqlite3StrAccumAppend(pAccum, "%", 1); break; } flag_leftjustify = flag_plussign = flag_blanksign = flag_alternateform = flag_altform2 = flag_zeropad = 0; done = 0; do{ switch( c ){ case '-': flag_leftjustify = 1; break; case '+': flag_plussign = 1; break; case ' ': flag_blanksign = 1; break; case '#': flag_alternateform = 1; break; case '!': flag_altform2 = 1; break; case '0': flag_zeropad = 1; break; default: done = 1; break; } }while( !done && (c=(*++fmt))!=0 ); width = 0; if( c=='*' ){ width = va_arg(ap,int); if( width<0 ){ flag_leftjustify = 1; width = -width; } c = *++fmt; }else{ while( c>='0' && c<='9' ){ width = width*10 + c - '0'; c = *++fmt; } } if( width > etBUFSIZE-10 ){ width = etBUFSIZE-10; } if( c=='.' ){ precision = 0; c = *++fmt; if( c=='*' ){ precision = va_arg(ap,int); if( precision<0 ) precision = -precision; c = *++fmt; }else{ while( c>='0' && c<='9' ){ precision = precision*10 + c - '0'; c = *++fmt; } } }else{ precision = -1; } if( c=='l' ){ flag_long = 1; c = *++fmt; if( c=='l' ){ flag_longlong = 1; c = *++fmt; }else{ flag_longlong = 0; } }else{ flag_long = flag_longlong = 0; } infop = 0; for(idx=0; idx<ArraySize(fmtinfo); idx++){ if( c==fmtinfo[idx].fmttype ){ infop = &fmtinfo[idx]; if( useExtended || (infop->flags & FLAG_INTERN)==0 ){ xtype = infop->type; }else{ return; } break; } } zExtra = 0; if( infop==0 ){ return; } if( precision>etBUFSIZE-40 && (infop->flags & FLAG_STRING)==0 ){ precision = etBUFSIZE-40; } switch( xtype ){ case etPOINTER: flag_longlong = sizeof(char*)==sizeof(i64); flag_long = sizeof(char*)==sizeof(long int); case etORDINAL: case etRADIX: if( infop->flags & FLAG_SIGNED ){ i64 v; if( flag_longlong ) v = va_arg(ap,i64); else if( flag_long ) v = va_arg(ap,long int); else v = va_arg(ap,int); if( v<0 ){ longvalue = -v; prefix = '-'; }else{ longvalue = v; if( flag_plussign ) prefix = '+'; else if( flag_blanksign ) prefix = ' '; else prefix = 0; } }else{ if( flag_longlong ) longvalue = va_arg(ap,u64); else if( flag_long ) longvalue = va_arg(ap,unsigned long int); else longvalue = va_arg(ap,unsigned int); prefix = 0; } if( longvalue==0 ) flag_alternateform = 0; if( flag_zeropad && precision<width-(prefix!=0) ){ precision = width-(prefix!=0); } bufpt = &buf[etBUFSIZE-1]; if( xtype==etORDINAL ){ static const char zOrd[] = "thstndrd"; int x = longvalue % 10; if( x>=4 || (longvalue/10)%10==1 ){ x = 0; } buf[etBUFSIZE-3] = zOrd[x*2]; buf[etBUFSIZE-2] = zOrd[x*2+1]; bufpt -= 2; } { register const char *cset; register int base; cset = &aDigits[infop->charset]; base = infop->base; do{ *(--bufpt) = cset[longvalue%base]; longvalue = longvalue/base; }while( longvalue>0 ); } length = &buf[etBUFSIZE-1]-bufpt; for(idx=precision-length; idx>0; idx--){ *(--bufpt) = '0'; } if( prefix ) *(--bufpt) = prefix; if( flag_alternateform && infop->prefix ){ const char *pre; char x; pre = &aPrefix[infop->prefix]; for(; (x=(*pre))!=0; pre++) *(--bufpt) = x; } length = &buf[etBUFSIZE-1]-bufpt; break; case etFLOAT: case etEXP: case etGENERIC: realvalue = va_arg(ap,double); 
#ifndef SQLITE_OMIT_FLOATING_POINT 
 if( precision<0 ) precision = 6; if( precision>etBUFSIZE/2-10 ) precision = etBUFSIZE/2-10; if( realvalue<0.0 ){ realvalue = -realvalue; prefix = '-'; }else{ if( flag_plussign ) prefix = '+'; else if( flag_blanksign ) prefix = ' '; else prefix = 0; } if( xtype==etGENERIC && precision>0 ) precision--; 
#if 0 
 for(idx=precision, rounder=0.4999; idx>0; idx--, rounder*=0.1); 
#else 
 for(idx=precision, rounder=0.5; idx>0; idx--, rounder*=0.1){} 
#endif 
 if( xtype==etFLOAT ) realvalue += rounder; exp = 0; if( sqlite3IsNaN(realvalue) ){ bufpt = "NaN"; length = 3; break; } if( realvalue>0.0 ){ while( realvalue>=1e32 && exp<=350 ){ realvalue *= 1e-32; exp+=32; } while( realvalue>=1e8 && exp<=350 ){ realvalue *= 1e-8; exp+=8; } while( realvalue>=10.0 && exp<=350 ){ realvalue *= 0.1; exp++; } while( realvalue<1e-8 ){ realvalue *= 1e8; exp-=8; } while( realvalue<1.0 ){ realvalue *= 10.0; exp--; } if( exp>350 ){ if( prefix=='-' ){ bufpt = "-Inf"; }else if( prefix=='+' ){ bufpt = "+Inf"; }else{ bufpt = "Inf"; } length = strlen(bufpt); break; } } bufpt = buf; flag_exp = xtype==etEXP; if( xtype!=etFLOAT ){ realvalue += rounder; if( realvalue>=10.0 ){ realvalue *= 0.1; exp++; } } if( xtype==etGENERIC ){ flag_rtz = !flag_alternateform; if( exp<-4 || exp>precision ){ xtype = etEXP; }else{ precision = precision - exp; xtype = etFLOAT; } }else{ flag_rtz = 0; } if( xtype==etEXP ){ e2 = 0; }else{ e2 = exp; } nsd = 0; flag_dp = (precision>0) | flag_alternateform | flag_altform2; if( prefix ){ *(bufpt++) = prefix; } if( e2<0 ){ *(bufpt++) = '0'; }else{ for(; e2>=0; e2--){ *(bufpt++) = et_getdigit(&realvalue,&nsd); } } if( flag_dp ){ *(bufpt++) = '.'; } for(e2++; e2<0; precision--, e2++){ assert( precision>0 ); *(bufpt++) = '0'; } while( (precision--)>0 ){ *(bufpt++) = et_getdigit(&realvalue,&nsd); } if( flag_rtz && flag_dp ){ while( bufpt[-1]=='0' ) *(--bufpt) = 0; assert( bufpt>buf ); if( bufpt[-1]=='.' ){ if( flag_altform2 ){ *(bufpt++) = '0'; }else{ *(--bufpt) = 0; } } } if( flag_exp || xtype==etEXP ){ *(bufpt++) = aDigits[infop->charset]; if( exp<0 ){ *(bufpt++) = '-'; exp = -exp; }else{ *(bufpt++) = '+'; } if( exp>=100 ){ *(bufpt++) = (exp/100)+'0'; exp %= 100; } *(bufpt++) = exp/10+'0'; *(bufpt++) = exp%10+'0'; } *bufpt = 0; length = bufpt-buf; bufpt = buf; if( flag_zeropad && !flag_leftjustify && length < width){ int i; int nPad = width - length; for(i=width; i>=nPad; i--){ bufpt[i] = bufpt[i-nPad]; } i = prefix!=0; while( nPad-- ) bufpt[i++] = '0'; length = width; } 
#endif 
 break; case etSIZE: *(va_arg(ap,int*)) = pAccum->nChar; length = width = 0; break; case etPERCENT: buf[0] = '%'; bufpt = buf; length = 1; break; case etCHARX: c = buf[0] = va_arg(ap,int); if( precision>=0 ){ for(idx=1; idx<precision; idx++) buf[idx] = c; length = precision; }else{ length =1; } bufpt = buf; break; case etSTRING: case etDYNSTRING: bufpt = va_arg(ap,char*); if( bufpt==0 ){ bufpt = ""; }else if( xtype==etDYNSTRING ){ zExtra = bufpt; } if( precision>=0 ){ for(length=0; length<precision && bufpt[length]; length++){} }else{ length = strlen(bufpt); } break; case etSQLESCAPE: case etSQLESCAPE2: case etSQLESCAPE3: { int i, j, n, ch, isnull; int needQuote; char q = ((xtype==etSQLESCAPE3)?'"':'\''); char *escarg = va_arg(ap,char*); isnull = escarg==0; if( isnull ) escarg = (xtype==etSQLESCAPE2 ? "NULL" : "(NULL)"); for(i=n=0; (ch=escarg[i])!=0; i++){ if( ch==q ) n++; } needQuote = !isnull && xtype==etSQLESCAPE2; n += i + 1 + needQuote*2; if( n>etBUFSIZE ){ bufpt = zExtra = sqlite3Malloc( n ); if( bufpt==0 ){ pAccum->mallocFailed = 1; return; } }else{ bufpt = buf; } j = 0; if( needQuote ) bufpt[j++] = q; for(i=0; (ch=escarg[i])!=0; i++){ bufpt[j++] = ch; if( ch==q ) bufpt[j++] = ch; } if( needQuote ) bufpt[j++] = q; bufpt[j] = 0; length = j; break; } case etTOKEN: { Token *pToken = va_arg(ap, Token*); if( pToken ){ sqlite3StrAccumAppend(pAccum, (const char*)pToken->z, pToken->n); } length = width = 0; break; } case etSRCLIST: { SrcList *pSrc = va_arg(ap, SrcList*); int k = va_arg(ap, int); struct SrcList_item *pItem = &pSrc->a[k]; assert( k>=0 && k<pSrc->nSrc ); if( pItem->zDatabase ){ sqlite3StrAccumAppend(pAccum, pItem->zDatabase, -1); sqlite3StrAccumAppend(pAccum, ".", 1); } sqlite3StrAccumAppend(pAccum, pItem->zName, -1); length = width = 0; break; } } if( !flag_leftjustify ){ register int nspace; nspace = width-length; if( nspace>0 ){ appendSpace(pAccum, nspace); } } if( length>0 ){ sqlite3StrAccumAppend(pAccum, bufpt, length); } if( flag_leftjustify ){ register int nspace; nspace = width-length; if( nspace>0 ){ appendSpace(pAccum, nspace); } } if( zExtra ){ sqlite3_free(zExtra); } } } SQLITE_PRIVATE void sqlite3StrAccumAppend(StrAccum *p, const char *z, int N){ if( p->tooBig | p->mallocFailed ){ return; } if( N<0 ){ N = strlen(z); } if( N==0 ){ return; } if( p->nChar+N >= p->nAlloc ){ char *zNew; if( !p->useMalloc ){ p->tooBig = 1; N = p->nAlloc - p->nChar - 1; if( N<=0 ){ return; } }else{ i64 szNew = p->nChar; szNew += N + 1; if( szNew > p->mxAlloc ){ sqlite3StrAccumReset(p); p->tooBig = 1; return; }else{ p->nAlloc = szNew; } zNew = sqlite3DbMallocRaw(p->db, p->nAlloc ); if( zNew ){ memcpy(zNew, p->zText, p->nChar); sqlite3StrAccumReset(p); p->zText = zNew; }else{ p->mallocFailed = 1; sqlite3StrAccumReset(p); return; } } } memcpy(&p->zText[p->nChar], z, N); p->nChar += N; } SQLITE_PRIVATE char *sqlite3StrAccumFinish(StrAccum *p){ if( p->zText ){ p->zText[p->nChar] = 0; if( p->useMalloc && p->zText==p->zBase ){ p->zText = sqlite3DbMallocRaw(p->db, p->nChar+1 ); if( p->zText ){ memcpy(p->zText, p->zBase, p->nChar+1); }else{ p->mallocFailed = 1; } } } return p->zText; } SQLITE_PRIVATE void sqlite3StrAccumReset(StrAccum *p){ if( p->zText!=p->zBase ){ sqlite3DbFree(p->db, p->zText); } p->zText = 0; } SQLITE_PRIVATE void sqlite3StrAccumInit(StrAccum *p, char *zBase, int n, int mx){ p->zText = p->zBase = zBase; p->db = 0; p->nChar = 0; p->nAlloc = n; p->mxAlloc = mx; p->useMalloc = 1; p->tooBig = 0; p->mallocFailed = 0; } SQLITE_PRIVATE char *sqlite3VMPrintf(sqlite3 *db, const char *zFormat, va_list ap){ char *z; char zBase[SQLITE_PRINT_BUF_SIZE]; StrAccum acc; sqlite3StrAccumInit(&acc, zBase, sizeof(zBase), db ? db->aLimit[SQLITE_LIMIT_LENGTH] : SQLITE_MAX_LENGTH); acc.db = db; sqlite3VXPrintf(&acc, 1, zFormat, ap); z = sqlite3StrAccumFinish(&acc); if( acc.mallocFailed && db ){ db->mallocFailed = 1; } return z; } SQLITE_PRIVATE char *sqlite3MPrintf(sqlite3 *db, const char *zFormat, ...){ va_list ap; char *z; va_start(ap, zFormat); z = sqlite3VMPrintf(db, zFormat, ap); va_end(ap); return z; } SQLITE_PRIVATE char *sqlite3MAppendf(sqlite3 *db, char *zStr, const char *zFormat, ...){ va_list ap; char *z; va_start(ap, zFormat); z = sqlite3VMPrintf(db, zFormat, ap); va_end(ap); sqlite3DbFree(db, zStr); return z; } SQLITE_API char *sqlite3_vmprintf(const char *zFormat, va_list ap){ char *z; char zBase[SQLITE_PRINT_BUF_SIZE]; StrAccum acc; 
#ifndef SQLITE_OMIT_AUTOINIT 
 if( sqlite3_initialize() ) return 0; 
#endif 
 sqlite3StrAccumInit(&acc, zBase, sizeof(zBase), SQLITE_MAX_LENGTH); sqlite3VXPrintf(&acc, 0, zFormat, ap); z = sqlite3StrAccumFinish(&acc); return z; } SQLITE_API char *sqlite3_mprintf(const char *zFormat, ...){ va_list ap; char *z; 
#ifndef SQLITE_OMIT_AUTOINIT 
 if( sqlite3_initialize() ) return 0; 
#endif 
 va_start(ap, zFormat); z = sqlite3_vmprintf(zFormat, ap); va_end(ap); return z; } SQLITE_API char *sqlite3_snprintf(int n, char *zBuf, const char *zFormat, ...){ char *z; va_list ap; StrAccum acc; if( n<=0 ){ return zBuf; } sqlite3StrAccumInit(&acc, zBuf, n, 0); acc.useMalloc = 0; va_start(ap,zFormat); sqlite3VXPrintf(&acc, 0, zFormat, ap); va_end(ap); z = sqlite3StrAccumFinish(&acc); return z; } 
#if defined(SQLITE_DEBUG) 
SQLITE_PRIVATE void sqlite3DebugPrintf(const char *zFormat, ...){ va_list ap; StrAccum acc; char zBuf[500]; sqlite3StrAccumInit(&acc, zBuf, sizeof(zBuf), 0); acc.useMalloc = 0; va_start(ap,zFormat); sqlite3VXPrintf(&acc, 0, zFormat, ap); va_end(ap); sqlite3StrAccumFinish(&acc); fprintf(stdout,"%s", zBuf); fflush(stdout); } 
#endif 
static SQLITE_WSD struct sqlite3PrngType { unsigned char isInit; unsigned char i, j; unsigned char s[256]; } sqlite3Prng = { 0, }; static int randomByte(void){ unsigned char t; 
#ifdef SQLITE_OMIT_WSD 
 struct sqlite3PrngType *p = &GLOBAL(struct sqlite3PrngType, sqlite3Prng); 
#define wsdPrng p[0] 
#else 
#define wsdPrng sqlite3Prng 
#endif 
 if( !wsdPrng.isInit ){ int i; char k[256]; wsdPrng.j = 0; wsdPrng.i = 0; sqlite3OsRandomness(sqlite3_vfs_find(0), 256, k); for(i=0; i<256; i++){ wsdPrng.s[i] = i; } for(i=0; i<256; i++){ wsdPrng.j += wsdPrng.s[i] + k[i]; t = wsdPrng.s[wsdPrng.j]; wsdPrng.s[wsdPrng.j] = wsdPrng.s[i]; wsdPrng.s[i] = t; } wsdPrng.isInit = 1; } wsdPrng.i++; t = wsdPrng.s[wsdPrng.i]; wsdPrng.j += t; wsdPrng.s[wsdPrng.i] = wsdPrng.s[wsdPrng.j]; wsdPrng.s[wsdPrng.j] = t; t += wsdPrng.s[wsdPrng.i]; return wsdPrng.s[t]; } SQLITE_API void sqlite3_randomness(int N, void *pBuf){ unsigned char *zBuf = pBuf; 
#if SQLITE_THREADSAFE 
 sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_PRNG); 
#endif 
 sqlite3_mutex_enter(mutex); while( N-- ){ *(zBuf++) = randomByte(); } sqlite3_mutex_leave(mutex); } 
#ifndef SQLITE_OMIT_BUILTIN_TEST 
static SQLITE_WSD struct sqlite3PrngType sqlite3SavedPrng = { 0, }; SQLITE_PRIVATE void sqlite3PrngSaveState(void){ memcpy( &GLOBAL(struct sqlite3PrngType, sqlite3SavedPrng), &GLOBAL(struct sqlite3PrngType, sqlite3Prng), sizeof(sqlite3Prng) ); } SQLITE_PRIVATE void sqlite3PrngRestoreState(void){ memcpy( &GLOBAL(struct sqlite3PrngType, sqlite3Prng), &GLOBAL(struct sqlite3PrngType, sqlite3SavedPrng), sizeof(sqlite3Prng) ); } SQLITE_PRIVATE void sqlite3PrngResetState(void){ GLOBAL(struct sqlite3PrngType, sqlite3Prng).isInit = 0; } 
#endif 
#ifndef _VDBEINT_H_ 
#define _VDBEINT_H_ 
#define keyToInt(X) (X) 
#define intToKey(X) (X) 
typedef struct VdbeOp Op; typedef unsigned char Bool; struct VdbeCursor { BtCursor *pCursor; int iDb; i64 lastRowid; i64 nextRowid; Bool zeroed; Bool rowidIsValid; Bool atFirst; Bool useRandomRowid; Bool nullRow; Bool nextRowidValid; Bool pseudoTable; Bool ephemPseudoTable; Bool deferredMoveto; Bool isTable; Bool isIndex; i64 movetoTarget; Btree *pBt; int nData; char *pData; i64 iKey; KeyInfo *pKeyInfo; int nField; i64 seqCount; sqlite3_vtab_cursor *pVtabCursor; const sqlite3_module *pModule; int cacheStatus; int payloadSize; u32 *aType; u32 *aOffset; u8 *aRow; }; typedef struct VdbeCursor VdbeCursor; 
#define CACHE_STALE 0 
struct Mem { union { i64 i; FuncDef *pDef; } u; double r; sqlite3 *db; char *z; int n; u16 flags; u8 type; u8 enc; void (*xDel)(void *); char *zMalloc; }; 
#define MEM_Null 0x0001 
#define MEM_Str 0x0002 
#define MEM_Int 0x0004 
#define MEM_Real 0x0008 
#define MEM_Blob 0x0010 
#define MemSetTypeFlag(p, f) ((p)->flags = ((p)->flags&~(MEM_Int|MEM_Real|MEM_Null|MEM_Blob|MEM_Str))|f) 
#define MEM_Term 0x0020 
#define MEM_Dyn 0x0040 
#define MEM_Static 0x0080 
#define MEM_Ephem 0x0100 
#define MEM_Agg 0x0400 
#define MEM_Zero 0x0800 
#ifdef SQLITE_OMIT_INCRBLOB 
#undef MEM_Zero 
#define MEM_Zero 0x0000 
#endif 
struct VdbeFunc { FuncDef *pFunc; int nAux; struct AuxData { void *pAux; void (*xDelete)(void *); } apAux[1]; }; struct sqlite3_context { FuncDef *pFunc; VdbeFunc *pVdbeFunc; Mem s; Mem *pMem; int isError; CollSeq *pColl; }; typedef struct Set Set; struct Set { Hash hash; HashElem *prev; }; typedef struct FifoPage FifoPage; struct FifoPage { int nSlot; int iWrite; int iRead; FifoPage *pNext; i64 aSlot[1]; }; typedef struct Fifo Fifo; struct Fifo { int nEntry; sqlite3 *db; FifoPage *pFirst; FifoPage *pLast; }; typedef struct Context Context; struct Context { i64 lastRowid; int nChange; Fifo sFifo; }; struct Vdbe { sqlite3 *db; Vdbe *pPrev,*pNext; int nOp; int nOpAlloc; Op *aOp; int nLabel; int nLabelAlloc; int *aLabel; Mem **apArg; Mem *aColName; int nCursor; VdbeCursor **apCsr; int nVar; Mem *aVar; char **azVar; int okVar; u32 magic; int nMem; Mem *aMem; int nCallback; int cacheCtr; Fifo sFifo; int contextStackTop; int contextStackDepth; Context *contextStack; int pc; int rc; unsigned uniqueCnt; int errorAction; int inTempTrans; int nResColumn; char **azResColumn; char *zErrMsg; Mem *pResultSet; u8 explain; u8 changeCntOn; u8 expired; u8 minWriteFileFormat; u8 inVtabMethod; u8 usesStmtJournal; u8 readOnly; int nChange; i64 startTime; int btreeMask; BtreeMutexArray aMutex; int aCounter[2]; int nSql; char *zSql; 
#ifdef SQLITE_DEBUG 
 FILE *trace; 
#endif 
 int openedStatement; 
#ifdef SQLITE_SSE 
 int fetchId; int lru; 
#endif 
#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT 
 Vdbe *pLruPrev; Vdbe *pLruNext; 
#endif 
}; 
#define VDBE_MAGIC_INIT 0x26bceaa5 
#define VDBE_MAGIC_RUN 0xbdf20da3 
#define VDBE_MAGIC_HALT 0x519c2973 
#define VDBE_MAGIC_DEAD 0xb606c3c8 
SQLITE_PRIVATE void sqlite3VdbeFreeCursor(Vdbe *, VdbeCursor*); void sqliteVdbePopStack(Vdbe*,int); SQLITE_PRIVATE int sqlite3VdbeCursorMoveto(VdbeCursor*); 
#if defined(SQLITE_DEBUG) || defined(VDBE_PROFILE) 
SQLITE_PRIVATE void sqlite3VdbePrintOp(FILE*, int, Op*); 
#endif 
SQLITE_PRIVATE int sqlite3VdbeSerialTypeLen(u32); SQLITE_PRIVATE u32 sqlite3VdbeSerialType(Mem*, int); SQLITE_PRIVATE int sqlite3VdbeSerialPut(unsigned char*, int, Mem*, int); SQLITE_PRIVATE int sqlite3VdbeSerialGet(const unsigned char*, u32, Mem*); SQLITE_PRIVATE void sqlite3VdbeDeleteAuxData(VdbeFunc*, int); int sqlite2BtreeKeyCompare(BtCursor *, const void *, int, int, int *); SQLITE_PRIVATE int sqlite3VdbeIdxKeyCompare(VdbeCursor*,UnpackedRecord*,int*); SQLITE_PRIVATE int sqlite3VdbeIdxRowid(BtCursor *, i64 *); SQLITE_PRIVATE int sqlite3MemCompare(const Mem*, const Mem*, const CollSeq*); SQLITE_PRIVATE int sqlite3VdbeExec(Vdbe*); SQLITE_PRIVATE int sqlite3VdbeList(Vdbe*); SQLITE_PRIVATE int sqlite3VdbeHalt(Vdbe*); SQLITE_PRIVATE int sqlite3VdbeChangeEncoding(Mem *, int); SQLITE_PRIVATE int sqlite3VdbeMemTooBig(Mem*); SQLITE_PRIVATE int sqlite3VdbeMemCopy(Mem*, const Mem*); SQLITE_PRIVATE void sqlite3VdbeMemShallowCopy(Mem*, const Mem*, int); SQLITE_PRIVATE void sqlite3VdbeMemMove(Mem*, Mem*); SQLITE_PRIVATE int sqlite3VdbeMemNulTerminate(Mem*); SQLITE_PRIVATE int sqlite3VdbeMemSetStr(Mem*, const char*, int, u8, void(*)(void*)); SQLITE_PRIVATE void sqlite3VdbeMemSetInt64(Mem*, i64); SQLITE_PRIVATE void sqlite3VdbeMemSetDouble(Mem*, double); SQLITE_PRIVATE void sqlite3VdbeMemSetNull(Mem*); SQLITE_PRIVATE void sqlite3VdbeMemSetZeroBlob(Mem*,int); SQLITE_PRIVATE int sqlite3VdbeMemMakeWriteable(Mem*); SQLITE_PRIVATE int sqlite3VdbeMemStringify(Mem*, int); SQLITE_PRIVATE i64 sqlite3VdbeIntValue(Mem*); SQLITE_PRIVATE int sqlite3VdbeMemIntegerify(Mem*); SQLITE_PRIVATE double sqlite3VdbeRealValue(Mem*); SQLITE_PRIVATE void sqlite3VdbeIntegerAffinity(Mem*); SQLITE_PRIVATE int sqlite3VdbeMemRealify(Mem*); SQLITE_PRIVATE int sqlite3VdbeMemNumerify(Mem*); SQLITE_PRIVATE int sqlite3VdbeMemFromBtree(BtCursor*,int,int,int,Mem*); SQLITE_PRIVATE void sqlite3VdbeMemRelease(Mem *p); SQLITE_PRIVATE void sqlite3VdbeMemReleaseExternal(Mem *p); SQLITE_PRIVATE int sqlite3VdbeMemFinalize(Mem*, FuncDef*); SQLITE_PRIVATE const char *sqlite3OpcodeName(int); SQLITE_PRIVATE int sqlite3VdbeOpcodeHasProperty(int, int); SQLITE_PRIVATE int sqlite3VdbeMemGrow(Mem *pMem, int n, int preserve); 
#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT 
SQLITE_PRIVATE int sqlite3VdbeReleaseBuffers(Vdbe *p); 
#endif 
#ifndef NDEBUG 
SQLITE_PRIVATE void sqlite3VdbeMemSanity(Mem*); 
#endif 
SQLITE_PRIVATE int sqlite3VdbeMemTranslate(Mem*, u8); 
#ifdef SQLITE_DEBUG 
SQLITE_PRIVATE void sqlite3VdbePrintSql(Vdbe*); SQLITE_PRIVATE void sqlite3VdbeMemPrettyPrint(Mem *pMem, char *zBuf); 
#endif 
SQLITE_PRIVATE int sqlite3VdbeMemHandleBom(Mem *pMem); SQLITE_PRIVATE void sqlite3VdbeFifoInit(Fifo*, sqlite3*); SQLITE_PRIVATE int sqlite3VdbeFifoPush(Fifo*, i64); SQLITE_PRIVATE int sqlite3VdbeFifoPop(Fifo*, i64*); SQLITE_PRIVATE void sqlite3VdbeFifoClear(Fifo*); 
#ifndef SQLITE_OMIT_INCRBLOB 
SQLITE_PRIVATE int sqlite3VdbeMemExpandBlob(Mem *); 
#else 
#define sqlite3VdbeMemExpandBlob(x) SQLITE_OK 
#endif 
#endif 
SQLITE_PRIVATE const int sqlite3one = 1; static const unsigned char sqlite3UtfTrans1[] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x00, 0x00, }; 
#define WRITE_UTF8(zOut, c) { if( c<0x00080 ){ *zOut++ = (c&0xFF); } else if( c<0x00800 ){ *zOut++ = 0xC0 + ((c>>6)&0x1F); *zOut++ = 0x80 + (c & 0x3F); } else if( c<0x10000 ){ *zOut++ = 0xE0 + ((c>>12)&0x0F); *zOut++ = 0x80 + ((c>>6) & 0x3F); *zOut++ = 0x80 + (c & 0x3F); }else{ *zOut++ = 0xF0 + ((c>>18) & 0x07); *zOut++ = 0x80 + ((c>>12) & 0x3F); *zOut++ = 0x80 + ((c>>6) & 0x3F); *zOut++ = 0x80 + (c & 0x3F); } } 
#define WRITE_UTF16LE(zOut, c) { if( c<=0xFFFF ){ *zOut++ = (c&0x00FF); *zOut++ = ((c>>8)&0x00FF); }else{ *zOut++ = (((c>>10)&0x003F) + (((c-0x10000)>>10)&0x00C0)); *zOut++ = (0x00D8 + (((c-0x10000)>>18)&0x03)); *zOut++ = (c&0x00FF); *zOut++ = (0x00DC + ((c>>8)&0x03)); } } 
#define WRITE_UTF16BE(zOut, c) { if( c<=0xFFFF ){ *zOut++ = ((c>>8)&0x00FF); *zOut++ = (c&0x00FF); }else{ *zOut++ = (0x00D8 + (((c-0x10000)>>18)&0x03)); *zOut++ = (((c>>10)&0x003F) + (((c-0x10000)>>10)&0x00C0)); *zOut++ = (0x00DC + ((c>>8)&0x03)); *zOut++ = (c&0x00FF); } } 
#define READ_UTF16LE(zIn, c){ c = (*zIn++); c += ((*zIn++)<<8); if( c>=0xD800 && c<0xE000 ){ int c2 = (*zIn++); c2 += ((*zIn++)<<8); c = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10); if( (c & 0xFFFF0000)==0 ) c = 0xFFFD; } } 
#define READ_UTF16BE(zIn, c){ c = ((*zIn++)<<8); c += (*zIn++); if( c>=0xD800 && c<0xE000 ){ int c2 = ((*zIn++)<<8); c2 += (*zIn++); c = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10); if( (c & 0xFFFF0000)==0 ) c = 0xFFFD; } } 
#define READ_UTF8(zIn, zTerm, c) c = *(zIn++); if( c>=0xc0 ){ c = sqlite3UtfTrans1[c-0xc0]; while( zIn!=zTerm && (*zIn & 0xc0)==0x80 ){ c = (c<<6) + (0x3f & *(zIn++)); } if( c<0x80 || (c&0xFFFFF800)==0xD800 || (c&0xFFFFFFFE)==0xFFFE ){ c = 0xFFFD; } } 
SQLITE_PRIVATE int sqlite3Utf8Read( const unsigned char *z, const unsigned char *zTerm, const unsigned char **pzNext ){ int c; READ_UTF8(z, zTerm, c); *pzNext = z; return c; } 
#ifndef SQLITE_OMIT_UTF16 
SQLITE_PRIVATE int sqlite3VdbeMemTranslate(Mem *pMem, u8 desiredEnc){ int len; unsigned char *zOut; unsigned char *zIn; unsigned char *zTerm; unsigned char *z; unsigned int c; assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) ); assert( pMem->flags&MEM_Str ); assert( pMem->enc!=desiredEnc ); assert( pMem->enc!=0 ); assert( pMem->n>=0 ); 
#if defined(TRANSLATE_TRACE) && defined(SQLITE_DEBUG) 
 { char zBuf[100]; sqlite3VdbeMemPrettyPrint(pMem, zBuf); fprintf(stderr, "INPUT: %s\n", zBuf); } 
#endif 
 if( pMem->enc!=SQLITE_UTF8 && desiredEnc!=SQLITE_UTF8 ){ u8 temp; int rc; rc = sqlite3VdbeMemMakeWriteable(pMem); if( rc!=SQLITE_OK ){ assert( rc==SQLITE_NOMEM ); return SQLITE_NOMEM; } zIn = (u8*)pMem->z; zTerm = &zIn[pMem->n&~1]; while( zIn<zTerm ){ temp = *zIn; *zIn = *(zIn+1); zIn++; *zIn++ = temp; } pMem->enc = desiredEnc; goto translate_out; } if( desiredEnc==SQLITE_UTF8 ){ pMem->n &= ~1; len = pMem->n * 2 + 1; }else{ len = pMem->n * 2 + 2; } zIn = (u8*)pMem->z; zTerm = &zIn[pMem->n]; zOut = sqlite3DbMallocRaw(pMem->db, len); if( !zOut ){ return SQLITE_NOMEM; } z = zOut; if( pMem->enc==SQLITE_UTF8 ){ if( desiredEnc==SQLITE_UTF16LE ){ while( zIn<zTerm ){ READ_UTF8(zIn, zTerm, c); WRITE_UTF16LE(z, c); } }else{ assert( desiredEnc==SQLITE_UTF16BE ); while( zIn<zTerm ){ READ_UTF8(zIn, zTerm, c); WRITE_UTF16BE(z, c); } } pMem->n = z - zOut; *z++ = 0; }else{ assert( desiredEnc==SQLITE_UTF8 ); if( pMem->enc==SQLITE_UTF16LE ){ while( zIn<zTerm ){ READ_UTF16LE(zIn, c); WRITE_UTF8(z, c); } }else{ while( zIn<zTerm ){ READ_UTF16BE(zIn, c); WRITE_UTF8(z, c); } } pMem->n = z - zOut; } *z = 0; assert( (pMem->n+(desiredEnc==SQLITE_UTF8?1:2))<=len ); sqlite3VdbeMemRelease(pMem); pMem->flags &= ~(MEM_Static|MEM_Dyn|MEM_Ephem); pMem->enc = desiredEnc; pMem->flags |= (MEM_Term|MEM_Dyn); pMem->z = (char*)zOut; pMem->zMalloc = pMem->z; translate_out: 
#if defined(TRANSLATE_TRACE) && defined(SQLITE_DEBUG) 
 { char zBuf[100]; sqlite3VdbeMemPrettyPrint(pMem, zBuf); fprintf(stderr, "OUTPUT: %s\n", zBuf); } 
#endif 
 return SQLITE_OK; } SQLITE_PRIVATE int sqlite3VdbeMemHandleBom(Mem *pMem){ int rc = SQLITE_OK; u8 bom = 0; if( pMem->n<0 || pMem->n>1 ){ u8 b1 = *(u8 *)pMem->z; u8 b2 = *(((u8 *)pMem->z) + 1); if( b1==0xFE && b2==0xFF ){ bom = SQLITE_UTF16BE; } if( b1==0xFF && b2==0xFE ){ bom = SQLITE_UTF16LE; } } if( bom ){ rc = sqlite3VdbeMemMakeWriteable(pMem); if( rc==SQLITE_OK ){ pMem->n -= 2; memmove(pMem->z, &pMem->z[2], pMem->n); pMem->z[pMem->n] = '\0'; pMem->z[pMem->n+1] = '\0'; pMem->flags |= MEM_Term; pMem->enc = bom; } } return rc; } 
#endif 
SQLITE_PRIVATE int sqlite3Utf8CharLen(const char *zIn, int nByte){ int r = 0; const u8 *z = (const u8*)zIn; const u8 *zTerm; if( nByte>=0 ){ zTerm = &z[nByte]; }else{ zTerm = (const u8*)(-1); } assert( z<=zTerm ); while( *z!=0 && z<zTerm ){ SQLITE_SKIP_UTF8(z); r++; } return r; } 
#if defined(SQLITE_TEST) && defined(SQLITE_DEBUG) 
SQLITE_PRIVATE int sqlite3Utf8To8(unsigned char *zIn){ unsigned char *zOut = zIn; unsigned char *zStart = zIn; unsigned char *zTerm = &zIn[strlen((char *)zIn)]; u32 c; while( zIn[0] ){ c = sqlite3Utf8Read(zIn, zTerm, (const u8**)&zIn); if( c!=0xfffd ){ WRITE_UTF8(zOut, c); } } *zOut = 0; return zOut - zStart; } 
#endif 
#ifndef SQLITE_OMIT_UTF16 
SQLITE_PRIVATE char *sqlite3Utf16to8(sqlite3 *db, const void *z, int nByte){ Mem m; memset(&m, 0, sizeof(m)); m.db = db; sqlite3VdbeMemSetStr(&m, z, nByte, SQLITE_UTF16NATIVE, SQLITE_STATIC); sqlite3VdbeChangeEncoding(&m, SQLITE_UTF8); if( db->mallocFailed ){ sqlite3VdbeMemRelease(&m); m.z = 0; } assert( (m.flags & MEM_Term)!=0 || db->mallocFailed ); assert( (m.flags & MEM_Str)!=0 || db->mallocFailed ); return (m.flags & MEM_Dyn)!=0 ? m.z : sqlite3DbStrDup(db, m.z); } SQLITE_PRIVATE int sqlite3Utf16ByteLen(const void *zIn, int nChar){ unsigned int c = 1; char const *z = zIn; int n = 0; if( SQLITE_UTF16NATIVE==SQLITE_UTF16BE ){ while( c && ((nChar<0) || n<nChar) ){ READ_UTF16BE(z, c); n++; } }else{ while( c && ((nChar<0) || n<nChar) ){ READ_UTF16LE(z, c); n++; } } return (z-(char const *)zIn)-((c==0)?2:0); } 
#if defined(SQLITE_TEST) 
SQLITE_PRIVATE void sqlite3UtfSelfTest(void){ unsigned int i, t; unsigned char zBuf[20]; unsigned char *z; unsigned char *zTerm; int n; unsigned int c; for(i=0; i<0x00110000; i++){ z = zBuf; WRITE_UTF8(z, i); n = z-zBuf; z[0] = 0; zTerm = z; z = zBuf; c = sqlite3Utf8Read(z, zTerm, (const u8**)&z); t = i; if( i>=0xD800 && i<=0xDFFF ) t = 0xFFFD; if( (i&0xFFFFFFFE)==0xFFFE ) t = 0xFFFD; assert( c==t ); assert( (z-zBuf)==n ); } for(i=0; i<0x00110000; i++){ if( i>=0xD800 && i<0xE000 ) continue; z = zBuf; WRITE_UTF16LE(z, i); n = z-zBuf; z[0] = 0; z = zBuf; READ_UTF16LE(z, c); assert( c==i ); assert( (z-zBuf)==n ); } for(i=0; i<0x00110000; i++){ if( i>=0xD800 && i<0xE000 ) continue; z = zBuf; WRITE_UTF16BE(z, i); n = z-zBuf; z[0] = 0; z = zBuf; READ_UTF16BE(z, c); assert( c==i ); assert( (z-zBuf)==n ); } } 
#endif 
#endif 
SQLITE_PRIVATE int sqlite3IsNaN(double x){ 
#ifdef __FAST_MATH__ 
#error SQLite will not work correctly with the -ffast-math option of GCC. 
#endif 
 volatile double y = x; volatile double z = y; return y!=z; } SQLITE_PRIVATE int sqlite3Strlen(sqlite3 *db, const char *z){ const char *z2 = z; int len; int x; while( *z2 ){ z2++; } x = z2 - z; len = 0x7fffffff & x; if( len!=x || len > db->aLimit[SQLITE_LIMIT_LENGTH] ){ return db->aLimit[SQLITE_LIMIT_LENGTH]; }else{ return len; } } SQLITE_PRIVATE void sqlite3Error(sqlite3 *db, int err_code, const char *zFormat, ...){ if( db && (db->pErr || (db->pErr = sqlite3ValueNew(db))!=0) ){ db->errCode = err_code; if( zFormat ){ char *z; va_list ap; va_start(ap, zFormat); z = sqlite3VMPrintf(db, zFormat, ap); va_end(ap); sqlite3ValueSetStr(db->pErr, -1, z, SQLITE_UTF8, SQLITE_DYNAMIC); }else{ sqlite3ValueSetStr(db->pErr, 0, 0, SQLITE_UTF8, SQLITE_STATIC); } } } SQLITE_PRIVATE void sqlite3ErrorMsg(Parse *pParse, const char *zFormat, ...){ va_list ap; sqlite3 *db = pParse->db; pParse->nErr++; sqlite3DbFree(db, pParse->zErrMsg); va_start(ap, zFormat); pParse->zErrMsg = sqlite3VMPrintf(db, zFormat, ap); va_end(ap); if( pParse->rc==SQLITE_OK ){ pParse->rc = SQLITE_ERROR; } } SQLITE_PRIVATE void sqlite3ErrorClear(Parse *pParse){ sqlite3DbFree(pParse->db, pParse->zErrMsg); pParse->zErrMsg = 0; pParse->nErr = 0; } SQLITE_PRIVATE void sqlite3Dequote(char *z){ int quote; int i, j; if( z==0 ) return; quote = z[0]; switch( quote ){ case '\'': break; case '"': break; case '`': break; case '[': quote = ']'; break; default: return; } for(i=1, j=0; z[i]; i++){ if( z[i]==quote ){ if( z[i+1]==quote ){ z[j++] = quote; i++; }else{ z[j++] = 0; break; } }else{ z[j++] = z[i]; } } } 
#define UpperToLower sqlite3UpperToLower 
SQLITE_PRIVATE int sqlite3StrICmp(const char *zLeft, const char *zRight){ register unsigned char *a, *b; a = (unsigned char *)zLeft; b = (unsigned char *)zRight; while( *a!=0 && UpperToLower[*a]==UpperToLower[*b]){ a++; b++; } return UpperToLower[*a] - UpperToLower[*b]; } SQLITE_PRIVATE int sqlite3StrNICmp(const char *zLeft, const char *zRight, int N){ register unsigned char *a, *b; a = (unsigned char *)zLeft; b = (unsigned char *)zRight; while( N-- > 0 && *a!=0 && UpperToLower[*a]==UpperToLower[*b]){ a++; b++; } return N<0 ? 0 : UpperToLower[*a] - UpperToLower[*b]; } SQLITE_PRIVATE int sqlite3IsNumber(const char *z, int *realnum, u8 enc){ int incr = (enc==SQLITE_UTF8?1:2); if( enc==SQLITE_UTF16BE ) z++; if( *z=='-' || *z=='+' ) z += incr; if( !isdigit(*(u8*)z) ){ return 0; } z += incr; if( realnum ) *realnum = 0; while( isdigit(*(u8*)z) ){ z += incr; } if( *z=='.' ){ z += incr; if( !isdigit(*(u8*)z) ) return 0; while( isdigit(*(u8*)z) ){ z += incr; } if( realnum ) *realnum = 1; } if( *z=='e' || *z=='E' ){ z += incr; if( *z=='+' || *z=='-' ) z += incr; if( !isdigit(*(u8*)z) ) return 0; while( isdigit(*(u8*)z) ){ z += incr; } if( realnum ) *realnum = 1; } return *z==0; } SQLITE_PRIVATE int sqlite3AtoF(const char *z, double *pResult){ 
#ifndef SQLITE_OMIT_FLOATING_POINT 
 int sign = 1; const char *zBegin = z; LONGDOUBLE_TYPE v1 = 0.0; int nSignificant = 0; while( isspace(*(u8*)z) ) z++; if( *z=='-' ){ sign = -1; z++; }else if( *z=='+' ){ z++; } while( z[0]=='0' ){ z++; } while( isdigit(*(u8*)z) ){ v1 = v1*10.0 + (*z - '0'); z++; nSignificant++; } if( *z=='.' ){ LONGDOUBLE_TYPE divisor = 1.0; z++; if( nSignificant==0 ){ while( z[0]=='0' ){ divisor *= 10.0; z++; } } while( isdigit(*(u8*)z) ){ if( nSignificant<18 ){ v1 = v1*10.0 + (*z - '0'); divisor *= 10.0; nSignificant++; } z++; } v1 /= divisor; } if( *z=='e' || *z=='E' ){ int esign = 1; int eval = 0; LONGDOUBLE_TYPE scale = 1.0; z++; if( *z=='-' ){ esign = -1; z++; }else if( *z=='+' ){ z++; } while( isdigit(*(u8*)z) ){ eval = eval*10 + *z - '0'; z++; } while( eval>=64 ){ scale *= 1.0e+64; eval -= 64; } while( eval>=16 ){ scale *= 1.0e+16; eval -= 16; } while( eval>=4 ){ scale *= 1.0e+4; eval -= 4; } while( eval>=1 ){ scale *= 1.0e+1; eval -= 1; } if( esign<0 ){ v1 /= scale; }else{ v1 *= scale; } } *pResult = sign<0 ? -v1 : v1; return z - zBegin; 
#else 
 return sqlite3Atoi64(z, pResult); 
#endif 
} static int compare2pow63(const char *zNum){ int c; c = memcmp(zNum,"922337203685477580",18); if( c==0 ){ c = zNum[18] - '8'; } return c; } SQLITE_PRIVATE int sqlite3Atoi64(const char *zNum, i64 *pNum){ i64 v = 0; int neg; int i, c; const char *zStart; while( isspace(*(u8*)zNum) ) zNum++; if( *zNum=='-' ){ neg = 1; zNum++; }else if( *zNum=='+' ){ neg = 0; zNum++; }else{ neg = 0; } zStart = zNum; while( zNum[0]=='0' ){ zNum++; } for(i=0; (c=zNum[i])>='0' && c<='9'; i++){ v = v*10 + c - '0'; } *pNum = neg ? -v : v; if( c!=0 || (i==0 && zStart==zNum) || i>19 ){ return 0; }else if( i<19 ){ return 1; }else{ return compare2pow63(zNum)<neg; } } SQLITE_PRIVATE int sqlite3FitsIn64Bits(const char *zNum, int negFlag){ int i, c; int neg = 0; if( *zNum=='-' ){ neg = 1; zNum++; }else if( *zNum=='+' ){ zNum++; } if( negFlag ) neg = 1-neg; while( *zNum=='0' ){ zNum++; } for(i=0; (c=zNum[i])>='0' && c<='9'; i++){} if( i<19 ){ return 1; }else if( i>19 ){ return 0; }else{ return compare2pow63(zNum)<neg; } } SQLITE_PRIVATE int sqlite3GetInt32(const char *zNum, int *pValue){ sqlite_int64 v = 0; int i, c; int neg = 0; if( zNum[0]=='-' ){ neg = 1; zNum++; }else if( zNum[0]=='+' ){ zNum++; } while( zNum[0]=='0' ) zNum++; for(i=0; i<11 && (c = zNum[i] - '0')>=0 && c<=9; i++){ v = v*10 + c; } if( i>10 ){ return 0; } if( v-neg>2147483647 ){ return 0; } if( neg ){ v = -v; } *pValue = (int)v; return 1; } SQLITE_PRIVATE int sqlite3PutVarint(unsigned char *p, u64 v){ int i, j, n; u8 buf[10]; if( v & (((u64)0xff000000)<<32) ){ p[8] = v; v >>= 8; for(i=7; i>=0; i--){ p[i] = (v & 0x7f) | 0x80; v >>= 7; } return 9; } n = 0; do{ buf[n++] = (v & 0x7f) | 0x80; v >>= 7; }while( v!=0 ); buf[0] &= 0x7f; assert( n<=9 ); for(i=0, j=n-1; j>=0; j--, i++){ p[i] = buf[j]; } return n; } SQLITE_PRIVATE int sqlite3PutVarint32(unsigned char *p, u32 v){ 
#ifndef putVarint32 
 if( (v & ~0x7f)==0 ){ p[0] = v; return 1; } 
#endif 
 if( (v & ~0x3fff)==0 ){ p[0] = (v>>7) | 0x80; p[1] = v & 0x7f; return 2; } return sqlite3PutVarint(p, v); } SQLITE_PRIVATE int sqlite3GetVarint(const unsigned char *p, u64 *v){ u32 a,b,s; a = *p; if (!(a&0x80)) { *v = a; return 1; } p++; b = *p; if (!(b&0x80)) { a &= 0x7f; a = a<<7; a |= b; *v = a; return 2; } p++; a = a<<14; a |= *p; if (!(a&0x80)) { a &= (0x7f<<14)|(0x7f); b &= 0x7f; b = b<<7; a |= b; *v = a; return 3; } a &= (0x7f<<14)|(0x7f); p++; b = b<<14; b |= *p; if (!(b&0x80)) { b &= (0x7f<<14)|(0x7f); a = a<<7; a |= b; *v = a; return 4; } b &= (0x7f<<14)|(0x7f); s = a; p++; a = a<<14; a |= *p; if (!(a&0x80)) { b = b<<7; a |= b; s = s>>18; *v = ((u64)s)<<32 | a; return 5; } s = s<<7; s |= b; p++; b = b<<14; b |= *p; if (!(b&0x80)) { a &= (0x7f<<14)|(0x7f); a = a<<7; a |= b; s = s>>18; *v = ((u64)s)<<32 | a; return 6; } p++; a = a<<14; a |= *p; if (!(a&0x80)) { a &= (0x7f<<28)|(0x7f<<14)|(0x7f); b &= (0x7f<<14)|(0x7f); b = b<<7; a |= b; s = s>>11; *v = ((u64)s)<<32 | a; return 7; } a &= (0x7f<<14)|(0x7f); p++; b = b<<14; b |= *p; if (!(b&0x80)) { b &= (0x7f<<28)|(0x7f<<14)|(0x7f); a = a<<7; a |= b; s = s>>4; *v = ((u64)s)<<32 | a; return 8; } p++; a = a<<15; a |= *p; b &= (0x7f<<14)|(0x7f); b = b<<8; a |= b; s = s<<4; b = p[-4]; b &= 0x7f; b = b>>3; s |= b; *v = ((u64)s)<<32 | a; return 9; } SQLITE_PRIVATE int sqlite3GetVarint32(const unsigned char *p, u32 *v){ u32 a,b; a = *p; 
#ifndef getVarint32 
 if (!(a&0x80)) { *v = a; return 1; } 
#endif 
 p++; b = *p; if (!(b&0x80)) { a &= 0x7f; a = a<<7; *v = a | b; return 2; } p++; a = a<<14; a |= *p; if (!(a&0x80)) { a &= (0x7f<<14)|(0x7f); b &= 0x7f; b = b<<7; *v = a | b; return 3; } p++; b = b<<14; b |= *p; if (!(b&0x80)) { b &= (0x7f<<14)|(0x7f); a &= (0x7f<<14)|(0x7f); a = a<<7; *v = a | b; return 4; } p++; a = a<<14; a |= *p; if (!(a&0x80)) { a &= (0x7f<<28)|(0x7f<<14)|(0x7f); b &= (0x7f<<28)|(0x7f<<14)|(0x7f); b = b<<7; *v = a | b; return 5; } { u64 v64; int n; p -= 4; n = sqlite3GetVarint(p, &v64); assert( n>5 && n<=9 ); *v = (u32)v64; return n; } } SQLITE_PRIVATE int sqlite3VarintLen(u64 v){ int i = 0; do{ i++; v >>= 7; }while( v!=0 && i<9 ); return i; } SQLITE_PRIVATE u32 sqlite3Get4byte(const u8 *p){ return (p[0]<<24) | (p[1]<<16) | (p[2]<<8) | p[3]; } SQLITE_PRIVATE void sqlite3Put4byte(unsigned char *p, u32 v){ p[0] = v>>24; p[1] = v>>16; p[2] = v>>8; p[3] = v; } 
#if !defined(SQLITE_OMIT_BLOB_LITERAL) || defined(SQLITE_HAS_CODEC) 
static int hexToInt(int h){ assert( (h>='0' && h<='9') || (h>='a' && h<='f') || (h>='A' && h<='F') ); 
#ifdef SQLITE_ASCII 
 h += 9*(1&(h>>6)); 
#endif 
#ifdef SQLITE_EBCDIC 
 h += 9*(1&~(h>>4)); 
#endif 
 return h & 0xf; } 
#endif 
#if !defined(SQLITE_OMIT_BLOB_LITERAL) || defined(SQLITE_HAS_CODEC) 
SQLITE_PRIVATE void *sqlite3HexToBlob(sqlite3 *db, const char *z, int n){ char *zBlob; int i; zBlob = (char *)sqlite3DbMallocRaw(db, n/2 + 1); n--; if( zBlob ){ for(i=0; i<n; i+=2){ zBlob[i/2] = (hexToInt(z[i])<<4) | hexToInt(z[i+1]); } zBlob[i/2] = 0; } return zBlob; } 
#endif 
#ifdef SQLITE_DEBUG 
SQLITE_PRIVATE int sqlite3SafetyOn(sqlite3 *db){ if( db->magic==SQLITE_MAGIC_OPEN ){ db->magic = SQLITE_MAGIC_BUSY; assert( sqlite3_mutex_held(db->mutex) ); return 0; }else if( db->magic==SQLITE_MAGIC_BUSY ){ db->magic = SQLITE_MAGIC_ERROR; db->u1.isInterrupted = 1; } return 1; } 
#endif 
#ifdef SQLITE_DEBUG 
SQLITE_PRIVATE int sqlite3SafetyOff(sqlite3 *db){ if( db->magic==SQLITE_MAGIC_BUSY ){ db->magic = SQLITE_MAGIC_OPEN; assert( sqlite3_mutex_held(db->mutex) ); return 0; }else{ db->magic = SQLITE_MAGIC_ERROR; db->u1.isInterrupted = 1; return 1; } } 
#endif 
SQLITE_PRIVATE int sqlite3SafetyCheckOk(sqlite3 *db){ u32 magic; if( db==0 ) return 0; magic = db->magic; if( magic!=SQLITE_MAGIC_OPEN && magic!=SQLITE_MAGIC_BUSY ) return 0; return 1; } SQLITE_PRIVATE int sqlite3SafetyCheckSickOrOk(sqlite3 *db){ u32 magic; if( db==0 ) return 0; magic = db->magic; if( magic!=SQLITE_MAGIC_SICK && magic!=SQLITE_MAGIC_OPEN && magic!=SQLITE_MAGIC_BUSY ) return 0; return 1; } SQLITE_PRIVATE void sqlite3HashInit(Hash *pNew, int copyKey){ assert( pNew!=0 ); pNew->copyKey = copyKey!=0; pNew->first = 0; pNew->count = 0; pNew->htsize = 0; pNew->ht = 0; } SQLITE_PRIVATE void sqlite3HashClear(Hash *pH){ HashElem *elem; assert( pH!=0 ); elem = pH->first; pH->first = 0; sqlite3_free(pH->ht); pH->ht = 0; pH->htsize = 0; while( elem ){ HashElem *next_elem = elem->next; if( pH->copyKey && elem->pKey ){ sqlite3_free(elem->pKey); } sqlite3_free(elem); elem = next_elem; } pH->count = 0; } static int strHash(const void *pKey, int nKey){ const char *z = (const char *)pKey; int h = 0; if( nKey<=0 ) nKey = strlen(z); while( nKey > 0 ){ h = (h<<3) ^ h ^ sqlite3UpperToLower[(unsigned char)*z++]; nKey--; } return h & 0x7fffffff; } static int strCompare(const void *pKey1, int n1, const void *pKey2, int n2){ if( n1!=n2 ) return 1; return sqlite3StrNICmp((const char*)pKey1,(const char*)pKey2,n1); } static void insertElement( Hash *pH, struct _ht *pEntry, HashElem *pNew ){ HashElem *pHead; pHead = pEntry->chain; if( pHead ){ pNew->next = pHead; pNew->prev = pHead->prev; if( pHead->prev ){ pHead->prev->next = pNew; } else { pH->first = pNew; } pHead->prev = pNew; }else{ pNew->next = pH->first; if( pH->first ){ pH->first->prev = pNew; } pNew->prev = 0; pH->first = pNew; } pEntry->count++; pEntry->chain = pNew; } static void rehash(Hash *pH, int new_size){ struct _ht *new_ht; HashElem *elem, *next_elem; 
#ifdef SQLITE_MALLOC_SOFT_LIMIT 
 if( new_size*sizeof(struct _ht)>SQLITE_MALLOC_SOFT_LIMIT ){ new_size = SQLITE_MALLOC_SOFT_LIMIT/sizeof(struct _ht); } if( new_size==pH->htsize ) return; 
#endif 
 if( pH->htsize>0 ) sqlite3BeginBenignMalloc(); new_ht = (struct _ht *)sqlite3MallocZero( new_size*sizeof(struct _ht) ); if( pH->htsize>0 ) sqlite3EndBenignMalloc(); if( new_ht==0 ) return; sqlite3_free(pH->ht); pH->ht = new_ht; pH->htsize = new_size; for(elem=pH->first, pH->first=0; elem; elem = next_elem){ int h = strHash(elem->pKey, elem->nKey) & (new_size-1); next_elem = elem->next; insertElement(pH, &new_ht[h], elem); } } static HashElem *findElementGivenHash( const Hash *pH, const void *pKey, int nKey, int h ){ HashElem *elem; int count; if( pH->ht ){ struct _ht *pEntry = &pH->ht[h]; elem = pEntry->chain; count = pEntry->count; while( count-- && elem ){ if( strCompare(elem->pKey,elem->nKey,pKey,nKey)==0 ){ return elem; } elem = elem->next; } } return 0; } static void removeElementGivenHash( Hash *pH, HashElem* elem, int h ){ struct _ht *pEntry; if( elem->prev ){ elem->prev->next = elem->next; }else{ pH->first = elem->next; } if( elem->next ){ elem->next->prev = elem->prev; } pEntry = &pH->ht[h]; if( pEntry->chain==elem ){ pEntry->chain = elem->next; } pEntry->count--; if( pEntry->count<=0 ){ pEntry->chain = 0; } if( pH->copyKey ){ sqlite3_free(elem->pKey); } sqlite3_free( elem ); pH->count--; if( pH->count<=0 ){ assert( pH->first==0 ); assert( pH->count==0 ); sqlite3HashClear(pH); } } SQLITE_PRIVATE HashElem *sqlite3HashFindElem(const Hash *pH, const void *pKey, int nKey){ int h; HashElem *elem; if( pH==0 || pH->ht==0 ) return 0; h = strHash(pKey,nKey); elem = findElementGivenHash(pH,pKey,nKey, h % pH->htsize); return elem; } SQLITE_PRIVATE void *sqlite3HashFind(const Hash *pH, const void *pKey, int nKey){ HashElem *elem; elem = sqlite3HashFindElem(pH, pKey, nKey); return elem ? elem->data : 0; } SQLITE_PRIVATE void *sqlite3HashInsert(Hash *pH, const void *pKey, int nKey, void *data){ int hraw; int h; HashElem *elem; HashElem *new_elem; assert( pH!=0 ); hraw = strHash(pKey, nKey); if( pH->htsize ){ h = hraw % pH->htsize; elem = findElementGivenHash(pH,pKey,nKey,h); if( elem ){ void *old_data = elem->data; if( data==0 ){ removeElementGivenHash(pH,elem,h); }else{ elem->data = data; if( !pH->copyKey ){ elem->pKey = (void *)pKey; } assert(nKey==elem->nKey); } return old_data; } } if( data==0 ) return 0; new_elem = (HashElem*)sqlite3Malloc( sizeof(HashElem) ); if( new_elem==0 ) return data; if( pH->copyKey && pKey!=0 ){ new_elem->pKey = sqlite3Malloc( nKey ); if( new_elem->pKey==0 ){ sqlite3_free(new_elem); return data; } memcpy((void*)new_elem->pKey, pKey, nKey); }else{ new_elem->pKey = (void*)pKey; } new_elem->nKey = nKey; pH->count++; if( pH->htsize==0 ){ rehash(pH, 128/sizeof(pH->ht[0])); if( pH->htsize==0 ){ pH->count = 0; if( pH->copyKey ){ sqlite3_free(new_elem->pKey); } sqlite3_free(new_elem); return data; } } if( pH->count > pH->htsize ){ rehash(pH,pH->htsize*2); } assert( pH->htsize>0 ); h = hraw % pH->htsize; insertElement(pH, &pH->ht[h], new_elem); new_elem->data = data; return 0; } 
#if !defined(SQLITE_OMIT_EXPLAIN) || !defined(NDEBUG) || defined(VDBE_PROFILE) || defined(SQLITE_DEBUG) 
SQLITE_PRIVATE const char *sqlite3OpcodeName(int i){ static const char *const azName[] = { "?", "VNext", "Affinity", "Column", "SetCookie", "Sequence", "MoveGt", "RowKey", "SCopy", "OpenWrite", "If", "VRowid", "CollSeq", "OpenRead", "Expire", "AutoCommit", "Not", "Pagecount", "IntegrityCk", "Sort", "Copy", "Trace", "Function", "IfNeg", "Noop", "Return", "NewRowid", "Variable", "String", "RealAffinity", "VRename", "ParseSchema", "VOpen", "Close", "CreateIndex", "IsUnique", "NotFound", "Int64", "MustBeInt", "Halt", "Rowid", "IdxLT", "AddImm", "Statement", "RowData", "MemMax", "NotExists", "Gosub", "Integer", "Prev", "VColumn", "CreateTable", "Last", "IncrVacuum", "IdxRowid", "ResetCount", "FifoWrite", "ContextPush", "Yield", "DropTrigger", "Or", "And", "DropIndex", "IdxGE", "IdxDelete", "IsNull", "NotNull", "Ne", "Eq", "Gt", "Le", "Lt", "Ge", "Vacuum", "BitAnd", "BitOr", "ShiftLeft", "ShiftRight", "Add", "Subtract", "Multiply", "Divide", "Remainder", "Concat", "MoveLe", "IfNot", "DropTable", "BitNot", "String8", "MakeRecord", "ResultRow", "Delete", "AggFinal", "Compare", "Goto", "TableLock", "FifoRead", "Clear", "MoveLt", "VerifyCookie", "AggStep", "SetNumColumns", "Transaction", "VFilter", "VDestroy", "ContextPop", "Next", "IdxInsert", "Insert", "Destroy", "ReadCookie", "ForceInt", "LoadAnalysis", "Explain", "OpenPseudo", "OpenEphemeral", "Null", "Move", "Blob", "Rewind", "MoveGe", "VBegin", "VUpdate", "IfZero", "VCreate", "Found", "Real", "IfPos", "NullRow", "Jump", "Permutation", "NotUsed_131", "NotUsed_132", "NotUsed_133", "NotUsed_134", "NotUsed_135", "NotUsed_136", "NotUsed_137", "NotUsed_138", "ToText", "ToBlob", "ToNumeric", "ToInt", "ToReal", }; return azName[i]; } 
#endif 
#if SQLITE_OS_OS2 
#if defined(SQLITE_THREADSAFE) && SQLITE_THREADSAFE 
#define SQLITE_OS2_THREADS 1 
#endif 
#ifndef _OS_COMMON_H_ 
#define _OS_COMMON_H_ 
#ifdef MEMORY_DEBUG 
#error "The MEMORY_DEBUG macro is obsolete. Use SQLITE_DEBUG instead." 
#endif 
#ifdef SQLITE_TEST 
SQLITE_API unsigned int sqlite3_pending_byte = 0x40000000; 
#endif 
#ifdef SQLITE_DEBUG 
SQLITE_PRIVATE int sqlite3OSTrace = 0; 
#define OSTRACE1(X) if( sqlite3OSTrace ) sqlite3DebugPrintf(X) 
#define OSTRACE2(X,Y) if( sqlite3OSTrace ) sqlite3DebugPrintf(X,Y) 
#define OSTRACE3(X,Y,Z) if( sqlite3OSTrace ) sqlite3DebugPrintf(X,Y,Z) 
#define OSTRACE4(X,Y,Z,A) if( sqlite3OSTrace ) sqlite3DebugPrintf(X,Y,Z,A) 
#define OSTRACE5(X,Y,Z,A,B) if( sqlite3OSTrace ) sqlite3DebugPrintf(X,Y,Z,A,B) 
#define OSTRACE6(X,Y,Z,A,B,C) if(sqlite3OSTrace) sqlite3DebugPrintf(X,Y,Z,A,B,C) 
#define OSTRACE7(X,Y,Z,A,B,C,D) if(sqlite3OSTrace) sqlite3DebugPrintf(X,Y,Z,A,B,C,D) 
#else 
#define OSTRACE1(X) 
#define OSTRACE2(X,Y) 
#define OSTRACE3(X,Y,Z) 
#define OSTRACE4(X,Y,Z,A) 
#define OSTRACE5(X,Y,Z,A,B) 
#define OSTRACE6(X,Y,Z,A,B,C) 
#define OSTRACE7(X,Y,Z,A,B,C,D) 
#endif 
#ifdef SQLITE_PERFORMANCE_TRACE 
#ifndef _HWTIME_H_ 
#define _HWTIME_H_ 
#if (defined(__GNUC__) || defined(_MSC_VER)) && (defined(i386) || defined(__i386__) || defined(_M_IX86)) 
#if defined(__GNUC__) 
 __inline__ sqlite_uint64 sqlite3Hwtime(void){ unsigned int lo, hi; __asm__ __volatile__ ("rdtsc" : "=a" (lo), "=d" (hi)); return (sqlite_uint64)hi << 32 | lo; } 
#elif defined(_MSC_VER) 
 __declspec(naked) __inline sqlite_uint64 __cdecl sqlite3Hwtime(void){ __asm { rdtsc ret ; return value at EDX:EAX } } 
#endif 
#elif (defined(__GNUC__) && defined(__x86_64__)) 
 __inline__ sqlite_uint64 sqlite3Hwtime(void){ unsigned long val; __asm__ __volatile__ ("rdtsc" : "=A" (val)); return val; } 
#elif (defined(__GNUC__) && defined(__ppc__)) 
 __inline__ sqlite_uint64 sqlite3Hwtime(void){ unsigned long long retval; unsigned long junk; __asm__ __volatile__ ("\n 1: mftbu %1\n mftb %L0\n mftbu %0\n cmpw %0,%1\n bne 1b" : "=r" (retval), "=r" (junk)); return retval; } 
#else 
#error Need implementation of sqlite3Hwtime() for your platform. 
 SQLITE_PRIVATE sqlite_uint64 sqlite3Hwtime(void){ return ((sqlite_uint64)0); } 
#endif 
#endif 
static sqlite_uint64 g_start; static sqlite_uint64 g_elapsed; 
#define TIMER_START g_start=sqlite3Hwtime() 
#define TIMER_END g_elapsed=sqlite3Hwtime()-g_start 
#define TIMER_ELAPSED g_elapsed 
#else 
#define TIMER_START 
#define TIMER_END 
#define TIMER_ELAPSED ((sqlite_uint64)0) 
#endif 
#ifdef SQLITE_TEST 
SQLITE_API int sqlite3_io_error_hit = 0; SQLITE_API int sqlite3_io_error_hardhit = 0; SQLITE_API int sqlite3_io_error_pending = 0; SQLITE_API int sqlite3_io_error_persist = 0; SQLITE_API int sqlite3_io_error_benign = 0; SQLITE_API int sqlite3_diskfull_pending = 0; SQLITE_API int sqlite3_diskfull = 0; 
#define SimulateIOErrorBenign(X) sqlite3_io_error_benign=(X) 
#define SimulateIOError(CODE) if( (sqlite3_io_error_persist && sqlite3_io_error_hit) || sqlite3_io_error_pending-- == 1 ) { local_ioerr(); CODE; } 
static void local_ioerr(){ IOTRACE(("IOERR\n")); sqlite3_io_error_hit++; if( !sqlite3_io_error_benign ) sqlite3_io_error_hardhit++; } 
#define SimulateDiskfullError(CODE) if( sqlite3_diskfull_pending ){ if( sqlite3_diskfull_pending == 1 ){ local_ioerr(); sqlite3_diskfull = 1; sqlite3_io_error_hit = 1; CODE; }else{ sqlite3_diskfull_pending--; } } 
#else 
#define SimulateIOErrorBenign(X) 
#define SimulateIOError(A) 
#define SimulateDiskfullError(A) 
#endif 
#ifdef SQLITE_TEST 
SQLITE_API int sqlite3_open_file_count = 0; 
#define OpenCounter(X) sqlite3_open_file_count+=(X) 
#else 
#define OpenCounter(X) 
#endif 
#endif 
typedef struct os2File os2File; struct os2File { const sqlite3_io_methods *pMethod; HFILE h; char* pathToDel; unsigned char locktype; }; 
#define LOCK_TIMEOUT 10L 
static int os2Close( sqlite3_file *id ){ APIRET rc = NO_ERROR; os2File *pFile; if( id && (pFile = (os2File*)id) != 0 ){ OSTRACE2( "CLOSE %d\n", pFile->h ); rc = DosClose( pFile->h ); pFile->locktype = NO_LOCK; if( pFile->pathToDel != NULL ){ rc = DosForceDelete( (PSZ)pFile->pathToDel ); free( pFile->pathToDel ); pFile->pathToDel = NULL; } id = 0; OpenCounter( -1 ); } return rc == NO_ERROR ? SQLITE_OK : SQLITE_IOERR; } static int os2Read( sqlite3_file *id, void *pBuf, int amt, sqlite3_int64 offset ){ ULONG fileLocation = 0L; ULONG got; os2File *pFile = (os2File*)id; assert( id!=0 ); SimulateIOError( return SQLITE_IOERR_READ ); OSTRACE3( "READ %d lock=%d\n", pFile->h, pFile->locktype ); if( DosSetFilePtr(pFile->h, offset, FILE_BEGIN, &fileLocation) != NO_ERROR ){ return SQLITE_IOERR; } if( DosRead( pFile->h, pBuf, amt, &got ) != NO_ERROR ){ return SQLITE_IOERR_READ; } if( got == (ULONG)amt ) return SQLITE_OK; else { memset(&((char*)pBuf)[got], 0, amt-got); return SQLITE_IOERR_SHORT_READ; } } static int os2Write( sqlite3_file *id, const void *pBuf, int amt, sqlite3_int64 offset ){ ULONG fileLocation = 0L; APIRET rc = NO_ERROR; ULONG wrote; os2File *pFile = (os2File*)id; assert( id!=0 ); SimulateIOError( return SQLITE_IOERR_WRITE ); SimulateDiskfullError( return SQLITE_FULL ); OSTRACE3( "WRITE %d lock=%d\n", pFile->h, pFile->locktype ); if( DosSetFilePtr(pFile->h, offset, FILE_BEGIN, &fileLocation) != NO_ERROR ){ return SQLITE_IOERR; } assert( amt>0 ); while( amt > 0 && ( rc = DosWrite( pFile->h, (PVOID)pBuf, amt, &wrote ) ) == NO_ERROR && wrote > 0 ){ amt -= wrote; pBuf = &((char*)pBuf)[wrote]; } return ( rc != NO_ERROR || amt > (int)wrote ) ? SQLITE_FULL : SQLITE_OK; } static int os2Truncate( sqlite3_file *id, i64 nByte ){ APIRET rc = NO_ERROR; os2File *pFile = (os2File*)id; OSTRACE3( "TRUNCATE %d %lld\n", pFile->h, nByte ); SimulateIOError( return SQLITE_IOERR_TRUNCATE ); rc = DosSetFileSize( pFile->h, nByte ); return rc == NO_ERROR ? SQLITE_OK : SQLITE_IOERR_TRUNCATE; } 
#ifdef SQLITE_TEST 
SQLITE_API int sqlite3_sync_count = 0; SQLITE_API int sqlite3_fullsync_count = 0; 
#endif 
static int os2Sync( sqlite3_file *id, int flags ){ os2File *pFile = (os2File*)id; OSTRACE3( "SYNC %d lock=%d\n", pFile->h, pFile->locktype ); 
#ifdef SQLITE_TEST 
 if( flags & SQLITE_SYNC_FULL){ sqlite3_fullsync_count++; } sqlite3_sync_count++; 
#endif 
 
#ifdef SQLITE_NO_SYNC 
 return SQLITE_OK; 
#else 
 return DosResetBuffer( pFile->h ) == NO_ERROR ? SQLITE_OK : SQLITE_IOERR; 
#endif 
} static int os2FileSize( sqlite3_file *id, sqlite3_int64 *pSize ){ APIRET rc = NO_ERROR; FILESTATUS3 fsts3FileInfo; memset(&fsts3FileInfo, 0, sizeof(fsts3FileInfo)); assert( id!=0 ); SimulateIOError( return SQLITE_IOERR_FSTAT ); rc = DosQueryFileInfo( ((os2File*)id)->h, FIL_STANDARD, &fsts3FileInfo, sizeof(FILESTATUS3) ); if( rc == NO_ERROR ){ *pSize = fsts3FileInfo.cbFile; return SQLITE_OK; }else{ return SQLITE_IOERR_FSTAT; } } static int getReadLock( os2File *pFile ){ FILELOCK LockArea, UnlockArea; APIRET res; memset(&LockArea, 0, sizeof(LockArea)); memset(&UnlockArea, 0, sizeof(UnlockArea)); LockArea.lOffset = SHARED_FIRST; LockArea.lRange = SHARED_SIZE; UnlockArea.lOffset = 0L; UnlockArea.lRange = 0L; res = DosSetFileLocks( pFile->h, &UnlockArea, &LockArea, LOCK_TIMEOUT, 1L ); OSTRACE3( "GETREADLOCK %d res=%d\n", pFile->h, res ); return res; } static int unlockReadLock( os2File *id ){ FILELOCK LockArea, UnlockArea; APIRET res; memset(&LockArea, 0, sizeof(LockArea)); memset(&UnlockArea, 0, sizeof(UnlockArea)); LockArea.lOffset = 0L; LockArea.lRange = 0L; UnlockArea.lOffset = SHARED_FIRST; UnlockArea.lRange = SHARED_SIZE; res = DosSetFileLocks( id->h, &UnlockArea, &LockArea, LOCK_TIMEOUT, 1L ); OSTRACE3( "UNLOCK-READLOCK file handle=%d res=%d?\n", id->h, res ); return res; } static int os2Lock( sqlite3_file *id, int locktype ){ int rc = SQLITE_OK; APIRET res = NO_ERROR; int newLocktype; int gotPendingLock = 0; FILELOCK LockArea, UnlockArea; os2File *pFile = (os2File*)id; memset(&LockArea, 0, sizeof(LockArea)); memset(&UnlockArea, 0, sizeof(UnlockArea)); assert( pFile!=0 ); OSTRACE4( "LOCK %d %d was %d\n", pFile->h, locktype, pFile->locktype ); if( pFile->locktype>=locktype ){ OSTRACE3( "LOCK %d %d ok (already held)\n", pFile->h, locktype ); return SQLITE_OK; } assert( pFile->locktype!=NO_LOCK || locktype==SHARED_LOCK ); assert( locktype!=PENDING_LOCK ); assert( locktype!=RESERVED_LOCK || pFile->locktype==SHARED_LOCK ); newLocktype = pFile->locktype; if( pFile->locktype==NO_LOCK || (locktype==EXCLUSIVE_LOCK && pFile->locktype==RESERVED_LOCK) ){ LockArea.lOffset = PENDING_BYTE; LockArea.lRange = 1L; UnlockArea.lOffset = 0L; UnlockArea.lRange = 0L; res = DosSetFileLocks( pFile->h, &UnlockArea, &LockArea, 100L, 0L ); if( res == NO_ERROR ){ gotPendingLock = 1; OSTRACE3( "LOCK %d pending lock boolean set. res=%d\n", pFile->h, res ); } } if( locktype==SHARED_LOCK && res == NO_ERROR ){ assert( pFile->locktype==NO_LOCK ); res = getReadLock(pFile); if( res == NO_ERROR ){ newLocktype = SHARED_LOCK; } OSTRACE3( "LOCK %d acquire shared lock. res=%d\n", pFile->h, res ); } if( locktype==RESERVED_LOCK && res == NO_ERROR ){ assert( pFile->locktype==SHARED_LOCK ); LockArea.lOffset = RESERVED_BYTE; LockArea.lRange = 1L; UnlockArea.lOffset = 0L; UnlockArea.lRange = 0L; res = DosSetFileLocks( pFile->h, &UnlockArea, &LockArea, LOCK_TIMEOUT, 0L ); if( res == NO_ERROR ){ newLocktype = RESERVED_LOCK; } OSTRACE3( "LOCK %d acquire reserved lock. res=%d\n", pFile->h, res ); } if( locktype==EXCLUSIVE_LOCK && res == NO_ERROR ){ newLocktype = PENDING_LOCK; gotPendingLock = 0; OSTRACE2( "LOCK %d acquire pending lock. pending lock boolean unset.\n", pFile->h ); } if( locktype==EXCLUSIVE_LOCK && res == NO_ERROR ){ assert( pFile->locktype>=SHARED_LOCK ); res = unlockReadLock(pFile); OSTRACE2( "unreadlock = %d\n", res ); LockArea.lOffset = SHARED_FIRST; LockArea.lRange = SHARED_SIZE; UnlockArea.lOffset = 0L; UnlockArea.lRange = 0L; res = DosSetFileLocks( pFile->h, &UnlockArea, &LockArea, LOCK_TIMEOUT, 0L ); if( res == NO_ERROR ){ newLocktype = EXCLUSIVE_LOCK; }else{ OSTRACE2( "OS/2 error-code = %d\n", res ); getReadLock(pFile); } OSTRACE3( "LOCK %d acquire exclusive lock. res=%d\n", pFile->h, res ); } if( gotPendingLock && locktype==SHARED_LOCK ){ int r; LockArea.lOffset = 0L; LockArea.lRange = 0L; UnlockArea.lOffset = PENDING_BYTE; UnlockArea.lRange = 1L; r = DosSetFileLocks( pFile->h, &UnlockArea, &LockArea, LOCK_TIMEOUT, 0L ); OSTRACE3( "LOCK %d unlocking pending/is shared. r=%d\n", pFile->h, r ); } if( res == NO_ERROR ){ rc = SQLITE_OK; }else{ OSTRACE4( "LOCK FAILED %d trying for %d but got %d\n", pFile->h, locktype, newLocktype ); rc = SQLITE_BUSY; } pFile->locktype = newLocktype; OSTRACE3( "LOCK %d now %d\n", pFile->h, pFile->locktype ); return rc; } static int os2CheckReservedLock( sqlite3_file *id, int *pOut ){ int r = 0; os2File *pFile = (os2File*)id; assert( pFile!=0 ); if( pFile->locktype>=RESERVED_LOCK ){ r = 1; OSTRACE3( "TEST WR-LOCK %d %d (local)\n", pFile->h, r ); }else{ FILELOCK LockArea, UnlockArea; APIRET rc = NO_ERROR; memset(&LockArea, 0, sizeof(LockArea)); memset(&UnlockArea, 0, sizeof(UnlockArea)); LockArea.lOffset = RESERVED_BYTE; LockArea.lRange = 1L; UnlockArea.lOffset = 0L; UnlockArea.lRange = 0L; rc = DosSetFileLocks( pFile->h, &UnlockArea, &LockArea, LOCK_TIMEOUT, 0L ); OSTRACE3( "TEST WR-LOCK %d lock reserved byte rc=%d\n", pFile->h, rc ); if( rc == NO_ERROR ){ APIRET rcu = NO_ERROR; LockArea.lOffset = 0L; LockArea.lRange = 0L; UnlockArea.lOffset = RESERVED_BYTE; UnlockArea.lRange = 1L; rcu = DosSetFileLocks( pFile->h, &UnlockArea, &LockArea, LOCK_TIMEOUT, 0L ); OSTRACE3( "TEST WR-LOCK %d unlock reserved byte r=%d\n", pFile->h, rcu ); } r = !(rc == NO_ERROR); OSTRACE3( "TEST WR-LOCK %d %d (remote)\n", pFile->h, r ); } *pOut = r; return SQLITE_OK; } static int os2Unlock( sqlite3_file *id, int locktype ){ int type; os2File *pFile = (os2File*)id; APIRET rc = SQLITE_OK; APIRET res = NO_ERROR; FILELOCK LockArea, UnlockArea; memset(&LockArea, 0, sizeof(LockArea)); memset(&UnlockArea, 0, sizeof(UnlockArea)); assert( pFile!=0 ); assert( locktype<=SHARED_LOCK ); OSTRACE4( "UNLOCK %d to %d was %d\n", pFile->h, locktype, pFile->locktype ); type = pFile->locktype; if( type>=EXCLUSIVE_LOCK ){ LockArea.lOffset = 0L; LockArea.lRange = 0L; UnlockArea.lOffset = SHARED_FIRST; UnlockArea.lRange = SHARED_SIZE; res = DosSetFileLocks( pFile->h, &UnlockArea, &LockArea, LOCK_TIMEOUT, 0L ); OSTRACE3( "UNLOCK %d exclusive lock res=%d\n", pFile->h, res ); if( locktype==SHARED_LOCK && getReadLock(pFile) != NO_ERROR ){ OSTRACE3( "UNLOCK %d to %d getReadLock() failed\n", pFile->h, locktype ); rc = SQLITE_IOERR_UNLOCK; } } if( type>=RESERVED_LOCK ){ LockArea.lOffset = 0L; LockArea.lRange = 0L; UnlockArea.lOffset = RESERVED_BYTE; UnlockArea.lRange = 1L; res = DosSetFileLocks( pFile->h, &UnlockArea, &LockArea, LOCK_TIMEOUT, 0L ); OSTRACE3( "UNLOCK %d reserved res=%d\n", pFile->h, res ); } if( locktype==NO_LOCK && type>=SHARED_LOCK ){ res = unlockReadLock(pFile); OSTRACE5( "UNLOCK %d is %d want %d res=%d\n", pFile->h, type, locktype, res ); } if( type>=PENDING_LOCK ){ LockArea.lOffset = 0L; LockArea.lRange = 0L; UnlockArea.lOffset = PENDING_BYTE; UnlockArea.lRange = 1L; res = DosSetFileLocks( pFile->h, &UnlockArea, &LockArea, LOCK_TIMEOUT, 0L ); OSTRACE3( "UNLOCK %d pending res=%d\n", pFile->h, res ); } pFile->locktype = locktype; OSTRACE3( "UNLOCK %d now %d\n", pFile->h, pFile->locktype ); return rc; } static int os2FileControl(sqlite3_file *id, int op, void *pArg){ switch( op ){ case SQLITE_FCNTL_LOCKSTATE: { *(int*)pArg = ((os2File*)id)->locktype; OSTRACE3( "FCNTL_LOCKSTATE %d lock=%d\n", ((os2File*)id)->h, ((os2File*)id)->locktype ); return SQLITE_OK; } } return SQLITE_ERROR; } static int os2SectorSize(sqlite3_file *id){ return SQLITE_DEFAULT_SECTOR_SIZE; } static int os2DeviceCharacteristics(sqlite3_file *id){ return 0; } static UconvObject ucUtf8 = NULL; static UconvObject uclCp = NULL; static void initUconvObjects( void ){ if( UniCreateUconvObject( UTF_8, &ucUtf8 ) != ULS_SUCCESS ) ucUtf8 = NULL; if ( UniCreateUconvObject( (UniChar *)L"@path=yes", &uclCp ) != ULS_SUCCESS ) uclCp = NULL; } static void freeUconvObjects( void ){ if ( ucUtf8 ) UniFreeUconvObject( ucUtf8 ); if ( uclCp ) UniFreeUconvObject( uclCp ); ucUtf8 = NULL; uclCp = NULL; } static char *convertUtf8PathToCp( const char *in ){ UniChar tempPath[CCHMAXPATH]; char *out = (char *)calloc( CCHMAXPATH, 1 ); if( !out ) return NULL; if( !ucUtf8 || !uclCp ) initUconvObjects(); if( UniStrToUcs( ucUtf8, tempPath, (char *)in, CCHMAXPATH ) != ULS_SUCCESS ) return out; UniStrFromUcs( uclCp, out, tempPath, CCHMAXPATH ); return out; } char *convertCpPathToUtf8( const char *in ){ UniChar tempPath[CCHMAXPATH]; char *out = (char *)calloc( CCHMAXPATH, 1 ); if( !out ) return NULL; if( !ucUtf8 || !uclCp ) initUconvObjects(); if( UniStrToUcs( uclCp, tempPath, (char *)in, CCHMAXPATH ) != ULS_SUCCESS ) return out; UniStrFromUcs( ucUtf8, out, tempPath, CCHMAXPATH ); return out; } static const sqlite3_io_methods os2IoMethod = { 1, os2Close, os2Read, os2Write, os2Truncate, os2Sync, os2FileSize, os2Lock, os2Unlock, os2CheckReservedLock, os2FileControl, os2SectorSize, os2DeviceCharacteristics }; static int getTempname(int nBuf, char *zBuf ){ static const unsigned char zChars[] = "abcdefghijklmnopqrstuvwxyz" "ABCDEFGHIJKLMNOPQRSTUVWXYZ" "0123456789"; int i, j; char zTempPathBuf[3]; PSZ zTempPath = (PSZ)&zTempPathBuf; if( sqlite3_temp_directory ){ zTempPath = sqlite3_temp_directory; }else{ if( DosScanEnv( (PSZ)"TEMP", &zTempPath ) ){ if( DosScanEnv( (PSZ)"TMP", &zTempPath ) ){ if( DosScanEnv( (PSZ)"TMPDIR", &zTempPath ) ){ ULONG ulDriveNum = 0, ulDriveMap = 0; DosQueryCurrentDisk( &ulDriveNum, &ulDriveMap ); sprintf( (char*)zTempPath, "%c:", (char)( 'A' + ulDriveNum - 1 ) ); } } } } j = strlen(zTempPath); while( j > 0 && ( zTempPath[j-1] == '\\' || zTempPath[j-1] == '/' || zTempPath[j-1] == ' ' ) ){ j--; } zTempPath[j] = '\0'; if( !sqlite3_temp_directory ){ char *zTempPathUTF = convertCpPathToUtf8( zTempPath ); sqlite3_snprintf( nBuf-30, zBuf, "%s\\"SQLITE_TEMP_FILE_PREFIX, zTempPathUTF ); free( zTempPathUTF ); }else{ sqlite3_snprintf( nBuf-30, zBuf, "%s\\"SQLITE_TEMP_FILE_PREFIX, zTempPath ); } j = strlen( zBuf ); sqlite3_randomness( 20, &zBuf[j] ); for( i = 0; i < 20; i++, j++ ){ zBuf[j] = (char)zChars[ ((unsigned char)zBuf[j])%(sizeof(zChars)-1) ]; } zBuf[j] = 0; OSTRACE2( "TEMP FILENAME: %s\n", zBuf ); return SQLITE_OK; } static int os2FullPathname( sqlite3_vfs *pVfs, const char *zRelative, int nFull, char *zFull ){ char *zRelativeCp = convertUtf8PathToCp( zRelative ); char zFullCp[CCHMAXPATH] = "\0"; char *zFullUTF; APIRET rc = DosQueryPathInfo( zRelativeCp, FIL_QUERYFULLNAME, zFullCp, CCHMAXPATH ); free( zRelativeCp ); zFullUTF = convertCpPathToUtf8( zFullCp ); sqlite3_snprintf( nFull, zFull, zFullUTF ); free( zFullUTF ); return rc == NO_ERROR ? SQLITE_OK : SQLITE_IOERR; } static int os2Open( sqlite3_vfs *pVfs, const char *zName, sqlite3_file *id, int flags, int *pOutFlags ){ HFILE h; ULONG ulFileAttribute = FILE_NORMAL; ULONG ulOpenFlags = 0; ULONG ulOpenMode = 0; os2File *pFile = (os2File*)id; APIRET rc = NO_ERROR; ULONG ulAction; char *zNameCp; char zTmpname[CCHMAXPATH+1]; if( !zName ){ int rc = getTempname(CCHMAXPATH+1, zTmpname); if( rc!=SQLITE_OK ){ return rc; } zName = zTmpname; } memset( pFile, 0, sizeof(*pFile) ); OSTRACE2( "OPEN want %d\n", flags ); if( flags & SQLITE_OPEN_READWRITE ){ ulOpenMode |= OPEN_ACCESS_READWRITE; OSTRACE1( "OPEN read/write\n" ); }else{ ulOpenMode |= OPEN_ACCESS_READONLY; OSTRACE1( "OPEN read only\n" ); } if( flags & SQLITE_OPEN_CREATE ){ ulOpenFlags |= OPEN_ACTION_OPEN_IF_EXISTS | OPEN_ACTION_CREATE_IF_NEW; OSTRACE1( "OPEN open new/create\n" ); }else{ ulOpenFlags |= OPEN_ACTION_OPEN_IF_EXISTS | OPEN_ACTION_FAIL_IF_NEW; OSTRACE1( "OPEN open existing\n" ); } if( flags & SQLITE_OPEN_MAIN_DB ){ ulOpenMode |= OPEN_SHARE_DENYNONE; OSTRACE1( "OPEN share read/write\n" ); }else{ ulOpenMode |= OPEN_SHARE_DENYWRITE; OSTRACE1( "OPEN share read only\n" ); } if( flags & SQLITE_OPEN_DELETEONCLOSE ){ char pathUtf8[CCHMAXPATH]; 
#ifdef NDEBUG 
 ulFileAttribute = FILE_HIDDEN; 
#endif 
 os2FullPathname( pVfs, zName, CCHMAXPATH, pathUtf8 ); pFile->pathToDel = convertUtf8PathToCp( pathUtf8 ); OSTRACE1( "OPEN hidden/delete on close file attributes\n" ); }else{ pFile->pathToDel = NULL; OSTRACE1( "OPEN normal file attribute\n" ); } ulOpenMode |= OPEN_FLAGS_RANDOM; ulOpenMode |= OPEN_FLAGS_FAIL_ON_ERROR; ulOpenMode |= OPEN_FLAGS_NOINHERIT; zNameCp = convertUtf8PathToCp( zName ); rc = DosOpen( (PSZ)zNameCp, &h, &ulAction, 0L, ulFileAttribute, ulOpenFlags, ulOpenMode, (PEAOP2)NULL ); free( zNameCp ); if( rc != NO_ERROR ){ OSTRACE7( "OPEN Invalid handle rc=%d: zName=%s, ulAction=%#lx, ulAttr=%#lx, ulFlags=%#lx, ulMode=%#lx\n", rc, zName, ulAction, ulFileAttribute, ulOpenFlags, ulOpenMode ); if( pFile->pathToDel ) free( pFile->pathToDel ); pFile->pathToDel = NULL; if( flags & SQLITE_OPEN_READWRITE ){ OSTRACE2( "OPEN %d Invalid handle\n", ((flags | SQLITE_OPEN_READONLY) & ~SQLITE_OPEN_READWRITE) ); return os2Open( pVfs, zName, id, ((flags | SQLITE_OPEN_READONLY) & ~SQLITE_OPEN_READWRITE), pOutFlags ); }else{ return SQLITE_CANTOPEN; } } if( pOutFlags ){ *pOutFlags = flags & SQLITE_OPEN_READWRITE ? SQLITE_OPEN_READWRITE : SQLITE_OPEN_READONLY; } pFile->pMethod = &os2IoMethod; pFile->h = h; OpenCounter(+1); OSTRACE3( "OPEN %d pOutFlags=%d\n", pFile->h, pOutFlags ); return SQLITE_OK; } static int os2Delete( sqlite3_vfs *pVfs, const char *zFilename, int syncDir ){ APIRET rc = NO_ERROR; char *zFilenameCp = convertUtf8PathToCp( zFilename ); SimulateIOError( return SQLITE_IOERR_DELETE ); rc = DosDelete( (PSZ)zFilenameCp ); free( zFilenameCp ); OSTRACE2( "DELETE \"%s\"\n", zFilename ); return rc == NO_ERROR ? SQLITE_OK : SQLITE_IOERR_DELETE; } static int os2Access( sqlite3_vfs *pVfs, const char *zFilename, int flags, int *pOut ){ FILESTATUS3 fsts3ConfigInfo; APIRET rc = NO_ERROR; char *zFilenameCp = convertUtf8PathToCp( zFilename ); memset( &fsts3ConfigInfo, 0, sizeof(fsts3ConfigInfo) ); rc = DosQueryPathInfo( (PSZ)zFilenameCp, FIL_STANDARD, &fsts3ConfigInfo, sizeof(FILESTATUS3) ); free( zFilenameCp ); OSTRACE4( "ACCESS fsts3ConfigInfo.attrFile=%d flags=%d rc=%d\n", fsts3ConfigInfo.attrFile, flags, rc ); switch( flags ){ case SQLITE_ACCESS_READ: case SQLITE_ACCESS_EXISTS: rc = (rc == NO_ERROR); OSTRACE3( "ACCESS %s access of read and exists rc=%d\n", zFilename, rc ); break; case SQLITE_ACCESS_READWRITE: rc = (rc == NO_ERROR) && ( (fsts3ConfigInfo.attrFile & FILE_READONLY) == 0 ); OSTRACE3( "ACCESS %s access of read/write rc=%d\n", zFilename, rc ); break; default: assert( !"Invalid flags argument" ); } *pOut = rc; return SQLITE_OK; } 
#ifndef SQLITE_OMIT_LOAD_EXTENSION 
static void *os2DlOpen(sqlite3_vfs *pVfs, const char *zFilename){ UCHAR loadErr[256]; HMODULE hmod; APIRET rc; char *zFilenameCp = convertUtf8PathToCp(zFilename); rc = DosLoadModule((PSZ)loadErr, sizeof(loadErr), zFilenameCp, &hmod); free(zFilenameCp); return rc != NO_ERROR ? 0 : (void*)hmod; } static void os2DlError(sqlite3_vfs *pVfs, int nBuf, char *zBufOut){ } static void *os2DlSym(sqlite3_vfs *pVfs, void *pHandle, const char *zSymbol){ PFN pfn; APIRET rc; rc = DosQueryProcAddr((HMODULE)pHandle, 0L, zSymbol, &pfn); if( rc != NO_ERROR ){ char _zSymbol[256] = "_"; strncat(_zSymbol, zSymbol, 255); rc = DosQueryProcAddr((HMODULE)pHandle, 0L, _zSymbol, &pfn); } return rc != NO_ERROR ? 0 : (void*)pfn; } static void os2DlClose(sqlite3_vfs *pVfs, void *pHandle){ DosFreeModule((HMODULE)pHandle); } 
#else 
#define os2DlOpen 0 
#define os2DlError 0 
#define os2DlSym 0 
#define os2DlClose 0 
#endif 
static int os2Randomness(sqlite3_vfs *pVfs, int nBuf, char *zBuf ){ ULONG sizeofULong = sizeof(ULONG); int n = 0; if( sizeof(DATETIME) <= nBuf - n ){ DATETIME x; DosGetDateTime(&x); memcpy(&zBuf[n], &x, sizeof(x)); n += sizeof(x); } if( sizeofULong <= nBuf - n ){ PPIB ppib; DosGetInfoBlocks(NULL, &ppib); memcpy(&zBuf[n], &ppib->pib_ulpid, sizeofULong); n += sizeofULong; } if( sizeofULong <= nBuf - n ){ PTIB ptib; DosGetInfoBlocks(&ptib, NULL); memcpy(&zBuf[n], &ptib->tib_ptib2->tib2_ultid, sizeofULong); n += sizeofULong; } if( sizeofULong <= nBuf - n ){ ULONG ulSysInfo[QSV_MAX]; DosQuerySysInfo(1L, QSV_MAX, ulSysInfo, sizeofULong * QSV_MAX); memcpy(&zBuf[n], &ulSysInfo[QSV_MS_COUNT - 1], sizeofULong); n += sizeofULong; if( sizeofULong <= nBuf - n ){ memcpy(&zBuf[n], &ulSysInfo[QSV_TIMER_INTERVAL - 1], sizeofULong); n += sizeofULong; } if( sizeofULong <= nBuf - n ){ memcpy(&zBuf[n], &ulSysInfo[QSV_TIME_LOW - 1], sizeofULong); n += sizeofULong; } if( sizeofULong <= nBuf - n ){ memcpy(&zBuf[n], &ulSysInfo[QSV_TIME_HIGH - 1], sizeofULong); n += sizeofULong; } if( sizeofULong <= nBuf - n ){ memcpy(&zBuf[n], &ulSysInfo[QSV_TOTAVAILMEM - 1], sizeofULong); n += sizeofULong; } } return n; } static int os2Sleep( sqlite3_vfs *pVfs, int microsec ){ DosSleep( (microsec/1000) ); return microsec; } 
#ifdef SQLITE_TEST 
SQLITE_API int sqlite3_current_time = 0; 
#endif 
int os2CurrentTime( sqlite3_vfs *pVfs, double *prNow ){ double now; SHORT minute; USHORT second, hour, day, month, year; DATETIME dt; DosGetDateTime( &dt ); second = (USHORT)dt.seconds; minute = (SHORT)dt.minutes + dt.timezone; hour = (USHORT)dt.hours; day = (USHORT)dt.day; month = (USHORT)dt.month; year = (USHORT)dt.year; now = day - 32076 + 1461*(year + 4800 + (month - 14)/12)/4 + 367*(month - 2 - (month - 14)/12*12)/12 - 3*((year + 4900 + (month - 14)/12)/100)/4; now += (hour + 12.0)/24.0; now += minute/1440.0; now += second/86400.0; *prNow = now; 
#ifdef SQLITE_TEST 
 if( sqlite3_current_time ){ *prNow = sqlite3_current_time/86400.0 + 2440587.5; } 
#endif 
 return 0; } static int os2GetLastError(sqlite3_vfs *pVfs, int nBuf, char *zBuf){ return 0; } SQLITE_API int sqlite3_os_init(void){ static sqlite3_vfs os2Vfs = { 1, sizeof(os2File), CCHMAXPATH, 0, "os2", 0, os2Open, os2Delete, os2Access, os2FullPathname, os2DlOpen, os2DlError, os2DlSym, os2DlClose, os2Randomness, os2Sleep, os2CurrentTime, os2GetLastError }; sqlite3_vfs_register(&os2Vfs, 1); initUconvObjects(); return SQLITE_OK; } SQLITE_API int sqlite3_os_end(void){ freeUconvObjects(); return SQLITE_OK; } 
#endif 
#if SQLITE_OS_UNIX 
#if !defined(SQLITE_ENABLE_LOCKING_STYLE) 
#if defined(__DARWIN__) 
#define SQLITE_ENABLE_LOCKING_STYLE 1 
#else 
#define SQLITE_ENABLE_LOCKING_STYLE 0 
#endif 
#endif 
#if defined(__RTP__) || defined(_WRS_KERNEL) 
#define IS_VXWORKS 1 
#else 
#define IS_VXWORKS 0 
#endif 
#ifndef SQLITE_DISABLE_LFS 
#define _LARGE_FILE 1 
#ifndef _FILE_OFFSET_BITS 
#define _FILE_OFFSET_BITS 64 
#endif 
#define _LARGEFILE_SOURCE 1 
#endif 
#include <sys/types.h> 
#include <sys/stat.h> 
#include <fcntl.h> 
#include <unistd.h> 
#include <sys/time.h> 
#include <errno.h> 
#if SQLITE_ENABLE_LOCKING_STYLE 
#include <sys/ioctl.h> 
#if IS_VXWORKS 
#define lstat stat 
#include <semaphore.h> 
#include <limits.h> 
#else 
#include <sys/param.h> 
#include <sys/mount.h> 
#endif 
#endif 
#if SQLITE_THREADSAFE 
#define SQLITE_UNIX_THREADS 1 
#endif 
#ifndef SQLITE_DEFAULT_FILE_PERMISSIONS 
#define SQLITE_DEFAULT_FILE_PERMISSIONS 0644 
#endif 
#define MAX_PATHNAME 512 
typedef struct unixFile unixFile; struct unixFile { sqlite3_io_methods const *pMethod; 
#ifdef SQLITE_TEST 
 char aPadding[32]; 
#endif 
 struct openCnt *pOpen; struct lockInfo *pLock; 
#if SQLITE_ENABLE_LOCKING_STYLE 
 void *lockingContext; 
#endif 
 int h; unsigned char locktype; int dirfd; 
#if SQLITE_THREADSAFE 
 pthread_t tid; 
#endif 
 int lastErrno; 
#if IS_VXWORKS 
 int isDelete; char *zRealpath; 
#endif 
}; 
#ifndef _OS_COMMON_H_ 
#define _OS_COMMON_H_ 
#ifdef MEMORY_DEBUG 
#error "The MEMORY_DEBUG macro is obsolete. Use SQLITE_DEBUG instead." 
#endif 
#ifdef SQLITE_TEST 
SQLITE_API unsigned int sqlite3_pending_byte = 0x40000000; 
#endif 
#ifdef SQLITE_DEBUG 
SQLITE_PRIVATE int sqlite3OSTrace = 0; 
#define OSTRACE1(X) if( sqlite3OSTrace ) sqlite3DebugPrintf(X) 
#define OSTRACE2(X,Y) if( sqlite3OSTrace ) sqlite3DebugPrintf(X,Y) 
#define OSTRACE3(X,Y,Z) if( sqlite3OSTrace ) sqlite3DebugPrintf(X,Y,Z) 
#define OSTRACE4(X,Y,Z,A) if( sqlite3OSTrace ) sqlite3DebugPrintf(X,Y,Z,A) 
#define OSTRACE5(X,Y,Z,A,B) if( sqlite3OSTrace ) sqlite3DebugPrintf(X,Y,Z,A,B) 
#define OSTRACE6(X,Y,Z,A,B,C) if(sqlite3OSTrace) sqlite3DebugPrintf(X,Y,Z,A,B,C) 
#define OSTRACE7(X,Y,Z,A,B,C,D) if(sqlite3OSTrace) sqlite3DebugPrintf(X,Y,Z,A,B,C,D) 
#else 
#define OSTRACE1(X) 
#define OSTRACE2(X,Y) 
#define OSTRACE3(X,Y,Z) 
#define OSTRACE4(X,Y,Z,A) 
#define OSTRACE5(X,Y,Z,A,B) 
#define OSTRACE6(X,Y,Z,A,B,C) 
#define OSTRACE7(X,Y,Z,A,B,C,D) 
#endif 
#ifdef SQLITE_PERFORMANCE_TRACE 
#ifndef _HWTIME_H_ 
#define _HWTIME_H_ 
#if (defined(__GNUC__) || defined(_MSC_VER)) && (defined(i386) || defined(__i386__) || defined(_M_IX86)) 
#if defined(__GNUC__) 
 __inline__ sqlite_uint64 sqlite3Hwtime(void){ unsigned int lo, hi; __asm__ __volatile__ ("rdtsc" : "=a" (lo), "=d" (hi)); return (sqlite_uint64)hi << 32 | lo; } 
#elif defined(_MSC_VER) 
 __declspec(naked) __inline sqlite_uint64 __cdecl sqlite3Hwtime(void){ __asm { rdtsc ret ; return value at EDX:EAX } } 
#endif 
#elif (defined(__GNUC__) && defined(__x86_64__)) 
 __inline__ sqlite_uint64 sqlite3Hwtime(void){ unsigned long val; __asm__ __volatile__ ("rdtsc" : "=A" (val)); return val; } 
#elif (defined(__GNUC__) && defined(__ppc__)) 
 __inline__ sqlite_uint64 sqlite3Hwtime(void){ unsigned long long retval; unsigned long junk; __asm__ __volatile__ ("\n 1: mftbu %1\n mftb %L0\n mftbu %0\n cmpw %0,%1\n bne 1b" : "=r" (retval), "=r" (junk)); return retval; } 
#else 
#error Need implementation of sqlite3Hwtime() for your platform. 
 SQLITE_PRIVATE sqlite_uint64 sqlite3Hwtime(void){ return ((sqlite_uint64)0); } 
#endif 
#endif 
static sqlite_uint64 g_start; static sqlite_uint64 g_elapsed; 
#define TIMER_START g_start=sqlite3Hwtime() 
#define TIMER_END g_elapsed=sqlite3Hwtime()-g_start 
#define TIMER_ELAPSED g_elapsed 
#else 
#define TIMER_START 
#define TIMER_END 
#define TIMER_ELAPSED ((sqlite_uint64)0) 
#endif 
#ifdef SQLITE_TEST 
SQLITE_API int sqlite3_io_error_hit = 0; SQLITE_API int sqlite3_io_error_hardhit = 0; SQLITE_API int sqlite3_io_error_pending = 0; SQLITE_API int sqlite3_io_error_persist = 0; SQLITE_API int sqlite3_io_error_benign = 0; SQLITE_API int sqlite3_diskfull_pending = 0; SQLITE_API int sqlite3_diskfull = 0; 
#define SimulateIOErrorBenign(X) sqlite3_io_error_benign=(X) 
#define SimulateIOError(CODE) if( (sqlite3_io_error_persist && sqlite3_io_error_hit) || sqlite3_io_error_pending-- == 1 ) { local_ioerr(); CODE; } 
static void local_ioerr(){ IOTRACE(("IOERR\n")); sqlite3_io_error_hit++; if( !sqlite3_io_error_benign ) sqlite3_io_error_hardhit++; } 
#define SimulateDiskfullError(CODE) if( sqlite3_diskfull_pending ){ if( sqlite3_diskfull_pending == 1 ){ local_ioerr(); sqlite3_diskfull = 1; sqlite3_io_error_hit = 1; CODE; }else{ sqlite3_diskfull_pending--; } } 
#else 
#define SimulateIOErrorBenign(X) 
#define SimulateIOError(A) 
#define SimulateDiskfullError(A) 
#endif 
#ifdef SQLITE_TEST 
SQLITE_API int sqlite3_open_file_count = 0; 
#define OpenCounter(X) sqlite3_open_file_count+=(X) 
#else 
#define OpenCounter(X) 
#endif 
#endif 
#ifndef O_LARGEFILE 
#define O_LARGEFILE 0 
#endif 
#ifdef SQLITE_DISABLE_LFS 
#undef O_LARGEFILE 
#define O_LARGEFILE 0 
#endif 
#ifndef O_NOFOLLOW 
#define O_NOFOLLOW 0 
#endif 
#ifndef O_BINARY 
#define O_BINARY 0 
#endif 
#ifdef __DJGPP__ 
#define fcntl(A,B,C) 0 
#endif 
#if SQLITE_THREADSAFE 
#define threadid pthread_self() 
#else 
#define threadid 0 
#endif 
#if SQLITE_THREADSAFE 
#define SET_THREADID(X) (X)->tid = pthread_self() 
#define CHECK_THREADID(X) (threadsOverrideEachOthersLocks==0 && !pthread_equal((X)->tid, pthread_self())) 
#else 
#define SET_THREADID(X) 
#define CHECK_THREADID(X) 0 
#endif 
struct lockKey { dev_t dev; 
#if IS_VXWORKS 
 void *rnam; 
#else 
 ino_t ino; 
#endif 
#if SQLITE_THREADSAFE 
 pthread_t tid; 
#endif 
}; struct lockInfo { struct lockKey key; int cnt; int locktype; int nRef; struct lockInfo *pNext, *pPrev; }; struct openKey { dev_t dev; 
#if IS_VXWORKS 
 void *rnam; 
#else 
 ino_t ino; 
#endif 
}; struct openCnt { struct openKey key; int nRef; int nLock; int nPending; int *aPending; 
#if IS_VXWORKS 
 sem_t *pSem; char aSemName[MAX_PATHNAME+1]; 
#endif 
 struct openCnt *pNext, *pPrev; }; static struct lockInfo *lockList = 0; static struct openCnt *openList = 0; 
#if IS_VXWORKS 
static Hash nameHash; 
#endif 
#define LOCKING_STYLE_POSIX 1 
#define LOCKING_STYLE_NONE 2 
#define LOCKING_STYLE_DOTFILE 3 
#define LOCKING_STYLE_FLOCK 4 
#define LOCKING_STYLE_AFP 5 
#define LOCKING_STYLE_NAMEDSEM 6 
#define IS_LOCK_ERROR(x) ((x != SQLITE_OK) && (x != SQLITE_BUSY)) 
static void enterMutex(void){ sqlite3_mutex_enter(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER)); } static void leaveMutex(void){ sqlite3_mutex_leave(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER)); } 
#if SQLITE_THREADSAFE 
#ifndef SQLITE_THREAD_OVERRIDE_LOCK 
#define SQLITE_THREAD_OVERRIDE_LOCK -1 
#endif 
#ifdef SQLITE_TEST 
int threadsOverrideEachOthersLocks = SQLITE_THREAD_OVERRIDE_LOCK; 
#else 
static int threadsOverrideEachOthersLocks = SQLITE_THREAD_OVERRIDE_LOCK; 
#endif 
struct threadTestData { int fd; struct flock lock; int result; }; 
#ifdef SQLITE_LOCK_TRACE 
static int lockTrace(int fd, int op, struct flock *p){ char *zOpName, *zType; int s; int savedErrno; if( op==F_GETLK ){ zOpName = "GETLK"; }else if( op==F_SETLK ){ zOpName = "SETLK"; }else{ s = fcntl(fd, op, p); sqlite3DebugPrintf("fcntl unknown %d %d %d\n", fd, op, s); return s; } if( p->l_type==F_RDLCK ){ zType = "RDLCK"; }else if( p->l_type==F_WRLCK ){ zType = "WRLCK"; }else if( p->l_type==F_UNLCK ){ zType = "UNLCK"; }else{ assert( 0 ); } assert( p->l_whence==SEEK_SET ); s = fcntl(fd, op, p); savedErrno = errno; sqlite3DebugPrintf("fcntl %d %d %s %s %d %d %d %d\n", threadid, fd, zOpName, zType, (int)p->l_start, (int)p->l_len, (int)p->l_pid, s); if( s==(-1) && op==F_SETLK && (p->l_type==F_RDLCK || p->l_type==F_WRLCK) ){ struct flock l2; l2 = *p; fcntl(fd, F_GETLK, &l2); if( l2.l_type==F_RDLCK ){ zType = "RDLCK"; }else if( l2.l_type==F_WRLCK ){ zType = "WRLCK"; }else if( l2.l_type==F_UNLCK ){ zType = "UNLCK"; }else{ assert( 0 ); } sqlite3DebugPrintf("fcntl-failure-reason: %s %d %d %d\n", zType, (int)l2.l_start, (int)l2.l_len, (int)l2.l_pid); } errno = savedErrno; return s; } 
#define fcntl lockTrace 
#endif 
#ifdef __linux__ 
 static void *threadLockingTest(void *pArg){ struct threadTestData *pData = (struct threadTestData*)pArg; pData->result = fcntl(pData->fd, F_GETLK, &pData->lock); return pArg; } static void testThreadLockingBehavior(int fd_orig){ int fd; int rc; struct threadTestData d; struct flock l; pthread_t t; fd = dup(fd_orig); if( fd<0 ) return; memset(&l, 0, sizeof(l)); l.l_type = F_RDLCK; l.l_len = 1; l.l_start = 0; l.l_whence = SEEK_SET; rc = fcntl(fd_orig, F_SETLK, &l); if( rc!=0 ) return; memset(&d, 0, sizeof(d)); d.fd = fd; d.lock = l; d.lock.l_type = F_WRLCK; pthread_create(&t, 0, threadLockingTest, &d); pthread_join(t, 0); close(fd); if( d.result!=0 ) return; threadsOverrideEachOthersLocks = (d.lock.l_type==F_UNLCK); } 
#else 
static void testThreadLockingBehavior(int fd_orig){ threadsOverrideEachOthersLocks = 1; } 
#endif 
#endif 
static void releaseLockInfo(struct lockInfo *pLock){ if( pLock ){ pLock->nRef--; if( pLock->nRef==0 ){ if( pLock->pPrev ){ assert( pLock->pPrev->pNext==pLock ); pLock->pPrev->pNext = pLock->pNext; }else{ assert( lockList==pLock ); lockList = pLock->pNext; } if( pLock->pNext ){ assert( pLock->pNext->pPrev==pLock ); pLock->pNext->pPrev = pLock->pPrev; } sqlite3_free(pLock); } } } static void releaseOpenCnt(struct openCnt *pOpen){ if( pOpen ){ pOpen->nRef--; if( pOpen->nRef==0 ){ if( pOpen->pPrev ){ assert( pOpen->pPrev->pNext==pOpen ); pOpen->pPrev->pNext = pOpen->pNext; }else{ assert( openList==pOpen ); openList = pOpen->pNext; } if( pOpen->pNext ){ assert( pOpen->pNext->pPrev==pOpen ); pOpen->pNext->pPrev = pOpen->pPrev; } sqlite3_free(pOpen->aPending); sqlite3_free(pOpen); } } } 
#if IS_VXWORKS 
char * vxrealpath(const char *pathname, int dostat) { struct stat sbuf; int len; char *where, *ptr, *last; char *result, *curpath, *workpath, *namebuf; len = pathconf(pathname, _PC_PATH_MAX); if( len<0 ){ len = PATH_MAX; } result = sqlite3_malloc(len * 4); if( !result ){ return 0; } curpath = result + len; workpath = curpath + len; namebuf = workpath + len; strcpy(curpath, pathname); if( *pathname!='/' ){ if( !getcwd(workpath, len) ){ sqlite3_free(result); return 0; } }else{ *workpath = '\0'; } where = curpath; while( *where ){ if( !strcmp(where, ".") ){ where++; continue; } if( !strncmp(where, "./", 2) ){ where += 2; continue; } if( !strncmp(where, "../", 3) ){ where += 3; ptr = last = workpath; while( *ptr ){ if( *ptr=='/' ){ last = ptr; } ptr++; } *last = '\0'; continue; } ptr = strchr(where, '/'); if( !ptr ){ ptr = where + strlen(where) - 1; }else{ *ptr = '\0'; } strcpy(namebuf, workpath); for( last = namebuf; *last; last++ ){ continue; } if( *--last!='/' ){ strcat(namebuf, "/"); } strcat(namebuf, where); where = ++ptr; if( dostat ){ if( stat(namebuf, &sbuf)==-1 ){ sqlite3_free(result); return 0; } if( (sbuf.st_mode & S_IFDIR)==S_IFDIR ){ strcpy(workpath, namebuf); continue; } if( *where ){ sqlite3_free(result); return 0; } } strcpy(workpath, namebuf); } strcpy(result, workpath); return result; } 
#endif 
#if SQLITE_ENABLE_LOCKING_STYLE 
static int testLockingStyle(int fd){ struct flock lockInfo; lockInfo.l_len = 1; lockInfo.l_start = 0; lockInfo.l_whence = SEEK_SET; lockInfo.l_type = F_RDLCK; if( fcntl(fd, F_GETLK, &lockInfo)!=-1 ) { return LOCKING_STYLE_POSIX; } return (IS_VXWORKS ? LOCKING_STYLE_NAMEDSEM : LOCKING_STYLE_DOTFILE); } 
#endif 
#if SQLITE_ENABLE_LOCKING_STYLE 
static int detectLockingStyle( sqlite3_vfs *pVfs, const char *filePath, int fd ){ 
#if IS_VXWORKS 
 if( !filePath ){ return LOCKING_STYLE_NONE; } if( pVfs->pAppData ){ return SQLITE_PTR_TO_INT(pVfs->pAppData); } if (access(filePath, 0) != -1){ return testLockingStyle(fd); } 
#else 
 struct Mapping { const char *zFilesystem; int eLockingStyle; } aMap[] = { { "hfs", LOCKING_STYLE_POSIX }, { "ufs", LOCKING_STYLE_POSIX }, { "afpfs", LOCKING_STYLE_AFP }, 
#ifdef SQLITE_ENABLE_AFP_LOCKING_SMB 
 { "smbfs", LOCKING_STYLE_AFP }, 
#else 
 { "smbfs", LOCKING_STYLE_FLOCK }, 
#endif 
 { "msdos", LOCKING_STYLE_DOTFILE }, { "webdav", LOCKING_STYLE_NONE }, { 0, 0 } }; int i; struct statfs fsInfo; if( !filePath ){ return LOCKING_STYLE_NONE; } if( pVfs->pAppData ){ return SQLITE_PTR_TO_INT(pVfs->pAppData); } if( statfs(filePath, &fsInfo) != -1 ){ if( fsInfo.f_flags & MNT_RDONLY ){ return LOCKING_STYLE_NONE; } for(i=0; aMap[i].zFilesystem; i++){ if( strcmp(fsInfo.f_fstypename, aMap[i].zFilesystem)==0 ){ return aMap[i].eLockingStyle; } } } return testLockingStyle(fd); 
#endif 
 return LOCKING_STYLE_POSIX; } 
#else 
#define detectLockingStyle(x,y,z) LOCKING_STYLE_POSIX 
#endif 
static int findLockInfo( int fd, 
#if IS_VXWORKS 
 void *rnam, 
#endif 
 struct lockInfo **ppLock, struct openCnt **ppOpen ){ int rc; struct lockKey key1; struct openKey key2; struct stat statbuf; struct lockInfo *pLock; struct openCnt *pOpen; rc = fstat(fd, &statbuf); if( rc!=0 ){ 
#ifdef EOVERFLOW 
 if( errno==EOVERFLOW ) return SQLITE_NOLFS; 
#endif 
 return SQLITE_IOERR; } if( statbuf.st_size==0 ){ write(fd, "S", 1); rc = fstat(fd, &statbuf); if( rc!=0 ){ return SQLITE_IOERR; } } memset(&key1, 0, sizeof(key1)); key1.dev = statbuf.st_dev; 
#if IS_VXWORKS 
 key1.rnam = rnam; 
#else 
 key1.ino = statbuf.st_ino; 
#endif 
#if SQLITE_THREADSAFE 
 if( threadsOverrideEachOthersLocks<0 ){ testThreadLockingBehavior(fd); } key1.tid = threadsOverrideEachOthersLocks ? 0 : pthread_self(); 
#endif 
 memset(&key2, 0, sizeof(key2)); key2.dev = statbuf.st_dev; 
#if IS_VXWORKS 
 key2.rnam = rnam; 
#else 
 key2.ino = statbuf.st_ino; 
#endif 
 pLock = lockList; while( pLock && memcmp(&key1, &pLock->key, sizeof(key1)) ){ pLock = pLock->pNext; } if( pLock==0 ){ pLock = sqlite3_malloc( sizeof(*pLock) ); if( pLock==0 ){ rc = SQLITE_NOMEM; goto exit_findlockinfo; } pLock->key = key1; pLock->nRef = 1; pLock->cnt = 0; pLock->locktype = 0; pLock->pNext = lockList; pLock->pPrev = 0; if( lockList ) lockList->pPrev = pLock; lockList = pLock; }else{ pLock->nRef++; } *ppLock = pLock; if( ppOpen!=0 ){ pOpen = openList; while( pOpen && memcmp(&key2, &pOpen->key, sizeof(key2)) ){ pOpen = pOpen->pNext; } if( pOpen==0 ){ pOpen = sqlite3_malloc( sizeof(*pOpen) ); if( pOpen==0 ){ releaseLockInfo(pLock); rc = SQLITE_NOMEM; goto exit_findlockinfo; } pOpen->key = key2; pOpen->nRef = 1; pOpen->nLock = 0; pOpen->nPending = 0; pOpen->aPending = 0; pOpen->pNext = openList; pOpen->pPrev = 0; if( openList ) openList->pPrev = pOpen; openList = pOpen; 
#if IS_VXWORKS 
 pOpen->pSem = NULL; pOpen->aSemName[0] = '\0'; 
#endif 
 }else{ pOpen->nRef++; } *ppOpen = pOpen; } exit_findlockinfo: return rc; } 
#ifdef SQLITE_DEBUG 
static const char *locktypeName(int locktype){ switch( locktype ){ case NO_LOCK: return "NONE"; case SHARED_LOCK: return "SHARED"; case RESERVED_LOCK: return "RESERVED"; case PENDING_LOCK: return "PENDING"; case EXCLUSIVE_LOCK: return "EXCLUSIVE"; } return "ERROR"; } 
#endif 
#if SQLITE_THREADSAFE 
static int transferOwnership(unixFile *pFile){ int rc; pthread_t hSelf; if( threadsOverrideEachOthersLocks ){ return SQLITE_OK; } hSelf = pthread_self(); if( pthread_equal(pFile->tid, hSelf) ){ OSTRACE1("No-transfer, same thread\n"); return SQLITE_OK; } if( pFile->locktype!=NO_LOCK ){ return SQLITE_MISUSE; } OSTRACE4("Transfer ownership of %d from %d to %d\n", pFile->h, pFile->tid, hSelf); pFile->tid = hSelf; if (pFile->pLock != NULL) { releaseLockInfo(pFile->pLock); 
#if IS_VXWORKS 
 rc = findLockInfo(pFile->h, pFile->zRealpath, &pFile->pLock, 0); 
#else 
 rc = findLockInfo(pFile->h, &pFile->pLock, 0); 
#endif 
 OSTRACE5("LOCK %d is now %s(%s,%d)\n", pFile->h, locktypeName(pFile->locktype), locktypeName(pFile->pLock->locktype), pFile->pLock->cnt); return rc; } else { return SQLITE_OK; } } 
#else 
 
#define transferOwnership(X) SQLITE_OK 
#endif 
static int seekAndRead(unixFile *id, sqlite3_int64 offset, void *pBuf, int cnt){ int got; i64 newOffset; TIMER_START; 
#if defined(USE_PREAD) 
 got = pread(id->h, pBuf, cnt, offset); SimulateIOError( got = -1 ); 
#elif defined(USE_PREAD64) 
 got = pread64(id->h, pBuf, cnt, offset); SimulateIOError( got = -1 ); 
#else 
 newOffset = lseek(id->h, offset, SEEK_SET); SimulateIOError( newOffset-- ); if( newOffset!=offset ){ return -1; } got = read(id->h, pBuf, cnt); 
#endif 
 TIMER_END; OSTRACE5("READ %-3d %5d %7lld %llu\n", id->h, got, offset, TIMER_ELAPSED); return got; } static int unixRead( sqlite3_file *id, void *pBuf, int amt, sqlite3_int64 offset ){ int got; assert( id ); got = seekAndRead((unixFile*)id, offset, pBuf, amt); if( got==amt ){ return SQLITE_OK; }else if( got<0 ){ return SQLITE_IOERR_READ; }else{ memset(&((char*)pBuf)[got], 0, amt-got); return SQLITE_IOERR_SHORT_READ; } } static int seekAndWrite(unixFile *id, i64 offset, const void *pBuf, int cnt){ int got; i64 newOffset; TIMER_START; 
#if defined(USE_PREAD) 
 got = pwrite(id->h, pBuf, cnt, offset); 
#elif defined(USE_PREAD64) 
 got = pwrite64(id->h, pBuf, cnt, offset); 
#else 
 newOffset = lseek(id->h, offset, SEEK_SET); if( newOffset!=offset ){ return -1; } got = write(id->h, pBuf, cnt); 
#endif 
 TIMER_END; OSTRACE5("WRITE %-3d %5d %7lld %llu\n", id->h, got, offset, TIMER_ELAPSED); return got; } static int unixWrite( sqlite3_file *id, const void *pBuf, int amt, sqlite3_int64 offset ){ int wrote = 0; assert( id ); assert( amt>0 ); while( amt>0 && (wrote = seekAndWrite((unixFile*)id, offset, pBuf, amt))>0 ){ amt -= wrote; offset += wrote; pBuf = &((char*)pBuf)[wrote]; } SimulateIOError(( wrote=(-1), amt=1 )); SimulateDiskfullError(( wrote=0, amt=1 )); if( amt>0 ){ if( wrote<0 ){ return SQLITE_IOERR_WRITE; }else{ return SQLITE_FULL; } } return SQLITE_OK; } 
#ifdef SQLITE_TEST 
SQLITE_API int sqlite3_sync_count = 0; SQLITE_API int sqlite3_fullsync_count = 0; 
#endif 
#ifndef HAVE_FDATASYNC 
#define fdatasync fsync 
#endif 
#ifdef F_FULLFSYNC 
#define HAVE_FULLFSYNC 1 
#else 
#define HAVE_FULLFSYNC 0 
#endif 
static int full_fsync(int fd, int fullSync, int dataOnly){ int rc; 
#ifdef SQLITE_NO_SYNC 
 UNUSED_PARAMETER(fd); UNUSED_PARAMETER(fullSync); UNUSED_PARAMETER(dataOnly); 
#elif HAVE_FULLFSYNC 
 UNUSED_PARAMETER(dataOnly); 
#else 
 UNUSED_PARAMETER(fullSync); 
#endif 
 
#ifdef SQLITE_TEST 
 if( fullSync ) sqlite3_fullsync_count++; sqlite3_sync_count++; 
#endif 
 
#ifdef SQLITE_NO_SYNC 
 rc = SQLITE_OK; 
#elif HAVE_FULLFSYNC 
 if( fullSync ){ rc = fcntl(fd, F_FULLFSYNC, 0); }else{ rc = 1; } if( rc ) rc = fsync(fd); 
#else 
 if( dataOnly ){ rc = fdatasync(fd); if( IS_VXWORKS && rc==-1 && errno==ENOTSUP ){ rc = fsync(fd); } }else{ rc = fsync(fd); } 
#endif 
 if( IS_VXWORKS && rc!= -1 ){ rc = 0; } return rc; } static int unixSync(sqlite3_file *id, int flags){ int rc; unixFile *pFile = (unixFile*)id; int isDataOnly = (flags&SQLITE_SYNC_DATAONLY); int isFullsync = (flags&0x0F)==SQLITE_SYNC_FULL; assert((flags&0x0F)==SQLITE_SYNC_NORMAL || (flags&0x0F)==SQLITE_SYNC_FULL ); SimulateDiskfullError( return SQLITE_FULL ); assert( pFile ); OSTRACE2("SYNC %-3d\n", pFile->h); rc = full_fsync(pFile->h, isFullsync, isDataOnly); SimulateIOError( rc=1 ); if( rc ){ return SQLITE_IOERR_FSYNC; } if( pFile->dirfd>=0 ){ OSTRACE4("DIRSYNC %-3d (have_fullfsync=%d fullsync=%d)\n", pFile->dirfd, HAVE_FULLFSYNC, isFullsync); 
#ifndef SQLITE_DISABLE_DIRSYNC 
 if( (!HAVE_FULLFSYNC || !isFullsync) && full_fsync(pFile->dirfd,0,0) ){ } 
#endif 
 close(pFile->dirfd); pFile->dirfd = -1; } return SQLITE_OK; } static int unixTruncate(sqlite3_file *id, i64 nByte){ int rc; assert( id ); SimulateIOError( return SQLITE_IOERR_TRUNCATE ); rc = ftruncate(((unixFile*)id)->h, (off_t)nByte); if( rc ){ return SQLITE_IOERR_TRUNCATE; }else{ return SQLITE_OK; } } static int unixFileSize(sqlite3_file *id, i64 *pSize){ int rc; struct stat buf; assert( id ); rc = fstat(((unixFile*)id)->h, &buf); SimulateIOError( rc=1 ); if( rc!=0 ){ return SQLITE_IOERR_FSTAT; } *pSize = buf.st_size; if( *pSize==1 ) *pSize = 0; return SQLITE_OK; } static int sqliteErrorFromPosixError(int posixError, int sqliteIOErr) { switch (posixError) { case 0: return SQLITE_OK; case EAGAIN: case ETIMEDOUT: case EBUSY: case EINTR: case ENOLCK: return SQLITE_BUSY; case EACCES: if( (sqliteIOErr == SQLITE_IOERR_LOCK) || (sqliteIOErr == SQLITE_IOERR_UNLOCK) || (sqliteIOErr == SQLITE_IOERR_RDLOCK) || (sqliteIOErr == SQLITE_IOERR_CHECKRESERVEDLOCK) ){ return SQLITE_BUSY; } case EPERM: return SQLITE_PERM; case EDEADLK: return SQLITE_IOERR_BLOCKED; 
#if EOPNOTSUPP!=ENOTSUP 
 case EOPNOTSUPP: 
#endif 
#ifdef ENOTSUP 
 case ENOTSUP: 
#endif 
 case EIO: case EBADF: case EINVAL: case ENOTCONN: case ENODEV: case ENXIO: case ENOENT: case ESTALE: case ENOSYS: default: return sqliteIOErr; } } static int unixCheckReservedLock(sqlite3_file *id, int *pResOut){ int rc = SQLITE_OK; int reserved = 0; unixFile *pFile = (unixFile*)id; SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; ); assert( pFile ); enterMutex(); if( pFile->pLock->locktype>SHARED_LOCK ){ reserved = 1; } if( !reserved ){ struct flock lock; lock.l_whence = SEEK_SET; lock.l_start = RESERVED_BYTE; lock.l_len = 1; lock.l_type = F_WRLCK; if (-1 == fcntl(pFile->h, F_GETLK, &lock)) { int tErrno = errno; rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_CHECKRESERVEDLOCK); pFile->lastErrno = tErrno; } else if( lock.l_type!=F_UNLCK ){ reserved = 1; } } leaveMutex(); OSTRACE4("TEST WR-LOCK %d %d %d\n", pFile->h, rc, reserved); *pResOut = reserved; return rc; } static int unixLock(sqlite3_file *id, int locktype){ int rc = SQLITE_OK; unixFile *pFile = (unixFile*)id; struct lockInfo *pLock = pFile->pLock; struct flock lock; int s; assert( pFile ); OSTRACE7("LOCK %d %s was %s(%s,%d) pid=%d\n", pFile->h, locktypeName(locktype), locktypeName(pFile->locktype), locktypeName(pLock->locktype), pLock->cnt , getpid()); if( pFile->locktype>=locktype ){ OSTRACE3("LOCK %d %s ok (already held)\n", pFile->h, locktypeName(locktype)); return SQLITE_OK; } assert( pFile->locktype!=NO_LOCK || locktype==SHARED_LOCK ); assert( locktype!=PENDING_LOCK ); assert( locktype!=RESERVED_LOCK || pFile->locktype==SHARED_LOCK ); enterMutex(); rc = transferOwnership(pFile); if( rc!=SQLITE_OK ){ leaveMutex(); return rc; } pLock = pFile->pLock; if( (pFile->locktype!=pLock->locktype && (pLock->locktype>=PENDING_LOCK || locktype>SHARED_LOCK)) ){ rc = SQLITE_BUSY; goto end_lock; } if( locktype==SHARED_LOCK && (pLock->locktype==SHARED_LOCK || pLock->locktype==RESERVED_LOCK) ){ assert( locktype==SHARED_LOCK ); assert( pFile->locktype==0 ); assert( pLock->cnt>0 ); pFile->locktype = SHARED_LOCK; pLock->cnt++; pFile->pOpen->nLock++; goto end_lock; } lock.l_len = 1L; lock.l_whence = SEEK_SET; if( locktype==SHARED_LOCK || (locktype==EXCLUSIVE_LOCK && pFile->locktype<PENDING_LOCK) ){ lock.l_type = (locktype==SHARED_LOCK?F_RDLCK:F_WRLCK); lock.l_start = PENDING_BYTE; s = fcntl(pFile->h, F_SETLK, &lock); if( s==(-1) ){ int tErrno = errno; rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK); if( IS_LOCK_ERROR(rc) ){ pFile->lastErrno = tErrno; } goto end_lock; } } if( locktype==SHARED_LOCK ){ int tErrno = 0; assert( pLock->cnt==0 ); assert( pLock->locktype==0 ); lock.l_start = SHARED_FIRST; lock.l_len = SHARED_SIZE; if( (s = fcntl(pFile->h, F_SETLK, &lock))==(-1) ){ tErrno = errno; } lock.l_start = PENDING_BYTE; lock.l_len = 1L; lock.l_type = F_UNLCK; if( fcntl(pFile->h, F_SETLK, &lock)!=0 ){ if( s != -1 ){ tErrno = errno; rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_UNLOCK); if( IS_LOCK_ERROR(rc) ){ pFile->lastErrno = tErrno; } goto end_lock; } } if( s==(-1) ){ rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK); if( IS_LOCK_ERROR(rc) ){ pFile->lastErrno = tErrno; } }else{ pFile->locktype = SHARED_LOCK; pFile->pOpen->nLock++; pLock->cnt = 1; } }else if( locktype==EXCLUSIVE_LOCK && pLock->cnt>1 ){ rc = SQLITE_BUSY; }else{ assert( 0!=pFile->locktype ); lock.l_type = F_WRLCK; switch( locktype ){ case RESERVED_LOCK: lock.l_start = RESERVED_BYTE; break; case EXCLUSIVE_LOCK: lock.l_start = SHARED_FIRST; lock.l_len = SHARED_SIZE; break; default: assert(0); } s = fcntl(pFile->h, F_SETLK, &lock); if( s==(-1) ){ int tErrno = errno; rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK); if( IS_LOCK_ERROR(rc) ){ pFile->lastErrno = tErrno; } } } if( rc==SQLITE_OK ){ pFile->locktype = locktype; pLock->locktype = locktype; }else if( locktype==EXCLUSIVE_LOCK ){ pFile->locktype = PENDING_LOCK; pLock->locktype = PENDING_LOCK; } end_lock: leaveMutex(); OSTRACE4("LOCK %d %s %s\n", pFile->h, locktypeName(locktype), rc==SQLITE_OK ? "ok" : "failed"); return rc; } static int unixUnlock(sqlite3_file *id, int locktype){ struct lockInfo *pLock; struct flock lock; int rc = SQLITE_OK; unixFile *pFile = (unixFile*)id; int h; assert( pFile ); OSTRACE7("UNLOCK %d %d was %d(%d,%d) pid=%d\n", pFile->h, locktype, pFile->locktype, pFile->pLock->locktype, pFile->pLock->cnt, getpid()); assert( locktype<=SHARED_LOCK ); if( pFile->locktype<=locktype ){ return SQLITE_OK; } if( CHECK_THREADID(pFile) ){ return SQLITE_MISUSE; } enterMutex(); h = pFile->h; pLock = pFile->pLock; assert( pLock->cnt!=0 ); if( pFile->locktype>SHARED_LOCK ){ assert( pLock->locktype==pFile->locktype ); SimulateIOErrorBenign(1); SimulateIOError( h=(-1) ) SimulateIOErrorBenign(0); if( locktype==SHARED_LOCK ){ lock.l_type = F_RDLCK; lock.l_whence = SEEK_SET; lock.l_start = SHARED_FIRST; lock.l_len = SHARED_SIZE; if( fcntl(h, F_SETLK, &lock)==(-1) ){ int tErrno = errno; rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_RDLOCK); if( IS_LOCK_ERROR(rc) ){ pFile->lastErrno = tErrno; } goto end_unlock; } } lock.l_type = F_UNLCK; lock.l_whence = SEEK_SET; lock.l_start = PENDING_BYTE; lock.l_len = 2L; assert( PENDING_BYTE+1==RESERVED_BYTE ); if( fcntl(h, F_SETLK, &lock)!=(-1) ){ pLock->locktype = SHARED_LOCK; }else{ int tErrno = errno; rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_UNLOCK); if( IS_LOCK_ERROR(rc) ){ pFile->lastErrno = tErrno; } goto end_unlock; } } if( locktype==NO_LOCK ){ struct openCnt *pOpen; pLock->cnt--; if( pLock->cnt==0 ){ lock.l_type = F_UNLCK; lock.l_whence = SEEK_SET; lock.l_start = lock.l_len = 0L; SimulateIOErrorBenign(1); SimulateIOError( h=(-1) ) SimulateIOErrorBenign(0); if( fcntl(h, F_SETLK, &lock)!=(-1) ){ pLock->locktype = NO_LOCK; }else{ int tErrno = errno; rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_UNLOCK); if( IS_LOCK_ERROR(rc) ){ pFile->lastErrno = tErrno; } pLock->cnt = 1; goto end_unlock; } } if( rc==SQLITE_OK ){ pOpen = pFile->pOpen; pOpen->nLock--; assert( pOpen->nLock>=0 ); if( pOpen->nLock==0 && pOpen->nPending>0 ){ int i; for(i=0; i<pOpen->nPending; i++){ close(pOpen->aPending[i]); } sqlite3_free(pOpen->aPending); pOpen->nPending = 0; pOpen->aPending = 0; } } } end_unlock: leaveMutex(); if( rc==SQLITE_OK ) pFile->locktype = locktype; return rc; } static int closeUnixFile(sqlite3_file *id){ unixFile *pFile = (unixFile*)id; if( pFile ){ if( pFile->dirfd>=0 ){ close(pFile->dirfd); } if( pFile->h>=0 ){ close(pFile->h); } 
#if IS_VXWORKS 
 if( pFile->isDelete && pFile->zRealpath ){ unlink(pFile->zRealpath); } if( pFile->zRealpath ){ HashElem *pElem; int n = strlen(pFile->zRealpath) + 1; pElem = sqlite3HashFindElem(&nameHash, pFile->zRealpath, n); if( pElem ){ long cnt = (long)pElem->data; cnt--; if( cnt==0 ){ sqlite3HashInsert(&nameHash, pFile->zRealpath, n, 0); }else{ pElem->data = (void*)cnt; } } } 
#endif 
 OSTRACE2("CLOSE %-3d\n", pFile->h); OpenCounter(-1); memset(pFile, 0, sizeof(unixFile)); } return SQLITE_OK; } static int unixClose(sqlite3_file *id){ if( id ){ unixFile *pFile = (unixFile *)id; unixUnlock(id, NO_LOCK); enterMutex(); if( pFile->pOpen && pFile->pOpen->nLock ){ int *aNew; struct openCnt *pOpen = pFile->pOpen; aNew = sqlite3_realloc(pOpen->aPending, (pOpen->nPending+1)*sizeof(int) ); if( aNew==0 ){ }else{ pOpen->aPending = aNew; pOpen->aPending[pOpen->nPending] = pFile->h; pOpen->nPending++; pFile->h = -1; } } releaseLockInfo(pFile->pLock); releaseOpenCnt(pFile->pOpen); closeUnixFile(id); leaveMutex(); } return SQLITE_OK; } 
#if SQLITE_ENABLE_LOCKING_STYLE 
#if !IS_VXWORKS 
#pragma mark AFP Support 
typedef struct afpLockingContext afpLockingContext; struct afpLockingContext { unsigned long long sharedLockByte; const char *filePath; }; struct ByteRangeLockPB2 { unsigned long long offset; unsigned long long length; unsigned long long retRangeStart; unsigned char unLockFlag; unsigned char startEndFlag; int fd; }; 
#define afpfsByteRangeLock2FSCTL _IOWR('z', 23, struct ByteRangeLockPB2) 
static int _AFPFSSetLock( const char *path, unixFile *pFile, unsigned long long offset, unsigned long long length, int setLockFlag ){ struct ByteRangeLockPB2 pb; int err; pb.unLockFlag = setLockFlag ? 0 : 1; pb.startEndFlag = 0; pb.offset = offset; pb.length = length; pb.fd = pFile->h; OSTRACE5("AFPLOCK setting lock %s for %d in range %llx:%llx\n", (setLockFlag?"ON":"OFF"), pFile->h, offset, length); err = fsctl(path, afpfsByteRangeLock2FSCTL, &pb, 0); if ( err==-1 ) { int rc; int tErrno = errno; OSTRACE4("AFPLOCK failed to fsctl() '%s' %d %s\n", path, tErrno, strerror(tErrno)); rc = sqliteErrorFromPosixError(tErrno, setLockFlag ? SQLITE_IOERR_LOCK : SQLITE_IOERR_UNLOCK); if( IS_LOCK_ERROR(rc) ){ pFile->lastErrno = tErrno; } return rc; } else { return SQLITE_OK; } } static int afpCheckReservedLock(sqlite3_file *id, int *pResOut){ int rc = SQLITE_OK; int reserved = 0; unixFile *pFile = (unixFile*)id; SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; ); assert( pFile ); afpLockingContext *context = (afpLockingContext *) pFile->lockingContext; if( pFile->locktype>SHARED_LOCK ){ reserved = 1; } if( !reserved ){ int lrc = _AFPFSSetLock(context->filePath, pFile, RESERVED_BYTE, 1,1); if( SQLITE_OK==lrc ){ lrc = _AFPFSSetLock(context->filePath, pFile, RESERVED_BYTE, 1, 0); } else { reserved = 1; } if( IS_LOCK_ERROR(lrc) ){ rc=lrc; } } OSTRACE4("TEST WR-LOCK %d %d %d\n", pFile->h, rc, reserved); *pResOut = reserved; return rc; } static int afpLock(sqlite3_file *id, int locktype){ int rc = SQLITE_OK; unixFile *pFile = (unixFile*)id; afpLockingContext *context = (afpLockingContext *) pFile->lockingContext; assert( pFile ); OSTRACE5("LOCK %d %s was %s pid=%d\n", pFile->h, locktypeName(locktype), locktypeName(pFile->locktype), getpid()); if( pFile->locktype>=locktype ){ OSTRACE3("LOCK %d %s ok (already held)\n", pFile->h, locktypeName(locktype)); return SQLITE_OK; } assert( pFile->locktype!=NO_LOCK || locktype==SHARED_LOCK ); assert( locktype!=PENDING_LOCK ); assert( locktype!=RESERVED_LOCK || pFile->locktype==SHARED_LOCK ); enterMutex(); rc = transferOwnership(pFile); if( rc!=SQLITE_OK ){ leaveMutex(); return rc; } if( locktype==SHARED_LOCK || (locktype==EXCLUSIVE_LOCK && pFile->locktype<PENDING_LOCK) ){ int failed; failed = _AFPFSSetLock(context->filePath, pFile, PENDING_BYTE, 1, 1); if (failed) { rc = failed; goto afp_end_lock; } } if( locktype==SHARED_LOCK ){ int lk, lrc1, lrc2, lrc1Errno; lk = random(); context->sharedLockByte = (lk & 0x7fffffff)%(SHARED_SIZE - 1); lrc1 = _AFPFSSetLock(context->filePath, pFile, SHARED_FIRST+context->sharedLockByte, 1, 1); if( IS_LOCK_ERROR(lrc1) ){ lrc1Errno = pFile->lastErrno; } lrc2 = _AFPFSSetLock(context->filePath, pFile, PENDING_BYTE, 1, 0); if( IS_LOCK_ERROR(lrc1) ) { pFile->lastErrno = lrc1Errno; rc = lrc1; goto afp_end_lock; } else if( IS_LOCK_ERROR(lrc2) ){ rc = lrc2; goto afp_end_lock; } else if( lrc1 != SQLITE_OK ) { rc = lrc1; } else { pFile->locktype = SHARED_LOCK; } }else{ int failed = 0; assert( 0!=pFile->locktype ); if (locktype >= RESERVED_LOCK && pFile->locktype < RESERVED_LOCK) { failed = _AFPFSSetLock(context->filePath, pFile, RESERVED_BYTE, 1,1); } if (!failed && locktype == EXCLUSIVE_LOCK) { if (!(failed = _AFPFSSetLock(context->filePath, pFile, SHARED_FIRST + context->sharedLockByte, 1, 0))) { failed = _AFPFSSetLock(context->filePath, pFile, SHARED_FIRST, SHARED_SIZE, 1); if (failed && (failed = _AFPFSSetLock(context->filePath, pFile, SHARED_FIRST + context->sharedLockByte, 1, 1))) { rc = failed; } } else { rc = failed; } } if( failed ){ rc = failed; } } if( rc==SQLITE_OK ){ pFile->locktype = locktype; }else if( locktype==EXCLUSIVE_LOCK ){ pFile->locktype = PENDING_LOCK; } afp_end_lock: leaveMutex(); OSTRACE4("LOCK %d %s %s\n", pFile->h, locktypeName(locktype), rc==SQLITE_OK ? "ok" : "failed"); return rc; } static int afpUnlock(sqlite3_file *id, int locktype) { int rc = SQLITE_OK; unixFile *pFile = (unixFile*)id; afpLockingContext *context = (afpLockingContext *) pFile->lockingContext; assert( pFile ); OSTRACE5("UNLOCK %d %d was %d pid=%d\n", pFile->h, locktype, pFile->locktype, getpid()); assert( locktype<=SHARED_LOCK ); if( pFile->locktype<=locktype ){ return SQLITE_OK; } if( CHECK_THREADID(pFile) ){ return SQLITE_MISUSE; } enterMutex(); int failed = SQLITE_OK; if( pFile->locktype>SHARED_LOCK ){ if( locktype==SHARED_LOCK ){ if (pFile->locktype==EXCLUSIVE_LOCK) { failed = _AFPFSSetLock(context->filePath, pFile, SHARED_FIRST, SHARED_SIZE, 0); if (!failed) { if ((failed = _AFPFSSetLock(context->filePath, pFile, SHARED_FIRST+ context->sharedLockByte, 1, 1))) { rc = failed; } } else { rc = failed; } } } if (rc == SQLITE_OK && pFile->locktype>=PENDING_LOCK) { if ((failed = _AFPFSSetLock(context->filePath, pFile, PENDING_BYTE, 1, 0))){ rc = failed; } } if (rc == SQLITE_OK && pFile->locktype>=RESERVED_LOCK) { if ((failed = _AFPFSSetLock(context->filePath, pFile, RESERVED_BYTE, 1, 0))) { rc = failed; } } } if( locktype==NO_LOCK ){ int failed = _AFPFSSetLock(context->filePath, pFile, SHARED_FIRST + context->sharedLockByte, 1, 0); if (failed) { rc = failed; } } if (rc == SQLITE_OK) pFile->locktype = locktype; leaveMutex(); return rc; } static int afpClose(sqlite3_file *id) { if( id ){ unixFile *pFile = (unixFile*)id; afpUnlock(id, NO_LOCK); sqlite3_free(pFile->lockingContext); } return closeUnixFile(id); } 
#pragma mark flock() style locking 
typedef void flockLockingContext; static int flockCheckReservedLock(sqlite3_file *id, int *pResOut){ int rc = SQLITE_OK; int reserved = 0; unixFile *pFile = (unixFile*)id; SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; ); assert( pFile ); if( pFile->locktype>SHARED_LOCK ){ reserved = 1; } if( !reserved ){ int lrc = flock(pFile->h, LOCK_EX | LOCK_NB); if( !lrc ){ lrc = flock(pFile->h, LOCK_UN); if ( lrc ) { int tErrno = errno; lrc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_UNLOCK); if( IS_LOCK_ERROR(lrc) ){ pFile->lastErrno = tErrno; rc = lrc; } } } else { int tErrno = errno; reserved = 1; lrc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK); if( IS_LOCK_ERROR(lrc) ){ pFile->lastErrno = tErrno; rc = lrc; } } } OSTRACE4("TEST WR-LOCK %d %d %d\n", pFile->h, rc, reserved); *pResOut = reserved; return rc; } static int flockLock(sqlite3_file *id, int locktype) { int rc = SQLITE_OK; unixFile *pFile = (unixFile*)id; assert( pFile ); if (pFile->locktype > NO_LOCK) { pFile->locktype = locktype; return SQLITE_OK; } if (flock(pFile->h, LOCK_EX | LOCK_NB)) { int tErrno = errno; rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK); if( IS_LOCK_ERROR(rc) ){ pFile->lastErrno = tErrno; } } else { pFile->locktype = locktype; } OSTRACE4("LOCK %d %s %s\n", pFile->h, locktypeName(locktype), rc==SQLITE_OK ? "ok" : "failed"); return rc; } static int flockUnlock(sqlite3_file *id, int locktype) { unixFile *pFile = (unixFile*)id; assert( pFile ); OSTRACE5("UNLOCK %d %d was %d pid=%d\n", pFile->h, locktype, pFile->locktype, getpid()); assert( locktype<=SHARED_LOCK ); if( pFile->locktype==locktype ){ return SQLITE_OK; } if (locktype==SHARED_LOCK) { pFile->locktype = locktype; return SQLITE_OK; } int rc = flock(pFile->h, LOCK_UN); if (rc) { int r, tErrno = errno; r = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_UNLOCK); if( IS_LOCK_ERROR(r) ){ pFile->lastErrno = tErrno; } return r; } else { pFile->locktype = NO_LOCK; return SQLITE_OK; } } static int flockClose(sqlite3_file *id) { if( id ){ flockUnlock(id, NO_LOCK); } return closeUnixFile(id); } 
#endif 
#pragma mark Old-School .lock file based locking 
static int dotlockCheckReservedLock(sqlite3_file *id, int *pResOut) { int rc = SQLITE_OK; int reserved = 0; unixFile *pFile = (unixFile*)id; SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; ); assert( pFile ); if( pFile->locktype>SHARED_LOCK ){ reserved = 1; } if( !reserved ){ char *zLockFile = (char *)pFile->lockingContext; struct stat statBuf; if( lstat(zLockFile, &statBuf)==0 ){ reserved = 1; }else{ int tErrno = errno; if( ENOENT != tErrno ){ rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_CHECKRESERVEDLOCK); pFile->lastErrno = tErrno; } } } OSTRACE4("TEST WR-LOCK %d %d %d\n", pFile->h, rc, reserved); *pResOut = reserved; return rc; } static int dotlockLock(sqlite3_file *id, int locktype) { unixFile *pFile = (unixFile*)id; int fd; char *zLockFile = (char *)pFile->lockingContext; int rc=SQLITE_OK; if (pFile->locktype > NO_LOCK) { pFile->locktype = locktype; 
#if !IS_VXWORKS 
 utimes(zLockFile, NULL); 
#endif 
 rc = SQLITE_OK; goto dotlock_end_lock; } struct stat statBuf; if (lstat(zLockFile,&statBuf) == 0){ rc = SQLITE_BUSY; goto dotlock_end_lock; } fd = open(zLockFile,O_RDONLY|O_CREAT|O_EXCL,0600); if( fd<0 ){ int tErrno = errno; if( EEXIST == tErrno ){ rc = SQLITE_BUSY; } else { rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK); if( IS_LOCK_ERROR(rc) ){ pFile->lastErrno = tErrno; } } goto dotlock_end_lock; } close(fd); pFile->locktype = locktype; dotlock_end_lock: return rc; } static int dotlockUnlock(sqlite3_file *id, int locktype) { unixFile *pFile = (unixFile*)id; char *zLockFile = (char *)pFile->lockingContext; assert( pFile ); OSTRACE5("UNLOCK %d %d was %d pid=%d\n", pFile->h, locktype, pFile->locktype, getpid()); assert( locktype<=SHARED_LOCK ); if( pFile->locktype==locktype ){ return SQLITE_OK; } if (locktype==SHARED_LOCK) { pFile->locktype = locktype; return SQLITE_OK; } if (unlink(zLockFile) ) { int rc, tErrno = errno; if( ENOENT != tErrno ){ rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_UNLOCK); } if( IS_LOCK_ERROR(rc) ){ pFile->lastErrno = tErrno; } return rc; } pFile->locktype = NO_LOCK; return SQLITE_OK; } static int dotlockClose(sqlite3_file *id) { int rc; if( id ){ unixFile *pFile = (unixFile*)id; dotlockUnlock(id, NO_LOCK); sqlite3_free(pFile->lockingContext); } if( IS_VXWORKS ) enterMutex(); rc = closeUnixFile(id); if( IS_VXWORKS ) leaveMutex(); return rc; } 
#if IS_VXWORKS 
#pragma mark POSIX/vxWorks named semaphore based locking 
static int namedsemCheckReservedLock(sqlite3_file *id, int *pResOut) { int rc = SQLITE_OK; int reserved = 0; unixFile *pFile = (unixFile*)id; SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; ); assert( pFile ); if( pFile->locktype>SHARED_LOCK ){ reserved = 1; } if( !reserved ){ sem_t *pSem = pFile->pOpen->pSem; struct stat statBuf; if( sem_trywait(pSem)==-1 ){ int tErrno = errno; if( EAGAIN != tErrno ){ rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_CHECKRESERVEDLOCK); pFile->lastErrno = tErrno; } else { reserved = (pFile->locktype < SHARED_LOCK); } }else{ sem_post(pSem); } } OSTRACE4("TEST WR-LOCK %d %d %d\n", pFile->h, rc, reserved); *pResOut = reserved; return rc; } static int namedsemLock(sqlite3_file *id, int locktype) { unixFile *pFile = (unixFile*)id; int fd; sem_t *pSem = pFile->pOpen->pSem; int rc = SQLITE_OK; if (pFile->locktype > NO_LOCK) { pFile->locktype = locktype; rc = SQLITE_OK; goto namedsem_end_lock; } if( sem_trywait(pSem)==-1 ){ rc = SQLITE_BUSY; goto namedsem_end_lock; } pFile->locktype = locktype; namedsem_end_lock: return rc; } static int namedsemUnlock(sqlite3_file *id, int locktype) { unixFile *pFile = (unixFile*)id; sem_t *pSem = pFile->pOpen->pSem; assert( pFile ); assert( pSem ); OSTRACE5("UNLOCK %d %d was %d pid=%d\n", pFile->h, locktype, pFile->locktype, getpid()); assert( locktype<=SHARED_LOCK ); if( pFile->locktype==locktype ){ return SQLITE_OK; } if (locktype==SHARED_LOCK) { pFile->locktype = locktype; return SQLITE_OK; } if ( sem_post(pSem)==-1 ) { int rc, tErrno = errno; rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_UNLOCK); if( IS_LOCK_ERROR(rc) ){ pFile->lastErrno = tErrno; } return rc; } pFile->locktype = NO_LOCK; return SQLITE_OK; } static int namedsemClose(sqlite3_file *id) { if( id ){ unixFile *pFile = (unixFile*)id; namedsemUnlock(id, NO_LOCK); assert( pFile ); enterMutex(); releaseLockInfo(pFile->pLock); releaseOpenCnt(pFile->pOpen); closeUnixFile(id); leaveMutex(); } return SQLITE_OK; } 
#endif 
#endif 
typedef void nolockLockingContext; static int nolockCheckReservedLock(sqlite3_file *NotUsed, int *pResOut){ UNUSED_PARAMETER(NotUsed); *pResOut = 0; return SQLITE_OK; } static int nolockLock(sqlite3_file *NotUsed, int NotUsed2){ UNUSED_PARAMETER2(NotUsed, NotUsed2); return SQLITE_OK; } static int nolockUnlock(sqlite3_file *NotUsed, int NotUsed2){ UNUSED_PARAMETER2(NotUsed, NotUsed2); return SQLITE_OK; } static int nolockClose(sqlite3_file *id) { int rc; if( IS_VXWORKS ) enterMutex(); rc = closeUnixFile(id); if( IS_VXWORKS ) leaveMutex(); return rc; } static int unixFileControl(sqlite3_file *id, int op, void *pArg){ switch( op ){ case SQLITE_FCNTL_LOCKSTATE: { *(int*)pArg = ((unixFile*)id)->locktype; return SQLITE_OK; } } return SQLITE_ERROR; } static int unixSectorSize(sqlite3_file *NotUsed){ UNUSED_PARAMETER(NotUsed); return SQLITE_DEFAULT_SECTOR_SIZE; } static int unixDeviceCharacteristics(sqlite3_file *NotUsed){ UNUSED_PARAMETER(NotUsed); return 0; } static int fillInUnixFile( sqlite3_vfs *pVfs, int h, int dirfd, sqlite3_file *pId, const char *zFilename, int noLock, int isDelete ){ int eLockingStyle; unixFile *pNew = (unixFile *)pId; int rc = SQLITE_OK; 
#define IOMETHODS(xClose, xLock, xUnlock, xCheckReservedLock) { 1, xClose, unixRead, unixWrite, unixTruncate, unixSync, unixFileSize, xLock, xUnlock, xCheckReservedLock, unixFileControl, unixSectorSize, unixDeviceCharacteristics } 
 static sqlite3_io_methods aIoMethod[] = { IOMETHODS(unixClose, unixLock, unixUnlock, unixCheckReservedLock) ,IOMETHODS(nolockClose, nolockLock, nolockUnlock, nolockCheckReservedLock) 
#if SQLITE_ENABLE_LOCKING_STYLE 
 ,IOMETHODS(dotlockClose, dotlockLock, dotlockUnlock,dotlockCheckReservedLock) 
#if IS_VXWORKS 
 ,IOMETHODS(nolockClose, nolockLock, nolockUnlock, nolockCheckReservedLock) ,IOMETHODS(nolockClose, nolockLock, nolockUnlock, nolockCheckReservedLock) ,IOMETHODS(namedsemClose, namedsemLock, namedsemUnlock, namedsemCheckReservedLock) 
#else 
 ,IOMETHODS(flockClose, flockLock, flockUnlock, flockCheckReservedLock) ,IOMETHODS(afpClose, afpLock, afpUnlock, afpCheckReservedLock) ,IOMETHODS(nolockClose, nolockLock, nolockUnlock, nolockCheckReservedLock) 
#endif 
#endif 
 }; assert(LOCKING_STYLE_POSIX==1); assert(LOCKING_STYLE_NONE==2); assert(LOCKING_STYLE_DOTFILE==3); assert(LOCKING_STYLE_FLOCK==4); assert(LOCKING_STYLE_AFP==5); assert(LOCKING_STYLE_NAMEDSEM==6); assert( pNew->pLock==NULL ); assert( pNew->pOpen==NULL ); if( !IS_VXWORKS ) UNUSED_PARAMETER(isDelete); if( !SQLITE_ENABLE_LOCKING_STYLE ) UNUSED_PARAMETER(pVfs); if( !IS_VXWORKS && !SQLITE_ENABLE_LOCKING_STYLE ) UNUSED_PARAMETER(zFilename); OSTRACE3("OPEN %-3d %s\n", h, zFilename); pNew->h = h; pNew->dirfd = dirfd; SET_THREADID(pNew); 
#if IS_VXWORKS 
 { HashElem *pElem; char *zRealname = vxrealpath(zFilename, 1); int n; pNew->zRealpath = 0; if( !zRealname ){ rc = SQLITE_NOMEM; eLockingStyle = LOCKING_STYLE_NONE; }else{ n = strlen(zRealname) + 1; enterMutex(); pElem = sqlite3HashFindElem(&nameHash, zRealname, n); if( pElem ){ long cnt = (long)pElem->data; cnt++; pNew->zRealpath = pElem->pKey; pElem->data = (void*)cnt; }else{ if( sqlite3HashInsert(&nameHash, zRealname, n, (void*)1)==0 ){ pElem = sqlite3HashFindElem(&nameHash, zRealname, n); if( pElem ){ pNew->zRealpath = pElem->pKey; }else{ sqlite3HashInsert(&nameHash, zRealname, n, 0); rc = SQLITE_NOMEM; eLockingStyle = LOCKING_STYLE_NONE; } } } leaveMutex(); sqlite3_free(zRealname); } } 
#endif 
 if( noLock ){ eLockingStyle = LOCKING_STYLE_NONE; }else{ eLockingStyle = detectLockingStyle(pVfs, zFilename, h); } switch( eLockingStyle ){ case LOCKING_STYLE_POSIX: { enterMutex(); 
#if IS_VXWORKS 
 rc = findLockInfo(h, pNew->zRealpath, &pNew->pLock, &pNew->pOpen); 
#else 
 rc = findLockInfo(h, &pNew->pLock, &pNew->pOpen); 
#endif 
 leaveMutex(); break; } 
#if SQLITE_ENABLE_LOCKING_STYLE 
#if !IS_VXWORKS 
 case LOCKING_STYLE_AFP: { afpLockingContext *pCtx; pNew->lockingContext = pCtx = sqlite3_malloc( sizeof(*pCtx) ); if( pCtx==0 ){ rc = SQLITE_NOMEM; }else{ pCtx->filePath = zFilename; srandomdev(); } break; } 
#endif 
 case LOCKING_STYLE_DOTFILE: { char *zLockFile; int nFilename; nFilename = strlen(zFilename) + 6; zLockFile = (char *)sqlite3_malloc(nFilename); if( zLockFile==0 ){ rc = SQLITE_NOMEM; }else{ sqlite3_snprintf(nFilename, zLockFile, "%s.lock", zFilename); } pNew->lockingContext = zLockFile; break; } 
#if IS_VXWORKS 
 case LOCKING_STYLE_NAMEDSEM: { enterMutex(); rc = findLockInfo(h, pNew->zRealpath, &pNew->pLock, &pNew->pOpen); if( (rc==SQLITE_OK) && (pNew->pOpen->pSem==NULL) ){ char *zSemName = pNew->pOpen->aSemName; int n; sqlite3_snprintf(MAX_PATHNAME, zSemName, "%s.sem", pNew->zRealpath); for( n=0; zSemName[n]; n++ ) if( zSemName[n]=='/' ) zSemName[n] = '_'; pNew->pOpen->pSem = sem_open(zSemName, O_CREAT, 0666, 1); if( pNew->pOpen->pSem == SEM_FAILED ){ rc = SQLITE_NOMEM; pNew->pOpen->aSemName[0] = '\0'; } } leaveMutex(); break; } 
#endif 
 case LOCKING_STYLE_FLOCK: case LOCKING_STYLE_NONE: break; 
#endif 
 } pNew->lastErrno = 0; 
#if IS_VXWORKS 
 if( rc!=SQLITE_OK ){ unlink(zFilename); isDelete = 0; } pNew->isDelete = isDelete; 
#endif 
 if( rc!=SQLITE_OK ){ if( dirfd>=0 ) close(dirfd); close(h); }else{ pNew->pMethod = &aIoMethod[eLockingStyle-1]; OpenCounter(+1); } return rc; } static int openDirectory(const char *zFilename, int *pFd){ int ii; int fd = -1; char zDirname[MAX_PATHNAME+1]; sqlite3_snprintf(MAX_PATHNAME, zDirname, "%s", zFilename); for(ii=strlen(zDirname); ii>=0 && zDirname[ii]!='/'; ii--); if( ii>0 ){ zDirname[ii] = '\0'; fd = open(zDirname, O_RDONLY|O_BINARY, 0); if( fd>=0 ){ 
#ifdef FD_CLOEXEC 
 fcntl(fd, F_SETFD, fcntl(fd, F_GETFD, 0) | FD_CLOEXEC); 
#endif 
 OSTRACE3("OPENDIR %-3d %s\n", fd, zDirname); } } *pFd = fd; return (fd>=0?SQLITE_OK:SQLITE_CANTOPEN); } static int getTempname(int nBuf, char *zBuf){ static const char *azDirs[] = { 0, "/var/tmp", "/usr/tmp", "/tmp", ".", }; static const unsigned char zChars[] = "abcdefghijklmnopqrstuvwxyz" "ABCDEFGHIJKLMNOPQRSTUVWXYZ" "0123456789"; int i, j; struct stat buf; const char *zDir = "."; SimulateIOError( return SQLITE_IOERR ); azDirs[0] = sqlite3_temp_directory; for(i=0; i<ArraySize(azDirs); i++){ if( azDirs[i]==0 ) continue; if( stat(azDirs[i], &buf) ) continue; if( !S_ISDIR(buf.st_mode) ) continue; if( access(azDirs[i], 07) ) continue; zDir = azDirs[i]; break; } if( (strlen(zDir) + strlen(SQLITE_TEMP_FILE_PREFIX) + 17) >= (size_t)nBuf ){ return SQLITE_ERROR; } do{ sqlite3_snprintf(nBuf-17, zBuf, "%s/"SQLITE_TEMP_FILE_PREFIX, zDir); j = strlen(zBuf); sqlite3_randomness(15, &zBuf[j]); for(i=0; i<15; i++, j++){ zBuf[j] = (char)zChars[ ((unsigned char)zBuf[j])%(sizeof(zChars)-1) ]; } zBuf[j] = 0; }while( access(zBuf,0)==0 ); return SQLITE_OK; } static int unixOpen( sqlite3_vfs *pVfs, const char *zPath, sqlite3_file *pFile, int flags, int *pOutFlags ){ int fd = 0; int dirfd = -1; int oflags = 0; int eType = flags&0xFFFFFF00; int noLock; int isExclusive = (flags & SQLITE_OPEN_EXCLUSIVE); int isDelete = (flags & SQLITE_OPEN_DELETEONCLOSE); int isCreate = (flags & SQLITE_OPEN_CREATE); int isReadonly = (flags & SQLITE_OPEN_READONLY); int isReadWrite = (flags & SQLITE_OPEN_READWRITE); int isOpenDirectory = (isCreate && (eType==SQLITE_OPEN_MASTER_JOURNAL || eType==SQLITE_OPEN_MAIN_JOURNAL) ); char zTmpname[MAX_PATHNAME+1]; const char *zName = zPath; assert((isReadonly==0 || isReadWrite==0) && (isReadWrite || isReadonly)); assert(isCreate==0 || isReadWrite); assert(isExclusive==0 || isCreate); assert(isDelete==0 || isCreate); assert( eType!=SQLITE_OPEN_MAIN_DB || !isDelete ); assert( eType!=SQLITE_OPEN_MAIN_JOURNAL || !isDelete ); assert( eType!=SQLITE_OPEN_MASTER_JOURNAL || !isDelete ); assert( eType==SQLITE_OPEN_MAIN_DB || eType==SQLITE_OPEN_TEMP_DB || eType==SQLITE_OPEN_MAIN_JOURNAL || eType==SQLITE_OPEN_TEMP_JOURNAL || eType==SQLITE_OPEN_SUBJOURNAL || eType==SQLITE_OPEN_MASTER_JOURNAL || eType==SQLITE_OPEN_TRANSIENT_DB ); memset(pFile, 0, sizeof(unixFile)); if( !zName ){ int rc; assert(isDelete && !isOpenDirectory); rc = getTempname(MAX_PATHNAME+1, zTmpname); if( rc!=SQLITE_OK ){ return rc; } zName = zTmpname; } if( isReadonly ) oflags |= O_RDONLY; if( isReadWrite ) oflags |= O_RDWR; if( isCreate ) oflags |= O_CREAT; if( isExclusive ) oflags |= (O_EXCL|O_NOFOLLOW); oflags |= (O_LARGEFILE|O_BINARY); fd = open(zName, oflags, isDelete?0600:SQLITE_DEFAULT_FILE_PERMISSIONS); OSTRACE4("OPENX %-3d %s 0%o\n", fd, zName, oflags); if( fd<0 && errno!=EISDIR && isReadWrite && !isExclusive ){ flags &= ~(SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE); flags |= SQLITE_OPEN_READONLY; return unixOpen(pVfs, zPath, pFile, flags, pOutFlags); } if( fd<0 ){ return SQLITE_CANTOPEN; } if( isDelete ){ 
#if IS_VXWORKS 
 zPath = zName; 
#else 
 unlink(zName); 
#endif 
 } if( pOutFlags ){ *pOutFlags = flags; } assert(fd!=0); if( isOpenDirectory ){ int rc = openDirectory(zPath, &dirfd); if( rc!=SQLITE_OK ){ close(fd); return rc; } } 
#ifdef FD_CLOEXEC 
 fcntl(fd, F_SETFD, fcntl(fd, F_GETFD, 0) | FD_CLOEXEC); 
#endif 
 noLock = eType!=SQLITE_OPEN_MAIN_DB; return fillInUnixFile(pVfs, fd, dirfd, pFile, zPath, noLock, isDelete); } static int unixDelete(sqlite3_vfs *NotUsed, const char *zPath, int dirSync){ int rc = SQLITE_OK; UNUSED_PARAMETER(NotUsed); SimulateIOError(return SQLITE_IOERR_DELETE); unlink(zPath); 
#ifndef SQLITE_DISABLE_DIRSYNC 
 if( dirSync ){ int fd; rc = openDirectory(zPath, &fd); if( rc==SQLITE_OK ){ 
#if IS_VXWORKS 
 if( fsync(fd)==-1 ) 
#else 
 if( fsync(fd) ) 
#endif 
 { rc = SQLITE_IOERR_DIR_FSYNC; } close(fd); } } 
#endif 
 return rc; } static int unixAccess( sqlite3_vfs *NotUsed, const char *zPath, int flags, int *pResOut ){ int amode = 0; UNUSED_PARAMETER(NotUsed); SimulateIOError( return SQLITE_IOERR_ACCESS; ); switch( flags ){ case SQLITE_ACCESS_EXISTS: amode = F_OK; break; case SQLITE_ACCESS_READWRITE: amode = W_OK|R_OK; break; case SQLITE_ACCESS_READ: amode = R_OK; break; default: assert(!"Invalid flags argument"); } *pResOut = (access(zPath, amode)==0); return SQLITE_OK; } static int unixFullPathname( sqlite3_vfs *pVfs, const char *zPath, int nOut, char *zOut ){ SimulateIOError( return SQLITE_ERROR ); assert( pVfs->mxPathname==MAX_PATHNAME ); UNUSED_PARAMETER(pVfs); 
#if IS_VXWORKS 
 { char *zRealname = vxrealpath(zPath, 0); zOut[0] = '\0'; if( !zRealname ){ return SQLITE_CANTOPEN; } sqlite3_snprintf(nOut, zOut, "%s", zRealname); sqlite3_free(zRealname); return SQLITE_OK; } 
#else 
 zOut[nOut-1] = '\0'; if( zPath[0]=='/' ){ sqlite3_snprintf(nOut, zOut, "%s", zPath); }else{ int nCwd; if( getcwd(zOut, nOut-1)==0 ){ return SQLITE_CANTOPEN; } nCwd = strlen(zOut); sqlite3_snprintf(nOut-nCwd, &zOut[nCwd], "/%s", zPath); } return SQLITE_OK; 
#if 0 
 if( zFull ){ int i, j; for(i=j=0; zFull[i]; i++){ if( zFull[i]=='/' ){ if( zFull[i+1]=='/' ) continue; if( zFull[i+1]=='.' && zFull[i+2]=='/' ){ i += 1; continue; } if( zFull[i+1]=='.' && zFull[i+2]=='.' && zFull[i+3]=='/' ){ while( j>0 && zFull[j-1]!='/' ){ j--; } i += 3; continue; } } zFull[j++] = zFull[i]; } zFull[j] = 0; } 
#endif 
#endif 
} 
#ifndef SQLITE_OMIT_LOAD_EXTENSION 
#include <dlfcn.h> 
static void *unixDlOpen(sqlite3_vfs *NotUsed, const char *zFilename){ UNUSED_PARAMETER(NotUsed); return dlopen(zFilename, RTLD_NOW | RTLD_GLOBAL); } static void unixDlError(sqlite3_vfs *NotUsed, int nBuf, char *zBufOut){ char *zErr; UNUSED_PARAMETER(NotUsed); enterMutex(); zErr = dlerror(); if( zErr ){ sqlite3_snprintf(nBuf, zBufOut, "%s", zErr); } leaveMutex(); } static void *unixDlSym(sqlite3_vfs *NotUsed, void *pHandle, const char*zSymbol){ UNUSED_PARAMETER(NotUsed); return dlsym(pHandle, zSymbol); } static void unixDlClose(sqlite3_vfs *NotUsed, void *pHandle){ UNUSED_PARAMETER(NotUsed); dlclose(pHandle); } 
#else 
#define unixDlOpen 0 
#define unixDlError 0 
#define unixDlSym 0 
#define unixDlClose 0 
#endif 
static int unixRandomness(sqlite3_vfs *NotUsed, int nBuf, char *zBuf){ UNUSED_PARAMETER(NotUsed); assert((size_t)nBuf>=(sizeof(time_t)+sizeof(int))); memset(zBuf, 0, nBuf); 
#if !defined(SQLITE_TEST) 
 { int pid, fd; fd = open("/dev/urandom", O_RDONLY); if( fd<0 ){ time_t t; time(&t); memcpy(zBuf, &t, sizeof(t)); pid = getpid(); memcpy(&zBuf[sizeof(t)], &pid, sizeof(pid)); assert( sizeof(t)+sizeof(pid)<=(size_t)nBuf ); nBuf = sizeof(t) + sizeof(pid); }else{ nBuf = read(fd, zBuf, nBuf); close(fd); } } 
#endif 
 return nBuf; } static int unixSleep(sqlite3_vfs *NotUsed, int microseconds){ 
#if IS_VXWORKS 
 struct timespec sp; sp.tv_sec = microseconds / 1000000; sp.tv_nsec = (microseconds % 1000000) * 1000; nanosleep(&sp, NULL); return microseconds; 
#elif defined(HAVE_USLEEP) && HAVE_USLEEP 
 usleep(microseconds); return microseconds; 
#else 
 int seconds = (microseconds+999999)/1000000; sleep(seconds); return seconds*1000000; 
#endif 
 UNUSED_PARAMETER(NotUsed); } 
#ifdef SQLITE_TEST 
SQLITE_API int sqlite3_current_time = 0; 
#endif 
static int unixCurrentTime(sqlite3_vfs *NotUsed, double *prNow){ 
#if IS_VXWORKS 
 struct timespec sNow; clock_gettime(CLOCK_REALTIME, &sNow); *prNow = 2440587.5 + sNow.tv_sec/86400.0 + sNow.tv_nsec/86400000000000.0; 
#elif defined(NO_GETTOD) 
 time_t t; time(&t); *prNow = t/86400.0 + 2440587.5; 
#else 
 struct timeval sNow; gettimeofday(&sNow, 0); *prNow = 2440587.5 + sNow.tv_sec/86400.0 + sNow.tv_usec/86400000000.0; 
#endif 
#ifdef SQLITE_TEST 
 if( sqlite3_current_time ){ *prNow = sqlite3_current_time/86400.0 + 2440587.5; } 
#endif 
 UNUSED_PARAMETER(NotUsed); return 0; } static int unixGetLastError(sqlite3_vfs *NotUsed, int NotUsed2, char *NotUsed3){ UNUSED_PARAMETER(NotUsed); UNUSED_PARAMETER(NotUsed2); UNUSED_PARAMETER(NotUsed3); return 0; } SQLITE_API int sqlite3_os_init(void){ 
#define UNIXVFS(zVfsName, pVfsAppData) { 1, sizeof(unixFile), MAX_PATHNAME, 0, zVfsName, (void *)pVfsAppData, unixOpen, unixDelete, unixAccess, unixFullPathname, unixDlOpen, unixDlError, unixDlSym, unixDlClose, unixRandomness, unixSleep, unixCurrentTime, unixGetLastError } 
 static sqlite3_vfs unixVfs = UNIXVFS("unix", 0); 
#if SQLITE_ENABLE_LOCKING_STYLE 
 int i; static sqlite3_vfs aVfs[] = { UNIXVFS("unix-posix", LOCKING_STYLE_POSIX), UNIXVFS("unix-afp", LOCKING_STYLE_AFP), UNIXVFS("unix-flock", LOCKING_STYLE_FLOCK), UNIXVFS("unix-dotfile", LOCKING_STYLE_DOTFILE), UNIXVFS("unix-none", LOCKING_STYLE_NONE), UNIXVFS("unix-namedsem",LOCKING_STYLE_NAMEDSEM), }; for(i=0; i<(sizeof(aVfs)/sizeof(sqlite3_vfs)); i++){ sqlite3_vfs_register(&aVfs[i], 0); } 
#endif 
#if IS_VXWORKS 
 sqlite3HashInit(&nameHash, 1); 
#endif 
 sqlite3_vfs_register(&unixVfs, 1); return SQLITE_OK; } SQLITE_API int sqlite3_os_end(void){ return SQLITE_OK; } 
#endif 
#if SQLITE_OS_WIN 
#include <winbase.h> 
#ifdef __CYGWIN__ 
#include <sys/cygwin.h> 
#endif 
#if defined(THREADSAFE) && THREADSAFE 
#define SQLITE_W32_THREADS 1 
#endif 
#ifndef _OS_COMMON_H_ 
#define _OS_COMMON_H_ 
#ifdef MEMORY_DEBUG 
#error "The MEMORY_DEBUG macro is obsolete. Use SQLITE_DEBUG instead." 
#endif 
#ifdef SQLITE_TEST 
SQLITE_API unsigned int sqlite3_pending_byte = 0x40000000; 
#endif 
#ifdef SQLITE_DEBUG 
SQLITE_PRIVATE int sqlite3OSTrace = 0; 
#define OSTRACE1(X) if( sqlite3OSTrace ) sqlite3DebugPrintf(X) 
#define OSTRACE2(X,Y) if( sqlite3OSTrace ) sqlite3DebugPrintf(X,Y) 
#define OSTRACE3(X,Y,Z) if( sqlite3OSTrace ) sqlite3DebugPrintf(X,Y,Z) 
#define OSTRACE4(X,Y,Z,A) if( sqlite3OSTrace ) sqlite3DebugPrintf(X,Y,Z,A) 
#define OSTRACE5(X,Y,Z,A,B) if( sqlite3OSTrace ) sqlite3DebugPrintf(X,Y,Z,A,B) 
#define OSTRACE6(X,Y,Z,A,B,C) if(sqlite3OSTrace) sqlite3DebugPrintf(X,Y,Z,A,B,C) 
#define OSTRACE7(X,Y,Z,A,B,C,D) if(sqlite3OSTrace) sqlite3DebugPrintf(X,Y,Z,A,B,C,D) 
#else 
#define OSTRACE1(X) 
#define OSTRACE2(X,Y) 
#define OSTRACE3(X,Y,Z) 
#define OSTRACE4(X,Y,Z,A) 
#define OSTRACE5(X,Y,Z,A,B) 
#define OSTRACE6(X,Y,Z,A,B,C) 
#define OSTRACE7(X,Y,Z,A,B,C,D) 
#endif 
#ifdef SQLITE_PERFORMANCE_TRACE 
#ifndef _HWTIME_H_ 
#define _HWTIME_H_ 
#if (defined(__GNUC__) || defined(_MSC_VER)) && (defined(i386) || defined(__i386__) || defined(_M_IX86)) 
#if defined(__GNUC__) 
 __inline__ sqlite_uint64 sqlite3Hwtime(void){ unsigned int lo, hi; __asm__ __volatile__ ("rdtsc" : "=a" (lo), "=d" (hi)); return (sqlite_uint64)hi << 32 | lo; } 
#elif defined(_MSC_VER) 
 __declspec(naked) __inline sqlite_uint64 __cdecl sqlite3Hwtime(void){ __asm { rdtsc ret ; return value at EDX:EAX } } 
#endif 
#elif (defined(__GNUC__) && defined(__x86_64__)) 
 __inline__ sqlite_uint64 sqlite3Hwtime(void){ unsigned long val; __asm__ __volatile__ ("rdtsc" : "=A" (val)); return val; } 
#elif (defined(__GNUC__) && defined(__ppc__)) 
 __inline__ sqlite_uint64 sqlite3Hwtime(void){ unsigned long long retval; unsigned long junk; __asm__ __volatile__ ("\n 1: mftbu %1\n mftb %L0\n mftbu %0\n cmpw %0,%1\n bne 1b" : "=r" (retval), "=r" (junk)); return retval; } 
#else 
#error Need implementation of sqlite3Hwtime() for your platform. 
 SQLITE_PRIVATE sqlite_uint64 sqlite3Hwtime(void){ return ((sqlite_uint64)0); } 
#endif 
#endif 
static sqlite_uint64 g_start; static sqlite_uint64 g_elapsed; 
#define TIMER_START g_start=sqlite3Hwtime() 
#define TIMER_END g_elapsed=sqlite3Hwtime()-g_start 
#define TIMER_ELAPSED g_elapsed 
#else 
#define TIMER_START 
#define TIMER_END 
#define TIMER_ELAPSED ((sqlite_uint64)0) 
#endif 
#ifdef SQLITE_TEST 
SQLITE_API int sqlite3_io_error_hit = 0; SQLITE_API int sqlite3_io_error_hardhit = 0; SQLITE_API int sqlite3_io_error_pending = 0; SQLITE_API int sqlite3_io_error_persist = 0; SQLITE_API int sqlite3_io_error_benign = 0; SQLITE_API int sqlite3_diskfull_pending = 0; SQLITE_API int sqlite3_diskfull = 0; 
#define SimulateIOErrorBenign(X) sqlite3_io_error_benign=(X) 
#define SimulateIOError(CODE) if( (sqlite3_io_error_persist && sqlite3_io_error_hit) || sqlite3_io_error_pending-- == 1 ) { local_ioerr(); CODE; } 
static void local_ioerr(){ IOTRACE(("IOERR\n")); sqlite3_io_error_hit++; if( !sqlite3_io_error_benign ) sqlite3_io_error_hardhit++; } 
#define SimulateDiskfullError(CODE) if( sqlite3_diskfull_pending ){ if( sqlite3_diskfull_pending == 1 ){ local_ioerr(); sqlite3_diskfull = 1; sqlite3_io_error_hit = 1; CODE; }else{ sqlite3_diskfull_pending--; } } 
#else 
#define SimulateIOErrorBenign(X) 
#define SimulateIOError(A) 
#define SimulateDiskfullError(A) 
#endif 
#ifdef SQLITE_TEST 
SQLITE_API int sqlite3_open_file_count = 0; 
#define OpenCounter(X) sqlite3_open_file_count+=(X) 
#else 
#define OpenCounter(X) 
#endif 
#endif 
#ifndef INVALID_FILE_ATTRIBUTES 
#define INVALID_FILE_ATTRIBUTES ((DWORD)-1) 
#endif 
#if SQLITE_OS_WINCE 
#define AreFileApisANSI() 1 
#endif 
#if SQLITE_OS_WINCE 
typedef struct winceLock { int nReaders; BOOL bPending; BOOL bReserved; BOOL bExclusive; } winceLock; 
#endif 
typedef struct winFile winFile; struct winFile { const sqlite3_io_methods *pMethod; HANDLE h; unsigned char locktype; short sharedLockByte; 
#if SQLITE_OS_WINCE 
 WCHAR *zDeleteOnClose; HANDLE hMutex; HANDLE hShared; winceLock local; winceLock *shared; 
#endif 
}; 
#ifdef SQLITE_TEST 
SQLITE_API int sqlite3_os_type = 0; 
#else 
static int sqlite3_os_type = 0; 
#endif 
#if SQLITE_OS_WINCE 
#define isNT() (1) 
#else 
 static int isNT(void){ if( sqlite3_os_type==0 ){ OSVERSIONINFO sInfo; sInfo.dwOSVersionInfoSize = sizeof(sInfo); GetVersionEx(&sInfo); sqlite3_os_type = sInfo.dwPlatformId==VER_PLATFORM_WIN32_NT ? 2 : 1; } return sqlite3_os_type==2; } 
#endif 
static WCHAR *utf8ToUnicode(const char *zFilename){ int nChar; WCHAR *zWideFilename; nChar = MultiByteToWideChar(CP_UTF8, 0, zFilename, -1, NULL, 0); zWideFilename = malloc( nChar*sizeof(zWideFilename[0]) ); if( zWideFilename==0 ){ return 0; } nChar = MultiByteToWideChar(CP_UTF8, 0, zFilename, -1, zWideFilename, nChar); if( nChar==0 ){ free(zWideFilename); zWideFilename = 0; } return zWideFilename; } static char *unicodeToUtf8(const WCHAR *zWideFilename){ int nByte; char *zFilename; nByte = WideCharToMultiByte(CP_UTF8, 0, zWideFilename, -1, 0, 0, 0, 0); zFilename = malloc( nByte ); if( zFilename==0 ){ return 0; } nByte = WideCharToMultiByte(CP_UTF8, 0, zWideFilename, -1, zFilename, nByte, 0, 0); if( nByte == 0 ){ free(zFilename); zFilename = 0; } return zFilename; } static WCHAR *mbcsToUnicode(const char *zFilename){ int nByte; WCHAR *zMbcsFilename; int codepage = AreFileApisANSI() ? CP_ACP : CP_OEMCP; nByte = MultiByteToWideChar(codepage, 0, zFilename, -1, NULL,0)*sizeof(WCHAR); zMbcsFilename = malloc( nByte*sizeof(zMbcsFilename[0]) ); if( zMbcsFilename==0 ){ return 0; } nByte = MultiByteToWideChar(codepage, 0, zFilename, -1, zMbcsFilename, nByte); if( nByte==0 ){ free(zMbcsFilename); zMbcsFilename = 0; } return zMbcsFilename; } static char *unicodeToMbcs(const WCHAR *zWideFilename){ int nByte; char *zFilename; int codepage = AreFileApisANSI() ? CP_ACP : CP_OEMCP; nByte = WideCharToMultiByte(codepage, 0, zWideFilename, -1, 0, 0, 0, 0); zFilename = malloc( nByte ); if( zFilename==0 ){ return 0; } nByte = WideCharToMultiByte(codepage, 0, zWideFilename, -1, zFilename, nByte, 0, 0); if( nByte == 0 ){ free(zFilename); zFilename = 0; } return zFilename; } SQLITE_API char *sqlite3_win32_mbcs_to_utf8(const char *zFilename){ char *zFilenameUtf8; WCHAR *zTmpWide; zTmpWide = mbcsToUnicode(zFilename); if( zTmpWide==0 ){ return 0; } zFilenameUtf8 = unicodeToUtf8(zTmpWide); free(zTmpWide); return zFilenameUtf8; } static char *utf8ToMbcs(const char *zFilename){ char *zFilenameMbcs; WCHAR *zTmpWide; zTmpWide = utf8ToUnicode(zFilename); if( zTmpWide==0 ){ return 0; } zFilenameMbcs = unicodeToMbcs(zTmpWide); free(zTmpWide); return zFilenameMbcs; } 
#if SQLITE_OS_WINCE 
struct tm *__cdecl localtime(const time_t *t) { static struct tm y; FILETIME uTm, lTm; SYSTEMTIME pTm; sqlite3_int64 t64; t64 = *t; t64 = (t64 + 11644473600)*10000000; uTm.dwLowDateTime = t64 & 0xFFFFFFFF; uTm.dwHighDateTime= t64 >> 32; FileTimeToLocalFileTime(&uTm,&lTm); FileTimeToSystemTime(&lTm,&pTm); y.tm_year = pTm.wYear - 1900; y.tm_mon = pTm.wMonth - 1; y.tm_wday = pTm.wDayOfWeek; y.tm_mday = pTm.wDay; y.tm_hour = pTm.wHour; y.tm_min = pTm.wMinute; y.tm_sec = pTm.wSecond; return &y; } 
#define GetTempPathA(a,b) 
#define LockFile(a,b,c,d,e) winceLockFile(&a, b, c, d, e) 
#define UnlockFile(a,b,c,d,e) winceUnlockFile(&a, b, c, d, e) 
#define LockFileEx(a,b,c,d,e,f) winceLockFileEx(&a, b, c, d, e, f) 
#define HANDLE_TO_WINFILE(a) (winFile*)&((char*)a)[-offsetof(winFile,h)] 
static void winceMutexAcquire(HANDLE h){ DWORD dwErr; do { dwErr = WaitForSingleObject(h, INFINITE); } while (dwErr != WAIT_OBJECT_0 && dwErr != WAIT_ABANDONED); } 
#define winceMutexRelease(h) ReleaseMutex(h) 
static BOOL winceCreateLock(const char *zFilename, winFile *pFile){ WCHAR *zTok; WCHAR *zName = utf8ToUnicode(zFilename); BOOL bInit = TRUE; ZeroMemory(&pFile->local, sizeof(pFile->local)); zTok = CharLowerW(zName); for (;*zTok;zTok++){ if (*zTok == '\\') *zTok = '_'; } pFile->hMutex = CreateMutexW(NULL, FALSE, zName); if (!pFile->hMutex){ free(zName); return FALSE; } winceMutexAcquire(pFile->hMutex); CharUpperW(zName); pFile->hShared = CreateFileMappingW(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, sizeof(winceLock), zName); if (GetLastError() == ERROR_ALREADY_EXISTS){ bInit = FALSE; } free(zName); if (pFile->hShared){ pFile->shared = (winceLock*)MapViewOfFile(pFile->hShared, FILE_MAP_READ|FILE_MAP_WRITE, 0, 0, sizeof(winceLock)); if (!pFile->shared){ CloseHandle(pFile->hShared); pFile->hShared = NULL; } } if (pFile->hShared == NULL){ winceMutexRelease(pFile->hMutex); CloseHandle(pFile->hMutex); pFile->hMutex = NULL; return FALSE; } if (bInit) { ZeroMemory(pFile->shared, sizeof(winceLock)); } winceMutexRelease(pFile->hMutex); return TRUE; } static void winceDestroyLock(winFile *pFile){ if (pFile->hMutex){ winceMutexAcquire(pFile->hMutex); if (pFile->local.nReaders){ pFile->shared->nReaders --; } if (pFile->local.bReserved){ pFile->shared->bReserved = FALSE; } if (pFile->local.bPending){ pFile->shared->bPending = FALSE; } if (pFile->local.bExclusive){ pFile->shared->bExclusive = FALSE; } UnmapViewOfFile(pFile->shared); CloseHandle(pFile->hShared); winceMutexRelease(pFile->hMutex); CloseHandle(pFile->hMutex); pFile->hMutex = NULL; } } static BOOL winceLockFile( HANDLE *phFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh ){ winFile *pFile = HANDLE_TO_WINFILE(phFile); BOOL bReturn = FALSE; if (!pFile->hMutex) return TRUE; winceMutexAcquire(pFile->hMutex); if (dwFileOffsetLow == SHARED_FIRST && nNumberOfBytesToLockLow == SHARED_SIZE){ if (pFile->shared->nReaders == 0 && pFile->shared->bExclusive == 0){ pFile->shared->bExclusive = TRUE; pFile->local.bExclusive = TRUE; bReturn = TRUE; } } else if ((dwFileOffsetLow >= SHARED_FIRST && dwFileOffsetLow < SHARED_FIRST + SHARED_SIZE) && nNumberOfBytesToLockLow == 1){ if (pFile->shared->bExclusive == 0){ pFile->local.nReaders ++; if (pFile->local.nReaders == 1){ pFile->shared->nReaders ++; } bReturn = TRUE; } } else if (dwFileOffsetLow == PENDING_BYTE && nNumberOfBytesToLockLow == 1){ if (pFile->shared->bPending == 0) { pFile->shared->bPending = TRUE; pFile->local.bPending = TRUE; bReturn = TRUE; } } else if (dwFileOffsetLow == RESERVED_BYTE && nNumberOfBytesToLockLow == 1){ if (pFile->shared->bReserved == 0) { pFile->shared->bReserved = TRUE; pFile->local.bReserved = TRUE; bReturn = TRUE; } } winceMutexRelease(pFile->hMutex); return bReturn; } static BOOL winceUnlockFile( HANDLE *phFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh ){ winFile *pFile = HANDLE_TO_WINFILE(phFile); BOOL bReturn = FALSE; if (!pFile->hMutex) return TRUE; winceMutexAcquire(pFile->hMutex); if (dwFileOffsetLow >= SHARED_FIRST && dwFileOffsetLow < SHARED_FIRST + SHARED_SIZE){ if (pFile->local.bExclusive){ pFile->local.bExclusive = FALSE; pFile->shared->bExclusive = FALSE; bReturn = TRUE; } else if (pFile->local.nReaders){ pFile->local.nReaders --; if (pFile->local.nReaders == 0) { pFile->shared->nReaders --; } bReturn = TRUE; } } else if (dwFileOffsetLow == PENDING_BYTE && nNumberOfBytesToUnlockLow == 1){ if (pFile->local.bPending){ pFile->local.bPending = FALSE; pFile->shared->bPending = FALSE; bReturn = TRUE; } } else if (dwFileOffsetLow == RESERVED_BYTE && nNumberOfBytesToUnlockLow == 1){ if (pFile->local.bReserved) { pFile->local.bReserved = FALSE; pFile->shared->bReserved = FALSE; bReturn = TRUE; } } winceMutexRelease(pFile->hMutex); return bReturn; } static BOOL winceLockFileEx( HANDLE *phFile, DWORD dwFlags, DWORD dwReserved, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh, LPOVERLAPPED lpOverlapped ){ if (lpOverlapped->Offset == SHARED_FIRST && dwFlags == 1 && nNumberOfBytesToLockLow == SHARED_SIZE){ return winceLockFile(phFile, SHARED_FIRST, 0, 1, 0); } return FALSE; } 
#endif 
#define MX_CLOSE_ATTEMPT 3 
static int winClose(sqlite3_file *id){ int rc, cnt = 0; winFile *pFile = (winFile*)id; OSTRACE2("CLOSE %d\n", pFile->h); do{ rc = CloseHandle(pFile->h); }while( rc==0 && ++cnt < MX_CLOSE_ATTEMPT && (Sleep(100), 1) ); 
#if SQLITE_OS_WINCE 
#define WINCE_DELETION_ATTEMPTS 3 
 winceDestroyLock(pFile); if( pFile->zDeleteOnClose ){ int cnt = 0; while( DeleteFileW(pFile->zDeleteOnClose)==0 && GetFileAttributesW(pFile->zDeleteOnClose)!=0xffffffff && cnt++ < WINCE_DELETION_ATTEMPTS ){ Sleep(100); } free(pFile->zDeleteOnClose); } 
#endif 
 OpenCounter(-1); return rc ? SQLITE_OK : SQLITE_IOERR; } 
#ifndef INVALID_SET_FILE_POINTER 
#define INVALID_SET_FILE_POINTER ((DWORD)-1) 
#endif 
static int winRead( sqlite3_file *id, void *pBuf, int amt, sqlite3_int64 offset ){ LONG upperBits = (offset>>32) & 0x7fffffff; LONG lowerBits = offset & 0xffffffff; DWORD rc; DWORD got; winFile *pFile = (winFile*)id; assert( id!=0 ); SimulateIOError(return SQLITE_IOERR_READ); OSTRACE3("READ %d lock=%d\n", pFile->h, pFile->locktype); rc = SetFilePointer(pFile->h, lowerBits, &upperBits, FILE_BEGIN); if( rc==INVALID_SET_FILE_POINTER && GetLastError()!=NO_ERROR ){ return SQLITE_FULL; } if( !ReadFile(pFile->h, pBuf, amt, &got, 0) ){ return SQLITE_IOERR_READ; } if( got==(DWORD)amt ){ return SQLITE_OK; }else{ memset(&((char*)pBuf)[got], 0, amt-got); return SQLITE_IOERR_SHORT_READ; } } static int winWrite( sqlite3_file *id, const void *pBuf, int amt, sqlite3_int64 offset ){ LONG upperBits = (offset>>32) & 0x7fffffff; LONG lowerBits = offset & 0xffffffff; DWORD rc; DWORD wrote; winFile *pFile = (winFile*)id; assert( id!=0 ); SimulateIOError(return SQLITE_IOERR_WRITE); SimulateDiskfullError(return SQLITE_FULL); OSTRACE3("WRITE %d lock=%d\n", pFile->h, pFile->locktype); rc = SetFilePointer(pFile->h, lowerBits, &upperBits, FILE_BEGIN); if( rc==INVALID_SET_FILE_POINTER && GetLastError()!=NO_ERROR ){ return SQLITE_FULL; } assert( amt>0 ); while( amt>0 && (rc = WriteFile(pFile->h, pBuf, amt, &wrote, 0))!=0 && wrote>0 ){ amt -= wrote; pBuf = &((char*)pBuf)[wrote]; } if( !rc || amt>(int)wrote ){ return SQLITE_FULL; } return SQLITE_OK; } static int winTruncate(sqlite3_file *id, sqlite3_int64 nByte){ DWORD rc; LONG upperBits = (nByte>>32) & 0x7fffffff; LONG lowerBits = nByte & 0xffffffff; winFile *pFile = (winFile*)id; OSTRACE3("TRUNCATE %d %lld\n", pFile->h, nByte); SimulateIOError(return SQLITE_IOERR_TRUNCATE); rc = SetFilePointer(pFile->h, lowerBits, &upperBits, FILE_BEGIN); if( INVALID_SET_FILE_POINTER != rc ){ if( SetEndOfFile(pFile->h) ){ return SQLITE_OK; } } return SQLITE_IOERR_TRUNCATE; } 
#ifdef SQLITE_TEST 
SQLITE_API int sqlite3_sync_count = 0; SQLITE_API int sqlite3_fullsync_count = 0; 
#endif 
static int winSync(sqlite3_file *id, int flags){ winFile *pFile = (winFile*)id; OSTRACE3("SYNC %d lock=%d\n", pFile->h, pFile->locktype); 
#ifdef SQLITE_TEST 
 if( flags & SQLITE_SYNC_FULL ){ sqlite3_fullsync_count++; } sqlite3_sync_count++; 
#endif 
 
#ifdef SQLITE_NO_SYNC 
 return SQLITE_OK; 
#else 
 if( FlushFileBuffers(pFile->h) ){ return SQLITE_OK; }else{ return SQLITE_IOERR; } 
#endif 
} static int winFileSize(sqlite3_file *id, sqlite3_int64 *pSize){ winFile *pFile = (winFile*)id; DWORD upperBits, lowerBits; SimulateIOError(return SQLITE_IOERR_FSTAT); lowerBits = GetFileSize(pFile->h, &upperBits); *pSize = (((sqlite3_int64)upperBits)<<32) + lowerBits; return SQLITE_OK; } 
#ifndef LOCKFILE_FAIL_IMMEDIATELY 
#define LOCKFILE_FAIL_IMMEDIATELY 1 
#endif 
static int getReadLock(winFile *pFile){ int res; if( isNT() ){ OVERLAPPED ovlp; ovlp.Offset = SHARED_FIRST; ovlp.OffsetHigh = 0; ovlp.hEvent = 0; res = LockFileEx(pFile->h, LOCKFILE_FAIL_IMMEDIATELY, 0, SHARED_SIZE, 0, &ovlp); 
#if SQLITE_OS_WINCE==0 
 }else{ int lk; sqlite3_randomness(sizeof(lk), &lk); pFile->sharedLockByte = (lk & 0x7fffffff)%(SHARED_SIZE - 1); res = LockFile(pFile->h, SHARED_FIRST+pFile->sharedLockByte, 0, 1, 0); 
#endif 
 } return res; } static int unlockReadLock(winFile *pFile){ int res; if( isNT() ){ res = UnlockFile(pFile->h, SHARED_FIRST, 0, SHARED_SIZE, 0); 
#if SQLITE_OS_WINCE==0 
 }else{ res = UnlockFile(pFile->h, SHARED_FIRST + pFile->sharedLockByte, 0, 1, 0); 
#endif 
 } return res; } static int winLock(sqlite3_file *id, int locktype){ int rc = SQLITE_OK; int res = 1; int newLocktype; int gotPendingLock = 0; winFile *pFile = (winFile*)id; assert( pFile!=0 ); OSTRACE5("LOCK %d %d was %d(%d)\n", pFile->h, locktype, pFile->locktype, pFile->sharedLockByte); if( pFile->locktype>=locktype ){ return SQLITE_OK; } assert( pFile->locktype!=NO_LOCK || locktype==SHARED_LOCK ); assert( locktype!=PENDING_LOCK ); assert( locktype!=RESERVED_LOCK || pFile->locktype==SHARED_LOCK ); newLocktype = pFile->locktype; if( pFile->locktype==NO_LOCK || (locktype==EXCLUSIVE_LOCK && pFile->locktype==RESERVED_LOCK) ){ int cnt = 3; while( cnt-->0 && (res = LockFile(pFile->h, PENDING_BYTE, 0, 1, 0))==0 ){ OSTRACE2("could not get a PENDING lock. cnt=%d\n", cnt); Sleep(1); } gotPendingLock = res; } if( locktype==SHARED_LOCK && res ){ assert( pFile->locktype==NO_LOCK ); res = getReadLock(pFile); if( res ){ newLocktype = SHARED_LOCK; } } if( locktype==RESERVED_LOCK && res ){ assert( pFile->locktype==SHARED_LOCK ); res = LockFile(pFile->h, RESERVED_BYTE, 0, 1, 0); if( res ){ newLocktype = RESERVED_LOCK; } } if( locktype==EXCLUSIVE_LOCK && res ){ newLocktype = PENDING_LOCK; gotPendingLock = 0; } if( locktype==EXCLUSIVE_LOCK && res ){ assert( pFile->locktype>=SHARED_LOCK ); res = unlockReadLock(pFile); OSTRACE2("unreadlock = %d\n", res); res = LockFile(pFile->h, SHARED_FIRST, 0, SHARED_SIZE, 0); if( res ){ newLocktype = EXCLUSIVE_LOCK; }else{ OSTRACE2("error-code = %d\n", GetLastError()); getReadLock(pFile); } } if( gotPendingLock && locktype==SHARED_LOCK ){ UnlockFile(pFile->h, PENDING_BYTE, 0, 1, 0); } if( res ){ rc = SQLITE_OK; }else{ OSTRACE4("LOCK FAILED %d trying for %d but got %d\n", pFile->h, locktype, newLocktype); rc = SQLITE_BUSY; } pFile->locktype = newLocktype; return rc; } static int winCheckReservedLock(sqlite3_file *id, int *pResOut){ int rc; winFile *pFile = (winFile*)id; assert( pFile!=0 ); if( pFile->locktype>=RESERVED_LOCK ){ rc = 1; OSTRACE3("TEST WR-LOCK %d %d (local)\n", pFile->h, rc); }else{ rc = LockFile(pFile->h, RESERVED_BYTE, 0, 1, 0); if( rc ){ UnlockFile(pFile->h, RESERVED_BYTE, 0, 1, 0); } rc = !rc; OSTRACE3("TEST WR-LOCK %d %d (remote)\n", pFile->h, rc); } *pResOut = rc; return SQLITE_OK; } static int winUnlock(sqlite3_file *id, int locktype){ int type; winFile *pFile = (winFile*)id; int rc = SQLITE_OK; assert( pFile!=0 ); assert( locktype<=SHARED_LOCK ); OSTRACE5("UNLOCK %d to %d was %d(%d)\n", pFile->h, locktype, pFile->locktype, pFile->sharedLockByte); type = pFile->locktype; if( type>=EXCLUSIVE_LOCK ){ UnlockFile(pFile->h, SHARED_FIRST, 0, SHARED_SIZE, 0); if( locktype==SHARED_LOCK && !getReadLock(pFile) ){ rc = SQLITE_IOERR_UNLOCK; } } if( type>=RESERVED_LOCK ){ UnlockFile(pFile->h, RESERVED_BYTE, 0, 1, 0); } if( locktype==NO_LOCK && type>=SHARED_LOCK ){ unlockReadLock(pFile); } if( type>=PENDING_LOCK ){ UnlockFile(pFile->h, PENDING_BYTE, 0, 1, 0); } pFile->locktype = locktype; return rc; } static int winFileControl(sqlite3_file *id, int op, void *pArg){ switch( op ){ case SQLITE_FCNTL_LOCKSTATE: { *(int*)pArg = ((winFile*)id)->locktype; return SQLITE_OK; } } return SQLITE_ERROR; } static int winSectorSize(sqlite3_file *id){ return SQLITE_DEFAULT_SECTOR_SIZE; } static int winDeviceCharacteristics(sqlite3_file *id){ return 0; } static const sqlite3_io_methods winIoMethod = { 1, winClose, winRead, winWrite, winTruncate, winSync, winFileSize, winLock, winUnlock, winCheckReservedLock, winFileControl, winSectorSize, winDeviceCharacteristics }; static void *convertUtf8Filename(const char *zFilename){ void *zConverted = 0; if( isNT() ){ zConverted = utf8ToUnicode(zFilename); 
#if SQLITE_OS_WINCE==0 
 }else{ zConverted = utf8ToMbcs(zFilename); 
#endif 
 } return zConverted; } static int getTempname(int nBuf, char *zBuf){ static char zChars[] = "abcdefghijklmnopqrstuvwxyz" "ABCDEFGHIJKLMNOPQRSTUVWXYZ" "0123456789"; size_t i, j; char zTempPath[MAX_PATH+1]; if( sqlite3_temp_directory ){ sqlite3_snprintf(MAX_PATH-30, zTempPath, "%s", sqlite3_temp_directory); }else if( isNT() ){ char *zMulti; WCHAR zWidePath[MAX_PATH]; GetTempPathW(MAX_PATH-30, zWidePath); zMulti = unicodeToUtf8(zWidePath); if( zMulti ){ sqlite3_snprintf(MAX_PATH-30, zTempPath, "%s", zMulti); free(zMulti); }else{ return SQLITE_NOMEM; } 
#if SQLITE_OS_WINCE==0 
 }else{ char *zUtf8; char zMbcsPath[MAX_PATH]; GetTempPathA(MAX_PATH-30, zMbcsPath); zUtf8 = sqlite3_win32_mbcs_to_utf8(zMbcsPath); if( zUtf8 ){ sqlite3_snprintf(MAX_PATH-30, zTempPath, "%s", zUtf8); free(zUtf8); }else{ return SQLITE_NOMEM; } 
#endif 
 } for(i=strlen(zTempPath); i>0 && zTempPath[i-1]=='\\'; i--){} zTempPath[i] = 0; sqlite3_snprintf(nBuf-30, zBuf, "%s\\"SQLITE_TEMP_FILE_PREFIX, zTempPath); j = strlen(zBuf); sqlite3_randomness(20, &zBuf[j]); for(i=0; i<20; i++, j++){ zBuf[j] = (char)zChars[ ((unsigned char)zBuf[j])%(sizeof(zChars)-1) ]; } zBuf[j] = 0; OSTRACE2("TEMP FILENAME: %s\n", zBuf); return SQLITE_OK; } static int getLastErrorMsg(int nBuf, char *zBuf){ DWORD error = GetLastError(); 
#if SQLITE_OS_WINCE 
 sqlite3_snprintf(nBuf, zBuf, "OsError 0x%x (%u)", error, error); 
#else 
 if (!FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, error, 0, zBuf, nBuf-1, 0)) { sqlite3_snprintf(nBuf, zBuf, "OsError 0x%x (%u)", error, error); } 
#endif 
 return 0; } static int winOpen( sqlite3_vfs *pVfs, const char *zName, sqlite3_file *id, int flags, int *pOutFlags ){ HANDLE h; DWORD dwDesiredAccess; DWORD dwShareMode; DWORD dwCreationDisposition; DWORD dwFlagsAndAttributes = 0; 
#if SQLITE_OS_WINCE 
 int isTemp = 0; 
#endif 
 winFile *pFile = (winFile*)id; void *zConverted; const char *zUtf8Name = zName; char zTmpname[MAX_PATH+1]; if( !zUtf8Name ){ int rc = getTempname(MAX_PATH+1, zTmpname); if( rc!=SQLITE_OK ){ return rc; } zUtf8Name = zTmpname; } zConverted = convertUtf8Filename(zUtf8Name); if( zConverted==0 ){ return SQLITE_NOMEM; } if( flags & SQLITE_OPEN_READWRITE ){ dwDesiredAccess = GENERIC_READ | GENERIC_WRITE; }else{ dwDesiredAccess = GENERIC_READ; } if( flags & SQLITE_OPEN_CREATE ){ dwCreationDisposition = OPEN_ALWAYS; }else{ dwCreationDisposition = OPEN_EXISTING; } if( flags & SQLITE_OPEN_MAIN_DB ){ dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE; }else{ dwShareMode = 0; } if( flags & SQLITE_OPEN_DELETEONCLOSE ){ 
#if SQLITE_OS_WINCE 
 dwFlagsAndAttributes = FILE_ATTRIBUTE_HIDDEN; isTemp = 1; 
#else 
 dwFlagsAndAttributes = FILE_ATTRIBUTE_TEMPORARY | FILE_ATTRIBUTE_HIDDEN | FILE_FLAG_DELETE_ON_CLOSE; 
#endif 
 }else{ dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL; } 
#if SQLITE_OS_WINCE 
 dwFlagsAndAttributes |= FILE_FLAG_RANDOM_ACCESS; 
#endif 
 if( isNT() ){ h = CreateFileW((WCHAR*)zConverted, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwFlagsAndAttributes, NULL ); 
#if SQLITE_OS_WINCE==0 
 }else{ h = CreateFileA((char*)zConverted, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwFlagsAndAttributes, NULL ); 
#endif 
 } if( h==INVALID_HANDLE_VALUE ){ free(zConverted); if( flags & SQLITE_OPEN_READWRITE ){ return winOpen(0, zName, id, ((flags|SQLITE_OPEN_READONLY)&~SQLITE_OPEN_READWRITE), pOutFlags); }else{ return SQLITE_CANTOPEN; } } if( pOutFlags ){ if( flags & SQLITE_OPEN_READWRITE ){ *pOutFlags = SQLITE_OPEN_READWRITE; }else{ *pOutFlags = SQLITE_OPEN_READONLY; } } memset(pFile, 0, sizeof(*pFile)); pFile->pMethod = &winIoMethod; pFile->h = h; 
#if SQLITE_OS_WINCE 
 if( (flags & (SQLITE_OPEN_READWRITE|SQLITE_OPEN_MAIN_DB)) == (SQLITE_OPEN_READWRITE|SQLITE_OPEN_MAIN_DB) && !winceCreateLock(zName, pFile) ){ CloseHandle(h); free(zConverted); return SQLITE_CANTOPEN; } if( isTemp ){ pFile->zDeleteOnClose = zConverted; }else 
#endif 
 { free(zConverted); } OpenCounter(+1); return SQLITE_OK; } 
#define MX_DELETION_ATTEMPTS 5 
static int winDelete( sqlite3_vfs *pVfs, const char *zFilename, int syncDir ){ int cnt = 0; DWORD rc; DWORD error; void *zConverted = convertUtf8Filename(zFilename); if( zConverted==0 ){ return SQLITE_NOMEM; } SimulateIOError(return SQLITE_IOERR_DELETE); if( isNT() ){ do{ DeleteFileW(zConverted); }while( ( ((rc = GetFileAttributesW(zConverted)) != INVALID_FILE_ATTRIBUTES) || ((error = GetLastError()) == ERROR_ACCESS_DENIED)) && (++cnt < MX_DELETION_ATTEMPTS) && (Sleep(100), 1) ); 
#if SQLITE_OS_WINCE==0 
 }else{ do{ DeleteFileA(zConverted); }while( ( ((rc = GetFileAttributesA(zConverted)) != INVALID_FILE_ATTRIBUTES) || ((error = GetLastError()) == ERROR_ACCESS_DENIED)) && (++cnt < MX_DELETION_ATTEMPTS) && (Sleep(100), 1) ); 
#endif 
 } free(zConverted); OSTRACE2("DELETE \"%s\"\n", zFilename); return ( (rc == INVALID_FILE_ATTRIBUTES) && (error == ERROR_FILE_NOT_FOUND)) ? SQLITE_OK : SQLITE_IOERR_DELETE; } static int winAccess( sqlite3_vfs *pVfs, const char *zFilename, int flags, int *pResOut ){ DWORD attr; int rc; void *zConverted = convertUtf8Filename(zFilename); if( zConverted==0 ){ return SQLITE_NOMEM; } if( isNT() ){ attr = GetFileAttributesW((WCHAR*)zConverted); 
#if SQLITE_OS_WINCE==0 
 }else{ attr = GetFileAttributesA((char*)zConverted); 
#endif 
 } free(zConverted); switch( flags ){ case SQLITE_ACCESS_READ: case SQLITE_ACCESS_EXISTS: rc = attr!=INVALID_FILE_ATTRIBUTES; break; case SQLITE_ACCESS_READWRITE: rc = (attr & FILE_ATTRIBUTE_READONLY)==0; break; default: assert(!"Invalid flags argument"); } *pResOut = rc; return SQLITE_OK; } static int winFullPathname( sqlite3_vfs *pVfs, const char *zRelative, int nFull, char *zFull ){ 
#if defined(__CYGWIN__) 
 cygwin_conv_to_full_win32_path(zRelative, zFull); return SQLITE_OK; 
#endif 
#if SQLITE_OS_WINCE 
 sqlite3_snprintf(pVfs->mxPathname, zFull, "%s", zRelative); return SQLITE_OK; 
#endif 
#if !SQLITE_OS_WINCE && !defined(__CYGWIN__) 
 int nByte; void *zConverted; char *zOut; zConverted = convertUtf8Filename(zRelative); if( isNT() ){ WCHAR *zTemp; nByte = GetFullPathNameW((WCHAR*)zConverted, 0, 0, 0) + 3; zTemp = malloc( nByte*sizeof(zTemp[0]) ); if( zTemp==0 ){ free(zConverted); return SQLITE_NOMEM; } GetFullPathNameW((WCHAR*)zConverted, nByte, zTemp, 0); free(zConverted); zOut = unicodeToUtf8(zTemp); free(zTemp); 
#if SQLITE_OS_WINCE==0 
 }else{ char *zTemp; nByte = GetFullPathNameA((char*)zConverted, 0, 0, 0) + 3; zTemp = malloc( nByte*sizeof(zTemp[0]) ); if( zTemp==0 ){ free(zConverted); return SQLITE_NOMEM; } GetFullPathNameA((char*)zConverted, nByte, zTemp, 0); free(zConverted); zOut = sqlite3_win32_mbcs_to_utf8(zTemp); free(zTemp); 
#endif 
 } if( zOut ){ sqlite3_snprintf(pVfs->mxPathname, zFull, "%s", zOut); free(zOut); return SQLITE_OK; }else{ return SQLITE_NOMEM; } 
#endif 
} 
#ifndef SQLITE_OMIT_LOAD_EXTENSION 
static void *winDlOpen(sqlite3_vfs *pVfs, const char *zFilename){ HANDLE h; void *zConverted = convertUtf8Filename(zFilename); if( zConverted==0 ){ return 0; } if( isNT() ){ h = LoadLibraryW((WCHAR*)zConverted); 
#if SQLITE_OS_WINCE==0 
 }else{ h = LoadLibraryA((char*)zConverted); 
#endif 
 } free(zConverted); return (void*)h; } static void winDlError(sqlite3_vfs *pVfs, int nBuf, char *zBufOut){ getLastErrorMsg(nBuf, zBufOut); } void *winDlSym(sqlite3_vfs *pVfs, void *pHandle, const char *zSymbol){ 
#if SQLITE_OS_WINCE 
 return GetProcAddressA((HANDLE)pHandle, zSymbol); 
#else 
 return GetProcAddress((HANDLE)pHandle, zSymbol); 
#endif 
} void winDlClose(sqlite3_vfs *pVfs, void *pHandle){ FreeLibrary((HANDLE)pHandle); } 
#else 
#define winDlOpen 0 
#define winDlError 0 
#define winDlSym 0 
#define winDlClose 0 
#endif 
static int winRandomness(sqlite3_vfs *pVfs, int nBuf, char *zBuf){ int n = 0; UNUSED_PARAMETER(pVfs); 
#if defined(SQLITE_TEST) 
 n = nBuf; memset(zBuf, 0, nBuf); 
#else 
 if( sizeof(SYSTEMTIME)<=nBuf-n ){ SYSTEMTIME x; GetSystemTime(&x); memcpy(&zBuf[n], &x, sizeof(x)); n += sizeof(x); } if( sizeof(DWORD)<=nBuf-n ){ DWORD pid = GetCurrentProcessId(); memcpy(&zBuf[n], &pid, sizeof(pid)); n += sizeof(pid); } if( sizeof(DWORD)<=nBuf-n ){ DWORD cnt = GetTickCount(); memcpy(&zBuf[n], &cnt, sizeof(cnt)); n += sizeof(cnt); } if( sizeof(LARGE_INTEGER)<=nBuf-n ){ LARGE_INTEGER i; QueryPerformanceCounter(&i); memcpy(&zBuf[n], &i, sizeof(i)); n += sizeof(i); } 
#endif 
 return n; } static int winSleep(sqlite3_vfs *pVfs, int microsec){ Sleep((microsec+999)/1000); return ((microsec+999)/1000)*1000; } 
#ifdef SQLITE_TEST 
SQLITE_API int sqlite3_current_time = 0; 
#endif 
int winCurrentTime(sqlite3_vfs *pVfs, double *prNow){ FILETIME ft; double now; 
#if SQLITE_OS_WINCE 
 SYSTEMTIME time; GetSystemTime(&time); if (!SystemTimeToFileTime(&time,&ft)){ return 1; } 
#else 
 GetSystemTimeAsFileTime( &ft ); 
#endif 
 now = ((double)ft.dwHighDateTime) * 4294967296.0; *prNow = (now + ft.dwLowDateTime)/864000000000.0 + 2305813.5; 
#ifdef SQLITE_TEST 
 if( sqlite3_current_time ){ *prNow = sqlite3_current_time/86400.0 + 2440587.5; } 
#endif 
 return 0; } static int winGetLastError(sqlite3_vfs *pVfs, int nBuf, char *zBuf){ return getLastErrorMsg(nBuf, zBuf); } SQLITE_API int sqlite3_os_init(void){ static sqlite3_vfs winVfs = { 1, sizeof(winFile), MAX_PATH, 0, "win32", 0, winOpen, winDelete, winAccess, winFullPathname, winDlOpen, winDlError, winDlSym, winDlClose, winRandomness, winSleep, winCurrentTime, winGetLastError }; sqlite3_vfs_register(&winVfs, 1); return SQLITE_OK; } SQLITE_API int sqlite3_os_end(void){ return SQLITE_OK; } 
#endif 
#define BITVEC_SZ 512 
#define BITVEC_USIZE (((BITVEC_SZ-(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*)) 
#define BITVEC_TELEM u8 
#define BITVEC_SZELEM 8 
#define BITVEC_NELEM (BITVEC_USIZE/sizeof(BITVEC_TELEM)) 
#define BITVEC_NBIT (BITVEC_NELEM*BITVEC_SZELEM) 
#define BITVEC_NINT (BITVEC_USIZE/sizeof(u32)) 
#define BITVEC_MXHASH (BITVEC_NINT/2) 
#define BITVEC_HASH(X) (((X)*1)%BITVEC_NINT) 
#define BITVEC_NPTR (BITVEC_USIZE/sizeof(Bitvec *)) 
struct Bitvec { u32 iSize; u32 nSet; u32 iDivisor; union { BITVEC_TELEM aBitmap[BITVEC_NELEM]; u32 aHash[BITVEC_NINT]; Bitvec *apSub[BITVEC_NPTR]; } u; }; SQLITE_PRIVATE Bitvec *sqlite3BitvecCreate(u32 iSize){ Bitvec *p; assert( sizeof(*p)==BITVEC_SZ ); p = sqlite3MallocZero( sizeof(*p) ); if( p ){ p->iSize = iSize; } return p; } SQLITE_PRIVATE int sqlite3BitvecTest(Bitvec *p, u32 i){ if( p==0 ) return 0; if( i>p->iSize || i==0 ) return 0; i--; while( p->iDivisor ){ u32 bin = i/p->iDivisor; i = i%p->iDivisor; p = p->u.apSub[bin]; if (!p) { return 0; } } if( p->iSize<=BITVEC_NBIT ){ return (p->u.aBitmap[i/BITVEC_SZELEM] & (1<<(i&(BITVEC_SZELEM-1))))!=0; } else{ u32 h = BITVEC_HASH(i++); while( p->u.aHash[h] ){ if( p->u.aHash[h]==i ) return 1; h++; if( h>=BITVEC_NINT ) h = 0; } return 0; } } SQLITE_PRIVATE int sqlite3BitvecSet(Bitvec *p, u32 i){ u32 h; assert( p!=0 ); assert( i>0 ); assert( i<=p->iSize ); i--; while((p->iSize > BITVEC_NBIT) && p->iDivisor) { u32 bin = i/p->iDivisor; i = i%p->iDivisor; if( p->u.apSub[bin]==0 ){ sqlite3BeginBenignMalloc(); p->u.apSub[bin] = sqlite3BitvecCreate( p->iDivisor ); sqlite3EndBenignMalloc(); if( p->u.apSub[bin]==0 ) return SQLITE_NOMEM; } p = p->u.apSub[bin]; } if( p->iSize<=BITVEC_NBIT ){ p->u.aBitmap[i/BITVEC_SZELEM] |= 1 << (i&(BITVEC_SZELEM-1)); return SQLITE_OK; } h = BITVEC_HASH(i++); if( !p->u.aHash[h] ){ if (p->nSet<(BITVEC_NINT-1)) { goto bitvec_set_end; } else { goto bitvec_set_rehash; } } do { if( p->u.aHash[h]==i ) return SQLITE_OK; h++; if( h>=BITVEC_NINT ) h = 0; } while( p->u.aHash[h] ); bitvec_set_rehash: if( p->nSet>=BITVEC_MXHASH ){ unsigned int j; int rc; u32 aiValues[BITVEC_NINT]; memcpy(aiValues, p->u.aHash, sizeof(aiValues)); memset(p->u.apSub, 0, sizeof(aiValues)); p->iDivisor = (p->iSize + BITVEC_NPTR - 1)/BITVEC_NPTR; rc = sqlite3BitvecSet(p, i); for(j=0; j<BITVEC_NINT; j++){ if( aiValues[j] ) rc |= sqlite3BitvecSet(p, aiValues[j]); } return rc; } bitvec_set_end: p->nSet++; p->u.aHash[h] = i; return SQLITE_OK; } SQLITE_PRIVATE void sqlite3BitvecClear(Bitvec *p, u32 i){ assert( p!=0 ); assert( i>0 ); i--; while( p->iDivisor ){ u32 bin = i/p->iDivisor; i = i%p->iDivisor; p = p->u.apSub[bin]; if (!p) { return; } } if( p->iSize<=BITVEC_NBIT ){ p->u.aBitmap[i/BITVEC_SZELEM] &= ~(1 << (i&(BITVEC_SZELEM-1))); }else{ unsigned int j; u32 aiValues[BITVEC_NINT]; memcpy(aiValues, p->u.aHash, sizeof(aiValues)); memset(p->u.aHash, 0, sizeof(aiValues)); p->nSet = 0; for(j=0; j<BITVEC_NINT; j++){ if( aiValues[j] && aiValues[j]!=(i+1) ){ u32 h = BITVEC_HASH(aiValues[j]-1); p->nSet++; while( p->u.aHash[h] ){ h++; if( h>=BITVEC_NINT ) h = 0; } p->u.aHash[h] = aiValues[j]; } } } } SQLITE_PRIVATE void sqlite3BitvecDestroy(Bitvec *p){ if( p==0 ) return; if( p->iDivisor ){ unsigned int i; for(i=0; i<BITVEC_NPTR; i++){ sqlite3BitvecDestroy(p->u.apSub[i]); } } sqlite3_free(p); } 
#ifndef SQLITE_OMIT_BUILTIN_TEST 
#define SETBIT(V,I) V[I>>3] |= (1<<(I&7)) 
#define CLEARBIT(V,I) V[I>>3] &= ~(1<<(I&7)) 
#define TESTBIT(V,I) (V[I>>3]&(1<<(I&7)))!=0 
SQLITE_PRIVATE int sqlite3BitvecBuiltinTest(int sz, int *aOp){ Bitvec *pBitvec = 0; unsigned char *pV = 0; int rc = -1; int i, nx, pc, op; pBitvec = sqlite3BitvecCreate( sz ); pV = sqlite3_malloc( (sz+7)/8 + 1 ); if( pBitvec==0 || pV==0 ) goto bitvec_end; memset(pV, 0, (sz+7)/8 + 1); pc = 0; while( (op = aOp[pc])!=0 ){ switch( op ){ case 1: case 2: case 5: { nx = 4; i = aOp[pc+2] - 1; aOp[pc+2] += aOp[pc+3]; break; } case 3: case 4: default: { nx = 2; sqlite3_randomness(sizeof(i), &i); break; } } if( (--aOp[pc+1]) > 0 ) nx = 0; pc += nx; i = (i & 0x7fffffff)%sz; if( (op & 1)!=0 ){ SETBIT(pV, (i+1)); if( op!=5 ){ if( sqlite3BitvecSet(pBitvec, i+1) ) goto bitvec_end; } }else{ CLEARBIT(pV, (i+1)); sqlite3BitvecClear(pBitvec, i+1); } } rc = sqlite3BitvecTest(0,0) + sqlite3BitvecTest(pBitvec, sz+1) + sqlite3BitvecTest(pBitvec, 0); for(i=1; i<=sz; i++){ if( (TESTBIT(pV,i))!=sqlite3BitvecTest(pBitvec,i) ){ rc = i; break; } } bitvec_end: sqlite3_free(pV); sqlite3BitvecDestroy(pBitvec); return rc; } 
#endif 
struct PCache { PgHdr *pDirty, *pDirtyTail; PgHdr *pSynced; int nRef; int nMax; int nMin; int szPage; int szExtra; int bPurgeable; int (*xStress)(void*,PgHdr*); void *pStress; sqlite3_pcache *pCache; PgHdr *pPage1; }; 
#ifdef SQLITE_ENABLE_EXPENSIVE_ASSERT 
#define expensive_assert(X) assert(X) 
#else 
#define expensive_assert(X) 
#endif 
#if !defined(NDEBUG) && defined(SQLITE_ENABLE_EXPENSIVE_ASSERT) 
static int pcacheCheckSynced(PCache *pCache){ PgHdr *p; for(p=pCache->pDirtyTail; p!=pCache->pSynced; p=p->pDirtyPrev){ assert( p->nRef || (p->flags&PGHDR_NEED_SYNC) ); } return (p==0 || p->nRef || (p->flags&PGHDR_NEED_SYNC)==0); } 
#endif 
static void pcacheRemoveFromDirtyList(PgHdr *pPage){ PCache *p = pPage->pCache; assert( pPage->pDirtyNext || pPage==p->pDirtyTail ); assert( pPage->pDirtyPrev || pPage==p->pDirty ); if( p->pSynced==pPage ){ PgHdr *pSynced = pPage->pDirtyPrev; while( pSynced && (pSynced->flags&PGHDR_NEED_SYNC) ){ pSynced = pSynced->pDirtyPrev; } p->pSynced = pSynced; } if( pPage->pDirtyNext ){ pPage->pDirtyNext->pDirtyPrev = pPage->pDirtyPrev; }else{ assert( pPage==p->pDirtyTail ); p->pDirtyTail = pPage->pDirtyPrev; } if( pPage->pDirtyPrev ){ pPage->pDirtyPrev->pDirtyNext = pPage->pDirtyNext; }else{ assert( pPage==p->pDirty ); p->pDirty = pPage->pDirtyNext; } pPage->pDirtyNext = 0; pPage->pDirtyPrev = 0; expensive_assert( pcacheCheckSynced(p) ); } static void pcacheAddToDirtyList(PgHdr *pPage){ PCache *p = pPage->pCache; assert( pPage->pDirtyNext==0 && pPage->pDirtyPrev==0 && p->pDirty!=pPage ); pPage->pDirtyNext = p->pDirty; if( pPage->pDirtyNext ){ assert( pPage->pDirtyNext->pDirtyPrev==0 ); pPage->pDirtyNext->pDirtyPrev = pPage; } p->pDirty = pPage; if( !p->pDirtyTail ){ p->pDirtyTail = pPage; } if( !p->pSynced && 0==(pPage->flags&PGHDR_NEED_SYNC) ){ p->pSynced = pPage; } expensive_assert( pcacheCheckSynced(p) ); } static void pcacheUnpin(PgHdr *p){ PCache *pCache = p->pCache; if( pCache->bPurgeable ){ if( p->pgno==1 ){ pCache->pPage1 = 0; } sqlite3GlobalConfig.pcache.xUnpin(pCache->pCache, p, 0); } } SQLITE_PRIVATE int sqlite3PcacheInitialize(void){ if( sqlite3GlobalConfig.pcache.xInit==0 ){ sqlite3PCacheSetDefault(); } return sqlite3GlobalConfig.pcache.xInit(sqlite3GlobalConfig.pcache.pArg); } SQLITE_PRIVATE void sqlite3PcacheShutdown(void){ if( sqlite3GlobalConfig.pcache.xShutdown ){ sqlite3GlobalConfig.pcache.xShutdown(sqlite3GlobalConfig.pcache.pArg); } } SQLITE_PRIVATE int sqlite3PcacheSize(void){ return sizeof(PCache); } SQLITE_PRIVATE void sqlite3PcacheOpen( int szPage, int szExtra, int bPurgeable, int (*xStress)(void*,PgHdr*), void *pStress, PCache *p ){ memset(p, 0, sizeof(PCache)); p->szPage = szPage; p->szExtra = szExtra; p->bPurgeable = bPurgeable; p->xStress = xStress; p->pStress = pStress; p->nMax = 100; p->nMin = 10; } SQLITE_PRIVATE void sqlite3PcacheSetPageSize(PCache *pCache, int szPage){ assert( pCache->nRef==0 && pCache->pDirty==0 ); if( pCache->pCache ){ sqlite3GlobalConfig.pcache.xDestroy(pCache->pCache); pCache->pCache = 0; } pCache->szPage = szPage; } SQLITE_PRIVATE int sqlite3PcacheFetch( PCache *pCache, Pgno pgno, int createFlag, PgHdr **ppPage ){ PgHdr *pPage = 0; int eCreate; assert( pCache!=0 ); assert( pgno>0 ); if( !pCache->pCache && createFlag ){ sqlite3_pcache *p; int nByte; nByte = pCache->szPage + pCache->szExtra + sizeof(PgHdr); p = sqlite3GlobalConfig.pcache.xCreate(nByte, pCache->bPurgeable); if( !p ){ return SQLITE_NOMEM; } sqlite3GlobalConfig.pcache.xCachesize(p, pCache->nMax); pCache->pCache = p; } eCreate = createFlag ? 1 : 0; if( eCreate && (!pCache->bPurgeable || !pCache->pDirty) ){ eCreate = 2; } if( pCache->pCache ){ pPage = sqlite3GlobalConfig.pcache.xFetch(pCache->pCache, pgno, eCreate); } if( !pPage && eCreate==1 ){ PgHdr *pPg; expensive_assert( pcacheCheckSynced(pCache) ); for(pPg=pCache->pSynced; pPg && (pPg->nRef || (pPg->flags&PGHDR_NEED_SYNC)); pPg=pPg->pDirtyPrev ); if( !pPg ){ for(pPg=pCache->pDirtyTail; pPg && pPg->nRef; pPg=pPg->pDirtyPrev); } if( pPg ){ int rc; rc = pCache->xStress(pCache->pStress, pPg); if( rc!=SQLITE_OK && rc!=SQLITE_BUSY ){ return rc; } } pPage = sqlite3GlobalConfig.pcache.xFetch(pCache->pCache, pgno, 2); } if( pPage ){ if( 0==pPage->nRef ){ pCache->nRef++; } pPage->nRef++; pPage->pData = (void*)&pPage[1]; pPage->pExtra = (void*)&((char*)pPage->pData)[pCache->szPage]; pPage->pCache = pCache; pPage->pgno = pgno; if( pgno==1 ){ pCache->pPage1 = pPage; } } *ppPage = pPage; return (pPage==0 && eCreate) ? SQLITE_NOMEM : SQLITE_OK; } SQLITE_PRIVATE void sqlite3PcacheRelease(PgHdr *p){ assert( p->nRef>0 ); p->nRef--; if( p->nRef==0 ){ PCache *pCache = p->pCache; pCache->nRef--; if( (p->flags&PGHDR_DIRTY)==0 ){ pcacheUnpin(p); }else{ pcacheRemoveFromDirtyList(p); pcacheAddToDirtyList(p); } } } SQLITE_PRIVATE void sqlite3PcacheRef(PgHdr *p){ assert(p->nRef>0); p->nRef++; } SQLITE_PRIVATE void sqlite3PcacheDrop(PgHdr *p){ PCache *pCache; assert( p->nRef==1 ); if( p->flags&PGHDR_DIRTY ){ pcacheRemoveFromDirtyList(p); } pCache = p->pCache; pCache->nRef--; if( p->pgno==1 ){ pCache->pPage1 = 0; } sqlite3GlobalConfig.pcache.xUnpin(pCache->pCache, p, 1); } SQLITE_PRIVATE void sqlite3PcacheMakeDirty(PgHdr *p){ PCache *pCache; p->flags &= ~PGHDR_DONT_WRITE; assert( p->nRef>0 ); if( 0==(p->flags & PGHDR_DIRTY) ){ pCache = p->pCache; p->flags |= PGHDR_DIRTY; pcacheAddToDirtyList( p); } } SQLITE_PRIVATE void sqlite3PcacheMakeClean(PgHdr *p){ if( (p->flags & PGHDR_DIRTY) ){ pcacheRemoveFromDirtyList(p); p->flags &= ~(PGHDR_DIRTY|PGHDR_NEED_SYNC); if( p->nRef==0 ){ pcacheUnpin(p); } } } SQLITE_PRIVATE void sqlite3PcacheCleanAll(PCache *pCache){ PgHdr *p; while( (p = pCache->pDirty)!=0 ){ sqlite3PcacheMakeClean(p); } } SQLITE_PRIVATE void sqlite3PcacheClearSyncFlags(PCache *pCache){ PgHdr *p; for(p=pCache->pDirty; p; p=p->pDirtyNext){ p->flags &= ~PGHDR_NEED_SYNC; } pCache->pSynced = pCache->pDirtyTail; } SQLITE_PRIVATE void sqlite3PcacheMove(PgHdr *p, Pgno newPgno){ PCache *pCache = p->pCache; assert( p->nRef>0 ); assert( newPgno>0 ); sqlite3GlobalConfig.pcache.xRekey(pCache->pCache, p, p->pgno, newPgno); p->pgno = newPgno; if( (p->flags&PGHDR_DIRTY) && (p->flags&PGHDR_NEED_SYNC) ){ pcacheRemoveFromDirtyList(p); pcacheAddToDirtyList(p); } } SQLITE_PRIVATE void sqlite3PcacheTruncate(PCache *pCache, Pgno pgno){ if( pCache->pCache ){ PgHdr *p; PgHdr *pNext; for(p=pCache->pDirty; p; p=pNext){ pNext = p->pDirtyNext; if( p->pgno>pgno ){ assert( p->flags&PGHDR_DIRTY ); sqlite3PcacheMakeClean(p); } } if( pgno==0 && pCache->pPage1 ){ memset(pCache->pPage1->pData, 0, pCache->szPage); pgno = 1; } sqlite3GlobalConfig.pcache.xTruncate(pCache->pCache, pgno+1); } } SQLITE_PRIVATE void sqlite3PcacheClose(PCache *pCache){ if( pCache->pCache ){ sqlite3GlobalConfig.pcache.xDestroy(pCache->pCache); } } SQLITE_PRIVATE int sqlite3PcacheClear(PCache *pCache){ sqlite3PcacheTruncate(pCache, 0); return SQLITE_OK; } static PgHdr *pcacheMergeDirtyList(PgHdr *pA, PgHdr *pB){ PgHdr result, *pTail; pTail = &result; while( pA && pB ){ if( pA->pgno<pB->pgno ){ pTail->pDirty = pA; pTail = pA; pA = pA->pDirty; }else{ pTail->pDirty = pB; pTail = pB; pB = pB->pDirty; } } if( pA ){ pTail->pDirty = pA; }else if( pB ){ pTail->pDirty = pB; }else{ pTail->pDirty = 0; } return result.pDirty; } 
#define N_SORT_BUCKET_ALLOC 25 
#define N_SORT_BUCKET 25 
#ifdef SQLITE_TEST 
 int sqlite3_pager_n_sort_bucket = 0; 
#undef N_SORT_BUCKET 
#define N_SORT_BUCKET (sqlite3_pager_n_sort_bucket?sqlite3_pager_n_sort_bucket:N_SORT_BUCKET_ALLOC) 
#endif 
static PgHdr *pcacheSortDirtyList(PgHdr *pIn){ PgHdr *a[N_SORT_BUCKET_ALLOC], *p; int i; memset(a, 0, sizeof(a)); while( pIn ){ p = pIn; pIn = p->pDirty; p->pDirty = 0; for(i=0; i<N_SORT_BUCKET-1; i++){ if( a[i]==0 ){ a[i] = p; break; }else{ p = pcacheMergeDirtyList(a[i], p); a[i] = 0; } } if( i==N_SORT_BUCKET-1 ){ a[i] = pcacheMergeDirtyList(a[i], p); } } p = a[0]; for(i=1; i<N_SORT_BUCKET; i++){ p = pcacheMergeDirtyList(p, a[i]); } return p; } SQLITE_PRIVATE PgHdr *sqlite3PcacheDirtyList(PCache *pCache){ PgHdr *p; for(p=pCache->pDirty; p; p=p->pDirtyNext){ p->pDirty = p->pDirtyNext; } return pcacheSortDirtyList(pCache->pDirty); } SQLITE_PRIVATE int sqlite3PcacheRefCount(PCache *pCache){ return pCache->nRef; } SQLITE_PRIVATE int sqlite3PcachePageRefcount(PgHdr *p){ return p->nRef; } SQLITE_PRIVATE int sqlite3PcachePagecount(PCache *pCache){ int nPage = 0; if( pCache->pCache ){ nPage = sqlite3GlobalConfig.pcache.xPagecount(pCache->pCache); } return nPage; } 
#ifdef SQLITE_TEST 
SQLITE_PRIVATE int sqlite3PcacheGetCachesize(PCache *pCache){ return pCache->nMax; } 
#endif 
SQLITE_PRIVATE void sqlite3PcacheSetCachesize(PCache *pCache, int mxPage){ pCache->nMax = mxPage; if( pCache->pCache ){ sqlite3GlobalConfig.pcache.xCachesize(pCache->pCache, mxPage); } } 
#ifdef SQLITE_CHECK_PAGES 
SQLITE_PRIVATE void sqlite3PcacheIterateDirty(PCache *pCache, void (*xIter)(PgHdr *)){ PgHdr *pDirty; for(pDirty=pCache->pDirty; pDirty; pDirty=pDirty->pDirtyNext){ xIter(pDirty); } } 
#endif 
typedef struct PCache1 PCache1; typedef struct PgHdr1 PgHdr1; typedef struct PgFreeslot PgFreeslot; struct PCache1 { int szPage; int bPurgeable; unsigned int nMin; unsigned int nMax; unsigned int nRecyclable; unsigned int nPage; unsigned int nHash; PgHdr1 **apHash; }; struct PgHdr1 { unsigned int iKey; PgHdr1 *pNext; PCache1 *pCache; PgHdr1 *pLruNext; PgHdr1 *pLruPrev; }; struct PgFreeslot { PgFreeslot *pNext; }; static SQLITE_WSD struct PCacheGlobal { sqlite3_mutex *mutex; int nMaxPage; int nMinPage; int nCurrentPage; PgHdr1 *pLruHead, *pLruTail; int szSlot; void *pStart, *pEnd; PgFreeslot *pFree; } pcache1_g; 
#define pcache1 (GLOBAL(struct PCacheGlobal, pcache1_g)) 
#define PGHDR1_TO_PAGE(p) (void *)(&((unsigned char *)p)[sizeof(PgHdr1)]) 
#define PAGE_TO_PGHDR1(p) (PgHdr1 *)(&((unsigned char *)p)[-1*sizeof(PgHdr1)]) 
#define pcache1EnterMutex() sqlite3_mutex_enter(pcache1.mutex) 
#define pcache1LeaveMutex() sqlite3_mutex_leave(pcache1.mutex) 
SQLITE_PRIVATE void sqlite3PCacheBufferSetup(void *pBuf, int sz, int n){ PgFreeslot *p; sz &= ~7; pcache1.szSlot = sz; pcache1.pStart = pBuf; pcache1.pFree = 0; while( n-- ){ p = (PgFreeslot*)pBuf; p->pNext = pcache1.pFree; pcache1.pFree = p; pBuf = (void*)&((char*)pBuf)[sz]; } pcache1.pEnd = pBuf; } static void *pcache1Alloc(int nByte){ void *p; assert( sqlite3_mutex_held(pcache1.mutex) ); if( nByte<=pcache1.szSlot && pcache1.pFree ){ p = (PgHdr1 *)pcache1.pFree; pcache1.pFree = pcache1.pFree->pNext; sqlite3StatusSet(SQLITE_STATUS_PAGECACHE_SIZE, nByte); sqlite3StatusAdd(SQLITE_STATUS_PAGECACHE_USED, 1); }else{ pcache1LeaveMutex(); p = sqlite3Malloc(nByte); pcache1EnterMutex(); if( p ){ int sz = sqlite3MallocSize(p); sqlite3StatusAdd(SQLITE_STATUS_PAGECACHE_OVERFLOW, sz); } } return p; } static void pcache1Free(void *p){ assert( sqlite3_mutex_held(pcache1.mutex) ); if( p==0 ) return; if( p>=pcache1.pStart && p<pcache1.pEnd ){ PgFreeslot *pSlot; sqlite3StatusAdd(SQLITE_STATUS_PAGECACHE_USED, -1); pSlot = (PgFreeslot*)p; pSlot->pNext = pcache1.pFree; pcache1.pFree = pSlot; }else{ int iSize = sqlite3MallocSize(p); sqlite3StatusAdd(SQLITE_STATUS_PAGECACHE_OVERFLOW, -iSize); sqlite3_free(p); } } static PgHdr1 *pcache1AllocPage(PCache1 *pCache){ int nByte = sizeof(PgHdr1) + pCache->szPage; PgHdr1 *p = (PgHdr1 *)pcache1Alloc(nByte); if( p ){ memset(p, 0, nByte); if( pCache->bPurgeable ){ pcache1.nCurrentPage++; } } return p; } static void pcache1FreePage(PgHdr1 *p){ if( p ){ if( p->pCache->bPurgeable ){ pcache1.nCurrentPage--; } pcache1Free(p); } } SQLITE_PRIVATE void *sqlite3PageMalloc(int sz){ void *p; pcache1EnterMutex(); p = pcache1Alloc(sz); pcache1LeaveMutex(); return p; } SQLITE_PRIVATE void sqlite3PageFree(void *p){ pcache1EnterMutex(); pcache1Free(p); pcache1LeaveMutex(); } static int pcache1ResizeHash(PCache1 *p){ PgHdr1 **apNew; unsigned int nNew; unsigned int i; assert( sqlite3_mutex_held(pcache1.mutex) ); nNew = p->nHash*2; if( nNew<256 ){ nNew = 256; } pcache1LeaveMutex(); apNew = (PgHdr1 **)sqlite3_malloc(sizeof(PgHdr1 *)*nNew); pcache1EnterMutex(); if( apNew ){ memset(apNew, 0, sizeof(PgHdr1 *)*nNew); for(i=0; i<p->nHash; i++){ PgHdr1 *pPage; PgHdr1 *pNext = p->apHash[i]; while( (pPage = pNext) ){ unsigned int h = pPage->iKey % nNew; pNext = pPage->pNext; pPage->pNext = apNew[h]; apNew[h] = pPage; } } sqlite3_free(p->apHash); p->apHash = apNew; p->nHash = nNew; } return (p->apHash ? SQLITE_OK : SQLITE_NOMEM); } static void pcache1PinPage(PgHdr1 *pPage){ assert( sqlite3_mutex_held(pcache1.mutex) ); if( pPage && (pPage->pLruNext || pPage==pcache1.pLruTail) ){ if( pPage->pLruPrev ){ pPage->pLruPrev->pLruNext = pPage->pLruNext; } if( pPage->pLruNext ){ pPage->pLruNext->pLruPrev = pPage->pLruPrev; } if( pcache1.pLruHead==pPage ){ pcache1.pLruHead = pPage->pLruNext; } if( pcache1.pLruTail==pPage ){ pcache1.pLruTail = pPage->pLruPrev; } pPage->pLruNext = 0; pPage->pLruPrev = 0; pPage->pCache->nRecyclable--; } } static void pcache1RemoveFromHash(PgHdr1 *pPage){ unsigned int h; PCache1 *pCache = pPage->pCache; PgHdr1 **pp; h = pPage->iKey % pCache->nHash; for(pp=&pCache->apHash[h]; (*pp)!=pPage; pp=&(*pp)->pNext); *pp = (*pp)->pNext; pCache->nPage--; } static void pcache1EnforceMaxPage(void){ assert( sqlite3_mutex_held(pcache1.mutex) ); while( pcache1.nCurrentPage>pcache1.nMaxPage && pcache1.pLruTail ){ PgHdr1 *p = pcache1.pLruTail; pcache1PinPage(p); pcache1RemoveFromHash(p); pcache1FreePage(p); } } static void pcache1TruncateUnsafe( PCache1 *pCache, unsigned int iLimit ){ unsigned int h; assert( sqlite3_mutex_held(pcache1.mutex) ); for(h=0; h<pCache->nHash; h++){ PgHdr1 **pp = &pCache->apHash[h]; PgHdr1 *pPage; while( (pPage = *pp) ){ if( pPage->iKey>=iLimit ){ pcache1PinPage(pPage); *pp = pPage->pNext; pcache1FreePage(pPage); }else{ pp = &pPage->pNext; } } } } static int pcache1Init(void *NotUsed){ UNUSED_PARAMETER(NotUsed); memset(&pcache1, 0, sizeof(pcache1)); if( sqlite3GlobalConfig.bCoreMutex ){ pcache1.mutex = sqlite3_mutex_alloc(SQLITE_MUTEX_STATIC_LRU); } return SQLITE_OK; } static void pcache1Shutdown(void *NotUsed){ UNUSED_PARAMETER(NotUsed); } static sqlite3_pcache *pcache1Create(int szPage, int bPurgeable){ PCache1 *pCache; pCache = (PCache1 *)sqlite3_malloc(sizeof(PCache1)); if( pCache ){ memset(pCache, 0, sizeof(PCache1)); pCache->szPage = szPage; pCache->bPurgeable = (bPurgeable ? 1 : 0); if( bPurgeable ){ pCache->nMin = 10; pcache1EnterMutex(); pcache1.nMinPage += pCache->nMin; pcache1LeaveMutex(); } } return (sqlite3_pcache *)pCache; } static void pcache1Cachesize(sqlite3_pcache *p, int nMax){ PCache1 *pCache = (PCache1 *)p; if( pCache->bPurgeable ){ pcache1EnterMutex(); pcache1.nMaxPage += (nMax - pCache->nMax); pCache->nMax = nMax; pcache1EnforceMaxPage(); pcache1LeaveMutex(); } } static int pcache1Pagecount(sqlite3_pcache *p){ int n; pcache1EnterMutex(); n = ((PCache1 *)p)->nPage; pcache1LeaveMutex(); return n; } static void *pcache1Fetch(sqlite3_pcache *p, unsigned int iKey, int createFlag){ unsigned int nPinned; PCache1 *pCache = (PCache1 *)p; PgHdr1 *pPage = 0; pcache1EnterMutex(); if( createFlag==1 ) sqlite3BeginBenignMalloc(); if( pCache->nHash>0 ){ unsigned int h = iKey % pCache->nHash; for(pPage=pCache->apHash[h]; pPage&&pPage->iKey!=iKey; pPage=pPage->pNext); } if( pPage || createFlag==0 ){ pcache1PinPage(pPage); goto fetch_out; } nPinned = pCache->nPage - pCache->nRecyclable; if( createFlag==1 && pCache->bPurgeable && ( nPinned>=(pcache1.nMaxPage+pCache->nMin-pcache1.nMinPage) || nPinned>=(pCache->nMax) )){ goto fetch_out; } if( pCache->nPage>=pCache->nHash && pcache1ResizeHash(pCache) ){ goto fetch_out; } if( pCache->bPurgeable && pcache1.pLruTail && ( pCache->nPage>=pCache->nMax-1 || pcache1.nCurrentPage>=pcache1.nMaxPage )){ pPage = pcache1.pLruTail; pcache1RemoveFromHash(pPage); pcache1PinPage(pPage); if( pPage->pCache->szPage!=pCache->szPage ){ pcache1FreePage(pPage); pPage = 0; }else{ pcache1.nCurrentPage -= (pPage->pCache->bPurgeable - pCache->bPurgeable); } } if( !pPage ){ pPage = pcache1AllocPage(pCache); } if( pPage ){ unsigned int h = iKey % pCache->nHash; memset(pPage, 0, pCache->szPage + sizeof(PgHdr1)); pCache->nPage++; pPage->iKey = iKey; pPage->pNext = pCache->apHash[h]; pPage->pCache = pCache; pCache->apHash[h] = pPage; } fetch_out: if( createFlag==1 ) sqlite3EndBenignMalloc(); pcache1LeaveMutex(); return (pPage ? PGHDR1_TO_PAGE(pPage) : 0); } static void pcache1Unpin(sqlite3_pcache *p, void *pPg, int reuseUnlikely){ PCache1 *pCache = (PCache1 *)p; PgHdr1 *pPage = PAGE_TO_PGHDR1(pPg); pcache1EnterMutex(); assert( pPage->pLruPrev==0 && pPage->pLruNext==0 ); assert( pcache1.pLruHead!=pPage && pcache1.pLruTail!=pPage ); if( reuseUnlikely || pcache1.nCurrentPage>pcache1.nMaxPage ){ pcache1RemoveFromHash(pPage); pcache1FreePage(pPage); }else{ if( pcache1.pLruHead ){ pcache1.pLruHead->pLruPrev = pPage; pPage->pLruNext = pcache1.pLruHead; pcache1.pLruHead = pPage; }else{ pcache1.pLruTail = pPage; pcache1.pLruHead = pPage; } pCache->nRecyclable++; } pcache1LeaveMutex(); } static void pcache1Rekey( sqlite3_pcache *p, void *pPg, unsigned int iOld, unsigned int iNew ){ PCache1 *pCache = (PCache1 *)p; PgHdr1 *pPage = PAGE_TO_PGHDR1(pPg); PgHdr1 **pp; unsigned int h; assert( pPage->iKey==iOld ); pcache1EnterMutex(); h = iOld%pCache->nHash; pp = &pCache->apHash[h]; while( (*pp)!=pPage ){ pp = &(*pp)->pNext; } *pp = pPage->pNext; h = iNew%pCache->nHash; pPage->iKey = iNew; pPage->pNext = pCache->apHash[h]; pCache->apHash[h] = pPage; pcache1LeaveMutex(); } static void pcache1Truncate(sqlite3_pcache *p, unsigned int iLimit){ PCache1 *pCache = (PCache1 *)p; pcache1EnterMutex(); pcache1TruncateUnsafe(pCache, iLimit); pcache1LeaveMutex(); } static void pcache1Destroy(sqlite3_pcache *p){ PCache1 *pCache = (PCache1 *)p; pcache1EnterMutex(); pcache1TruncateUnsafe(pCache, 0); pcache1.nMaxPage -= pCache->nMax; pcache1.nMinPage -= pCache->nMin; pcache1EnforceMaxPage(); pcache1LeaveMutex(); sqlite3_free(pCache->apHash); sqlite3_free(pCache); } SQLITE_PRIVATE void sqlite3PCacheSetDefault(void){ static sqlite3_pcache_methods defaultMethods = { 0, pcache1Init, pcache1Shutdown, pcache1Create, pcache1Cachesize, pcache1Pagecount, pcache1Fetch, pcache1Unpin, pcache1Rekey, pcache1Truncate, pcache1Destroy }; sqlite3_config(SQLITE_CONFIG_PCACHE, &defaultMethods); } 
#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT 
SQLITE_PRIVATE int sqlite3PcacheReleaseMemory(int nReq){ int nFree = 0; if( pcache1.pStart==0 ){ PgHdr1 *p; pcache1EnterMutex(); while( (nReq<0 || nFree<nReq) && (p=pcache1.pLruTail) ){ nFree += sqlite3MallocSize(p); pcache1PinPage(p); pcache1RemoveFromHash(p); pcache1FreePage(p); } pcache1LeaveMutex(); } return nFree; } 
#endif 
#ifdef SQLITE_TEST 
SQLITE_PRIVATE void sqlite3PcacheStats( int *pnCurrent, int *pnMax, int *pnMin, int *pnRecyclable ){ PgHdr1 *p; int nRecyclable = 0; for(p=pcache1.pLruHead; p; p=p->pLruNext){ nRecyclable++; } *pnCurrent = pcache1.nCurrentPage; *pnMax = pcache1.nMaxPage; *pnMin = pcache1.nMinPage; *pnRecyclable = nRecyclable; } 
#endif 
#ifndef SQLITE_OMIT_DISKIO 
#if 0 
#define sqlite3DebugPrintf printf 
#define PAGERTRACE1(X) sqlite3DebugPrintf(X) 
#define PAGERTRACE2(X,Y) sqlite3DebugPrintf(X,Y) 
#define PAGERTRACE3(X,Y,Z) sqlite3DebugPrintf(X,Y,Z) 
#define PAGERTRACE4(X,Y,Z,W) sqlite3DebugPrintf(X,Y,Z,W) 
#define PAGERTRACE5(X,Y,Z,W,V) sqlite3DebugPrintf(X,Y,Z,W,V) 
#else 
#define PAGERTRACE1(X) 
#define PAGERTRACE2(X,Y) 
#define PAGERTRACE3(X,Y,Z) 
#define PAGERTRACE4(X,Y,Z,W) 
#define PAGERTRACE5(X,Y,Z,W,V) 
#endif 
#define PAGERID(p) ((int)(p->fd)) 
#define FILEHANDLEID(fd) ((int)fd) 
#define PAGER_UNLOCK 0 
#define PAGER_SHARED 1 
#define PAGER_RESERVED 2 
#define PAGER_EXCLUSIVE 4 
#define PAGER_SYNCED 5 
#ifndef SQLITE_BUSY_RESERVED_LOCK 
#define SQLITE_BUSY_RESERVED_LOCK 0 
#endif 
#define FORCE_ALIGNMENT(X) (((X)+7)&~7) 
#ifdef SQLITE_HAS_CODEC 
#define CODEC1(P,D,N,X) if( P->xCodec!=0 ){ P->xCodec(P->pCodecArg,D,N,X); } 
#define CODEC2(P,D,N,X) ((char*)(P->xCodec!=0?P->xCodec(P->pCodecArg,D,N,X):D)) 
#else 
#define CODEC1(P,D,N,X) 
#define CODEC2(P,D,N,X) ((char*)D) 
#endif 
struct Pager { sqlite3_vfs *pVfs; u8 journalOpen; u8 journalStarted; u8 useJournal; u8 noReadlock; u8 stmtOpen; u8 stmtInUse; u8 stmtAutoopen; u8 noSync; u8 fullSync; u8 sync_flags; u8 state; u8 tempFile; u8 readOnly; u8 needSync; u8 dirtyCache; u8 alwaysRollback; u8 memDb; u8 setMaster; u8 doNotSync; u8 exclusiveMode; u8 journalMode; u8 dbModified; u8 changeCountDone; u8 dbSizeValid; u32 vfsFlags; int errCode; Pgno dbSize; Pgno origDbSize; Pgno stmtSize; int nRec; u32 cksumInit; int stmtNRec; int nExtra; int pageSize; int nPage; int mxPage; Pgno mxPgno; Bitvec *pInJournal; Bitvec *pInStmt; Bitvec *pAlwaysRollback; char *zFilename; char *zJournal; char *zDirectory; sqlite3_file *fd, *jfd; sqlite3_file *stfd; int (*xBusyHandler)(void*); void *pBusyHandlerArg; i64 journalOff; i64 journalHdr; i64 stmtHdrOff; i64 stmtCksum; i64 stmtJSize; u32 sectorSize; 
#ifdef SQLITE_TEST 
 int nHit, nMiss; int nRead, nWrite; 
#endif 
 void (*xReiniter)(DbPage*); 
#ifdef SQLITE_HAS_CODEC 
 void *(*xCodec)(void*,void*,Pgno,int); void *pCodecArg; 
#endif 
 char *pTmpSpace; char dbFileVers[16]; i64 journalSizeLimit; PCache *pPCache; }; 
#ifdef SQLITE_TEST 
SQLITE_API int sqlite3_pager_readdb_count = 0; SQLITE_API int sqlite3_pager_writedb_count = 0; SQLITE_API int sqlite3_pager_writej_count = 0; 
#define PAGER_INCR(v) v++ 
#else 
#define PAGER_INCR(v) 
#endif 
static const unsigned char aJournalMagic[] = { 0xd9, 0xd5, 0x05, 0xf9, 0x20, 0xa1, 0x63, 0xd7, }; 
#define JOURNAL_PG_SZ(pPager) ((pPager->pageSize) + 8) 
#define JOURNAL_HDR_SZ(pPager) (pPager->sectorSize) 
#ifdef SQLITE_OMIT_MEMORYDB 
#define MEMDB 0 
#else 
#define MEMDB pPager->memDb 
#endif 
#define PAGER_MJ_PGNO(x) ((Pgno)((PENDING_BYTE/((x)->pageSize))+1)) 
#define PAGER_MAX_PGNO 2147483647 
static int pageInStatement(PgHdr *pPg){ Pager *pPager = pPg->pPager; return sqlite3BitvecTest(pPager->pInStmt, pPg->pgno); } static int pageInJournal(PgHdr *pPg){ return sqlite3BitvecTest(pPg->pPager->pInJournal, pPg->pgno); } static int read32bits(sqlite3_file *fd, i64 offset, u32 *pRes){ unsigned char ac[4]; int rc = sqlite3OsRead(fd, ac, sizeof(ac), offset); if( rc==SQLITE_OK ){ *pRes = sqlite3Get4byte(ac); } return rc; } 
#define put32bits(A,B) sqlite3Put4byte((u8*)A,B) 
static int write32bits(sqlite3_file *fd, i64 offset, u32 val){ char ac[4]; put32bits(ac, val); return sqlite3OsWrite(fd, ac, 4, offset); } static int osUnlock(sqlite3_file *pFd, int eLock){ if( !pFd->pMethods ){ return SQLITE_OK; } return sqlite3OsUnlock(pFd, eLock); } 
#ifdef SQLITE_ENABLE_ATOMIC_WRITE 
static int jrnlBufferSize(Pager *pPager){ int dc; int nSector; int szPage; sqlite3_file *fd = pPager->fd; if( fd->pMethods ){ dc = sqlite3OsDeviceCharacteristics(fd); nSector = sqlite3OsSectorSize(fd); szPage = pPager->pageSize; } assert(SQLITE_IOCAP_ATOMIC512==(512>>8)); assert(SQLITE_IOCAP_ATOMIC64K==(65536>>8)); if( !fd->pMethods || (dc & (SQLITE_IOCAP_ATOMIC|(szPage>>8)) && nSector<=szPage) ){ return JOURNAL_HDR_SZ(pPager) + JOURNAL_PG_SZ(pPager); } return 0; } 
#endif 
static void pager_unlock(Pager *pPager); static int pager_error(Pager *pPager, int rc){ int rc2 = rc & 0xff; assert( pPager->errCode==SQLITE_FULL || pPager->errCode==SQLITE_OK || (pPager->errCode & 0xff)==SQLITE_IOERR ); if( rc2==SQLITE_FULL || rc2==SQLITE_IOERR || rc2==SQLITE_CORRUPT ){ pPager->errCode = rc; if( pPager->state==PAGER_UNLOCK && sqlite3PcacheRefCount(pPager->pPCache)==0 ){ pager_unlock(pPager); } } return rc; } 
#ifdef SQLITE_CHECK_PAGES 
static u32 pager_datahash(int nByte, unsigned char *pData){ u32 hash = 0; int i; for(i=0; i<nByte; i++){ hash = (hash*1039) + pData[i]; } return hash; } static u32 pager_pagehash(PgHdr *pPage){ return pager_datahash(pPage->pPager->pageSize, (unsigned char *)pPage->pData); } static void pager_set_pagehash(PgHdr *pPage){ pPage->pageHash = pager_pagehash(pPage); } 
#define CHECK_PAGE(x) checkPage(x) 
static void checkPage(PgHdr *pPg){ Pager *pPager = pPg->pPager; assert( !pPg->pageHash || pPager->errCode || (pPg->flags&PGHDR_DIRTY) || pPg->pageHash==pager_pagehash(pPg) ); } 
#else 
#define pager_datahash(X,Y) 0 
#define pager_pagehash(X) 0 
#define CHECK_PAGE(x) 
#endif 
static int readMasterJournal(sqlite3_file *pJrnl, char *zMaster, u32 nMaster){ int rc; u32 len; i64 szJ; u32 cksum; u32 u; unsigned char aMagic[8]; zMaster[0] = '\0'; rc = sqlite3OsFileSize(pJrnl, &szJ); if( rc!=SQLITE_OK || szJ<16 ) return rc; rc = read32bits(pJrnl, szJ-16, &len); if( rc!=SQLITE_OK ) return rc; if( len>=nMaster ){ return SQLITE_OK; } rc = read32bits(pJrnl, szJ-12, &cksum); if( rc!=SQLITE_OK ) return rc; rc = sqlite3OsRead(pJrnl, aMagic, 8, szJ-8); if( rc!=SQLITE_OK || memcmp(aMagic, aJournalMagic, 8) ) return rc; rc = sqlite3OsRead(pJrnl, zMaster, len, szJ-16-len); if( rc!=SQLITE_OK ){ return rc; } zMaster[len] = '\0'; for(u=0; u<len; u++){ cksum -= zMaster[u]; } if( cksum ){ zMaster[0] = '\0'; } return SQLITE_OK; } static void seekJournalHdr(Pager *pPager){ i64 offset = 0; i64 c = pPager->journalOff; if( c ){ offset = ((c-1)/JOURNAL_HDR_SZ(pPager) + 1) * JOURNAL_HDR_SZ(pPager); } assert( offset%JOURNAL_HDR_SZ(pPager)==0 ); assert( offset>=c ); assert( (offset-c)<JOURNAL_HDR_SZ(pPager) ); pPager->journalOff = offset; } static int zeroJournalHdr(Pager *pPager, int doTruncate){ int rc = SQLITE_OK; static const char zeroHdr[28] = {0}; if( pPager->journalOff ){ i64 iLimit = pPager->journalSizeLimit; IOTRACE(("JZEROHDR %p\n", pPager)) if( doTruncate || iLimit==0 ){ rc = sqlite3OsTruncate(pPager->jfd, 0); }else{ rc = sqlite3OsWrite(pPager->jfd, zeroHdr, sizeof(zeroHdr), 0); } if( rc==SQLITE_OK && !pPager->noSync ){ rc = sqlite3OsSync(pPager->jfd, SQLITE_SYNC_DATAONLY|pPager->sync_flags); } if( rc==SQLITE_OK && iLimit>0 ){ i64 sz; rc = sqlite3OsFileSize(pPager->jfd, &sz); if( rc==SQLITE_OK && sz>iLimit ){ rc = sqlite3OsTruncate(pPager->jfd, iLimit); } } } return rc; } static int writeJournalHdr(Pager *pPager){ int rc = SQLITE_OK; char *zHeader = pPager->pTmpSpace; u32 nHeader = pPager->pageSize; u32 nWrite; if( nHeader>JOURNAL_HDR_SZ(pPager) ){ nHeader = JOURNAL_HDR_SZ(pPager); } if( pPager->stmtHdrOff==0 ){ pPager->stmtHdrOff = pPager->journalOff; } seekJournalHdr(pPager); pPager->journalHdr = pPager->journalOff; memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic)); assert(pPager->fd->pMethods||pPager->noSync); if( (pPager->noSync) || (pPager->journalMode==PAGER_JOURNALMODE_MEMORY) || (sqlite3OsDeviceCharacteristics(pPager->fd)&SQLITE_IOCAP_SAFE_APPEND) ){ put32bits(&zHeader[sizeof(aJournalMagic)], 0xffffffff); }else{ put32bits(&zHeader[sizeof(aJournalMagic)], 0); } sqlite3_randomness(sizeof(pPager->cksumInit), &pPager->cksumInit); put32bits(&zHeader[sizeof(aJournalMagic)+4], pPager->cksumInit); put32bits(&zHeader[sizeof(aJournalMagic)+8], pPager->dbSize); put32bits(&zHeader[sizeof(aJournalMagic)+12], pPager->sectorSize); if( pPager->journalHdr==0 ){ put32bits(&zHeader[sizeof(aJournalMagic)+16], pPager->pageSize); } for(nWrite=0; rc==SQLITE_OK&&nWrite<JOURNAL_HDR_SZ(pPager); nWrite+=nHeader){ IOTRACE(("JHDR %p %lld %d\n", pPager, pPager->journalHdr, nHeader)) rc = sqlite3OsWrite(pPager->jfd, zHeader, nHeader, pPager->journalOff); pPager->journalOff += nHeader; } return rc; } static int readJournalHdr( Pager *pPager, i64 journalSize, u32 *pNRec, u32 *pDbSize ){ int rc; unsigned char aMagic[8]; i64 jrnlOff; int iPageSize; seekJournalHdr(pPager); if( pPager->journalOff+JOURNAL_HDR_SZ(pPager) > journalSize ){ return SQLITE_DONE; } jrnlOff = pPager->journalOff; rc = sqlite3OsRead(pPager->jfd, aMagic, sizeof(aMagic), jrnlOff); if( rc ) return rc; jrnlOff += sizeof(aMagic); if( memcmp(aMagic, aJournalMagic, sizeof(aMagic))!=0 ){ return SQLITE_DONE; } rc = read32bits(pPager->jfd, jrnlOff, pNRec); if( rc ) return rc; rc = read32bits(pPager->jfd, jrnlOff+4, &pPager->cksumInit); if( rc ) return rc; rc = read32bits(pPager->jfd, jrnlOff+8, pDbSize); if( rc ) return rc; rc = read32bits(pPager->jfd, jrnlOff+16, (u32 *)&iPageSize); if( rc==SQLITE_OK && iPageSize>=512 && iPageSize<=SQLITE_MAX_PAGE_SIZE && ((iPageSize-1)&iPageSize)==0 ){ u16 pagesize = iPageSize; rc = sqlite3PagerSetPagesize(pPager, &pagesize); } if( rc ) return rc; rc = read32bits(pPager->jfd, jrnlOff+12, &pPager->sectorSize); if( rc ) return rc; if( (pPager->sectorSize & (pPager->sectorSize-1))!=0 || pPager->sectorSize>0x1000000 ){ return SQLITE_DONE; } pPager->journalOff += JOURNAL_HDR_SZ(pPager); return SQLITE_OK; } static int writeMasterJournal(Pager *pPager, const char *zMaster){ int rc; int len; int i; i64 jrnlOff; i64 jrnlSize; u32 cksum = 0; char zBuf[sizeof(aJournalMagic)+2*4]; if( !zMaster || pPager->setMaster ) return SQLITE_OK; if( pPager->journalMode==PAGER_JOURNALMODE_MEMORY ) return SQLITE_OK; pPager->setMaster = 1; len = strlen(zMaster); for(i=0; i<len; i++){ cksum += zMaster[i]; } if( pPager->fullSync ){ seekJournalHdr(pPager); } jrnlOff = pPager->journalOff; pPager->journalOff += (len+20); rc = write32bits(pPager->jfd, jrnlOff, PAGER_MJ_PGNO(pPager)); if( rc!=SQLITE_OK ) return rc; jrnlOff += 4; rc = sqlite3OsWrite(pPager->jfd, zMaster, len, jrnlOff); if( rc!=SQLITE_OK ) return rc; jrnlOff += len; put32bits(zBuf, len); put32bits(&zBuf[4], cksum); memcpy(&zBuf[8], aJournalMagic, sizeof(aJournalMagic)); rc = sqlite3OsWrite(pPager->jfd, zBuf, 8+sizeof(aJournalMagic), jrnlOff); jrnlOff += 8+sizeof(aJournalMagic); pPager->needSync = !pPager->noSync; if( (rc==SQLITE_OK) && (rc = sqlite3OsFileSize(pPager->jfd, &jrnlSize))==SQLITE_OK && jrnlSize>jrnlOff ){ rc = sqlite3OsTruncate(pPager->jfd, jrnlOff); } return rc; } static PgHdr *pager_lookup(Pager *pPager, Pgno pgno){ PgHdr *p; sqlite3PcacheFetch(pPager->pPCache, pgno, 0, &p); return p; } static void pager_reset(Pager *pPager){ if( pPager->errCode ) return; sqlite3PcacheClear(pPager->pPCache); } static void pager_unlock(Pager *pPager){ if( !pPager->exclusiveMode ){ int rc = osUnlock(pPager->fd, NO_LOCK); if( rc ) pPager->errCode = rc; pPager->dbSizeValid = 0; IOTRACE(("UNLOCK %p\n", pPager)) if( pPager->journalOpen ){ sqlite3OsClose(pPager->jfd); pPager->journalOpen = 0; sqlite3BitvecDestroy(pPager->pInJournal); pPager->pInJournal = 0; sqlite3BitvecDestroy(pPager->pAlwaysRollback); pPager->pAlwaysRollback = 0; } if( pPager->errCode ){ if( rc==SQLITE_OK ) pPager->errCode = SQLITE_OK; pager_reset(pPager); if( pPager->stmtOpen ){ sqlite3OsClose(pPager->stfd); sqlite3BitvecDestroy(pPager->pInStmt); pPager->pInStmt = 0; } pPager->stmtOpen = 0; pPager->stmtInUse = 0; pPager->journalOff = 0; pPager->journalStarted = 0; pPager->stmtAutoopen = 0; pPager->origDbSize = 0; } pPager->state = PAGER_UNLOCK; pPager->changeCountDone = 0; } } static void pagerUnlockAndRollback(Pager *p){ if( p->errCode==SQLITE_OK && p->state>=PAGER_RESERVED ){ sqlite3BeginBenignMalloc(); sqlite3PagerRollback(p); sqlite3EndBenignMalloc(); } pager_unlock(p); } static int pager_end_transaction(Pager *pPager, int hasMaster){ int rc = SQLITE_OK; int rc2 = SQLITE_OK; if( pPager->state<PAGER_RESERVED ){ return SQLITE_OK; } sqlite3PagerStmtCommit(pPager); if( pPager->stmtOpen && !pPager->exclusiveMode ){ sqlite3OsClose(pPager->stfd); pPager->stmtOpen = 0; } if( pPager->journalOpen ){ if( pPager->journalMode==PAGER_JOURNALMODE_MEMORY ){ int isMemoryJournal = sqlite3IsMemJournal(pPager->jfd); sqlite3OsClose(pPager->jfd); pPager->journalOpen = 0; if( !isMemoryJournal ){ rc = sqlite3OsDelete(pPager->pVfs, pPager->zJournal, 0); } }else if( pPager->journalMode==PAGER_JOURNALMODE_TRUNCATE && (rc = sqlite3OsTruncate(pPager->jfd, 0))==SQLITE_OK ){ pPager->journalOff = 0; pPager->journalStarted = 0; }else if( pPager->exclusiveMode || pPager->journalMode==PAGER_JOURNALMODE_PERSIST ){ rc = zeroJournalHdr(pPager, hasMaster); pager_error(pPager, rc); pPager->journalOff = 0; pPager->journalStarted = 0; }else{ assert( pPager->journalMode==PAGER_JOURNALMODE_DELETE || rc ); sqlite3OsClose(pPager->jfd); pPager->journalOpen = 0; if( rc==SQLITE_OK && !pPager->tempFile ){ rc = sqlite3OsDelete(pPager->pVfs, pPager->zJournal, 0); } } sqlite3BitvecDestroy(pPager->pInJournal); pPager->pInJournal = 0; sqlite3BitvecDestroy(pPager->pAlwaysRollback); pPager->pAlwaysRollback = 0; 
#ifdef SQLITE_CHECK_PAGES 
 sqlite3PcacheIterateDirty(pPager->pPCache, pager_set_pagehash); 
#endif 
 sqlite3PcacheCleanAll(pPager->pPCache); pPager->dirtyCache = 0; pPager->nRec = 0; }else{ assert( pPager->pInJournal==0 ); } if( !pPager->exclusiveMode ){ rc2 = osUnlock(pPager->fd, SHARED_LOCK); pPager->state = PAGER_SHARED; }else if( pPager->state==PAGER_SYNCED ){ pPager->state = PAGER_EXCLUSIVE; } pPager->origDbSize = 0; pPager->setMaster = 0; pPager->needSync = 0; if( !MEMDB ){ pPager->dbSizeValid = 0; } pPager->dbModified = 0; return (rc==SQLITE_OK?rc2:rc); } static u32 pager_cksum(Pager *pPager, const u8 *aData){ u32 cksum = pPager->cksumInit; int i = pPager->pageSize-200; while( i>0 ){ cksum += aData[i]; i -= 200; } return cksum; } static int pager_playback_one_page( Pager *pPager, sqlite3_file *jfd, i64 offset, int isMainJrnl ){ int rc; PgHdr *pPg; Pgno pgno; u32 cksum; u8 *aData = (u8 *)pPager->pTmpSpace; assert( jfd == (isMainJrnl ? pPager->jfd : pPager->stfd) ); assert( aData ); rc = read32bits(jfd, offset, &pgno); if( rc!=SQLITE_OK ) return rc; rc = sqlite3OsRead(jfd, aData, pPager->pageSize, offset+4); if( rc!=SQLITE_OK ) return rc; pPager->journalOff += pPager->pageSize + 4; if( pgno==0 || pgno==PAGER_MJ_PGNO(pPager) ){ return SQLITE_DONE; } if( pgno>(unsigned)pPager->dbSize ){ return SQLITE_OK; } if( isMainJrnl ){ rc = read32bits(jfd, offset+pPager->pageSize+4, &cksum); if( rc ) return rc; pPager->journalOff += 4; if( pager_cksum(pPager, aData)!=cksum ){ return SQLITE_DONE; } } assert( pPager->state==PAGER_RESERVED || pPager->state>=PAGER_EXCLUSIVE ); pPg = pager_lookup(pPager, pgno); PAGERTRACE4("PLAYBACK %d page %d hash(%08x)\n", PAGERID(pPager), pgno, pager_datahash(pPager->pageSize, aData)); if( (pPager->state>=PAGER_EXCLUSIVE) && (pPg==0 || 0==(pPg->flags&PGHDR_NEED_SYNC)) && (pPager->fd->pMethods) ){ i64 ofst = (pgno-1)*(i64)pPager->pageSize; rc = sqlite3OsWrite(pPager->fd, aData, pPager->pageSize, ofst); } if( pPg ){ void *pData; pData = pPg->pData; memcpy(pData, aData, pPager->pageSize); if( pPager->xReiniter ){ pPager->xReiniter(pPg); } if( isMainJrnl ){ sqlite3PcacheMakeClean(pPg); } 
#ifdef SQLITE_CHECK_PAGES 
 pPg->pageHash = pager_pagehash(pPg); 
#endif 
 if( pgno==1 ){ memcpy(&pPager->dbFileVers, &((u8*)pData)[24],sizeof(pPager->dbFileVers)); } CODEC1(pPager, pData, pPg->pgno, 3); sqlite3PcacheRelease(pPg); } return rc; } static int pager_delmaster(Pager *pPager, const char *zMaster){ sqlite3_vfs *pVfs = pPager->pVfs; int rc; int master_open = 0; sqlite3_file *pMaster; sqlite3_file *pJournal; char *zMasterJournal = 0; i64 nMasterJournal; pMaster = (sqlite3_file *)sqlite3Malloc(pVfs->szOsFile * 2); pJournal = (sqlite3_file *)(((u8 *)pMaster) + pVfs->szOsFile); if( !pMaster ){ rc = SQLITE_NOMEM; }else{ int flags = (SQLITE_OPEN_READONLY|SQLITE_OPEN_MASTER_JOURNAL); rc = sqlite3OsOpen(pVfs, zMaster, pMaster, flags, 0); } if( rc!=SQLITE_OK ) goto delmaster_out; master_open = 1; rc = sqlite3OsFileSize(pMaster, &nMasterJournal); if( rc!=SQLITE_OK ) goto delmaster_out; if( nMasterJournal>0 ){ char *zJournal; char *zMasterPtr = 0; int nMasterPtr = pPager->pVfs->mxPathname+1; zMasterJournal = (char *)sqlite3Malloc(nMasterJournal + nMasterPtr); if( !zMasterJournal ){ rc = SQLITE_NOMEM; goto delmaster_out; } zMasterPtr = &zMasterJournal[nMasterJournal]; rc = sqlite3OsRead(pMaster, zMasterJournal, nMasterJournal, 0); if( rc!=SQLITE_OK ) goto delmaster_out; zJournal = zMasterJournal; while( (zJournal-zMasterJournal)<nMasterJournal ){ int exists; rc = sqlite3OsAccess(pVfs, zJournal, SQLITE_ACCESS_EXISTS, &exists); if( rc!=SQLITE_OK ){ goto delmaster_out; } if( exists ){ int c; int flags = (SQLITE_OPEN_READONLY|SQLITE_OPEN_MAIN_JOURNAL); rc = sqlite3OsOpen(pVfs, zJournal, pJournal, flags, 0); if( rc!=SQLITE_OK ){ goto delmaster_out; } rc = readMasterJournal(pJournal, zMasterPtr, nMasterPtr); sqlite3OsClose(pJournal); if( rc!=SQLITE_OK ){ goto delmaster_out; } c = zMasterPtr[0]!=0 && strcmp(zMasterPtr, zMaster)==0; if( c ){ goto delmaster_out; } } zJournal += (strlen(zJournal)+1); } } rc = sqlite3OsDelete(pVfs, zMaster, 0); delmaster_out: if( zMasterJournal ){ sqlite3_free(zMasterJournal); } if( master_open ){ sqlite3OsClose(pMaster); } sqlite3_free(pMaster); return rc; } static void pager_truncate_cache(Pager *pPager); static int pager_truncate(Pager *pPager, Pgno nPage){ int rc = SQLITE_OK; if( pPager->state>=PAGER_EXCLUSIVE && pPager->fd->pMethods ){ i64 currentSize, newSize; rc = sqlite3OsFileSize(pPager->fd, &currentSize); newSize = pPager->pageSize*(i64)nPage; if( rc==SQLITE_OK && currentSize!=newSize ){ if( currentSize>newSize ){ rc = sqlite3OsTruncate(pPager->fd, newSize); }else{ rc = sqlite3OsWrite(pPager->fd, "", 1, newSize-1); } } } if( rc==SQLITE_OK ){ pPager->dbSize = nPage; pager_truncate_cache(pPager); } return rc; } static void setSectorSize(Pager *pPager){ assert(pPager->fd->pMethods||pPager->tempFile); if( !pPager->tempFile ){ pPager->sectorSize = sqlite3OsSectorSize(pPager->fd); } if( pPager->sectorSize<512 ){ pPager->sectorSize = 512; } } static int pager_playback(Pager *pPager, int isHot){ sqlite3_vfs *pVfs = pPager->pVfs; i64 szJ; u32 nRec; u32 u; Pgno mxPg = 0; int rc; int res = 1; char *zMaster = 0; assert( pPager->journalOpen ); rc = sqlite3OsFileSize(pPager->jfd, &szJ); if( rc!=SQLITE_OK || szJ==0 ){ goto end_playback; } zMaster = pPager->pTmpSpace; rc = readMasterJournal(pPager->jfd, zMaster, pPager->pVfs->mxPathname+1); if( rc==SQLITE_OK && zMaster[0] ){ rc = sqlite3OsAccess(pVfs, zMaster, SQLITE_ACCESS_EXISTS, &res); } zMaster = 0; if( rc!=SQLITE_OK || !res ){ goto end_playback; } pPager->journalOff = 0; while( 1 ){ rc = readJournalHdr(pPager, szJ, &nRec, &mxPg); if( rc!=SQLITE_OK ){ if( rc==SQLITE_DONE ){ rc = SQLITE_OK; } goto end_playback; } if( nRec==0xffffffff ){ assert( pPager->journalOff==JOURNAL_HDR_SZ(pPager) ); nRec = (szJ - JOURNAL_HDR_SZ(pPager))/JOURNAL_PG_SZ(pPager); } if( nRec==0 && !isHot && pPager->journalHdr+JOURNAL_HDR_SZ(pPager)==pPager->journalOff ){ nRec = (szJ - pPager->journalOff) / JOURNAL_PG_SZ(pPager); } if( pPager->journalOff==JOURNAL_HDR_SZ(pPager) ){ rc = pager_truncate(pPager, mxPg); if( rc!=SQLITE_OK ){ goto end_playback; } } for(u=0; u<nRec; u++){ rc = pager_playback_one_page(pPager, pPager->jfd, pPager->journalOff, 1); if( rc!=SQLITE_OK ){ if( rc==SQLITE_DONE ){ rc = SQLITE_OK; pPager->journalOff = szJ; break; }else{ rc = SQLITE_CORRUPT_BKPT; goto end_playback; } } } } assert( 0 ); end_playback: if( rc==SQLITE_OK ){ zMaster = pPager->pTmpSpace; rc = readMasterJournal(pPager->jfd, zMaster, pPager->pVfs->mxPathname+1); } if( rc==SQLITE_OK ){ rc = pager_end_transaction(pPager, zMaster[0]!='\0'); } if( rc==SQLITE_OK && zMaster[0] && res ){ rc = pager_delmaster(pPager, zMaster); } setSectorSize(pPager); return rc; } static int pager_stmt_playback(Pager *pPager){ i64 szJ; i64 hdrOff; int nRec; int i; int rc; szJ = pPager->journalOff; hdrOff = pPager->stmtHdrOff; assert( pPager->fullSync || !hdrOff ); if( !hdrOff ){ hdrOff = szJ; } rc = pager_truncate(pPager, pPager->stmtSize); assert( pPager->state>=PAGER_SHARED ); assert( pPager->stmtInUse && pPager->journalOpen ); nRec = pPager->stmtNRec; for(i=0; i<nRec; i++){ i64 offset = i*(4+pPager->pageSize); rc = pager_playback_one_page(pPager, pPager->stfd, offset, 0); assert( rc!=SQLITE_DONE ); if( rc!=SQLITE_OK ) goto end_stmt_playback; } pPager->journalOff = pPager->stmtJSize; pPager->cksumInit = pPager->stmtCksum; while( pPager->journalOff < hdrOff ){ rc = pager_playback_one_page(pPager, pPager->jfd, pPager->journalOff, 1); assert( rc!=SQLITE_DONE ); if( rc!=SQLITE_OK ) goto end_stmt_playback; } while( pPager->journalOff < szJ ){ u32 nJRec; u32 dummy; rc = readJournalHdr(pPager, szJ, &nJRec, &dummy); if( rc!=SQLITE_OK ){ assert( rc!=SQLITE_DONE ); goto end_stmt_playback; } if( nJRec==0 ){ nJRec = (szJ - pPager->journalOff) / (pPager->pageSize+8); } for(i=nJRec-1; i>=0 && pPager->journalOff < szJ; i--){ rc = pager_playback_one_page(pPager, pPager->jfd, pPager->journalOff, 1); assert( rc!=SQLITE_DONE ); if( rc!=SQLITE_OK ) goto end_stmt_playback; } } pPager->journalOff = szJ; end_stmt_playback: if( rc==SQLITE_OK) { pPager->journalOff = szJ; } return rc; } SQLITE_PRIVATE void sqlite3PagerSetCachesize(Pager *pPager, int mxPage){ sqlite3PcacheSetCachesize(pPager->pPCache, mxPage); } 
#ifndef SQLITE_OMIT_PAGER_PRAGMAS 
SQLITE_PRIVATE void sqlite3PagerSetSafetyLevel(Pager *pPager, int level, int bFullFsync){ pPager->noSync = level==1 || pPager->tempFile; pPager->fullSync = level==3 && !pPager->tempFile; pPager->sync_flags = (bFullFsync?SQLITE_SYNC_FULL:SQLITE_SYNC_NORMAL); if( pPager->noSync ) pPager->needSync = 0; } 
#endif 
#ifdef SQLITE_TEST 
SQLITE_API int sqlite3_opentemp_count = 0; 
#endif 
static int sqlite3PagerOpentemp( Pager *pPager, sqlite3_file *pFile, int vfsFlags ){ int rc; 
#ifdef SQLITE_TEST 
 sqlite3_opentemp_count++; 
#endif 
 vfsFlags |= SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE | SQLITE_OPEN_EXCLUSIVE | SQLITE_OPEN_DELETEONCLOSE; rc = sqlite3OsOpen(pPager->pVfs, 0, pFile, vfsFlags, 0); assert( rc!=SQLITE_OK || pFile->pMethods ); return rc; } static int pagerStress(void *,PgHdr *); SQLITE_PRIVATE int sqlite3PagerOpen( sqlite3_vfs *pVfs, Pager **ppPager, const char *zFilename, int nExtra, int flags, int vfsFlags ){ u8 *pPtr; Pager *pPager = 0; int rc = SQLITE_OK; int i; int tempFile = 0; int memDb = 0; int readOnly = 0; int useJournal = (flags & PAGER_OMIT_JOURNAL)==0; int noReadlock = (flags & PAGER_NO_READLOCK)!=0; int journalFileSize; int pcacheSize = sqlite3PcacheSize(); int szPageDflt = SQLITE_DEFAULT_PAGE_SIZE; char *zPathname = 0; int nPathname = 0; if( sqlite3JournalSize(pVfs)>sqlite3MemJournalSize() ){ journalFileSize = sqlite3JournalSize(pVfs); }else{ journalFileSize = sqlite3MemJournalSize(); } *ppPager = 0; if( zFilename && zFilename[0] ){ nPathname = pVfs->mxPathname+1; zPathname = sqlite3Malloc(nPathname*2); if( zPathname==0 ){ return SQLITE_NOMEM; } 
#ifndef SQLITE_OMIT_MEMORYDB 
 if( strcmp(zFilename,":memory:")==0 ){ memDb = 1; zPathname[0] = 0; }else 
#endif 
 { rc = sqlite3OsFullPathname(pVfs, zFilename, nPathname, zPathname); } if( rc!=SQLITE_OK ){ sqlite3_free(zPathname); return rc; } nPathname = strlen(zPathname); } pPager = sqlite3MallocZero( sizeof(*pPager) + pcacheSize + journalFileSize + pVfs->szOsFile + journalFileSize * 2 + 3*nPathname + 40 ); if( !pPager ){ sqlite3_free(zPathname); return SQLITE_NOMEM; } pPager->pPCache = (PCache *)&pPager[1]; pPtr = ((u8 *)&pPager[1]) + pcacheSize; pPager->vfsFlags = vfsFlags; pPager->fd = (sqlite3_file*)&pPtr[pVfs->szOsFile*0]; pPager->stfd = (sqlite3_file*)&pPtr[pVfs->szOsFile]; pPager->jfd = (sqlite3_file*)&pPtr[pVfs->szOsFile+journalFileSize]; pPager->zFilename = (char*)&pPtr[pVfs->szOsFile+2*journalFileSize]; pPager->zDirectory = &pPager->zFilename[nPathname+1]; pPager->zJournal = &pPager->zDirectory[nPathname+1]; pPager->pVfs = pVfs; if( zPathname ){ memcpy(pPager->zFilename, zPathname, nPathname+1); sqlite3_free(zPathname); } if( zFilename && zFilename[0] && !memDb ){ if( nPathname>(pVfs->mxPathname - (int)sizeof("-journal")) ){ rc = SQLITE_CANTOPEN; }else{ int fout = 0; rc = sqlite3OsOpen(pVfs, pPager->zFilename, pPager->fd, pPager->vfsFlags, &fout); readOnly = (fout&SQLITE_OPEN_READONLY); if( rc==SQLITE_OK && !readOnly ){ int iSectorSize = sqlite3OsSectorSize(pPager->fd); if( szPageDflt<iSectorSize ){ szPageDflt = iSectorSize; } 
#ifdef SQLITE_ENABLE_ATOMIC_WRITE 
 { int iDc = sqlite3OsDeviceCharacteristics(pPager->fd); int ii; assert(SQLITE_IOCAP_ATOMIC512==(512>>8)); assert(SQLITE_IOCAP_ATOMIC64K==(65536>>8)); assert(SQLITE_MAX_DEFAULT_PAGE_SIZE<=65536); for(ii=szPageDflt; ii<=SQLITE_MAX_DEFAULT_PAGE_SIZE; ii=ii*2){ if( iDc&(SQLITE_IOCAP_ATOMIC|(ii>>8)) ) szPageDflt = ii; } } 
#endif 
 if( szPageDflt>SQLITE_MAX_DEFAULT_PAGE_SIZE ){ szPageDflt = SQLITE_MAX_DEFAULT_PAGE_SIZE; } } } }else{ tempFile = 1; pPager->state = PAGER_EXCLUSIVE; } if( pPager && rc==SQLITE_OK ){ pPager->pTmpSpace = sqlite3PageMalloc(szPageDflt); } if( !pPager || !pPager->pTmpSpace ){ sqlite3OsClose(pPager->fd); sqlite3_free(pPager); return ((rc==SQLITE_OK)?SQLITE_NOMEM:rc); } nExtra = FORCE_ALIGNMENT(nExtra); sqlite3PcacheOpen(szPageDflt, nExtra, !memDb, !memDb?pagerStress:0, (void *)pPager, pPager->pPCache); PAGERTRACE3("OPEN %d %s\n", FILEHANDLEID(pPager->fd), pPager->zFilename); IOTRACE(("OPEN %p %s\n", pPager, pPager->zFilename)) memcpy(pPager->zDirectory, pPager->zFilename, nPathname+1); for(i=strlen(pPager->zDirectory); i>0 && pPager->zDirectory[i-1]!='/'; i--){} if( i>0 ) pPager->zDirectory[i-1] = 0; if( zPathname ){ memcpy(pPager->zJournal, pPager->zFilename, nPathname); memcpy(&pPager->zJournal[nPathname], "-journal", 9); }else{ pPager->zJournal = 0; } pPager->useJournal = useJournal; pPager->noReadlock = noReadlock && readOnly; pPager->dbSizeValid = memDb; pPager->pageSize = szPageDflt; pPager->mxPage = 100; pPager->mxPgno = SQLITE_MAX_PAGE_COUNT; assert( pPager->state == (tempFile ? PAGER_EXCLUSIVE : PAGER_UNLOCK) ); pPager->tempFile = tempFile; assert( tempFile==PAGER_LOCKINGMODE_NORMAL || tempFile==PAGER_LOCKINGMODE_EXCLUSIVE ); assert( PAGER_LOCKINGMODE_EXCLUSIVE==1 ); pPager->exclusiveMode = tempFile; pPager->memDb = memDb; pPager->readOnly = readOnly; pPager->noSync = pPager->tempFile || !useJournal; pPager->fullSync = (pPager->noSync?0:1); pPager->sync_flags = SQLITE_SYNC_NORMAL; pPager->nExtra = nExtra; pPager->journalSizeLimit = SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT; assert(pPager->fd->pMethods||tempFile); setSectorSize(pPager); if( memDb ){ pPager->journalMode = PAGER_JOURNALMODE_MEMORY; } *ppPager = pPager; return SQLITE_OK; } SQLITE_PRIVATE void sqlite3PagerSetBusyhandler( Pager *pPager, int (*xBusyHandler)(void *), void *pBusyHandlerArg ){ pPager->xBusyHandler = xBusyHandler; pPager->pBusyHandlerArg = pBusyHandlerArg; } SQLITE_PRIVATE void sqlite3PagerSetReiniter(Pager *pPager, void (*xReinit)(DbPage*)){ pPager->xReiniter = xReinit; } SQLITE_PRIVATE int sqlite3PagerSetPagesize(Pager *pPager, u16 *pPageSize){ int rc = pPager->errCode; if( rc==SQLITE_OK ){ u16 pageSize = *pPageSize; assert( pageSize==0 || (pageSize>=512 && pageSize<=SQLITE_MAX_PAGE_SIZE) ); if( pageSize && pageSize!=pPager->pageSize && (pPager->memDb==0 || pPager->dbSize==0) && sqlite3PcacheRefCount(pPager->pPCache)==0 ){ char *pNew = (char *)sqlite3PageMalloc(pageSize); if( !pNew ){ rc = SQLITE_NOMEM; }else{ pager_reset(pPager); pPager->pageSize = pageSize; if( !pPager->memDb ) setSectorSize(pPager); sqlite3PageFree(pPager->pTmpSpace); pPager->pTmpSpace = pNew; sqlite3PcacheSetPageSize(pPager->pPCache, pageSize); } } *pPageSize = pPager->pageSize; } return rc; } SQLITE_PRIVATE void *sqlite3PagerTempSpace(Pager *pPager){ return pPager->pTmpSpace; } SQLITE_PRIVATE int sqlite3PagerMaxPageCount(Pager *pPager, int mxPage){ if( mxPage>0 ){ pPager->mxPgno = mxPage; } sqlite3PagerPagecount(pPager, 0); return pPager->mxPgno; } 
#ifdef SQLITE_TEST 
SQLITE_API extern int sqlite3_io_error_pending; SQLITE_API extern int sqlite3_io_error_hit; static int saved_cnt; void disable_simulated_io_errors(void){ saved_cnt = sqlite3_io_error_pending; sqlite3_io_error_pending = -1; } void enable_simulated_io_errors(void){ sqlite3_io_error_pending = saved_cnt; } 
#else 
#define disable_simulated_io_errors() 
#define enable_simulated_io_errors() 
#endif 
SQLITE_PRIVATE int sqlite3PagerReadFileheader(Pager *pPager, int N, unsigned char *pDest){ int rc = SQLITE_OK; memset(pDest, 0, N); assert(pPager->fd->pMethods||pPager->tempFile); if( pPager->fd->pMethods ){ IOTRACE(("DBHDR %p 0 %d\n", pPager, N)) rc = sqlite3OsRead(pPager->fd, pDest, N, 0); if( rc==SQLITE_IOERR_SHORT_READ ){ rc = SQLITE_OK; } } return rc; } SQLITE_PRIVATE int sqlite3PagerPagecount(Pager *pPager, int *pnPage){ i64 n = 0; int rc; assert( pPager!=0 ); if( pPager->errCode ){ rc = pPager->errCode; return rc; } if( pPager->dbSizeValid ){ n = pPager->dbSize; } else { assert(pPager->fd->pMethods||pPager->tempFile); if( (pPager->fd->pMethods) && (rc = sqlite3OsFileSize(pPager->fd, &n))!=SQLITE_OK ){ pager_error(pPager, rc); return rc; } if( n>0 && n<pPager->pageSize ){ n = 1; }else{ n /= pPager->pageSize; } if( pPager->state!=PAGER_UNLOCK ){ pPager->dbSize = n; pPager->dbSizeValid = 1; } } if( n==(PENDING_BYTE/pPager->pageSize) ){ n++; } if( n>pPager->mxPgno ){ pPager->mxPgno = n; } if( pnPage ){ *pnPage = n; } return SQLITE_OK; } static int syncJournal(Pager*); static void pager_truncate_cache(Pager *pPager){ sqlite3PcacheTruncate(pPager->pPCache, pPager->dbSize); } static int pager_wait_on_lock(Pager *pPager, int locktype){ int rc; assert( PAGER_SHARED==SHARED_LOCK ); assert( PAGER_RESERVED==RESERVED_LOCK ); assert( PAGER_EXCLUSIVE==EXCLUSIVE_LOCK ); assert( pPager->state>=PAGER_SHARED || pPager->dbSizeValid==0 ); if( pPager->state>=locktype ){ rc = SQLITE_OK; }else{ do { rc = sqlite3OsLock(pPager->fd, locktype); }while( rc==SQLITE_BUSY && pPager->xBusyHandler(pPager->pBusyHandlerArg) ); if( rc==SQLITE_OK ){ pPager->state = locktype; IOTRACE(("LOCK %p %d\n", pPager, locktype)) } } return rc; } SQLITE_PRIVATE int sqlite3PagerTruncate(Pager *pPager, Pgno nPage){ int rc = SQLITE_OK; assert( pPager->state>=PAGER_SHARED ); sqlite3PagerPagecount(pPager, 0); if( pPager->errCode ){ rc = pPager->errCode; }else if( nPage<pPager->dbSize ){ rc = syncJournal(pPager); if( rc==SQLITE_OK ){ rc = pager_wait_on_lock(pPager, EXCLUSIVE_LOCK); } if( rc==SQLITE_OK ){ rc = pager_truncate(pPager, nPage); } } return rc; } SQLITE_PRIVATE int sqlite3PagerClose(Pager *pPager){ disable_simulated_io_errors(); sqlite3BeginBenignMalloc(); pPager->errCode = 0; pPager->exclusiveMode = 0; pager_reset(pPager); if( !MEMDB ){ pagerUnlockAndRollback(pPager); } enable_simulated_io_errors(); sqlite3EndBenignMalloc(); PAGERTRACE2("CLOSE %d\n", PAGERID(pPager)); IOTRACE(("CLOSE %p\n", pPager)) if( pPager->journalOpen ){ sqlite3OsClose(pPager->jfd); } sqlite3BitvecDestroy(pPager->pInJournal); sqlite3BitvecDestroy(pPager->pAlwaysRollback); if( pPager->stmtOpen ){ sqlite3OsClose(pPager->stfd); } sqlite3OsClose(pPager->fd); sqlite3PageFree(pPager->pTmpSpace); sqlite3PcacheClose(pPager->pPCache); sqlite3_free(pPager); return SQLITE_OK; } 
#if !defined(NDEBUG) || defined(SQLITE_TEST) 
SQLITE_PRIVATE Pgno sqlite3PagerPagenumber(DbPage *p){ return p->pgno; } 
#endif 
SQLITE_PRIVATE int sqlite3PagerRef(DbPage *pPg){ sqlite3PcacheRef(pPg); return SQLITE_OK; } static int syncJournal(Pager *pPager){ int rc = SQLITE_OK; if( pPager->needSync ){ assert( !pPager->tempFile ); if( pPager->journalMode!=PAGER_JOURNALMODE_MEMORY ){ int iDc = sqlite3OsDeviceCharacteristics(pPager->fd); assert( pPager->journalOpen ); if( 0==(iDc&SQLITE_IOCAP_SAFE_APPEND) ){ i64 jrnlOff; if( pPager->fullSync && 0==(iDc&SQLITE_IOCAP_SEQUENTIAL) ){ PAGERTRACE2("SYNC journal of %d\n", PAGERID(pPager)); IOTRACE(("JSYNC %p\n", pPager)) rc = sqlite3OsSync(pPager->jfd, pPager->sync_flags); if( rc!=0 ) return rc; } jrnlOff = pPager->journalHdr + sizeof(aJournalMagic); IOTRACE(("JHDR %p %lld %d\n", pPager, jrnlOff, 4)); rc = write32bits(pPager->jfd, jrnlOff, pPager->nRec); if( rc ) return rc; } if( 0==(iDc&SQLITE_IOCAP_SEQUENTIAL) ){ PAGERTRACE2("SYNC journal of %d\n", PAGERID(pPager)); IOTRACE(("JSYNC %p\n", pPager)) rc = sqlite3OsSync(pPager->jfd, pPager->sync_flags| (pPager->sync_flags==SQLITE_SYNC_FULL?SQLITE_SYNC_DATAONLY:0) ); if( rc!=0 ) return rc; } pPager->journalStarted = 1; } pPager->needSync = 0; sqlite3PcacheClearSyncFlags(pPager->pPCache); } return rc; } static int pager_write_pagelist(PgHdr *pList){ Pager *pPager; int rc; if( pList==0 ) return SQLITE_OK; pPager = pList->pPager; rc = pager_wait_on_lock(pPager, EXCLUSIVE_LOCK); if( rc!=SQLITE_OK ){ return rc; } while( pList ){ if( !pPager->fd->pMethods ){ assert(pPager->tempFile); rc = sqlite3PagerOpentemp(pPager, pPager->fd, pPager->vfsFlags); if( rc ) return rc; } if( pList->pgno<=pPager->dbSize && 0==(pList->flags&PGHDR_DONT_WRITE) ){ i64 offset = (pList->pgno-1)*(i64)pPager->pageSize; char *pData = CODEC2(pPager, pList->pData, pList->pgno, 6); PAGERTRACE4("STORE %d page %d hash(%08x)\n", PAGERID(pPager), pList->pgno, pager_pagehash(pList)); IOTRACE(("PGOUT %p %d\n", pPager, pList->pgno)); rc = sqlite3OsWrite(pPager->fd, pData, pPager->pageSize, offset); PAGER_INCR(sqlite3_pager_writedb_count); PAGER_INCR(pPager->nWrite); if( pList->pgno==1 ){ memcpy(&pPager->dbFileVers, &pData[24], sizeof(pPager->dbFileVers)); } } 
#ifndef NDEBUG 
 else{ PAGERTRACE3("NOSTORE %d page %d\n", PAGERID(pPager), pList->pgno); } 
#endif 
 if( rc ) return rc; 
#ifdef SQLITE_CHECK_PAGES 
 pList->pageHash = pager_pagehash(pList); 
#endif 
 pList = pList->pDirty; } return SQLITE_OK; } static int pagerStress(void *p, PgHdr *pPg){ Pager *pPager = (Pager *)p; int rc = SQLITE_OK; if( pPager->doNotSync ){ return SQLITE_OK; } assert( pPg->flags&PGHDR_DIRTY ); if( pPager->errCode==SQLITE_OK ){ if( pPg->flags&PGHDR_NEED_SYNC ){ rc = syncJournal(pPager); if( rc==SQLITE_OK && pPager->fullSync && !(pPager->journalMode==PAGER_JOURNALMODE_MEMORY) && !(sqlite3OsDeviceCharacteristics(pPager->fd)&SQLITE_IOCAP_SAFE_APPEND) ){ pPager->nRec = 0; rc = writeJournalHdr(pPager); } } if( rc==SQLITE_OK ){ pPg->pDirty = 0; rc = pager_write_pagelist(pPg); } if( rc!=SQLITE_OK ){ pager_error(pPager, rc); } } if( rc==SQLITE_OK ){ sqlite3PcacheMakeClean(pPg); } return rc; } static int hasHotJournal(Pager *pPager, int *pExists){ sqlite3_vfs *pVfs = pPager->pVfs; int rc = SQLITE_OK; int exists; int locked; assert( pPager!=0 ); assert( pPager->useJournal ); assert( pPager->fd->pMethods ); *pExists = 0; rc = sqlite3OsAccess(pVfs, pPager->zJournal, SQLITE_ACCESS_EXISTS, &exists); if( rc==SQLITE_OK && exists ){ rc = sqlite3OsCheckReservedLock(pPager->fd, &locked); } if( rc==SQLITE_OK && exists && !locked ){ int nPage; rc = sqlite3PagerPagecount(pPager, &nPage); if( rc==SQLITE_OK ){ if( nPage==0 ){ sqlite3OsDelete(pVfs, pPager->zJournal, 0); }else{ *pExists = 1; } } } return rc; } static int readDbPage(Pager *pPager, PgHdr *pPg, Pgno pgno){ int rc; i64 offset; assert( MEMDB==0 ); assert(pPager->fd->pMethods||pPager->tempFile); if( !pPager->fd->pMethods ){ return SQLITE_IOERR_SHORT_READ; } offset = (pgno-1)*(i64)pPager->pageSize; rc = sqlite3OsRead(pPager->fd, pPg->pData, pPager->pageSize, offset); PAGER_INCR(sqlite3_pager_readdb_count); PAGER_INCR(pPager->nRead); IOTRACE(("PGIN %p %d\n", pPager, pgno)); if( pgno==1 ){ memcpy(&pPager->dbFileVers, &((u8*)pPg->pData)[24], sizeof(pPager->dbFileVers)); } CODEC1(pPager, pPg->pData, pPg->pgno, 3); PAGERTRACE4("FETCH %d page %d hash(%08x)\n", PAGERID(pPager), pPg->pgno, pager_pagehash(pPg)); return rc; } static int pagerSharedLock(Pager *pPager){ int rc = SQLITE_OK; int isErrorReset = 0; if( !MEMDB && pPager->exclusiveMode && sqlite3PcacheRefCount(pPager->pPCache)==0 && pPager->errCode ){ if( pPager->journalOpen ){ isErrorReset = 1; } pPager->errCode = SQLITE_OK; pager_reset(pPager); } if( pPager->errCode && pPager->errCode!=SQLITE_FULL ){ return pPager->errCode; } if( pPager->state==PAGER_UNLOCK || isErrorReset ){ sqlite3_vfs *pVfs = pPager->pVfs; int isHotJournal; assert( !MEMDB ); assert( sqlite3PcacheRefCount(pPager->pPCache)==0 ); if( !pPager->noReadlock ){ rc = pager_wait_on_lock(pPager, SHARED_LOCK); if( rc!=SQLITE_OK ){ assert( pPager->state==PAGER_UNLOCK ); return pager_error(pPager, rc); } assert( pPager->state>=SHARED_LOCK ); } if( !isErrorReset ){ rc = hasHotJournal(pPager, &isHotJournal); if( rc!=SQLITE_OK ){ goto failed; } } if( isErrorReset || isHotJournal ){ if( pPager->state<EXCLUSIVE_LOCK ){ rc = sqlite3OsLock(pPager->fd, EXCLUSIVE_LOCK); if( rc!=SQLITE_OK ){ rc = pager_error(pPager, rc); goto failed; } pPager->state = PAGER_EXCLUSIVE; } if( !isErrorReset && pPager->journalOpen==0 ){ int res; rc = sqlite3OsAccess(pVfs,pPager->zJournal,SQLITE_ACCESS_EXISTS,&res); if( rc==SQLITE_OK ){ if( res ){ int fout = 0; int f = SQLITE_OPEN_READWRITE|SQLITE_OPEN_MAIN_JOURNAL; assert( !pPager->tempFile ); rc = sqlite3OsOpen(pVfs, pPager->zJournal, pPager->jfd, f, &fout); assert( rc!=SQLITE_OK || pPager->jfd->pMethods ); if( rc==SQLITE_OK && fout&SQLITE_OPEN_READONLY ){ rc = SQLITE_CANTOPEN; sqlite3OsClose(pPager->jfd); } }else{ rc = SQLITE_BUSY; } } } if( rc!=SQLITE_OK ){ goto failed; } pPager->journalOpen = 1; pPager->journalStarted = 0; pPager->journalOff = 0; pPager->setMaster = 0; pPager->journalHdr = 0; rc = pager_playback(pPager, 1); if( rc!=SQLITE_OK ){ rc = pager_error(pPager, rc); goto failed; } assert(pPager->state==PAGER_SHARED || (pPager->exclusiveMode && pPager->state>PAGER_SHARED) ); } if( sqlite3PcachePagecount(pPager->pPCache)>0 ){ char dbFileVers[sizeof(pPager->dbFileVers)]; sqlite3PagerPagecount(pPager, 0); if( pPager->errCode ){ rc = pPager->errCode; goto failed; } assert( pPager->dbSizeValid ); if( pPager->dbSize>0 ){ IOTRACE(("CKVERS %p %d\n", pPager, sizeof(dbFileVers))); rc = sqlite3OsRead(pPager->fd, &dbFileVers, sizeof(dbFileVers), 24); if( rc!=SQLITE_OK ){ goto failed; } }else{ memset(dbFileVers, 0, sizeof(dbFileVers)); } if( memcmp(pPager->dbFileVers, dbFileVers, sizeof(dbFileVers))!=0 ){ pager_reset(pPager); } } assert( pPager->exclusiveMode || pPager->state<=PAGER_SHARED ); if( pPager->state==PAGER_UNLOCK ){ pPager->state = PAGER_SHARED; } } failed: if( rc!=SQLITE_OK ){ pager_unlock(pPager); } return rc; } static int pager_get_content(PgHdr *pPg){ if( pPg->flags&PGHDR_NEED_READ ){ int rc = readDbPage(pPg->pPager, pPg, pPg->pgno); if( rc==SQLITE_OK ){ pPg->flags &= ~PGHDR_NEED_READ; }else{ return rc; } } return SQLITE_OK; } static void pagerUnlockIfUnused(Pager *pPager){ if( (sqlite3PcacheRefCount(pPager->pPCache)==0) && (!pPager->exclusiveMode || pPager->journalOff>0) ){ pagerUnlockAndRollback(pPager); } } static void pagerDropPage(DbPage *pPg){ Pager *pPager = pPg->pPager; sqlite3PcacheDrop(pPg); pagerUnlockIfUnused(pPager); } SQLITE_PRIVATE int sqlite3PagerAcquire( Pager *pPager, Pgno pgno, DbPage **ppPage, int noContent ){ PgHdr *pPg = 0; int rc; assert( pPager->state==PAGER_UNLOCK || sqlite3PcacheRefCount(pPager->pPCache)>0 || pgno==1 ); if( pgno>PAGER_MAX_PGNO || pgno==0 || pgno==PAGER_MJ_PGNO(pPager) ){ return SQLITE_CORRUPT_BKPT; } assert( pPager!=0 ); *ppPage = 0; rc = pagerSharedLock(pPager); if( rc!=SQLITE_OK ){ return rc; } assert( pPager->state!=PAGER_UNLOCK ); rc = sqlite3PcacheFetch(pPager->pPCache, pgno, 1, &pPg); if( rc!=SQLITE_OK ){ return rc; } if( pPg->pPager==0 ){ int nMax; PAGER_INCR(pPager->nMiss); pPg->pPager = pPager; memset(pPg->pExtra, 0, pPager->nExtra); rc = sqlite3PagerPagecount(pPager, &nMax); if( rc!=SQLITE_OK ){ sqlite3PagerUnref(pPg); return rc; } if( nMax<(int)pgno || MEMDB || noContent ){ if( pgno>pPager->mxPgno ){ sqlite3PagerUnref(pPg); return SQLITE_FULL; } memset(pPg->pData, 0, pPager->pageSize); if( noContent ){ pPg->flags |= PGHDR_NEED_READ; } IOTRACE(("ZERO %p %d\n", pPager, pgno)); }else{ rc = readDbPage(pPager, pPg, pgno); if( rc!=SQLITE_OK && rc!=SQLITE_IOERR_SHORT_READ ){ pagerDropPage(pPg); return rc; } } 
#ifdef SQLITE_CHECK_PAGES 
 pPg->pageHash = pager_pagehash(pPg); 
#endif 
 }else{ assert(sqlite3PcacheRefCount(pPager->pPCache)>0 || pgno==1); PAGER_INCR(pPager->nHit); if( !noContent ){ rc = pager_get_content(pPg); if( rc ){ sqlite3PagerUnref(pPg); return rc; } } } *ppPage = pPg; return SQLITE_OK; } SQLITE_PRIVATE DbPage *sqlite3PagerLookup(Pager *pPager, Pgno pgno){ PgHdr *pPg = 0; assert( pPager!=0 ); assert( pgno!=0 ); if( (pPager->state!=PAGER_UNLOCK) && (pPager->errCode==SQLITE_OK || pPager->errCode==SQLITE_FULL) ){ sqlite3PcacheFetch(pPager->pPCache, pgno, 0, &pPg); } return pPg; } SQLITE_PRIVATE int sqlite3PagerUnref(DbPage *pPg){ if( pPg ){ Pager *pPager = pPg->pPager; sqlite3PcacheRelease(pPg); pagerUnlockIfUnused(pPager); } return SQLITE_OK; } static int pager_open_journal(Pager *pPager){ sqlite3_vfs *pVfs = pPager->pVfs; int flags = (SQLITE_OPEN_READWRITE|SQLITE_OPEN_EXCLUSIVE|SQLITE_OPEN_CREATE); int rc; assert( pPager->state>=PAGER_RESERVED ); assert( pPager->useJournal ); assert( pPager->pInJournal==0 ); sqlite3PagerPagecount(pPager, 0); pPager->pInJournal = sqlite3BitvecCreate(pPager->dbSize); if( pPager->pInJournal==0 ){ rc = SQLITE_NOMEM; goto failed_to_open_journal; } if( pPager->journalOpen==0 ){ if( pPager->tempFile ){ flags |= (SQLITE_OPEN_DELETEONCLOSE|SQLITE_OPEN_TEMP_JOURNAL); }else{ flags |= (SQLITE_OPEN_MAIN_JOURNAL); } if( pPager->journalMode==PAGER_JOURNALMODE_MEMORY ){ sqlite3MemJournalOpen(pPager->jfd); rc = SQLITE_OK; }else{ 
#ifdef SQLITE_ENABLE_ATOMIC_WRITE 
 rc = sqlite3JournalOpen( pVfs, pPager->zJournal, pPager->jfd, flags, jrnlBufferSize(pPager) ); 
#else 
 rc = sqlite3OsOpen(pVfs, pPager->zJournal, pPager->jfd, flags, 0); 
#endif 
 } assert( rc!=SQLITE_OK || pPager->jfd->pMethods ); pPager->journalOff = 0; pPager->setMaster = 0; pPager->journalHdr = 0; if( rc!=SQLITE_OK ){ if( rc==SQLITE_NOMEM ){ sqlite3OsDelete(pVfs, pPager->zJournal, 0); } goto failed_to_open_journal; } } pPager->journalOpen = 1; pPager->journalStarted = 0; pPager->needSync = 0; pPager->nRec = 0; if( pPager->errCode ){ rc = pPager->errCode; goto failed_to_open_journal; } pPager->origDbSize = pPager->dbSize; rc = writeJournalHdr(pPager); if( pPager->stmtAutoopen && rc==SQLITE_OK ){ rc = sqlite3PagerStmtBegin(pPager); } if( rc!=SQLITE_OK && rc!=SQLITE_NOMEM && rc!=SQLITE_IOERR_NOMEM ){ rc = pager_end_transaction(pPager, 0); if( rc==SQLITE_OK ){ rc = SQLITE_FULL; } } return rc; failed_to_open_journal: sqlite3BitvecDestroy(pPager->pInJournal); pPager->pInJournal = 0; return rc; } SQLITE_PRIVATE int sqlite3PagerBegin(DbPage *pPg, int exFlag){ Pager *pPager = pPg->pPager; int rc = SQLITE_OK; assert( pPg->nRef>0 ); assert( pPager->state!=PAGER_UNLOCK ); if( pPager->state==PAGER_SHARED ){ assert( pPager->pInJournal==0 ); assert( !MEMDB ); rc = sqlite3OsLock(pPager->fd, RESERVED_LOCK); if( rc==SQLITE_OK ){ pPager->state = PAGER_RESERVED; if( exFlag ){ rc = pager_wait_on_lock(pPager, EXCLUSIVE_LOCK); } } if( rc!=SQLITE_OK ){ return rc; } pPager->dirtyCache = 0; PAGERTRACE2("TRANSACTION %d\n", PAGERID(pPager)); if( pPager->useJournal && !pPager->tempFile && pPager->journalMode!=PAGER_JOURNALMODE_OFF ){ rc = pager_open_journal(pPager); } }else if( pPager->journalOpen && pPager->journalOff==0 ){ assert( pPager->nRec==0 ); assert( pPager->origDbSize==0 ); assert( pPager->pInJournal==0 ); sqlite3PagerPagecount(pPager, 0); pPager->pInJournal = sqlite3BitvecCreate( pPager->dbSize ); if( !pPager->pInJournal ){ rc = SQLITE_NOMEM; }else{ pPager->origDbSize = pPager->dbSize; rc = writeJournalHdr(pPager); } } assert( !pPager->journalOpen || pPager->journalOff>0 || rc!=SQLITE_OK ); return rc; } static int pager_write(PgHdr *pPg){ void *pData = pPg->pData; Pager *pPager = pPg->pPager; int rc = SQLITE_OK; if( pPager->errCode ){ return pPager->errCode; } if( pPager->readOnly ){ return SQLITE_PERM; } assert( !pPager->setMaster ); CHECK_PAGE(pPg); rc = pager_get_content(pPg); if( rc ){ return rc; } sqlite3PcacheMakeDirty(pPg); if( pageInJournal(pPg) && (pageInStatement(pPg) || pPager->stmtInUse==0) ){ pPager->dirtyCache = 1; pPager->dbModified = 1; }else{ assert( pPager->state!=PAGER_UNLOCK ); rc = sqlite3PagerBegin(pPg, 0); if( rc!=SQLITE_OK ){ return rc; } assert( pPager->state>=PAGER_RESERVED ); if( !pPager->journalOpen && pPager->useJournal && pPager->journalMode!=PAGER_JOURNALMODE_OFF ){ rc = pager_open_journal(pPager); if( rc!=SQLITE_OK ) return rc; } pPager->dirtyCache = 1; pPager->dbModified = 1; if( !pageInJournal(pPg) && pPager->journalOpen ){ if( pPg->pgno<=pPager->origDbSize ){ u32 cksum; char *pData2; assert( pPg->pgno!=PAGER_MJ_PGNO(pPager) ); pData2 = CODEC2(pPager, pData, pPg->pgno, 7); cksum = pager_cksum(pPager, (u8*)pData2); rc = write32bits(pPager->jfd, pPager->journalOff, pPg->pgno); if( rc==SQLITE_OK ){ rc = sqlite3OsWrite(pPager->jfd, pData2, pPager->pageSize, pPager->journalOff + 4); pPager->journalOff += pPager->pageSize+4; } if( rc==SQLITE_OK ){ rc = write32bits(pPager->jfd, pPager->journalOff, cksum); pPager->journalOff += 4; } IOTRACE(("JOUT %p %d %lld %d\n", pPager, pPg->pgno, pPager->journalOff, pPager->pageSize)); PAGER_INCR(sqlite3_pager_writej_count); PAGERTRACE5("JOURNAL %d page %d needSync=%d hash(%08x)\n", PAGERID(pPager), pPg->pgno, ((pPg->flags&PGHDR_NEED_SYNC)?1:0), pager_pagehash(pPg)); if( rc!=SQLITE_OK ){ return rc; } pPager->nRec++; assert( pPager->pInJournal!=0 ); sqlite3BitvecSet(pPager->pInJournal, pPg->pgno); if( !pPager->noSync ){ pPg->flags |= PGHDR_NEED_SYNC; } if( pPager->stmtInUse ){ sqlite3BitvecSet(pPager->pInStmt, pPg->pgno); } }else{ if( !pPager->journalStarted && !pPager->noSync ){ pPg->flags |= PGHDR_NEED_SYNC; } PAGERTRACE4("APPEND %d page %d needSync=%d\n", PAGERID(pPager), pPg->pgno, ((pPg->flags&PGHDR_NEED_SYNC)?1:0)); } if( pPg->flags&PGHDR_NEED_SYNC ){ pPager->needSync = 1; } } if( pPager->stmtInUse && !pageInStatement(pPg) && pPg->pgno<=pPager->stmtSize ){ i64 offset = pPager->stmtNRec*(4+pPager->pageSize); char *pData2 = CODEC2(pPager, pData, pPg->pgno, 7); assert( pageInJournal(pPg) || pPg->pgno>pPager->origDbSize ); rc = write32bits(pPager->stfd, offset, pPg->pgno); if( rc==SQLITE_OK ){ rc = sqlite3OsWrite(pPager->stfd, pData2, pPager->pageSize, offset+4); } PAGERTRACE3("STMT-JOURNAL %d page %d\n", PAGERID(pPager), pPg->pgno); if( rc!=SQLITE_OK ){ return rc; } pPager->stmtNRec++; assert( pPager->pInStmt!=0 ); sqlite3BitvecSet(pPager->pInStmt, pPg->pgno); } } assert( pPager->state>=PAGER_SHARED ); if( pPager->dbSize<pPg->pgno ){ pPager->dbSize = pPg->pgno; if( pPager->dbSize==(PAGER_MJ_PGNO(pPager)-1) ){ pPager->dbSize++; } } return rc; } SQLITE_PRIVATE int sqlite3PagerWrite(DbPage *pDbPage){ int rc = SQLITE_OK; PgHdr *pPg = pDbPage; Pager *pPager = pPg->pPager; Pgno nPagePerSector = (pPager->sectorSize/pPager->pageSize); if( nPagePerSector>1 ){ Pgno nPageCount; Pgno pg1; int nPage; int ii; int needSync = 0; assert( !MEMDB ); assert( pPager->doNotSync==0 ); pPager->doNotSync = 1; pg1 = ((pPg->pgno-1) & ~(nPagePerSector-1)) + 1; sqlite3PagerPagecount(pPager, (int *)&nPageCount); if( pPg->pgno>nPageCount ){ nPage = (pPg->pgno - pg1)+1; }else if( (pg1+nPagePerSector-1)>nPageCount ){ nPage = nPageCount+1-pg1; }else{ nPage = nPagePerSector; } assert(nPage>0); assert(pg1<=pPg->pgno); assert((pg1+nPage)>pPg->pgno); for(ii=0; ii<nPage && rc==SQLITE_OK; ii++){ Pgno pg = pg1+ii; PgHdr *pPage; if( pg==pPg->pgno || !sqlite3BitvecTest(pPager->pInJournal, pg) ){ if( pg!=PAGER_MJ_PGNO(pPager) ){ rc = sqlite3PagerGet(pPager, pg, &pPage); if( rc==SQLITE_OK ){ rc = pager_write(pPage); if( pPage->flags&PGHDR_NEED_SYNC ){ needSync = 1; } sqlite3PagerUnref(pPage); } } }else if( (pPage = pager_lookup(pPager, pg))!=0 ){ if( pPage->flags&PGHDR_NEED_SYNC ){ needSync = 1; } sqlite3PagerUnref(pPage); } } if( needSync ){ assert( !MEMDB && pPager->noSync==0 ); for(ii=0; ii<nPage && needSync; ii++){ PgHdr *pPage = pager_lookup(pPager, pg1+ii); if( pPage ) pPage->flags |= PGHDR_NEED_SYNC; sqlite3PagerUnref(pPage); } assert(pPager->needSync); } assert( pPager->doNotSync==1 ); pPager->doNotSync = 0; }else{ rc = pager_write(pDbPage); } return rc; } 
#ifndef NDEBUG 
SQLITE_PRIVATE int sqlite3PagerIswriteable(DbPage *pPg){ return pPg->flags&PGHDR_DIRTY; } 
#endif 
SQLITE_PRIVATE int sqlite3PagerDontWrite(DbPage *pDbPage){ PgHdr *pPg = pDbPage; Pager *pPager = pPg->pPager; int rc; if( pPg->pgno>pPager->origDbSize ){ return SQLITE_OK; } if( pPager->pAlwaysRollback==0 ){ assert( pPager->pInJournal ); pPager->pAlwaysRollback = sqlite3BitvecCreate(pPager->origDbSize); if( !pPager->pAlwaysRollback ){ return SQLITE_NOMEM; } } rc = sqlite3BitvecSet(pPager->pAlwaysRollback, pPg->pgno); if( rc==SQLITE_OK && (pPg->flags&PGHDR_DIRTY) && !pPager->stmtInUse ){ assert( pPager->state>=PAGER_SHARED ); if( pPager->dbSize==pPg->pgno && pPager->origDbSize<pPager->dbSize ){ }else{ PAGERTRACE3("DONT_WRITE page %d of %d\n", pPg->pgno, PAGERID(pPager)); IOTRACE(("CLEAN %p %d\n", pPager, pPg->pgno)) pPg->flags |= PGHDR_DONT_WRITE; 
#ifdef SQLITE_CHECK_PAGES 
 pPg->pageHash = pager_pagehash(pPg); 
#endif 
 } } return rc; } SQLITE_PRIVATE void sqlite3PagerDontRollback(DbPage *pPg){ Pager *pPager = pPg->pPager; assert( pPager->state>=PAGER_RESERVED ); if( pPager->journalOpen==0 || sqlite3BitvecTest(pPager->pAlwaysRollback, pPg->pgno) || pPg->pgno>pPager->origDbSize ){ return; } 
#ifdef SQLITE_SECURE_DELETE 
 if( sqlite3BitvecTest(pPager->pInJournal, pPg->pgno)!=0 || pPg->pgno>pPager->origDbSize ){ return; } 
#endif 
 assert( pPager->pInJournal!=0 ); sqlite3BitvecSet(pPager->pInJournal, pPg->pgno); pPg->flags &= ~PGHDR_NEED_READ; if( pPager->stmtInUse ){ assert( pPager->stmtSize >= pPager->origDbSize ); sqlite3BitvecSet(pPager->pInStmt, pPg->pgno); } PAGERTRACE3("DONT_ROLLBACK page %d of %d\n", pPg->pgno, PAGERID(pPager)); IOTRACE(("GARBAGE %p %d\n", pPager, pPg->pgno)) } static int pager_incr_changecounter(Pager *pPager, int isDirect){ PgHdr *pPgHdr; u32 change_counter; int rc = SQLITE_OK; 
#ifndef SQLITE_ENABLE_ATOMIC_WRITE 
 assert( isDirect==0 ); 
#endif 
 if( !pPager->changeCountDone ){ rc = sqlite3PagerGet(pPager, 1, &pPgHdr); if( rc!=SQLITE_OK ) return rc; if( !isDirect ){ rc = sqlite3PagerWrite(pPgHdr); if( rc!=SQLITE_OK ){ sqlite3PagerUnref(pPgHdr); return rc; } } change_counter = sqlite3Get4byte((u8*)pPager->dbFileVers); change_counter++; put32bits(((char*)pPgHdr->pData)+24, change_counter); 
#ifdef SQLITE_ENABLE_ATOMIC_WRITE 
 if( isDirect && pPager->fd->pMethods ){ const void *zBuf = pPgHdr->pData; rc = sqlite3OsWrite(pPager->fd, zBuf, pPager->pageSize, 0); } 
#endif 
 sqlite3PagerUnref(pPgHdr); pPager->changeCountDone = 1; } return rc; } SQLITE_PRIVATE int sqlite3PagerSync(Pager *pPager){ int rc; if( MEMDB ){ rc = SQLITE_OK; }else{ rc = sqlite3OsSync(pPager->fd, pPager->sync_flags); } return rc; } SQLITE_PRIVATE int sqlite3PagerCommitPhaseOne( Pager *pPager, const char *zMaster, Pgno nTrunc, int noSync ){ int rc = SQLITE_OK; if( pPager->errCode ){ return pPager->errCode; } if( pPager->dbModified==0 && (pPager->journalMode!=PAGER_JOURNALMODE_DELETE || pPager->exclusiveMode!=0) ){ assert( pPager->dirtyCache==0 || pPager->journalOpen==0 ); return SQLITE_OK; } PAGERTRACE4("DATABASE SYNC: File=%s zMaster=%s nTrunc=%d\n", pPager->zFilename, zMaster, nTrunc); if( pPager->state!=PAGER_SYNCED && !MEMDB && pPager->dirtyCache ){ PgHdr *pPg; 
#ifdef SQLITE_ENABLE_ATOMIC_WRITE 
 int useAtomicWrite; pPg = sqlite3PcacheDirtyList(pPager->pPCache); useAtomicWrite = ( !zMaster && pPager->journalOpen && pPager->journalOff==jrnlBufferSize(pPager) && nTrunc==0 && (pPg==0 || pPg->pDirty==0) ); assert( pPager->journalOpen || pPager->journalMode==PAGER_JOURNALMODE_OFF ); if( useAtomicWrite ){ int offset = pPager->journalHdr + sizeof(aJournalMagic); assert(pPager->nRec==1); rc = write32bits(pPager->jfd, offset, pPager->nRec); if( rc==SQLITE_OK ){ rc = pager_incr_changecounter(pPager, 1); } }else{ rc = sqlite3JournalCreate(pPager->jfd); } if( !useAtomicWrite && rc==SQLITE_OK ) 
#endif 
 if( !pPager->setMaster ){ rc = pager_incr_changecounter(pPager, 0); if( rc!=SQLITE_OK ) goto sync_exit; if( pPager->journalMode!=PAGER_JOURNALMODE_OFF ){ 
#ifndef SQLITE_OMIT_AUTOVACUUM 
 if( nTrunc!=0 ){ Pgno i; Pgno iSkip = PAGER_MJ_PGNO(pPager); for( i=nTrunc+1; i<=pPager->origDbSize; i++ ){ if( !sqlite3BitvecTest(pPager->pInJournal, i) && i!=iSkip ){ rc = sqlite3PagerGet(pPager, i, &pPg); if( rc!=SQLITE_OK ) goto sync_exit; rc = sqlite3PagerWrite(pPg); sqlite3PagerUnref(pPg); if( rc!=SQLITE_OK ) goto sync_exit; } } } 
#endif 
 rc = writeMasterJournal(pPager, zMaster); if( rc!=SQLITE_OK ) goto sync_exit; rc = syncJournal(pPager); } } if( rc!=SQLITE_OK ) goto sync_exit; 
#ifndef SQLITE_OMIT_AUTOVACUUM 
 if( nTrunc!=0 ){ rc = sqlite3PagerTruncate(pPager, nTrunc); if( rc!=SQLITE_OK ) goto sync_exit; } 
#endif 
 pPg = sqlite3PcacheDirtyList(pPager->pPCache); rc = pager_write_pagelist(pPg); if( rc!=SQLITE_OK ){ assert( rc!=SQLITE_IOERR_BLOCKED ); goto sync_exit; } sqlite3PcacheCleanAll(pPager->pPCache); if( !pPager->noSync && !noSync ){ rc = sqlite3OsSync(pPager->fd, pPager->sync_flags); } IOTRACE(("DBSYNC %p\n", pPager)) pPager->state = PAGER_SYNCED; }else if( MEMDB && nTrunc!=0 ){ rc = sqlite3PagerTruncate(pPager, nTrunc); } sync_exit: if( rc==SQLITE_IOERR_BLOCKED ){ rc = SQLITE_BUSY; } return rc; } SQLITE_PRIVATE int sqlite3PagerCommitPhaseTwo(Pager *pPager){ int rc = SQLITE_OK; if( pPager->errCode ){ return pPager->errCode; } if( pPager->state<PAGER_RESERVED ){ return SQLITE_ERROR; } if( pPager->dbModified==0 && (pPager->journalMode!=PAGER_JOURNALMODE_DELETE || pPager->exclusiveMode!=0) ){ assert( pPager->dirtyCache==0 || pPager->journalOpen==0 ); return SQLITE_OK; } PAGERTRACE2("COMMIT %d\n", PAGERID(pPager)); assert( pPager->state==PAGER_SYNCED || MEMDB || !pPager->dirtyCache ); rc = pager_end_transaction(pPager, pPager->setMaster); rc = pager_error(pPager, rc); return rc; } SQLITE_PRIVATE int sqlite3PagerRollback(Pager *pPager){ int rc = SQLITE_OK; PAGERTRACE2("ROLLBACK %d\n", PAGERID(pPager)); if( !pPager->dirtyCache || !pPager->journalOpen ){ rc = pager_end_transaction(pPager, pPager->setMaster); }else if( pPager->errCode && pPager->errCode!=SQLITE_FULL ){ if( pPager->state>=PAGER_EXCLUSIVE ){ pager_playback(pPager, 0); } rc = pPager->errCode; }else{ if( pPager->state==PAGER_RESERVED ){ int rc2; rc = pager_playback(pPager, 0); rc2 = pager_end_transaction(pPager, pPager->setMaster); if( rc==SQLITE_OK ){ rc = rc2; } }else{ rc = pager_playback(pPager, 0); } if( !MEMDB ){ pPager->dbSizeValid = 0; } rc = pager_error(pPager, rc); } return rc; } SQLITE_PRIVATE int sqlite3PagerIsreadonly(Pager *pPager){ return pPager->readOnly; } SQLITE_PRIVATE int sqlite3PagerRefcount(Pager *pPager){ return sqlite3PcacheRefCount(pPager->pPCache); } SQLITE_PRIVATE int sqlite3PagerPageRefcount(DbPage *pPage){ return sqlite3PcachePageRefcount(pPage); } 
#ifdef SQLITE_TEST 
SQLITE_PRIVATE int *sqlite3PagerStats(Pager *pPager){ static int a[11]; a[0] = sqlite3PcacheRefCount(pPager->pPCache); a[1] = sqlite3PcachePagecount(pPager->pPCache); a[2] = sqlite3PcacheGetCachesize(pPager->pPCache); a[3] = pPager->dbSizeValid ? (int) pPager->dbSize : -1; a[4] = pPager->state; a[5] = pPager->errCode; a[6] = pPager->nHit; a[7] = pPager->nMiss; a[8] = 0; a[9] = pPager->nRead; a[10] = pPager->nWrite; return a; } SQLITE_PRIVATE int sqlite3PagerIsMemdb(Pager *pPager){ return MEMDB; } 
#endif 
static int pagerStmtBegin(Pager *pPager){ int rc; assert( !pPager->stmtInUse ); assert( pPager->state>=PAGER_SHARED ); assert( pPager->dbSizeValid ); PAGERTRACE2("STMT-BEGIN %d\n", PAGERID(pPager)); if( !pPager->journalOpen ){ pPager->stmtAutoopen = 1; return SQLITE_OK; } assert( pPager->journalOpen ); assert( pPager->pInStmt==0 ); pPager->pInStmt = sqlite3BitvecCreate(pPager->dbSize); if( pPager->pInStmt==0 ){ return SQLITE_NOMEM; } pPager->stmtJSize = pPager->journalOff; pPager->stmtSize = pPager->dbSize; pPager->stmtHdrOff = 0; pPager->stmtCksum = pPager->cksumInit; if( !pPager->stmtOpen ){ if( pPager->journalMode==PAGER_JOURNALMODE_MEMORY ){ sqlite3MemJournalOpen(pPager->stfd); }else{ rc = sqlite3PagerOpentemp(pPager, pPager->stfd, SQLITE_OPEN_SUBJOURNAL); if( rc ){ goto stmt_begin_failed; } } pPager->stmtOpen = 1; pPager->stmtNRec = 0; } pPager->stmtInUse = 1; return SQLITE_OK; stmt_begin_failed: if( pPager->pInStmt ){ sqlite3BitvecDestroy(pPager->pInStmt); pPager->pInStmt = 0; } return rc; } SQLITE_PRIVATE int sqlite3PagerStmtBegin(Pager *pPager){ int rc; rc = pagerStmtBegin(pPager); return rc; } SQLITE_PRIVATE int sqlite3PagerStmtCommit(Pager *pPager){ if( pPager->stmtInUse ){ PAGERTRACE2("STMT-COMMIT %d\n", PAGERID(pPager)); sqlite3BitvecDestroy(pPager->pInStmt); pPager->pInStmt = 0; pPager->stmtNRec = 0; pPager->stmtInUse = 0; if( sqlite3IsMemJournal(pPager->stfd) ){ sqlite3OsTruncate(pPager->stfd, 0); } } pPager->stmtAutoopen = 0; return SQLITE_OK; } SQLITE_PRIVATE int sqlite3PagerStmtRollback(Pager *pPager){ int rc; if( pPager->stmtInUse ){ PAGERTRACE2("STMT-ROLLBACK %d\n", PAGERID(pPager)); rc = pager_stmt_playback(pPager); sqlite3PagerStmtCommit(pPager); }else{ rc = SQLITE_OK; } pPager->stmtAutoopen = 0; return rc; } SQLITE_PRIVATE const char *sqlite3PagerFilename(Pager *pPager){ return pPager->zFilename; } SQLITE_PRIVATE const sqlite3_vfs *sqlite3PagerVfs(Pager *pPager){ return pPager->pVfs; } SQLITE_PRIVATE sqlite3_file *sqlite3PagerFile(Pager *pPager){ return pPager->fd; } SQLITE_PRIVATE const char *sqlite3PagerDirname(Pager *pPager){ return pPager->zDirectory; } SQLITE_PRIVATE const char *sqlite3PagerJournalname(Pager *pPager){ return pPager->zJournal; } SQLITE_PRIVATE int sqlite3PagerNosync(Pager *pPager){ return pPager->noSync; } 
#ifdef SQLITE_HAS_CODEC 
SQLITE_PRIVATE void sqlite3PagerSetCodec( Pager *pPager, void *(*xCodec)(void*,void*,Pgno,int), void *pCodecArg ){ pPager->xCodec = xCodec; pPager->pCodecArg = pCodecArg; } 
#endif 
#ifndef SQLITE_OMIT_AUTOVACUUM 
SQLITE_PRIVATE int sqlite3PagerMovepage(Pager *pPager, DbPage *pPg, Pgno pgno, int isCommit){ PgHdr *pPgOld; Pgno needSyncPgno = 0; assert( pPg->nRef>0 ); PAGERTRACE5("MOVE %d page %d (needSync=%d) moves to %d\n", PAGERID(pPager), pPg->pgno, (pPg->flags&PGHDR_NEED_SYNC)?1:0, pgno); IOTRACE(("MOVE %p %d %d\n", pPager, pPg->pgno, pgno)) pager_get_content(pPg); if( (pPg->flags&PGHDR_NEED_SYNC) && !isCommit ){ needSyncPgno = pPg->pgno; assert( pageInJournal(pPg) || pPg->pgno>pPager->origDbSize ); assert( pPg->flags&PGHDR_DIRTY ); assert( pPager->needSync ); } pPg->flags &= ~PGHDR_NEED_SYNC; pPgOld = pager_lookup(pPager, pgno); assert( !pPgOld || pPgOld->nRef==1 ); if( pPgOld ){ pPg->flags |= (pPgOld->flags&PGHDR_NEED_SYNC); } sqlite3PcacheMove(pPg, pgno); if( pPgOld ){ sqlite3PcacheDrop(pPgOld); } sqlite3PcacheMakeDirty(pPg); pPager->dirtyCache = 1; pPager->dbModified = 1; if( needSyncPgno ){ int rc; PgHdr *pPgHdr; assert( pPager->needSync ); rc = sqlite3PagerGet(pPager, needSyncPgno, &pPgHdr); if( rc!=SQLITE_OK ){ if( pPager->pInJournal && needSyncPgno<=pPager->origDbSize ){ sqlite3BitvecClear(pPager->pInJournal, needSyncPgno); } return rc; } pPager->needSync = 1; assert( pPager->noSync==0 && !MEMDB ); pPgHdr->flags |= PGHDR_NEED_SYNC; sqlite3PcacheMakeDirty(pPgHdr); sqlite3PagerUnref(pPgHdr); } return SQLITE_OK; } 
#endif 
SQLITE_PRIVATE void *sqlite3PagerGetData(DbPage *pPg){ assert( pPg->nRef>0 || pPg->pPager->memDb ); return pPg->pData; } SQLITE_PRIVATE void *sqlite3PagerGetExtra(DbPage *pPg){ Pager *pPager = pPg->pPager; return (pPager?pPg->pExtra:0); } SQLITE_PRIVATE int sqlite3PagerLockingMode(Pager *pPager, int eMode){ assert( eMode==PAGER_LOCKINGMODE_QUERY || eMode==PAGER_LOCKINGMODE_NORMAL || eMode==PAGER_LOCKINGMODE_EXCLUSIVE ); assert( PAGER_LOCKINGMODE_QUERY<0 ); assert( PAGER_LOCKINGMODE_NORMAL>=0 && PAGER_LOCKINGMODE_EXCLUSIVE>=0 ); if( eMode>=0 && !pPager->tempFile ){ pPager->exclusiveMode = eMode; } return (int)pPager->exclusiveMode; } SQLITE_PRIVATE int sqlite3PagerJournalMode(Pager *pPager, int eMode){ if( !MEMDB ){ assert( eMode==PAGER_JOURNALMODE_QUERY || eMode==PAGER_JOURNALMODE_DELETE || eMode==PAGER_JOURNALMODE_TRUNCATE || eMode==PAGER_JOURNALMODE_PERSIST || eMode==PAGER_JOURNALMODE_OFF || eMode==PAGER_JOURNALMODE_MEMORY ); assert( PAGER_JOURNALMODE_QUERY<0 ); if( eMode>=0 ){ pPager->journalMode = eMode; }else{ assert( eMode==PAGER_JOURNALMODE_QUERY ); } } return (int)pPager->journalMode; } SQLITE_PRIVATE i64 sqlite3PagerJournalSizeLimit(Pager *pPager, i64 iLimit){ if( iLimit>=-1 ){ pPager->journalSizeLimit = iLimit; } return pPager->journalSizeLimit; } 
#endif 
#define ROUND8(x) ((x+7)&~7) 
#define MX_CELL_SIZE(pBt) (pBt->pageSize-8) 
#define MX_CELL(pBt) ((pBt->pageSize-8)/6) 
typedef struct MemPage MemPage; typedef struct BtLock BtLock; 
#ifndef SQLITE_FILE_HEADER 
#define SQLITE_FILE_HEADER "SQLite format 3" 
#endif 
#define PTF_INTKEY 0x01 
#define PTF_ZERODATA 0x02 
#define PTF_LEAFDATA 0x04 
#define PTF_LEAF 0x08 
struct MemPage { u8 isInit; u8 nOverflow; u8 intKey; u8 leaf; u8 hasData; u8 hdrOffset; u8 childPtrSize; u16 maxLocal; u16 minLocal; u16 cellOffset; u16 nFree; u16 nCell; u16 maskPage; struct _OvflCell { u8 *pCell; u16 idx; } aOvfl[5]; BtShared *pBt; u8 *aData; DbPage *pDbPage; Pgno pgno; }; 
#define EXTRA_SIZE sizeof(MemPage) 
struct Btree { sqlite3 *db; BtShared *pBt; u8 inTrans; u8 sharable; u8 locked; int wantToLock; Btree *pNext; Btree *pPrev; }; 
#define TRANS_NONE 0 
#define TRANS_READ 1 
#define TRANS_WRITE 2 
struct BtShared { Pager *pPager; sqlite3 *db; BtCursor *pCursor; MemPage *pPage1; u8 inStmt; u8 readOnly; u8 pageSizeFixed; 
#ifndef SQLITE_OMIT_AUTOVACUUM 
 u8 autoVacuum; u8 incrVacuum; Pgno nTrunc; 
#endif 
 u16 pageSize; u16 usableSize; int maxLocal; int minLocal; int maxLeaf; int minLeaf; u8 inTransaction; int nTransaction; void *pSchema; void (*xFreeSchema)(void*); sqlite3_mutex *mutex; 
#ifndef SQLITE_OMIT_SHARED_CACHE 
 int nRef; BtShared *pNext; BtLock *pLock; Btree *pExclusive; 
#endif 
 u8 *pTmpSpace; }; typedef struct CellInfo CellInfo; struct CellInfo { u8 *pCell; i64 nKey; u32 nData; u32 nPayload; u16 nHeader; u16 nLocal; u16 iOverflow; u16 nSize; }; 
#define BTCURSOR_MAX_DEPTH 20 
struct BtCursor { Btree *pBtree; BtShared *pBt; BtCursor *pNext, *pPrev; struct KeyInfo *pKeyInfo; Pgno pgnoRoot; CellInfo info; u8 wrFlag; u8 atLast; u8 validNKey; u8 eState; void *pKey; i64 nKey; int skip; 
#ifndef SQLITE_OMIT_INCRBLOB 
 u8 isIncrblobHandle; Pgno *aOverflow; 
#endif 
#ifndef NDEBUG 
 u8 pagesShuffled; 
#endif 
 i16 iPage; MemPage *apPage[BTCURSOR_MAX_DEPTH]; u16 aiIdx[BTCURSOR_MAX_DEPTH]; }; 
#define CURSOR_INVALID 0 
#define CURSOR_VALID 1 
#define CURSOR_REQUIRESEEK 2 
#define CURSOR_FAULT 3 
#ifdef SQLITE_OMIT_DISKIO 
#define PENDING_BYTE_PAGE(pBt) 0x7fffffff 
#else 
#define PENDING_BYTE_PAGE(pBt) ((Pgno)((PENDING_BYTE/(pBt)->pageSize)+1)) 
#endif 
struct BtLock { Btree *pBtree; Pgno iTable; u8 eLock; BtLock *pNext; }; 
#define READ_LOCK 1 
#define WRITE_LOCK 2 
#define PTRMAP_PAGENO(pBt, pgno) ptrmapPageno(pBt, pgno) 
#define PTRMAP_PTROFFSET(pgptrmap, pgno) (5*(pgno-pgptrmap-1)) 
#define PTRMAP_ISPAGE(pBt, pgno) (PTRMAP_PAGENO((pBt),(pgno))==(pgno)) 
#define PTRMAP_ROOTPAGE 1 
#define PTRMAP_FREEPAGE 2 
#define PTRMAP_OVERFLOW1 3 
#define PTRMAP_OVERFLOW2 4 
#define PTRMAP_BTREE 5 
#define btreeIntegrity(p) assert( p->pBt->inTransaction!=TRANS_NONE || p->pBt->nTransaction==0 ); assert( p->pBt->inTransaction>=p->inTrans ); 
#ifndef SQLITE_OMIT_AUTOVACUUM 
#define ISAUTOVACUUM (pBt->autoVacuum) 
#else 
#define ISAUTOVACUUM 0 
#endif 
typedef struct IntegrityCk IntegrityCk; struct IntegrityCk { BtShared *pBt; Pager *pPager; Pgno nPage; int *anRef; int mxErr; int nErr; int mallocFailed; StrAccum errMsg; }; 
#define get2byte(x) ((x)[0]<<8 | (x)[1]) 
#define put2byte(p,v) ((p)[0] = (v)>>8, (p)[1] = (v)) 
#define get4byte sqlite3Get4byte 
#define put4byte sqlite3Put4byte 
SQLITE_PRIVATE int sqlite3BtreeGetPage(BtShared*, Pgno, MemPage**, int); SQLITE_PRIVATE int sqlite3BtreeInitPage(MemPage *pPage); SQLITE_PRIVATE void sqlite3BtreeParseCellPtr(MemPage*, u8*, CellInfo*); SQLITE_PRIVATE void sqlite3BtreeParseCell(MemPage*, int, CellInfo*); SQLITE_PRIVATE int sqlite3BtreeRestoreCursorPosition(BtCursor *pCur); SQLITE_PRIVATE void sqlite3BtreeGetTempCursor(BtCursor *pCur, BtCursor *pTempCur); SQLITE_PRIVATE void sqlite3BtreeReleaseTempCursor(BtCursor *pCur); SQLITE_PRIVATE void sqlite3BtreeMoveToParent(BtCursor *pCur); 
#if SQLITE_THREADSAFE && !defined(SQLITE_OMIT_SHARED_CACHE) 
SQLITE_PRIVATE void sqlite3BtreeEnter(Btree *p){ Btree *pLater; assert( p->pNext==0 || p->pNext->pBt>p->pBt ); assert( p->pPrev==0 || p->pPrev->pBt<p->pBt ); assert( p->pNext==0 || p->pNext->db==p->db ); assert( p->pPrev==0 || p->pPrev->db==p->db ); assert( p->sharable || (p->pNext==0 && p->pPrev==0) ); assert( !p->locked || p->wantToLock>0 ); assert( p->sharable || p->wantToLock==0 ); assert( sqlite3_mutex_held(p->db->mutex) ); if( !p->sharable ) return; p->wantToLock++; if( p->locked ) return; if( sqlite3_mutex_try(p->pBt->mutex)==SQLITE_OK ){ p->locked = 1; return; } for(pLater=p->pNext; pLater; pLater=pLater->pNext){ assert( pLater->sharable ); assert( pLater->pNext==0 || pLater->pNext->pBt>pLater->pBt ); assert( !pLater->locked || pLater->wantToLock>0 ); if( pLater->locked ){ sqlite3_mutex_leave(pLater->pBt->mutex); pLater->locked = 0; } } sqlite3_mutex_enter(p->pBt->mutex); p->locked = 1; for(pLater=p->pNext; pLater; pLater=pLater->pNext){ if( pLater->wantToLock ){ sqlite3_mutex_enter(pLater->pBt->mutex); pLater->locked = 1; } } } SQLITE_PRIVATE void sqlite3BtreeLeave(Btree *p){ if( p->sharable ){ assert( p->wantToLock>0 ); p->wantToLock--; if( p->wantToLock==0 ){ assert( p->locked ); sqlite3_mutex_leave(p->pBt->mutex); p->locked = 0; } } } 
#ifndef NDEBUG 
SQLITE_PRIVATE int sqlite3BtreeHoldsMutex(Btree *p){ return (p->sharable==0 || (p->locked && p->wantToLock && sqlite3_mutex_held(p->pBt->mutex))); } 
#endif 
#ifndef SQLITE_OMIT_INCRBLOB 
SQLITE_PRIVATE void sqlite3BtreeEnterCursor(BtCursor *pCur){ sqlite3BtreeEnter(pCur->pBtree); } SQLITE_PRIVATE void sqlite3BtreeLeaveCursor(BtCursor *pCur){ sqlite3BtreeLeave(pCur->pBtree); } 
#endif 
SQLITE_PRIVATE void sqlite3BtreeEnterAll(sqlite3 *db){ int i; Btree *p, *pLater; assert( sqlite3_mutex_held(db->mutex) ); for(i=0; i<db->nDb; i++){ p = db->aDb[i].pBt; if( p && p->sharable ){ p->wantToLock++; if( !p->locked ){ assert( p->wantToLock==1 ); while( p->pPrev ) p = p->pPrev; while( p->locked && p->pNext ) p = p->pNext; for(pLater = p->pNext; pLater; pLater=pLater->pNext){ if( pLater->locked ){ sqlite3_mutex_leave(pLater->pBt->mutex); pLater->locked = 0; } } while( p ){ sqlite3_mutex_enter(p->pBt->mutex); p->locked++; p = p->pNext; } } } } } SQLITE_PRIVATE void sqlite3BtreeLeaveAll(sqlite3 *db){ int i; Btree *p; assert( sqlite3_mutex_held(db->mutex) ); for(i=0; i<db->nDb; i++){ p = db->aDb[i].pBt; if( p && p->sharable ){ assert( p->wantToLock>0 ); p->wantToLock--; if( p->wantToLock==0 ){ assert( p->locked ); sqlite3_mutex_leave(p->pBt->mutex); p->locked = 0; } } } } 
#ifndef NDEBUG 
SQLITE_PRIVATE int sqlite3BtreeHoldsAllMutexes(sqlite3 *db){ int i; if( !sqlite3_mutex_held(db->mutex) ){ return 0; } for(i=0; i<db->nDb; i++){ Btree *p; p = db->aDb[i].pBt; if( p && p->sharable && (p->wantToLock==0 || !sqlite3_mutex_held(p->pBt->mutex)) ){ return 0; } } return 1; } 
#endif 
SQLITE_PRIVATE void sqlite3BtreeMutexArrayInsert(BtreeMutexArray *pArray, Btree *pBtree){ int i, j; BtShared *pBt; if( pBtree==0 || pBtree->sharable==0 ) return; 
#ifndef NDEBUG 
 { for(i=0; i<pArray->nMutex; i++){ assert( pArray->aBtree[i]!=pBtree ); } } 
#endif 
 assert( pArray->nMutex>=0 ); assert( pArray->nMutex<ArraySize(pArray->aBtree)-1 ); pBt = pBtree->pBt; for(i=0; i<pArray->nMutex; i++){ assert( pArray->aBtree[i]!=pBtree ); if( pArray->aBtree[i]->pBt>pBt ){ for(j=pArray->nMutex; j>i; j--){ pArray->aBtree[j] = pArray->aBtree[j-1]; } pArray->aBtree[i] = pBtree; pArray->nMutex++; return; } } pArray->aBtree[pArray->nMutex++] = pBtree; } SQLITE_PRIVATE void sqlite3BtreeMutexArrayEnter(BtreeMutexArray *pArray){ int i; for(i=0; i<pArray->nMutex; i++){ Btree *p = pArray->aBtree[i]; assert( i==0 || pArray->aBtree[i-1]->pBt<p->pBt ); assert( !p->locked || p->wantToLock>0 ); assert( sqlite3_mutex_held(p->db->mutex) ); p->wantToLock++; if( !p->locked && p->sharable ){ sqlite3_mutex_enter(p->pBt->mutex); p->locked = 1; } } } SQLITE_PRIVATE void sqlite3BtreeMutexArrayLeave(BtreeMutexArray *pArray){ int i; for(i=0; i<pArray->nMutex; i++){ Btree *p = pArray->aBtree[i]; assert( i==0 || pArray->aBtree[i-1]->pBt<p->pBt ); assert( p->locked || !p->sharable ); assert( p->wantToLock>0 ); assert( sqlite3_mutex_held(p->db->mutex) ); p->wantToLock--; if( p->wantToLock==0 && p->locked ){ sqlite3_mutex_leave(p->pBt->mutex); p->locked = 0; } } } 
#endif 
static const char zMagicHeader[] = SQLITE_FILE_HEADER; 
#if 0 
int sqlite3BtreeTrace=0; 
#define TRACE(X) if(sqlite3BtreeTrace){printf X;fflush(stdout);} 
#else 
#define TRACE(X) 
#endif 
#ifndef NDEBUG 
#define VVA_ONLY(X) X 
#else 
#define VVA_ONLY(X) 
#endif 
#ifndef SQLITE_OMIT_SHARED_CACHE 
#ifdef SQLITE_TEST 
SQLITE_PRIVATE BtShared *SQLITE_WSD sqlite3SharedCacheList = 0; 
#else 
static BtShared *SQLITE_WSD sqlite3SharedCacheList = 0; 
#endif 
#endif 
#ifndef SQLITE_OMIT_SHARED_CACHE 
SQLITE_API int sqlite3_enable_shared_cache(int enable){ sqlite3GlobalConfig.sharedCacheEnabled = enable; return SQLITE_OK; } 
#endif 
static int checkReadLocks(Btree*, Pgno, BtCursor*, i64); 
#ifdef SQLITE_OMIT_SHARED_CACHE 
 
#define queryTableLock(a,b,c) SQLITE_OK 
#define lockTable(a,b,c) SQLITE_OK 
#define unlockAllTables(a) 
#endif 
#ifndef SQLITE_OMIT_SHARED_CACHE 
static int queryTableLock(Btree *p, Pgno iTab, u8 eLock){ BtShared *pBt = p->pBt; BtLock *pIter; assert( sqlite3BtreeHoldsMutex(p) ); assert( eLock==READ_LOCK || eLock==WRITE_LOCK ); assert( p->db!=0 ); if( !p->sharable ){ return SQLITE_OK; } if( pBt->pExclusive && pBt->pExclusive!=p ){ return SQLITE_LOCKED; } if( 0==(p->db->flags&SQLITE_ReadUncommitted) || eLock==WRITE_LOCK || iTab==MASTER_ROOT ){ for(pIter=pBt->pLock; pIter; pIter=pIter->pNext){ if( pIter->pBtree!=p && pIter->iTable==iTab && (pIter->eLock!=eLock || eLock!=READ_LOCK) ){ return SQLITE_LOCKED; } } } return SQLITE_OK; } 
#endif 
#ifndef SQLITE_OMIT_SHARED_CACHE 
static int lockTable(Btree *p, Pgno iTable, u8 eLock){ BtShared *pBt = p->pBt; BtLock *pLock = 0; BtLock *pIter; assert( sqlite3BtreeHoldsMutex(p) ); assert( eLock==READ_LOCK || eLock==WRITE_LOCK ); assert( p->db!=0 ); if( !p->sharable ){ return SQLITE_OK; } assert( SQLITE_OK==queryTableLock(p, iTable, eLock) ); if( (p->db->flags&SQLITE_ReadUncommitted) && (eLock==READ_LOCK) && iTable!=MASTER_ROOT ){ return SQLITE_OK; } for(pIter=pBt->pLock; pIter; pIter=pIter->pNext){ if( pIter->iTable==iTable && pIter->pBtree==p ){ pLock = pIter; break; } } if( !pLock ){ pLock = (BtLock *)sqlite3MallocZero(sizeof(BtLock)); if( !pLock ){ return SQLITE_NOMEM; } pLock->iTable = iTable; pLock->pBtree = p; pLock->pNext = pBt->pLock; pBt->pLock = pLock; } assert( WRITE_LOCK>READ_LOCK ); if( eLock>pLock->eLock ){ pLock->eLock = eLock; } return SQLITE_OK; } 
#endif 
#ifndef SQLITE_OMIT_SHARED_CACHE 
static void unlockAllTables(Btree *p){ BtShared *pBt = p->pBt; BtLock **ppIter = &pBt->pLock; assert( sqlite3BtreeHoldsMutex(p) ); assert( p->sharable || 0==*ppIter ); while( *ppIter ){ BtLock *pLock = *ppIter; assert( pBt->pExclusive==0 || pBt->pExclusive==pLock->pBtree ); if( pLock->pBtree==p ){ *ppIter = pLock->pNext; sqlite3_free(pLock); }else{ ppIter = &pLock->pNext; } } if( pBt->pExclusive==p ){ pBt->pExclusive = 0; } } 
#endif 
static void releasePage(MemPage *pPage); 
#ifndef NDEBUG 
static int cursorHoldsMutex(BtCursor *p){ return sqlite3_mutex_held(p->pBt->mutex); } 
#endif 
#ifndef SQLITE_OMIT_INCRBLOB 
static void invalidateOverflowCache(BtCursor *pCur){ assert( cursorHoldsMutex(pCur) ); sqlite3_free(pCur->aOverflow); pCur->aOverflow = 0; } static void invalidateAllOverflowCache(BtShared *pBt){ BtCursor *p; assert( sqlite3_mutex_held(pBt->mutex) ); for(p=pBt->pCursor; p; p=p->pNext){ invalidateOverflowCache(p); } } 
#else 
#define invalidateOverflowCache(x) 
#define invalidateAllOverflowCache(x) 
#endif 
static int saveCursorPosition(BtCursor *pCur){ int rc; assert( CURSOR_VALID==pCur->eState ); assert( 0==pCur->pKey ); assert( cursorHoldsMutex(pCur) ); rc = sqlite3BtreeKeySize(pCur, &pCur->nKey); if( rc==SQLITE_OK && 0==pCur->apPage[0]->intKey){ void *pKey = sqlite3Malloc(pCur->nKey); if( pKey ){ rc = sqlite3BtreeKey(pCur, 0, pCur->nKey, pKey); if( rc==SQLITE_OK ){ pCur->pKey = pKey; }else{ sqlite3_free(pKey); } }else{ rc = SQLITE_NOMEM; } } assert( !pCur->apPage[0]->intKey || !pCur->pKey ); if( rc==SQLITE_OK ){ int i; for(i=0; i<=pCur->iPage; i++){ releasePage(pCur->apPage[i]); pCur->apPage[i] = 0; } pCur->iPage = -1; pCur->eState = CURSOR_REQUIRESEEK; } invalidateOverflowCache(pCur); return rc; } static int saveAllCursors(BtShared *pBt, Pgno iRoot, BtCursor *pExcept){ BtCursor *p; assert( sqlite3_mutex_held(pBt->mutex) ); assert( pExcept==0 || pExcept->pBt==pBt ); for(p=pBt->pCursor; p; p=p->pNext){ if( p!=pExcept && (0==iRoot || p->pgnoRoot==iRoot) && p->eState==CURSOR_VALID ){ int rc = saveCursorPosition(p); if( SQLITE_OK!=rc ){ return rc; } } } return SQLITE_OK; } SQLITE_PRIVATE void sqlite3BtreeClearCursor(BtCursor *pCur){ assert( cursorHoldsMutex(pCur) ); sqlite3_free(pCur->pKey); pCur->pKey = 0; pCur->eState = CURSOR_INVALID; } SQLITE_PRIVATE int sqlite3BtreeRestoreCursorPosition(BtCursor *pCur){ int rc; assert( cursorHoldsMutex(pCur) ); assert( pCur->eState>=CURSOR_REQUIRESEEK ); if( pCur->eState==CURSOR_FAULT ){ return pCur->skip; } pCur->eState = CURSOR_INVALID; rc = sqlite3BtreeMoveto(pCur, pCur->pKey, pCur->nKey, 0, &pCur->skip); if( rc==SQLITE_OK ){ sqlite3_free(pCur->pKey); pCur->pKey = 0; assert( pCur->eState==CURSOR_VALID || pCur->eState==CURSOR_INVALID ); } return rc; } 
#define restoreCursorPosition(p) (p->eState>=CURSOR_REQUIRESEEK ? sqlite3BtreeRestoreCursorPosition(p) : SQLITE_OK) 
SQLITE_PRIVATE int sqlite3BtreeCursorHasMoved(BtCursor *pCur, int *pHasMoved){ int rc; rc = restoreCursorPosition(pCur); if( rc ){ *pHasMoved = 1; return rc; } if( pCur->eState!=CURSOR_VALID || pCur->skip!=0 ){ *pHasMoved = 1; }else{ *pHasMoved = 0; } return SQLITE_OK; } 
#ifndef SQLITE_OMIT_AUTOVACUUM 
static Pgno ptrmapPageno(BtShared *pBt, Pgno pgno){ int nPagesPerMapPage; Pgno iPtrMap, ret; assert( sqlite3_mutex_held(pBt->mutex) ); nPagesPerMapPage = (pBt->usableSize/5)+1; iPtrMap = (pgno-2)/nPagesPerMapPage; ret = (iPtrMap*nPagesPerMapPage) + 2; if( ret==PENDING_BYTE_PAGE(pBt) ){ ret++; } return ret; } static int ptrmapPut(BtShared *pBt, Pgno key, u8 eType, Pgno parent){ DbPage *pDbPage; u8 *pPtrmap; Pgno iPtrmap; int offset; int rc; assert( sqlite3_mutex_held(pBt->mutex) ); assert( 0==PTRMAP_ISPAGE(pBt, PENDING_BYTE_PAGE(pBt)) ); assert( pBt->autoVacuum ); if( key==0 ){ return SQLITE_CORRUPT_BKPT; } iPtrmap = PTRMAP_PAGENO(pBt, key); rc = sqlite3PagerGet(pBt->pPager, iPtrmap, &pDbPage); if( rc!=SQLITE_OK ){ return rc; } offset = PTRMAP_PTROFFSET(iPtrmap, key); pPtrmap = (u8 *)sqlite3PagerGetData(pDbPage); if( eType!=pPtrmap[offset] || get4byte(&pPtrmap[offset+1])!=parent ){ TRACE(("PTRMAP_UPDATE: %d->(%d,%d)\n", key, eType, parent)); rc = sqlite3PagerWrite(pDbPage); if( rc==SQLITE_OK ){ pPtrmap[offset] = eType; put4byte(&pPtrmap[offset+1], parent); } } sqlite3PagerUnref(pDbPage); return rc; } static int ptrmapGet(BtShared *pBt, Pgno key, u8 *pEType, Pgno *pPgno){ DbPage *pDbPage; int iPtrmap; u8 *pPtrmap; int offset; int rc; assert( sqlite3_mutex_held(pBt->mutex) ); iPtrmap = PTRMAP_PAGENO(pBt, key); rc = sqlite3PagerGet(pBt->pPager, iPtrmap, &pDbPage); if( rc!=0 ){ return rc; } pPtrmap = (u8 *)sqlite3PagerGetData(pDbPage); offset = PTRMAP_PTROFFSET(iPtrmap, key); assert( pEType!=0 ); *pEType = pPtrmap[offset]; if( pPgno ) *pPgno = get4byte(&pPtrmap[offset+1]); sqlite3PagerUnref(pDbPage); if( *pEType<1 || *pEType>5 ) return SQLITE_CORRUPT_BKPT; return SQLITE_OK; } 
#else 
#define ptrmapPut(w,x,y,z) SQLITE_OK 
#define ptrmapGet(w,x,y,z) SQLITE_OK 
#define ptrmapPutOvfl(y,z) SQLITE_OK 
#endif 
#define findCell(P,I) ((P)->aData + ((P)->maskPage & get2byte(&(P)->aData[(P)->cellOffset+2*(I)]))) 
static u8 *findOverflowCell(MemPage *pPage, int iCell){ int i; assert( sqlite3_mutex_held(pPage->pBt->mutex) ); for(i=pPage->nOverflow-1; i>=0; i--){ int k; struct _OvflCell *pOvfl; pOvfl = &pPage->aOvfl[i]; k = pOvfl->idx; if( k<=iCell ){ if( k==iCell ){ return pOvfl->pCell; } iCell--; } } return findCell(pPage, iCell); } SQLITE_PRIVATE void sqlite3BtreeParseCellPtr( MemPage *pPage, u8 *pCell, CellInfo *pInfo ){ int n; u32 nPayload; assert( sqlite3_mutex_held(pPage->pBt->mutex) ); pInfo->pCell = pCell; assert( pPage->leaf==0 || pPage->leaf==1 ); n = pPage->childPtrSize; assert( n==4-4*pPage->leaf ); if( pPage->intKey ){ if( pPage->hasData ){ n += getVarint32(&pCell[n], nPayload); }else{ nPayload = 0; } n += getVarint(&pCell[n], (u64*)&pInfo->nKey); pInfo->nData = nPayload; }else{ pInfo->nData = 0; n += getVarint32(&pCell[n], nPayload); pInfo->nKey = nPayload; } pInfo->nPayload = nPayload; pInfo->nHeader = n; if( likely(nPayload<=pPage->maxLocal) ){ int nSize; nSize = nPayload + n; pInfo->nLocal = nPayload; pInfo->iOverflow = 0; if( (nSize & ~3)==0 ){ nSize = 4; } pInfo->nSize = nSize; }else{ int minLocal; int maxLocal; int surplus; minLocal = pPage->minLocal; maxLocal = pPage->maxLocal; surplus = minLocal + (nPayload - minLocal)%(pPage->pBt->usableSize - 4); if( surplus <= maxLocal ){ pInfo->nLocal = surplus; }else{ pInfo->nLocal = minLocal; } pInfo->iOverflow = pInfo->nLocal + n; pInfo->nSize = pInfo->iOverflow + 4; } } 
#define parseCell(pPage, iCell, pInfo) sqlite3BtreeParseCellPtr((pPage), findCell((pPage), (iCell)), (pInfo)) 
SQLITE_PRIVATE void sqlite3BtreeParseCell( MemPage *pPage, int iCell, CellInfo *pInfo ){ parseCell(pPage, iCell, pInfo); } 
#ifndef NDEBUG 
static u16 cellSize(MemPage *pPage, int iCell){ CellInfo info; sqlite3BtreeParseCell(pPage, iCell, &info); return info.nSize; } 
#endif 
static u16 cellSizePtr(MemPage *pPage, u8 *pCell){ CellInfo info; sqlite3BtreeParseCellPtr(pPage, pCell, &info); return info.nSize; } 
#ifndef SQLITE_OMIT_AUTOVACUUM 
static int ptrmapPutOvflPtr(MemPage *pPage, u8 *pCell){ CellInfo info; assert( pCell!=0 ); sqlite3BtreeParseCellPtr(pPage, pCell, &info); assert( (info.nData+(pPage->intKey?0:info.nKey))==info.nPayload ); if( (info.nData+(pPage->intKey?0:info.nKey))>info.nLocal ){ Pgno ovfl = get4byte(&pCell[info.iOverflow]); return ptrmapPut(pPage->pBt, ovfl, PTRMAP_OVERFLOW1, pPage->pgno); } return SQLITE_OK; } static int ptrmapPutOvfl(MemPage *pPage, int iCell){ u8 *pCell; assert( sqlite3_mutex_held(pPage->pBt->mutex) ); pCell = findOverflowCell(pPage, iCell); return ptrmapPutOvflPtr(pPage, pCell); } 
#endif 
static int defragmentPage(MemPage *pPage){ int i; int pc; int addr; int hdr; int size; int usableSize; int cellOffset; int cbrk; int nCell; unsigned char *data; unsigned char *temp; assert( sqlite3PagerIswriteable(pPage->pDbPage) ); assert( pPage->pBt!=0 ); assert( pPage->pBt->usableSize <= SQLITE_MAX_PAGE_SIZE ); assert( pPage->nOverflow==0 ); assert( sqlite3_mutex_held(pPage->pBt->mutex) ); temp = sqlite3PagerTempSpace(pPage->pBt->pPager); data = pPage->aData; hdr = pPage->hdrOffset; cellOffset = pPage->cellOffset; nCell = pPage->nCell; assert( nCell==get2byte(&data[hdr+3]) ); usableSize = pPage->pBt->usableSize; cbrk = get2byte(&data[hdr+5]); memcpy(&temp[cbrk], &data[cbrk], usableSize - cbrk); cbrk = usableSize; for(i=0; i<nCell; i++){ u8 *pAddr; pAddr = &data[cellOffset + i*2]; pc = get2byte(pAddr); if( pc>=usableSize ){ return SQLITE_CORRUPT_BKPT; } size = cellSizePtr(pPage, &temp[pc]); cbrk -= size; if( cbrk<cellOffset+2*nCell || pc+size>usableSize ){ return SQLITE_CORRUPT_BKPT; } assert( cbrk+size<=usableSize && cbrk>=0 ); memcpy(&data[cbrk], &temp[pc], size); put2byte(pAddr, cbrk); } assert( cbrk>=cellOffset+2*nCell ); put2byte(&data[hdr+5], cbrk); data[hdr+1] = 0; data[hdr+2] = 0; data[hdr+7] = 0; addr = cellOffset+2*nCell; memset(&data[addr], 0, cbrk-addr); if( cbrk-addr!=pPage->nFree ){ return SQLITE_CORRUPT_BKPT; } return SQLITE_OK; } static int allocateSpace(MemPage *pPage, int nByte){ int addr, pc, hdr; int size; int nFrag; int top; int nCell; int cellOffset; unsigned char *data; data = pPage->aData; assert( sqlite3PagerIswriteable(pPage->pDbPage) ); assert( pPage->pBt ); assert( sqlite3_mutex_held(pPage->pBt->mutex) ); assert( nByte>=0 ); assert( pPage->nFree>=nByte ); assert( pPage->nOverflow==0 ); pPage->nFree -= nByte; hdr = pPage->hdrOffset; nFrag = data[hdr+7]; if( nFrag<60 ){ addr = hdr+1; while( (pc = get2byte(&data[addr]))>0 ){ size = get2byte(&data[pc+2]); if( size>=nByte ){ if( size<nByte+4 ){ memcpy(&data[addr], &data[pc], 2); data[hdr+7] = nFrag + size - nByte; return pc; }else{ put2byte(&data[pc+2], size-nByte); return pc + size - nByte; } } addr = pc; } } top = get2byte(&data[hdr+5]); nCell = get2byte(&data[hdr+3]); cellOffset = pPage->cellOffset; if( nFrag>=60 || cellOffset + 2*nCell > top - nByte ){ defragmentPage(pPage); top = get2byte(&data[hdr+5]); } top -= nByte; assert( cellOffset + 2*nCell <= top ); put2byte(&data[hdr+5], top); return top; } static int freeSpace(MemPage *pPage, int start, int size){ int addr, pbegin, hdr; unsigned char *data = pPage->aData; assert( pPage->pBt!=0 ); assert( sqlite3PagerIswriteable(pPage->pDbPage) ); assert( start>=pPage->hdrOffset+6+(pPage->leaf?0:4) ); assert( (start + size)<=pPage->pBt->usableSize ); assert( sqlite3_mutex_held(pPage->pBt->mutex) ); assert( size>=0 ); 
#ifdef SQLITE_SECURE_DELETE 
 memset(&data[start], 0, size); 
#endif 
 hdr = pPage->hdrOffset; addr = hdr + 1; while( (pbegin = get2byte(&data[addr]))<start && pbegin>0 ){ assert( pbegin<=pPage->pBt->usableSize-4 ); if( pbegin<=addr ) { return SQLITE_CORRUPT_BKPT; } addr = pbegin; } if ( pbegin>pPage->pBt->usableSize-4 ) { return SQLITE_CORRUPT_BKPT; } assert( pbegin>addr || pbegin==0 ); put2byte(&data[addr], start); put2byte(&data[start], pbegin); put2byte(&data[start+2], size); pPage->nFree += size; addr = pPage->hdrOffset + 1; while( (pbegin = get2byte(&data[addr]))>0 ){ int pnext, psize; assert( pbegin>addr ); assert( pbegin<=pPage->pBt->usableSize-4 ); pnext = get2byte(&data[pbegin]); psize = get2byte(&data[pbegin+2]); if( pbegin + psize + 3 >= pnext && pnext>0 ){ int frag = pnext - (pbegin+psize); if( (frag<0) || (frag>data[pPage->hdrOffset+7]) ){ return SQLITE_CORRUPT_BKPT; } data[pPage->hdrOffset+7] -= frag; put2byte(&data[pbegin], get2byte(&data[pnext])); put2byte(&data[pbegin+2], pnext+get2byte(&data[pnext+2])-pbegin); }else{ addr = pbegin; } } if( data[hdr+1]==data[hdr+5] && data[hdr+2]==data[hdr+6] ){ int top; pbegin = get2byte(&data[hdr+1]); memcpy(&data[hdr+1], &data[pbegin], 2); top = get2byte(&data[hdr+5]); put2byte(&data[hdr+5], top + get2byte(&data[pbegin+2])); } return SQLITE_OK; } static int decodeFlags(MemPage *pPage, int flagByte){ BtShared *pBt; assert( pPage->hdrOffset==(pPage->pgno==1 ? 100 : 0) ); assert( sqlite3_mutex_held(pPage->pBt->mutex) ); pPage->leaf = flagByte>>3; assert( PTF_LEAF == 1<<3 ); flagByte &= ~PTF_LEAF; pPage->childPtrSize = 4-4*pPage->leaf; pBt = pPage->pBt; if( flagByte==(PTF_LEAFDATA | PTF_INTKEY) ){ pPage->intKey = 1; pPage->hasData = pPage->leaf; pPage->maxLocal = pBt->maxLeaf; pPage->minLocal = pBt->minLeaf; }else if( flagByte==PTF_ZERODATA ){ pPage->intKey = 0; pPage->hasData = 0; pPage->maxLocal = pBt->maxLocal; pPage->minLocal = pBt->minLocal; }else{ return SQLITE_CORRUPT_BKPT; } return SQLITE_OK; } SQLITE_PRIVATE int sqlite3BtreeInitPage(MemPage *pPage){ assert( pPage->pBt!=0 ); assert( sqlite3_mutex_held(pPage->pBt->mutex) ); assert( pPage->pgno==sqlite3PagerPagenumber(pPage->pDbPage) ); assert( pPage == sqlite3PagerGetExtra(pPage->pDbPage) ); assert( pPage->aData == sqlite3PagerGetData(pPage->pDbPage) ); if( !pPage->isInit ){ int pc; int hdr; u8 *data; BtShared *pBt; int usableSize; int cellOffset; int nFree; int top; pBt = pPage->pBt; hdr = pPage->hdrOffset; data = pPage->aData; if( decodeFlags(pPage, data[hdr]) ) return SQLITE_CORRUPT_BKPT; assert( pBt->pageSize>=512 && pBt->pageSize<=32768 ); pPage->maskPage = pBt->pageSize - 1; pPage->nOverflow = 0; usableSize = pBt->usableSize; pPage->cellOffset = cellOffset = hdr + 12 - 4*pPage->leaf; top = get2byte(&data[hdr+5]); pPage->nCell = get2byte(&data[hdr+3]); if( pPage->nCell>MX_CELL(pBt) ){ return SQLITE_CORRUPT_BKPT; } pc = get2byte(&data[hdr+1]); nFree = data[hdr+7] + top - (cellOffset + 2*pPage->nCell); while( pc>0 ){ int next, size; if( pc>usableSize-4 ){ return SQLITE_CORRUPT_BKPT; } next = get2byte(&data[pc]); size = get2byte(&data[pc+2]); if( next>0 && next<=pc+size+3 ){ return SQLITE_CORRUPT_BKPT; } nFree += size; pc = next; } pPage->nFree = nFree; if( nFree>=usableSize ){ return SQLITE_CORRUPT_BKPT; } 
#if 0 
 { u8 *pOff; u8 *pEnd; u8 mask; mask = ~(((u8)(pBt->pageSize>>8))-1); pEnd = &data[cellOffset + pPage->nCell*2]; for(pOff=&data[cellOffset]; pOff!=pEnd && !((*pOff)&mask); pOff+=2); if( pOff!=pEnd ){ return SQLITE_CORRUPT_BKPT; } } 
#endif 
 pPage->isInit = 1; } return SQLITE_OK; } static void zeroPage(MemPage *pPage, int flags){ unsigned char *data = pPage->aData; BtShared *pBt = pPage->pBt; int hdr = pPage->hdrOffset; int first; assert( sqlite3PagerPagenumber(pPage->pDbPage)==pPage->pgno ); assert( sqlite3PagerGetExtra(pPage->pDbPage) == (void*)pPage ); assert( sqlite3PagerGetData(pPage->pDbPage) == data ); assert( sqlite3PagerIswriteable(pPage->pDbPage) ); assert( sqlite3_mutex_held(pBt->mutex) ); data[hdr] = flags; first = hdr + 8 + 4*((flags&PTF_LEAF)==0); memset(&data[hdr+1], 0, 4); data[hdr+7] = 0; put2byte(&data[hdr+5], pBt->usableSize); pPage->nFree = pBt->usableSize - first; decodeFlags(pPage, flags); pPage->hdrOffset = hdr; pPage->cellOffset = first; pPage->nOverflow = 0; assert( pBt->pageSize>=512 && pBt->pageSize<=32768 ); pPage->maskPage = pBt->pageSize - 1; pPage->nCell = 0; pPage->isInit = 1; } static MemPage *btreePageFromDbPage(DbPage *pDbPage, Pgno pgno, BtShared *pBt){ MemPage *pPage = (MemPage*)sqlite3PagerGetExtra(pDbPage); pPage->aData = sqlite3PagerGetData(pDbPage); pPage->pDbPage = pDbPage; pPage->pBt = pBt; pPage->pgno = pgno; pPage->hdrOffset = pPage->pgno==1 ? 100 : 0; return pPage; } SQLITE_PRIVATE int sqlite3BtreeGetPage( BtShared *pBt, Pgno pgno, MemPage **ppPage, int noContent ){ int rc; DbPage *pDbPage; assert( sqlite3_mutex_held(pBt->mutex) ); rc = sqlite3PagerAcquire(pBt->pPager, pgno, (DbPage**)&pDbPage, noContent); if( rc ) return rc; *ppPage = btreePageFromDbPage(pDbPage, pgno, pBt); return SQLITE_OK; } static Pgno pagerPagecount(BtShared *pBt){ int nPage = -1; int rc; assert( pBt->pPage1 ); rc = sqlite3PagerPagecount(pBt->pPager, &nPage); assert( rc==SQLITE_OK || nPage==-1 ); return (Pgno)nPage; } static int getAndInitPage( BtShared *pBt, Pgno pgno, MemPage **ppPage ){ int rc; DbPage *pDbPage; MemPage *pPage; assert( sqlite3_mutex_held(pBt->mutex) ); if( pgno==0 ){ return SQLITE_CORRUPT_BKPT; } pDbPage = sqlite3PagerLookup(pBt->pPager, pgno); if( pDbPage ){ *ppPage = pPage = btreePageFromDbPage(pDbPage, pgno, pBt); rc = SQLITE_OK; }else{ if( pgno>pagerPagecount(pBt) ){ return SQLITE_CORRUPT_BKPT; } rc = sqlite3BtreeGetPage(pBt, pgno, ppPage, 0); if( rc ) return rc; pPage = *ppPage; } if( !pPage->isInit ){ rc = sqlite3BtreeInitPage(pPage); } if( rc!=SQLITE_OK ){ releasePage(pPage); *ppPage = 0; } return rc; } static void releasePage(MemPage *pPage){ if( pPage ){ assert( pPage->aData ); assert( pPage->pBt ); assert( sqlite3PagerGetExtra(pPage->pDbPage) == (void*)pPage ); assert( sqlite3PagerGetData(pPage->pDbPage)==pPage->aData ); assert( sqlite3_mutex_held(pPage->pBt->mutex) ); sqlite3PagerUnref(pPage->pDbPage); } } static void pageReinit(DbPage *pData){ MemPage *pPage; pPage = (MemPage *)sqlite3PagerGetExtra(pData); if( pPage->isInit ){ assert( sqlite3_mutex_held(pPage->pBt->mutex) ); pPage->isInit = 0; if( sqlite3PagerPageRefcount(pData)>0 ){ sqlite3BtreeInitPage(pPage); } } } static int btreeInvokeBusyHandler(void *pArg){ BtShared *pBt = (BtShared*)pArg; assert( pBt->db ); assert( sqlite3_mutex_held(pBt->db->mutex) ); return sqlite3InvokeBusyHandler(&pBt->db->busyHandler); } SQLITE_PRIVATE int sqlite3BtreeOpen( const char *zFilename, sqlite3 *db, Btree **ppBtree, int flags, int vfsFlags ){ sqlite3_vfs *pVfs; BtShared *pBt = 0; Btree *p; int rc = SQLITE_OK; int nReserve; unsigned char zDbHeader[100]; 
#if !defined(SQLITE_OMIT_SHARED_CACHE) || !defined(SQLITE_OMIT_AUTOVACUUM) 
#ifdef SQLITE_OMIT_MEMORYDB 
 const int isMemdb = 0; 
#else 
 const int isMemdb = zFilename && !strcmp(zFilename, ":memory:"); 
#endif 
#endif 
 assert( db!=0 ); assert( sqlite3_mutex_held(db->mutex) ); pVfs = db->pVfs; p = sqlite3MallocZero(sizeof(Btree)); if( !p ){ return SQLITE_NOMEM; } p->inTrans = TRANS_NONE; p->db = db; 
#if !defined(SQLITE_OMIT_SHARED_CACHE) && !defined(SQLITE_OMIT_DISKIO) 
 if( isMemdb==0 && (db->flags & SQLITE_Vtab)==0 && zFilename && zFilename[0] ){ if( sqlite3GlobalConfig.sharedCacheEnabled ){ int nFullPathname = pVfs->mxPathname+1; char *zFullPathname = sqlite3Malloc(nFullPathname); sqlite3_mutex *mutexShared; p->sharable = 1; db->flags |= SQLITE_SharedCache; if( !zFullPathname ){ sqlite3_free(p); return SQLITE_NOMEM; } sqlite3OsFullPathname(pVfs, zFilename, nFullPathname, zFullPathname); mutexShared = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER); sqlite3_mutex_enter(mutexShared); for(pBt=GLOBAL(BtShared*,sqlite3SharedCacheList); pBt; pBt=pBt->pNext){ assert( pBt->nRef>0 ); if( 0==strcmp(zFullPathname, sqlite3PagerFilename(pBt->pPager)) && sqlite3PagerVfs(pBt->pPager)==pVfs ){ p->pBt = pBt; pBt->nRef++; break; } } sqlite3_mutex_leave(mutexShared); sqlite3_free(zFullPathname); } 
#ifdef SQLITE_DEBUG 
 else{ p->sharable = 1; } 
#endif 
 } 
#endif 
 if( pBt==0 ){ assert( sizeof(i64)==8 || sizeof(i64)==4 ); assert( sizeof(u64)==8 || sizeof(u64)==4 ); assert( sizeof(u32)==4 ); assert( sizeof(u16)==2 ); assert( sizeof(Pgno)==4 ); pBt = sqlite3MallocZero( sizeof(*pBt) ); if( pBt==0 ){ rc = SQLITE_NOMEM; goto btree_open_out; } rc = sqlite3PagerOpen(pVfs, &pBt->pPager, zFilename, EXTRA_SIZE, flags, vfsFlags); if( rc==SQLITE_OK ){ rc = sqlite3PagerReadFileheader(pBt->pPager,sizeof(zDbHeader),zDbHeader); } if( rc!=SQLITE_OK ){ goto btree_open_out; } sqlite3PagerSetBusyhandler(pBt->pPager, btreeInvokeBusyHandler, pBt); p->pBt = pBt; sqlite3PagerSetReiniter(pBt->pPager, pageReinit); pBt->pCursor = 0; pBt->pPage1 = 0; pBt->readOnly = sqlite3PagerIsreadonly(pBt->pPager); pBt->pageSize = get2byte(&zDbHeader[16]); if( pBt->pageSize<512 || pBt->pageSize>SQLITE_MAX_PAGE_SIZE || ((pBt->pageSize-1)&pBt->pageSize)!=0 ){ pBt->pageSize = 0; sqlite3PagerSetPagesize(pBt->pPager, &pBt->pageSize); 
#ifndef SQLITE_OMIT_AUTOVACUUM 
 if( zFilename && !isMemdb ){ pBt->autoVacuum = (SQLITE_DEFAULT_AUTOVACUUM ? 1 : 0); pBt->incrVacuum = (SQLITE_DEFAULT_AUTOVACUUM==2 ? 1 : 0); } 
#endif 
 nReserve = 0; }else{ nReserve = zDbHeader[20]; pBt->pageSizeFixed = 1; 
#ifndef SQLITE_OMIT_AUTOVACUUM 
 pBt->autoVacuum = (get4byte(&zDbHeader[36 + 4*4])?1:0); pBt->incrVacuum = (get4byte(&zDbHeader[36 + 7*4])?1:0); 
#endif 
 } pBt->usableSize = pBt->pageSize - nReserve; assert( (pBt->pageSize & 7)==0 ); sqlite3PagerSetPagesize(pBt->pPager, &pBt->pageSize); 
#if !defined(SQLITE_OMIT_SHARED_CACHE) && !defined(SQLITE_OMIT_DISKIO) 
 if( p->sharable ){ sqlite3_mutex *mutexShared; pBt->nRef = 1; mutexShared = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER); if( SQLITE_THREADSAFE && sqlite3GlobalConfig.bCoreMutex ){ pBt->mutex = sqlite3MutexAlloc(SQLITE_MUTEX_FAST); if( pBt->mutex==0 ){ rc = SQLITE_NOMEM; db->mallocFailed = 0; goto btree_open_out; } } sqlite3_mutex_enter(mutexShared); pBt->pNext = GLOBAL(BtShared*,sqlite3SharedCacheList); GLOBAL(BtShared*,sqlite3SharedCacheList) = pBt; sqlite3_mutex_leave(mutexShared); } 
#endif 
 } 
#if !defined(SQLITE_OMIT_SHARED_CACHE) && !defined(SQLITE_OMIT_DISKIO) 
 if( p->sharable ){ int i; Btree *pSib; for(i=0; i<db->nDb; i++){ if( (pSib = db->aDb[i].pBt)!=0 && pSib->sharable ){ while( pSib->pPrev ){ pSib = pSib->pPrev; } if( p->pBt<pSib->pBt ){ p->pNext = pSib; p->pPrev = 0; pSib->pPrev = p; }else{ while( pSib->pNext && pSib->pNext->pBt<p->pBt ){ pSib = pSib->pNext; } p->pNext = pSib->pNext; p->pPrev = pSib; if( p->pNext ){ p->pNext->pPrev = p; } pSib->pNext = p; } break; } } } 
#endif 
 *ppBtree = p; btree_open_out: if( rc!=SQLITE_OK ){ if( pBt && pBt->pPager ){ sqlite3PagerClose(pBt->pPager); } sqlite3_free(pBt); sqlite3_free(p); *ppBtree = 0; } return rc; } static int removeFromSharingList(BtShared *pBt){ 
#ifndef SQLITE_OMIT_SHARED_CACHE 
 sqlite3_mutex *pMaster; BtShared *pList; int removed = 0; assert( sqlite3_mutex_notheld(pBt->mutex) ); pMaster = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER); sqlite3_mutex_enter(pMaster); pBt->nRef--; if( pBt->nRef<=0 ){ if( GLOBAL(BtShared*,sqlite3SharedCacheList)==pBt ){ GLOBAL(BtShared*,sqlite3SharedCacheList) = pBt->pNext; }else{ pList = GLOBAL(BtShared*,sqlite3SharedCacheList); while( ALWAYS(pList) && pList->pNext!=pBt ){ pList=pList->pNext; } if( ALWAYS(pList) ){ pList->pNext = pBt->pNext; } } if( SQLITE_THREADSAFE ){ sqlite3_mutex_free(pBt->mutex); } removed = 1; } sqlite3_mutex_leave(pMaster); return removed; 
#else 
 return 1; 
#endif 
} static void allocateTempSpace(BtShared *pBt){ if( !pBt->pTmpSpace ){ pBt->pTmpSpace = sqlite3PageMalloc( pBt->pageSize ); } } static void freeTempSpace(BtShared *pBt){ sqlite3PageFree( pBt->pTmpSpace); pBt->pTmpSpace = 0; } SQLITE_PRIVATE int sqlite3BtreeClose(Btree *p){ BtShared *pBt = p->pBt; BtCursor *pCur; assert( sqlite3_mutex_held(p->db->mutex) ); sqlite3BtreeEnter(p); pBt->db = p->db; pCur = pBt->pCursor; while( pCur ){ BtCursor *pTmp = pCur; pCur = pCur->pNext; if( pTmp->pBtree==p ){ sqlite3BtreeCloseCursor(pTmp); } } sqlite3BtreeRollback(p); sqlite3BtreeLeave(p); assert( p->wantToLock==0 && p->locked==0 ); if( !p->sharable || removeFromSharingList(pBt) ){ assert( !pBt->pCursor ); sqlite3PagerClose(pBt->pPager); if( pBt->xFreeSchema && pBt->pSchema ){ pBt->xFreeSchema(pBt->pSchema); } sqlite3_free(pBt->pSchema); freeTempSpace(pBt); sqlite3_free(pBt); } 
#ifndef SQLITE_OMIT_SHARED_CACHE 
 assert( p->wantToLock==0 ); assert( p->locked==0 ); if( p->pPrev ) p->pPrev->pNext = p->pNext; if( p->pNext ) p->pNext->pPrev = p->pPrev; 
#endif 
 sqlite3_free(p); return SQLITE_OK; } SQLITE_PRIVATE int sqlite3BtreeSetCacheSize(Btree *p, int mxPage){ BtShared *pBt = p->pBt; assert( sqlite3_mutex_held(p->db->mutex) ); sqlite3BtreeEnter(p); sqlite3PagerSetCachesize(pBt->pPager, mxPage); sqlite3BtreeLeave(p); return SQLITE_OK; } 
#ifndef SQLITE_OMIT_PAGER_PRAGMAS 
SQLITE_PRIVATE int sqlite3BtreeSetSafetyLevel(Btree *p, int level, int fullSync){ BtShared *pBt = p->pBt; assert( sqlite3_mutex_held(p->db->mutex) ); sqlite3BtreeEnter(p); sqlite3PagerSetSafetyLevel(pBt->pPager, level, fullSync); sqlite3BtreeLeave(p); return SQLITE_OK; } 
#endif 
SQLITE_PRIVATE int sqlite3BtreeSyncDisabled(Btree *p){ BtShared *pBt = p->pBt; int rc; assert( sqlite3_mutex_held(p->db->mutex) ); sqlite3BtreeEnter(p); assert( pBt && pBt->pPager ); rc = sqlite3PagerNosync(pBt->pPager); sqlite3BtreeLeave(p); return rc; } 
#if !defined(SQLITE_OMIT_PAGER_PRAGMAS) || !defined(SQLITE_OMIT_VACUUM) 
SQLITE_PRIVATE int sqlite3BtreeSetPageSize(Btree *p, int pageSize, int nReserve){ int rc = SQLITE_OK; BtShared *pBt = p->pBt; sqlite3BtreeEnter(p); if( pBt->pageSizeFixed ){ sqlite3BtreeLeave(p); return SQLITE_READONLY; } if( nReserve<0 ){ nReserve = pBt->pageSize - pBt->usableSize; } if( pageSize>=512 && pageSize<=SQLITE_MAX_PAGE_SIZE && ((pageSize-1)&pageSize)==0 ){ assert( (pageSize & 7)==0 ); assert( !pBt->pPage1 && !pBt->pCursor ); pBt->pageSize = pageSize; freeTempSpace(pBt); rc = sqlite3PagerSetPagesize(pBt->pPager, &pBt->pageSize); } pBt->usableSize = pBt->pageSize - nReserve; sqlite3BtreeLeave(p); return rc; } SQLITE_PRIVATE int sqlite3BtreeGetPageSize(Btree *p){ return p->pBt->pageSize; } SQLITE_PRIVATE int sqlite3BtreeGetReserve(Btree *p){ int n; sqlite3BtreeEnter(p); n = p->pBt->pageSize - p->pBt->usableSize; sqlite3BtreeLeave(p); return n; } SQLITE_PRIVATE int sqlite3BtreeMaxPageCount(Btree *p, int mxPage){ int n; sqlite3BtreeEnter(p); n = sqlite3PagerMaxPageCount(p->pBt->pPager, mxPage); sqlite3BtreeLeave(p); return n; } 
#endif 
SQLITE_PRIVATE int sqlite3BtreeSetAutoVacuum(Btree *p, int autoVacuum){ 
#ifdef SQLITE_OMIT_AUTOVACUUM 
 return SQLITE_READONLY; 
#else 
 BtShared *pBt = p->pBt; int rc = SQLITE_OK; int av = (autoVacuum?1:0); sqlite3BtreeEnter(p); if( pBt->pageSizeFixed && av!=pBt->autoVacuum ){ rc = SQLITE_READONLY; }else{ pBt->autoVacuum = av; } sqlite3BtreeLeave(p); return rc; 
#endif 
} SQLITE_PRIVATE int sqlite3BtreeGetAutoVacuum(Btree *p){ 
#ifdef SQLITE_OMIT_AUTOVACUUM 
 return BTREE_AUTOVACUUM_NONE; 
#else 
 int rc; sqlite3BtreeEnter(p); rc = ( (!p->pBt->autoVacuum)?BTREE_AUTOVACUUM_NONE: (!p->pBt->incrVacuum)?BTREE_AUTOVACUUM_FULL: BTREE_AUTOVACUUM_INCR ); sqlite3BtreeLeave(p); return rc; 
#endif 
} static int lockBtree(BtShared *pBt){ int rc; MemPage *pPage1; int nPage; assert( sqlite3_mutex_held(pBt->mutex) ); if( pBt->pPage1 ) return SQLITE_OK; rc = sqlite3BtreeGetPage(pBt, 1, &pPage1, 0); if( rc!=SQLITE_OK ) return rc; rc = sqlite3PagerPagecount(pBt->pPager, &nPage); if( rc!=SQLITE_OK ){ goto page1_init_failed; }else if( nPage>0 ){ int pageSize; int usableSize; u8 *page1 = pPage1->aData; rc = SQLITE_NOTADB; if( memcmp(page1, zMagicHeader, 16)!=0 ){ goto page1_init_failed; } if( page1[18]>1 ){ pBt->readOnly = 1; } if( page1[19]>1 ){ goto page1_init_failed; } if( memcmp(&page1[21], "\100\040\040",3)!=0 ){ goto page1_init_failed; } pageSize = get2byte(&page1[16]); if( ((pageSize-1)&pageSize)!=0 || pageSize<512 || (SQLITE_MAX_PAGE_SIZE<32768 && pageSize>SQLITE_MAX_PAGE_SIZE) ){ goto page1_init_failed; } assert( (pageSize & 7)==0 ); usableSize = pageSize - page1[20]; if( pageSize!=pBt->pageSize ){ releasePage(pPage1); pBt->usableSize = usableSize; pBt->pageSize = pageSize; freeTempSpace(pBt); sqlite3PagerSetPagesize(pBt->pPager, &pBt->pageSize); return SQLITE_OK; } if( usableSize<500 ){ goto page1_init_failed; } pBt->pageSize = pageSize; pBt->usableSize = usableSize; 
#ifndef SQLITE_OMIT_AUTOVACUUM 
 pBt->autoVacuum = (get4byte(&page1[36 + 4*4])?1:0); pBt->incrVacuum = (get4byte(&page1[36 + 7*4])?1:0); 
#endif 
 } pBt->maxLocal = (pBt->usableSize-12)*64/255 - 23; pBt->minLocal = (pBt->usableSize-12)*32/255 - 23; pBt->maxLeaf = pBt->usableSize - 35; pBt->minLeaf = (pBt->usableSize-12)*32/255 - 23; assert( pBt->maxLeaf + 23 <= MX_CELL_SIZE(pBt) ); pBt->pPage1 = pPage1; return SQLITE_OK; page1_init_failed: releasePage(pPage1); pBt->pPage1 = 0; return rc; } static int lockBtreeWithRetry(Btree *pRef){ int rc = SQLITE_OK; assert( sqlite3BtreeHoldsMutex(pRef) ); if( pRef->inTrans==TRANS_NONE ){ u8 inTransaction = pRef->pBt->inTransaction; btreeIntegrity(pRef); rc = sqlite3BtreeBeginTrans(pRef, 0); pRef->pBt->inTransaction = inTransaction; pRef->inTrans = TRANS_NONE; if( rc==SQLITE_OK ){ pRef->pBt->nTransaction--; } btreeIntegrity(pRef); } return rc; } static void unlockBtreeIfUnused(BtShared *pBt){ assert( sqlite3_mutex_held(pBt->mutex) ); if( pBt->inTransaction==TRANS_NONE && pBt->pCursor==0 && pBt->pPage1!=0 ){ if( sqlite3PagerRefcount(pBt->pPager)>=1 ){ assert( pBt->pPage1->aData ); 
#if 0 
 if( pBt->pPage1->aData==0 ){ MemPage *pPage = pBt->pPage1; pPage->aData = sqlite3PagerGetData(pPage->pDbPage); pPage->pBt = pBt; pPage->pgno = 1; } 
#endif 
 releasePage(pBt->pPage1); } pBt->pPage1 = 0; pBt->inStmt = 0; } } static int newDatabase(BtShared *pBt){ MemPage *pP1; unsigned char *data; int rc; int nPage; assert( sqlite3_mutex_held(pBt->mutex) ); rc = sqlite3PagerPagecount(pBt->pPager, &nPage); if( rc!=SQLITE_OK || nPage>0 ){ return rc; } pP1 = pBt->pPage1; assert( pP1!=0 ); data = pP1->aData; rc = sqlite3PagerWrite(pP1->pDbPage); if( rc ) return rc; memcpy(data, zMagicHeader, sizeof(zMagicHeader)); assert( sizeof(zMagicHeader)==16 ); put2byte(&data[16], pBt->pageSize); data[18] = 1; data[19] = 1; data[20] = pBt->pageSize - pBt->usableSize; data[21] = 64; data[22] = 32; data[23] = 32; memset(&data[24], 0, 100-24); zeroPage(pP1, PTF_INTKEY|PTF_LEAF|PTF_LEAFDATA ); pBt->pageSizeFixed = 1; 
#ifndef SQLITE_OMIT_AUTOVACUUM 
 assert( pBt->autoVacuum==1 || pBt->autoVacuum==0 ); assert( pBt->incrVacuum==1 || pBt->incrVacuum==0 ); put4byte(&data[36 + 4*4], pBt->autoVacuum); put4byte(&data[36 + 7*4], pBt->incrVacuum); 
#endif 
 return SQLITE_OK; } SQLITE_PRIVATE int sqlite3BtreeBeginTrans(Btree *p, int wrflag){ BtShared *pBt = p->pBt; int rc = SQLITE_OK; sqlite3BtreeEnter(p); pBt->db = p->db; btreeIntegrity(p); if( p->inTrans==TRANS_WRITE || (p->inTrans==TRANS_READ && !wrflag) ){ goto trans_begun; } if( pBt->readOnly && wrflag ){ rc = SQLITE_READONLY; goto trans_begun; } if( pBt->inTransaction==TRANS_WRITE && wrflag ){ rc = SQLITE_BUSY; goto trans_begun; } 
#ifndef SQLITE_OMIT_SHARED_CACHE 
 if( wrflag>1 ){ BtLock *pIter; for(pIter=pBt->pLock; pIter; pIter=pIter->pNext){ if( pIter->pBtree!=p ){ rc = SQLITE_BUSY; goto trans_begun; } } } 
#endif 
 do { if( pBt->pPage1==0 ){ do{ rc = lockBtree(pBt); }while( pBt->pPage1==0 && rc==SQLITE_OK ); } if( rc==SQLITE_OK && wrflag ){ if( pBt->readOnly ){ rc = SQLITE_READONLY; }else{ rc = sqlite3PagerBegin(pBt->pPage1->pDbPage, wrflag>1); if( rc==SQLITE_OK ){ rc = newDatabase(pBt); } } } if( rc==SQLITE_OK ){ if( wrflag ) pBt->inStmt = 0; }else{ unlockBtreeIfUnused(pBt); } }while( rc==SQLITE_BUSY && pBt->inTransaction==TRANS_NONE && btreeInvokeBusyHandler(pBt) ); if( rc==SQLITE_OK ){ if( p->inTrans==TRANS_NONE ){ pBt->nTransaction++; } p->inTrans = (wrflag?TRANS_WRITE:TRANS_READ); if( p->inTrans>pBt->inTransaction ){ pBt->inTransaction = p->inTrans; } 
#ifndef SQLITE_OMIT_SHARED_CACHE 
 if( wrflag>1 ){ assert( !pBt->pExclusive ); pBt->pExclusive = p; } 
#endif 
 } trans_begun: btreeIntegrity(p); sqlite3BtreeLeave(p); return rc; } 
#ifndef SQLITE_OMIT_AUTOVACUUM 
static int setChildPtrmaps(MemPage *pPage){ int i; int nCell; int rc; BtShared *pBt = pPage->pBt; int isInitOrig = pPage->isInit; Pgno pgno = pPage->pgno; assert( sqlite3_mutex_held(pPage->pBt->mutex) ); rc = sqlite3BtreeInitPage(pPage); if( rc!=SQLITE_OK ){ goto set_child_ptrmaps_out; } nCell = pPage->nCell; for(i=0; i<nCell; i++){ u8 *pCell = findCell(pPage, i); rc = ptrmapPutOvflPtr(pPage, pCell); if( rc!=SQLITE_OK ){ goto set_child_ptrmaps_out; } if( !pPage->leaf ){ Pgno childPgno = get4byte(pCell); rc = ptrmapPut(pBt, childPgno, PTRMAP_BTREE, pgno); if( rc!=SQLITE_OK ) goto set_child_ptrmaps_out; } } if( !pPage->leaf ){ Pgno childPgno = get4byte(&pPage->aData[pPage->hdrOffset+8]); rc = ptrmapPut(pBt, childPgno, PTRMAP_BTREE, pgno); } set_child_ptrmaps_out: pPage->isInit = isInitOrig; return rc; } static int modifyPagePointer(MemPage *pPage, Pgno iFrom, Pgno iTo, u8 eType){ assert( sqlite3_mutex_held(pPage->pBt->mutex) ); if( eType==PTRMAP_OVERFLOW2 ){ if( get4byte(pPage->aData)!=iFrom ){ return SQLITE_CORRUPT_BKPT; } put4byte(pPage->aData, iTo); }else{ int isInitOrig = pPage->isInit; int i; int nCell; sqlite3BtreeInitPage(pPage); nCell = pPage->nCell; for(i=0; i<nCell; i++){ u8 *pCell = findCell(pPage, i); if( eType==PTRMAP_OVERFLOW1 ){ CellInfo info; sqlite3BtreeParseCellPtr(pPage, pCell, &info); if( info.iOverflow ){ if( iFrom==get4byte(&pCell[info.iOverflow]) ){ put4byte(&pCell[info.iOverflow], iTo); break; } } }else{ if( get4byte(pCell)==iFrom ){ put4byte(pCell, iTo); break; } } } if( i==nCell ){ if( eType!=PTRMAP_BTREE || get4byte(&pPage->aData[pPage->hdrOffset+8])!=iFrom ){ return SQLITE_CORRUPT_BKPT; } put4byte(&pPage->aData[pPage->hdrOffset+8], iTo); } pPage->isInit = isInitOrig; } return SQLITE_OK; } static int relocatePage( BtShared *pBt, MemPage *pDbPage, u8 eType, Pgno iPtrPage, Pgno iFreePage, int isCommit ){ MemPage *pPtrPage; Pgno iDbPage = pDbPage->pgno; Pager *pPager = pBt->pPager; int rc; assert( eType==PTRMAP_OVERFLOW2 || eType==PTRMAP_OVERFLOW1 || eType==PTRMAP_BTREE || eType==PTRMAP_ROOTPAGE ); assert( sqlite3_mutex_held(pBt->mutex) ); assert( pDbPage->pBt==pBt ); TRACE(("AUTOVACUUM: Moving %d to free page %d (ptr page %d type %d)\n", iDbPage, iFreePage, iPtrPage, eType)); rc = sqlite3PagerMovepage(pPager, pDbPage->pDbPage, iFreePage, isCommit); if( rc!=SQLITE_OK ){ return rc; } pDbPage->pgno = iFreePage; if( eType==PTRMAP_BTREE || eType==PTRMAP_ROOTPAGE ){ rc = setChildPtrmaps(pDbPage); if( rc!=SQLITE_OK ){ return rc; } }else{ Pgno nextOvfl = get4byte(pDbPage->aData); if( nextOvfl!=0 ){ rc = ptrmapPut(pBt, nextOvfl, PTRMAP_OVERFLOW2, iFreePage); if( rc!=SQLITE_OK ){ return rc; } } } if( eType!=PTRMAP_ROOTPAGE ){ rc = sqlite3BtreeGetPage(pBt, iPtrPage, &pPtrPage, 0); if( rc!=SQLITE_OK ){ return rc; } rc = sqlite3PagerWrite(pPtrPage->pDbPage); if( rc!=SQLITE_OK ){ releasePage(pPtrPage); return rc; } rc = modifyPagePointer(pPtrPage, iDbPage, iFreePage, eType); releasePage(pPtrPage); if( rc==SQLITE_OK ){ rc = ptrmapPut(pBt, iFreePage, eType, iPtrPage); } } return rc; } static int allocateBtreePage(BtShared *, MemPage **, Pgno *, Pgno, u8); static int incrVacuumStep(BtShared *pBt, Pgno nFin){ Pgno iLastPg; Pgno nFreeList; assert( sqlite3_mutex_held(pBt->mutex) ); iLastPg = pBt->nTrunc; if( iLastPg==0 ){ iLastPg = pagerPagecount(pBt); } if( !PTRMAP_ISPAGE(pBt, iLastPg) && iLastPg!=PENDING_BYTE_PAGE(pBt) ){ int rc; u8 eType; Pgno iPtrPage; nFreeList = get4byte(&pBt->pPage1->aData[36]); if( nFreeList==0 || nFin==iLastPg ){ return SQLITE_DONE; } rc = ptrmapGet(pBt, iLastPg, &eType, &iPtrPage); if( rc!=SQLITE_OK ){ return rc; } if( eType==PTRMAP_ROOTPAGE ){ return SQLITE_CORRUPT_BKPT; } if( eType==PTRMAP_FREEPAGE ){ if( nFin==0 ){ Pgno iFreePg; MemPage *pFreePg; rc = allocateBtreePage(pBt, &pFreePg, &iFreePg, iLastPg, 1); if( rc!=SQLITE_OK ){ return rc; } assert( iFreePg==iLastPg ); releasePage(pFreePg); } } else { Pgno iFreePg; MemPage *pLastPg; rc = sqlite3BtreeGetPage(pBt, iLastPg, &pLastPg, 0); if( rc!=SQLITE_OK ){ return rc; } do { MemPage *pFreePg; rc = allocateBtreePage(pBt, &pFreePg, &iFreePg, 0, 0); if( rc!=SQLITE_OK ){ releasePage(pLastPg); return rc; } releasePage(pFreePg); }while( nFin!=0 && iFreePg>nFin ); assert( iFreePg<iLastPg ); rc = sqlite3PagerWrite(pLastPg->pDbPage); if( rc==SQLITE_OK ){ rc = relocatePage(pBt, pLastPg, eType, iPtrPage, iFreePg, nFin!=0); } releasePage(pLastPg); if( rc!=SQLITE_OK ){ return rc; } } } pBt->nTrunc = iLastPg - 1; while( pBt->nTrunc==PENDING_BYTE_PAGE(pBt)||PTRMAP_ISPAGE(pBt, pBt->nTrunc) ){ pBt->nTrunc--; } return SQLITE_OK; } SQLITE_PRIVATE int sqlite3BtreeIncrVacuum(Btree *p){ int rc; BtShared *pBt = p->pBt; sqlite3BtreeEnter(p); pBt->db = p->db; assert( pBt->inTransaction==TRANS_WRITE && p->inTrans==TRANS_WRITE ); if( !pBt->autoVacuum ){ rc = SQLITE_DONE; }else{ invalidateAllOverflowCache(pBt); rc = incrVacuumStep(pBt, 0); } sqlite3BtreeLeave(p); return rc; } static int autoVacuumCommit(BtShared *pBt, Pgno *pnTrunc){ int rc = SQLITE_OK; Pager *pPager = pBt->pPager; VVA_ONLY( int nRef = sqlite3PagerRefcount(pPager) ); assert( sqlite3_mutex_held(pBt->mutex) ); invalidateAllOverflowCache(pBt); assert(pBt->autoVacuum); if( !pBt->incrVacuum ){ Pgno nFin = 0; if( pBt->nTrunc==0 ){ Pgno nFree; Pgno nPtrmap; const int pgsz = pBt->pageSize; Pgno nOrig = pagerPagecount(pBt); if( PTRMAP_ISPAGE(pBt, nOrig) ){ return SQLITE_CORRUPT_BKPT; } if( nOrig==PENDING_BYTE_PAGE(pBt) ){ nOrig--; } nFree = get4byte(&pBt->pPage1->aData[36]); nPtrmap = (nFree-nOrig+PTRMAP_PAGENO(pBt, nOrig)+pgsz/5)/(pgsz/5); nFin = nOrig - nFree - nPtrmap; if( nOrig>PENDING_BYTE_PAGE(pBt) && nFin<=PENDING_BYTE_PAGE(pBt) ){ nFin--; } while( PTRMAP_ISPAGE(pBt, nFin) || nFin==PENDING_BYTE_PAGE(pBt) ){ nFin--; } } while( rc==SQLITE_OK ){ rc = incrVacuumStep(pBt, nFin); } if( rc==SQLITE_DONE ){ assert(nFin==0 || pBt->nTrunc==0 || nFin<=pBt->nTrunc); rc = SQLITE_OK; if( pBt->nTrunc && nFin ){ rc = sqlite3PagerWrite(pBt->pPage1->pDbPage); put4byte(&pBt->pPage1->aData[32], 0); put4byte(&pBt->pPage1->aData[36], 0); pBt->nTrunc = nFin; } } if( rc!=SQLITE_OK ){ sqlite3PagerRollback(pPager); } } if( rc==SQLITE_OK ){ *pnTrunc = pBt->nTrunc; pBt->nTrunc = 0; } assert( nRef==sqlite3PagerRefcount(pPager) ); return rc; } 
#endif 
SQLITE_PRIVATE int sqlite3BtreeCommitPhaseOne(Btree *p, const char *zMaster){ int rc = SQLITE_OK; if( p->inTrans==TRANS_WRITE ){ BtShared *pBt = p->pBt; Pgno nTrunc = 0; sqlite3BtreeEnter(p); pBt->db = p->db; 
#ifndef SQLITE_OMIT_AUTOVACUUM 
 if( pBt->autoVacuum ){ rc = autoVacuumCommit(pBt, &nTrunc); if( rc!=SQLITE_OK ){ sqlite3BtreeLeave(p); return rc; } } 
#endif 
 rc = sqlite3PagerCommitPhaseOne(pBt->pPager, zMaster, nTrunc, 0); sqlite3BtreeLeave(p); } return rc; } SQLITE_PRIVATE int sqlite3BtreeCommitPhaseTwo(Btree *p){ BtShared *pBt = p->pBt; sqlite3BtreeEnter(p); pBt->db = p->db; btreeIntegrity(p); if( p->inTrans==TRANS_WRITE ){ int rc; assert( pBt->inTransaction==TRANS_WRITE ); assert( pBt->nTransaction>0 ); rc = sqlite3PagerCommitPhaseTwo(pBt->pPager); if( rc!=SQLITE_OK ){ sqlite3BtreeLeave(p); return rc; } pBt->inTransaction = TRANS_READ; pBt->inStmt = 0; } unlockAllTables(p); if( p->inTrans!=TRANS_NONE ){ pBt->nTransaction--; if( 0==pBt->nTransaction ){ pBt->inTransaction = TRANS_NONE; } } p->inTrans = TRANS_NONE; unlockBtreeIfUnused(pBt); btreeIntegrity(p); sqlite3BtreeLeave(p); return SQLITE_OK; } SQLITE_PRIVATE int sqlite3BtreeCommit(Btree *p){ int rc; sqlite3BtreeEnter(p); rc = sqlite3BtreeCommitPhaseOne(p, 0); if( rc==SQLITE_OK ){ rc = sqlite3BtreeCommitPhaseTwo(p); } sqlite3BtreeLeave(p); return rc; } 
#ifndef NDEBUG 
static int countWriteCursors(BtShared *pBt){ BtCursor *pCur; int r = 0; for(pCur=pBt->pCursor; pCur; pCur=pCur->pNext){ if( pCur->wrFlag && pCur->eState!=CURSOR_FAULT ) r++; } return r; } 
#endif 
SQLITE_PRIVATE void sqlite3BtreeTripAllCursors(Btree *pBtree, int errCode){ BtCursor *p; sqlite3BtreeEnter(pBtree); for(p=pBtree->pBt->pCursor; p; p=p->pNext){ int i; sqlite3BtreeClearCursor(p); p->eState = CURSOR_FAULT; p->skip = errCode; for(i=0; i<=p->iPage; i++){ releasePage(p->apPage[i]); p->apPage[i] = 0; } } sqlite3BtreeLeave(pBtree); } SQLITE_PRIVATE int sqlite3BtreeRollback(Btree *p){ int rc; BtShared *pBt = p->pBt; MemPage *pPage1; sqlite3BtreeEnter(p); pBt->db = p->db; rc = saveAllCursors(pBt, 0, 0); 
#ifndef SQLITE_OMIT_SHARED_CACHE 
 if( rc!=SQLITE_OK ){ sqlite3BtreeTripAllCursors(p, rc); } 
#endif 
 btreeIntegrity(p); unlockAllTables(p); if( p->inTrans==TRANS_WRITE ){ int rc2; 
#ifndef SQLITE_OMIT_AUTOVACUUM 
 pBt->nTrunc = 0; 
#endif 
 assert( TRANS_WRITE==pBt->inTransaction ); rc2 = sqlite3PagerRollback(pBt->pPager); if( rc2!=SQLITE_OK ){ rc = rc2; } if( sqlite3BtreeGetPage(pBt, 1, &pPage1, 0)==SQLITE_OK ){ releasePage(pPage1); } assert( countWriteCursors(pBt)==0 ); pBt->inTransaction = TRANS_READ; } if( p->inTrans!=TRANS_NONE ){ assert( pBt->nTransaction>0 ); pBt->nTransaction--; if( 0==pBt->nTransaction ){ pBt->inTransaction = TRANS_NONE; } } p->inTrans = TRANS_NONE; pBt->inStmt = 0; unlockBtreeIfUnused(pBt); btreeIntegrity(p); sqlite3BtreeLeave(p); return rc; } SQLITE_PRIVATE int sqlite3BtreeBeginStmt(Btree *p){ int rc; BtShared *pBt = p->pBt; sqlite3BtreeEnter(p); pBt->db = p->db; if( (p->inTrans!=TRANS_WRITE) || pBt->inStmt ){ rc = pBt->readOnly ? SQLITE_READONLY : SQLITE_ERROR; }else{ assert( pBt->inTransaction==TRANS_WRITE ); rc = pBt->readOnly ? SQLITE_OK : sqlite3PagerStmtBegin(pBt->pPager); pBt->inStmt = 1; } sqlite3BtreeLeave(p); return rc; } SQLITE_PRIVATE int sqlite3BtreeCommitStmt(Btree *p){ int rc; BtShared *pBt = p->pBt; sqlite3BtreeEnter(p); pBt->db = p->db; if( pBt->inStmt && !pBt->readOnly ){ rc = sqlite3PagerStmtCommit(pBt->pPager); }else{ rc = SQLITE_OK; } pBt->inStmt = 0; sqlite3BtreeLeave(p); return rc; } SQLITE_PRIVATE int sqlite3BtreeRollbackStmt(Btree *p){ int rc = SQLITE_OK; BtShared *pBt = p->pBt; sqlite3BtreeEnter(p); pBt->db = p->db; if( pBt->inStmt && !pBt->readOnly ){ rc = sqlite3PagerStmtRollback(pBt->pPager); pBt->inStmt = 0; } sqlite3BtreeLeave(p); return rc; } static int btreeCursor( Btree *p, int iTable, int wrFlag, struct KeyInfo *pKeyInfo, BtCursor *pCur ){ int rc; Pgno nPage; BtShared *pBt = p->pBt; assert( sqlite3BtreeHoldsMutex(p) ); if( wrFlag ){ if( pBt->readOnly ){ return SQLITE_READONLY; } if( checkReadLocks(p, iTable, 0, 0) ){ return SQLITE_LOCKED; } } if( pBt->pPage1==0 ){ rc = lockBtreeWithRetry(p); if( rc!=SQLITE_OK ){ return rc; } if( pBt->readOnly && wrFlag ){ return SQLITE_READONLY; } } pCur->pgnoRoot = (Pgno)iTable; rc = sqlite3PagerPagecount(pBt->pPager, (int *)&nPage); if( rc!=SQLITE_OK ){ return rc; } if( iTable==1 && nPage==0 ){ rc = SQLITE_EMPTY; goto create_cursor_exception; } rc = getAndInitPage(pBt, pCur->pgnoRoot, &pCur->apPage[0]); if( rc!=SQLITE_OK ){ goto create_cursor_exception; } pCur->pKeyInfo = pKeyInfo; pCur->pBtree = p; pCur->pBt = pBt; pCur->wrFlag = wrFlag; pCur->pNext = pBt->pCursor; if( pCur->pNext ){ pCur->pNext->pPrev = pCur; } pBt->pCursor = pCur; pCur->eState = CURSOR_INVALID; return SQLITE_OK; create_cursor_exception: releasePage(pCur->apPage[0]); unlockBtreeIfUnused(pBt); return rc; } SQLITE_PRIVATE int sqlite3BtreeCursor( Btree *p, int iTable, int wrFlag, struct KeyInfo *pKeyInfo, BtCursor *pCur ){ int rc; sqlite3BtreeEnter(p); p->pBt->db = p->db; rc = btreeCursor(p, iTable, wrFlag, pKeyInfo, pCur); sqlite3BtreeLeave(p); return rc; } SQLITE_PRIVATE int sqlite3BtreeCursorSize(){ return sizeof(BtCursor); } SQLITE_PRIVATE int sqlite3BtreeCloseCursor(BtCursor *pCur){ Btree *pBtree = pCur->pBtree; if( pBtree ){ int i; BtShared *pBt = pCur->pBt; sqlite3BtreeEnter(pBtree); pBt->db = pBtree->db; sqlite3BtreeClearCursor(pCur); if( pCur->pPrev ){ pCur->pPrev->pNext = pCur->pNext; }else{ pBt->pCursor = pCur->pNext; } if( pCur->pNext ){ pCur->pNext->pPrev = pCur->pPrev; } for(i=0; i<=pCur->iPage; i++){ releasePage(pCur->apPage[i]); } unlockBtreeIfUnused(pBt); invalidateOverflowCache(pCur); sqlite3BtreeLeave(pBtree); } return SQLITE_OK; } SQLITE_PRIVATE void sqlite3BtreeGetTempCursor(BtCursor *pCur, BtCursor *pTempCur){ int i; assert( cursorHoldsMutex(pCur) ); memcpy(pTempCur, pCur, sizeof(BtCursor)); pTempCur->pNext = 0; pTempCur->pPrev = 0; for(i=0; i<=pTempCur->iPage; i++){ sqlite3PagerRef(pTempCur->apPage[i]->pDbPage); } assert( pTempCur->pKey==0 ); } SQLITE_PRIVATE void sqlite3BtreeReleaseTempCursor(BtCursor *pCur){ int i; assert( cursorHoldsMutex(pCur) ); for(i=0; i<=pCur->iPage; i++){ sqlite3PagerUnref(pCur->apPage[i]->pDbPage); } sqlite3_free(pCur->pKey); } 
#ifndef NDEBUG 
 static void assertCellInfo(BtCursor *pCur){ CellInfo info; int iPage = pCur->iPage; memset(&info, 0, sizeof(info)); sqlite3BtreeParseCell(pCur->apPage[iPage], pCur->aiIdx[iPage], &info); assert( memcmp(&info, &pCur->info, sizeof(info))==0 ); } 
#else 
#define assertCellInfo(x) 
#endif 
#ifdef _MSC_VER 
 static void getCellInfo(BtCursor *pCur){ if( pCur->info.nSize==0 ){ int iPage = pCur->iPage; sqlite3BtreeParseCell(pCur->apPage[iPage],pCur->aiIdx[iPage],&pCur->info); pCur->validNKey = 1; }else{ assertCellInfo(pCur); } } 
#else 
 
#define getCellInfo(pCur) if( pCur->info.nSize==0 ){ int iPage = pCur->iPage; sqlite3BtreeParseCell(pCur->apPage[iPage],pCur->aiIdx[iPage],&pCur->info); pCur->validNKey = 1; }else{ assertCellInfo(pCur); } 
#endif 
SQLITE_PRIVATE int sqlite3BtreeKeySize(BtCursor *pCur, i64 *pSize){ int rc; assert( cursorHoldsMutex(pCur) ); rc = restoreCursorPosition(pCur); if( rc==SQLITE_OK ){ assert( pCur->eState==CURSOR_INVALID || pCur->eState==CURSOR_VALID ); if( pCur->eState==CURSOR_INVALID ){ *pSize = 0; }else{ getCellInfo(pCur); *pSize = pCur->info.nKey; } } return rc; } SQLITE_PRIVATE int sqlite3BtreeDataSize(BtCursor *pCur, u32 *pSize){ int rc; assert( cursorHoldsMutex(pCur) ); rc = restoreCursorPosition(pCur); if( rc==SQLITE_OK ){ assert( pCur->eState==CURSOR_INVALID || pCur->eState==CURSOR_VALID ); if( pCur->eState==CURSOR_INVALID ){ *pSize = 0; }else{ getCellInfo(pCur); *pSize = pCur->info.nData; } } return rc; } static int getOverflowPage( BtShared *pBt, Pgno ovfl, MemPage **ppPage, Pgno *pPgnoNext ){ Pgno next = 0; int rc; assert( sqlite3_mutex_held(pBt->mutex) ); assert(ppPage || pPgnoNext); if( !pPgnoNext ){ return sqlite3BtreeGetPage(pBt, ovfl, ppPage, 1); } 
#ifndef SQLITE_OMIT_AUTOVACUUM 
 if( pBt->autoVacuum ){ Pgno pgno; Pgno iGuess = ovfl+1; u8 eType; while( PTRMAP_ISPAGE(pBt, iGuess) || iGuess==PENDING_BYTE_PAGE(pBt) ){ iGuess++; } if( iGuess<=pagerPagecount(pBt) ){ rc = ptrmapGet(pBt, iGuess, &eType, &pgno); if( rc!=SQLITE_OK ){ return rc; } if( eType==PTRMAP_OVERFLOW2 && pgno==ovfl ){ next = iGuess; } } } 
#endif 
 if( next==0 || ppPage ){ MemPage *pPage = 0; rc = sqlite3BtreeGetPage(pBt, ovfl, &pPage, next!=0); assert(rc==SQLITE_OK || pPage==0); if( next==0 && rc==SQLITE_OK ){ next = get4byte(pPage->aData); } if( ppPage ){ *ppPage = pPage; }else{ releasePage(pPage); } } *pPgnoNext = next; return rc; } static int copyPayload( void *pPayload, void *pBuf, int nByte, int eOp, DbPage *pDbPage ){ if( eOp ){ int rc = sqlite3PagerWrite(pDbPage); if( rc!=SQLITE_OK ){ return rc; } memcpy(pPayload, pBuf, nByte); }else{ memcpy(pBuf, pPayload, nByte); } return SQLITE_OK; } static int accessPayload( BtCursor *pCur, u32 offset, u32 amt, unsigned char *pBuf, int skipKey, int eOp ){ unsigned char *aPayload; int rc = SQLITE_OK; u32 nKey; int iIdx = 0; MemPage *pPage = pCur->apPage[pCur->iPage]; BtShared *pBt = pCur->pBt; assert( pPage ); assert( pCur->eState==CURSOR_VALID ); assert( pCur->aiIdx[pCur->iPage]<pPage->nCell ); assert( cursorHoldsMutex(pCur) ); getCellInfo(pCur); aPayload = pCur->info.pCell + pCur->info.nHeader; nKey = (pPage->intKey ? 0 : pCur->info.nKey); if( skipKey ){ offset += nKey; } if( offset+amt > nKey+pCur->info.nData || &aPayload[pCur->info.nLocal] > &pPage->aData[pBt->usableSize] ){ return SQLITE_CORRUPT_BKPT; } if( offset<pCur->info.nLocal ){ int a = amt; if( a+offset>pCur->info.nLocal ){ a = pCur->info.nLocal - offset; } rc = copyPayload(&aPayload[offset], pBuf, a, eOp, pPage->pDbPage); offset = 0; pBuf += a; amt -= a; }else{ offset -= pCur->info.nLocal; } if( rc==SQLITE_OK && amt>0 ){ const u32 ovflSize = pBt->usableSize - 4; Pgno nextPage; nextPage = get4byte(&aPayload[pCur->info.nLocal]); 
#ifndef SQLITE_OMIT_INCRBLOB 
 if( pCur->isIncrblobHandle && !pCur->aOverflow ){ int nOvfl = (pCur->info.nPayload-pCur->info.nLocal+ovflSize-1)/ovflSize; pCur->aOverflow = (Pgno *)sqlite3MallocZero(sizeof(Pgno)*nOvfl); if( nOvfl && !pCur->aOverflow ){ rc = SQLITE_NOMEM; } } if( pCur->aOverflow && pCur->aOverflow[offset/ovflSize] ){ iIdx = (offset/ovflSize); nextPage = pCur->aOverflow[iIdx]; offset = (offset%ovflSize); } 
#endif 
 for( ; rc==SQLITE_OK && amt>0 && nextPage; iIdx++){ 
#ifndef SQLITE_OMIT_INCRBLOB 
 if( pCur->aOverflow ){ assert(!pCur->aOverflow[iIdx] || pCur->aOverflow[iIdx]==nextPage); pCur->aOverflow[iIdx] = nextPage; } 
#endif 
 if( offset>=ovflSize ){ 
#ifndef SQLITE_OMIT_INCRBLOB 
 if( pCur->aOverflow && pCur->aOverflow[iIdx+1] ){ nextPage = pCur->aOverflow[iIdx+1]; } else 
#endif 
 rc = getOverflowPage(pBt, nextPage, 0, &nextPage); offset -= ovflSize; }else{ DbPage *pDbPage; int a = amt; rc = sqlite3PagerGet(pBt->pPager, nextPage, &pDbPage); if( rc==SQLITE_OK ){ aPayload = sqlite3PagerGetData(pDbPage); nextPage = get4byte(aPayload); if( a + offset > ovflSize ){ a = ovflSize - offset; } rc = copyPayload(&aPayload[offset+4], pBuf, a, eOp, pDbPage); sqlite3PagerUnref(pDbPage); offset = 0; amt -= a; pBuf += a; } } } } if( rc==SQLITE_OK && amt>0 ){ return SQLITE_CORRUPT_BKPT; } return rc; } SQLITE_PRIVATE int sqlite3BtreeKey(BtCursor *pCur, u32 offset, u32 amt, void *pBuf){ int rc; assert( cursorHoldsMutex(pCur) ); rc = restoreCursorPosition(pCur); if( rc==SQLITE_OK ){ assert( pCur->eState==CURSOR_VALID ); assert( pCur->iPage>=0 && pCur->apPage[pCur->iPage] ); if( pCur->apPage[0]->intKey ){ return SQLITE_CORRUPT_BKPT; } assert( pCur->aiIdx[pCur->iPage]<pCur->apPage[pCur->iPage]->nCell ); rc = accessPayload(pCur, offset, amt, (unsigned char*)pBuf, 0, 0); } return rc; } SQLITE_PRIVATE int sqlite3BtreeData(BtCursor *pCur, u32 offset, u32 amt, void *pBuf){ int rc; 
#ifndef SQLITE_OMIT_INCRBLOB 
 if ( pCur->eState==CURSOR_INVALID ){ return SQLITE_ABORT; } 
#endif 
 assert( cursorHoldsMutex(pCur) ); rc = restoreCursorPosition(pCur); if( rc==SQLITE_OK ){ assert( pCur->eState==CURSOR_VALID ); assert( pCur->iPage>=0 && pCur->apPage[pCur->iPage] ); assert( pCur->aiIdx[pCur->iPage]<pCur->apPage[pCur->iPage]->nCell ); rc = accessPayload(pCur, offset, amt, pBuf, 1, 0); } return rc; } static const unsigned char *fetchPayload( BtCursor *pCur, int *pAmt, int skipKey ){ unsigned char *aPayload; MemPage *pPage; u32 nKey; u32 nLocal; assert( pCur!=0 && pCur->iPage>=0 && pCur->apPage[pCur->iPage]); assert( pCur->eState==CURSOR_VALID ); assert( cursorHoldsMutex(pCur) ); pPage = pCur->apPage[pCur->iPage]; assert( pCur->aiIdx[pCur->iPage]<pPage->nCell ); getCellInfo(pCur); aPayload = pCur->info.pCell; aPayload += pCur->info.nHeader; if( pPage->intKey ){ nKey = 0; }else{ nKey = pCur->info.nKey; } if( skipKey ){ aPayload += nKey; nLocal = pCur->info.nLocal - nKey; }else{ nLocal = pCur->info.nLocal; if( nLocal>nKey ){ nLocal = nKey; } } *pAmt = nLocal; return aPayload; } SQLITE_PRIVATE const void *sqlite3BtreeKeyFetch(BtCursor *pCur, int *pAmt){ assert( cursorHoldsMutex(pCur) ); if( pCur->eState==CURSOR_VALID ){ return (const void*)fetchPayload(pCur, pAmt, 0); } return 0; } SQLITE_PRIVATE const void *sqlite3BtreeDataFetch(BtCursor *pCur, int *pAmt){ assert( cursorHoldsMutex(pCur) ); if( pCur->eState==CURSOR_VALID ){ return (const void*)fetchPayload(pCur, pAmt, 1); } return 0; } static int moveToChild(BtCursor *pCur, u32 newPgno){ int rc; int i = pCur->iPage; MemPage *pNewPage; BtShared *pBt = pCur->pBt; assert( cursorHoldsMutex(pCur) ); assert( pCur->eState==CURSOR_VALID ); assert( pCur->iPage<BTCURSOR_MAX_DEPTH ); if( pCur->iPage>=(BTCURSOR_MAX_DEPTH-1) ){ return SQLITE_CORRUPT_BKPT; } rc = getAndInitPage(pBt, newPgno, &pNewPage); if( rc ) return rc; pCur->apPage[i+1] = pNewPage; pCur->aiIdx[i+1] = 0; pCur->iPage++; pCur->info.nSize = 0; pCur->validNKey = 0; if( pNewPage->nCell<1 ){ return SQLITE_CORRUPT_BKPT; } return SQLITE_OK; } 
#ifndef NDEBUG 
static void assertParentIndex(MemPage *pParent, int iIdx, Pgno iChild){ assert( iIdx<=pParent->nCell ); if( iIdx==pParent->nCell ){ assert( get4byte(&pParent->aData[pParent->hdrOffset+8])==iChild ); }else{ assert( get4byte(findCell(pParent, iIdx))==iChild ); } } 
#else 
#define assertParentIndex(x,y,z) 
#endif 
SQLITE_PRIVATE void sqlite3BtreeMoveToParent(BtCursor *pCur){ assert( cursorHoldsMutex(pCur) ); assert( pCur->eState==CURSOR_VALID ); assert( pCur->iPage>0 ); assert( pCur->apPage[pCur->iPage] ); assertParentIndex( pCur->apPage[pCur->iPage-1], pCur->aiIdx[pCur->iPage-1], pCur->apPage[pCur->iPage]->pgno ); releasePage(pCur->apPage[pCur->iPage]); pCur->iPage--; pCur->info.nSize = 0; pCur->validNKey = 0; } static int moveToRoot(BtCursor *pCur){ MemPage *pRoot; int rc = SQLITE_OK; Btree *p = pCur->pBtree; BtShared *pBt = p->pBt; assert( cursorHoldsMutex(pCur) ); assert( CURSOR_INVALID < CURSOR_REQUIRESEEK ); assert( CURSOR_VALID < CURSOR_REQUIRESEEK ); assert( CURSOR_FAULT > CURSOR_REQUIRESEEK ); if( pCur->eState>=CURSOR_REQUIRESEEK ){ if( pCur->eState==CURSOR_FAULT ){ return pCur->skip; } sqlite3BtreeClearCursor(pCur); } if( pCur->iPage>=0 ){ int i; for(i=1; i<=pCur->iPage; i++){ releasePage(pCur->apPage[i]); } }else{ if( SQLITE_OK!=(rc = getAndInitPage(pBt, pCur->pgnoRoot, &pCur->apPage[0])) ){ pCur->eState = CURSOR_INVALID; return rc; } } pRoot = pCur->apPage[0]; assert( pRoot->pgno==pCur->pgnoRoot ); pCur->iPage = 0; pCur->aiIdx[0] = 0; pCur->info.nSize = 0; pCur->atLast = 0; pCur->validNKey = 0; if( pRoot->nCell==0 && !pRoot->leaf ){ Pgno subpage; assert( pRoot->pgno==1 ); subpage = get4byte(&pRoot->aData[pRoot->hdrOffset+8]); assert( subpage>0 ); pCur->eState = CURSOR_VALID; rc = moveToChild(pCur, subpage); }else{ pCur->eState = ((pRoot->nCell>0)?CURSOR_VALID:CURSOR_INVALID); } return rc; } static int moveToLeftmost(BtCursor *pCur){ Pgno pgno; int rc = SQLITE_OK; MemPage *pPage; assert( cursorHoldsMutex(pCur) ); assert( pCur->eState==CURSOR_VALID ); while( rc==SQLITE_OK && !(pPage = pCur->apPage[pCur->iPage])->leaf ){ assert( pCur->aiIdx[pCur->iPage]<pPage->nCell ); pgno = get4byte(findCell(pPage, pCur->aiIdx[pCur->iPage])); rc = moveToChild(pCur, pgno); } return rc; } static int moveToRightmost(BtCursor *pCur){ Pgno pgno; int rc = SQLITE_OK; MemPage *pPage; assert( cursorHoldsMutex(pCur) ); assert( pCur->eState==CURSOR_VALID ); while( rc==SQLITE_OK && !(pPage = pCur->apPage[pCur->iPage])->leaf ){ pgno = get4byte(&pPage->aData[pPage->hdrOffset+8]); pCur->aiIdx[pCur->iPage] = pPage->nCell; rc = moveToChild(pCur, pgno); } if( rc==SQLITE_OK ){ pCur->aiIdx[pCur->iPage] = pPage->nCell-1; pCur->info.nSize = 0; pCur->validNKey = 0; } return rc; } SQLITE_PRIVATE int sqlite3BtreeFirst(BtCursor *pCur, int *pRes){ int rc; assert( cursorHoldsMutex(pCur) ); assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) ); rc = moveToRoot(pCur); if( rc==SQLITE_OK ){ if( pCur->eState==CURSOR_INVALID ){ assert( pCur->apPage[pCur->iPage]->nCell==0 ); *pRes = 1; rc = SQLITE_OK; }else{ assert( pCur->apPage[pCur->iPage]->nCell>0 ); *pRes = 0; rc = moveToLeftmost(pCur); } } return rc; } SQLITE_PRIVATE int sqlite3BtreeLast(BtCursor *pCur, int *pRes){ int rc; assert( cursorHoldsMutex(pCur) ); assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) ); rc = moveToRoot(pCur); if( rc==SQLITE_OK ){ if( CURSOR_INVALID==pCur->eState ){ assert( pCur->apPage[pCur->iPage]->nCell==0 ); *pRes = 1; }else{ assert( pCur->eState==CURSOR_VALID ); *pRes = 0; rc = moveToRightmost(pCur); getCellInfo(pCur); pCur->atLast = rc==SQLITE_OK; } } return rc; } SQLITE_PRIVATE int sqlite3BtreeMovetoUnpacked( BtCursor *pCur, UnpackedRecord *pIdxKey, i64 intKey, int biasRight, int *pRes ){ int rc; assert( cursorHoldsMutex(pCur) ); assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) ); if( pCur->eState==CURSOR_VALID && pCur->validNKey && pCur->apPage[0]->intKey ){ if( pCur->info.nKey==intKey ){ *pRes = 0; return SQLITE_OK; } if( pCur->atLast && pCur->info.nKey<intKey ){ *pRes = -1; return SQLITE_OK; } } rc = moveToRoot(pCur); if( rc ){ return rc; } assert( pCur->apPage[pCur->iPage] ); assert( pCur->apPage[pCur->iPage]->isInit ); if( pCur->eState==CURSOR_INVALID ){ *pRes = -1; assert( pCur->apPage[pCur->iPage]->nCell==0 ); return SQLITE_OK; } assert( pCur->apPage[0]->intKey || pIdxKey ); for(;;){ int lwr, upr; Pgno chldPg; MemPage *pPage = pCur->apPage[pCur->iPage]; int c = -1; lwr = 0; upr = pPage->nCell-1; if( !pPage->intKey && pIdxKey==0 ){ rc = SQLITE_CORRUPT_BKPT; goto moveto_finish; } if( biasRight ){ pCur->aiIdx[pCur->iPage] = upr; }else{ pCur->aiIdx[pCur->iPage] = (upr+lwr)/2; } if( lwr<=upr ) for(;;){ void *pCellKey; i64 nCellKey; int idx = pCur->aiIdx[pCur->iPage]; pCur->info.nSize = 0; pCur->validNKey = 1; if( pPage->intKey ){ u8 *pCell; pCell = findCell(pPage, idx) + pPage->childPtrSize; if( pPage->hasData ){ u32 dummy; pCell += getVarint32(pCell, dummy); } getVarint(pCell, (u64*)&nCellKey); if( nCellKey==intKey ){ c = 0; }else if( nCellKey<intKey ){ c = -1; }else{ assert( nCellKey>intKey ); c = +1; } }else{ int available; pCellKey = (void *)fetchPayload(pCur, &available, 0); nCellKey = pCur->info.nKey; if( available>=nCellKey ){ c = sqlite3VdbeRecordCompare(nCellKey, pCellKey, pIdxKey); }else{ pCellKey = sqlite3Malloc( nCellKey ); if( pCellKey==0 ){ rc = SQLITE_NOMEM; goto moveto_finish; } rc = sqlite3BtreeKey(pCur, 0, nCellKey, (void *)pCellKey); c = sqlite3VdbeRecordCompare(nCellKey, pCellKey, pIdxKey); sqlite3_free(pCellKey); if( rc ) goto moveto_finish; } } if( c==0 ){ pCur->info.nKey = nCellKey; if( pPage->intKey && !pPage->leaf ){ lwr = idx; upr = lwr - 1; break; }else{ if( pRes ) *pRes = 0; rc = SQLITE_OK; goto moveto_finish; } } if( c<0 ){ lwr = idx+1; }else{ upr = idx-1; } if( lwr>upr ){ pCur->info.nKey = nCellKey; break; } pCur->aiIdx[pCur->iPage] = (lwr+upr)/2; } assert( lwr==upr+1 ); assert( pPage->isInit ); if( pPage->leaf ){ chldPg = 0; }else if( lwr>=pPage->nCell ){ chldPg = get4byte(&pPage->aData[pPage->hdrOffset+8]); }else{ chldPg = get4byte(findCell(pPage, lwr)); } if( chldPg==0 ){ assert( pCur->aiIdx[pCur->iPage]<pCur->apPage[pCur->iPage]->nCell ); if( pRes ) *pRes = c; rc = SQLITE_OK; goto moveto_finish; } pCur->aiIdx[pCur->iPage] = lwr; pCur->info.nSize = 0; pCur->validNKey = 0; rc = moveToChild(pCur, chldPg); if( rc ) goto moveto_finish; } moveto_finish: return rc; } SQLITE_PRIVATE int sqlite3BtreeMoveto( BtCursor *pCur, const void *pKey, i64 nKey, int bias, int *pRes ){ int rc; UnpackedRecord *pIdxKey; UnpackedRecord aSpace[16]; if( pKey ){ pIdxKey = sqlite3VdbeRecordUnpack(pCur->pKeyInfo, nKey, pKey, aSpace, sizeof(aSpace)); if( pIdxKey==0 ) return SQLITE_NOMEM; }else{ pIdxKey = 0; } rc = sqlite3BtreeMovetoUnpacked(pCur, pIdxKey, nKey, bias, pRes); if( pKey ){ sqlite3VdbeDeleteUnpackedRecord(pIdxKey); } return rc; } SQLITE_PRIVATE int sqlite3BtreeEof(BtCursor *pCur){ return (CURSOR_VALID!=pCur->eState); } SQLITE_PRIVATE sqlite3 *sqlite3BtreeCursorDb(const BtCursor *pCur){ assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) ); return pCur->pBtree->db; } SQLITE_PRIVATE int sqlite3BtreeNext(BtCursor *pCur, int *pRes){ int rc; int idx; MemPage *pPage; assert( cursorHoldsMutex(pCur) ); rc = restoreCursorPosition(pCur); if( rc!=SQLITE_OK ){ return rc; } assert( pRes!=0 ); if( CURSOR_INVALID==pCur->eState ){ *pRes = 1; return SQLITE_OK; } if( pCur->skip>0 ){ pCur->skip = 0; *pRes = 0; return SQLITE_OK; } pCur->skip = 0; pPage = pCur->apPage[pCur->iPage]; idx = ++pCur->aiIdx[pCur->iPage]; assert( pPage->isInit ); assert( idx<=pPage->nCell ); pCur->info.nSize = 0; pCur->validNKey = 0; if( idx>=pPage->nCell ){ if( !pPage->leaf ){ rc = moveToChild(pCur, get4byte(&pPage->aData[pPage->hdrOffset+8])); if( rc ) return rc; rc = moveToLeftmost(pCur); *pRes = 0; return rc; } do{ if( pCur->iPage==0 ){ *pRes = 1; pCur->eState = CURSOR_INVALID; return SQLITE_OK; } sqlite3BtreeMoveToParent(pCur); pPage = pCur->apPage[pCur->iPage]; }while( pCur->aiIdx[pCur->iPage]>=pPage->nCell ); *pRes = 0; if( pPage->intKey ){ rc = sqlite3BtreeNext(pCur, pRes); }else{ rc = SQLITE_OK; } return rc; } *pRes = 0; if( pPage->leaf ){ return SQLITE_OK; } rc = moveToLeftmost(pCur); return rc; } SQLITE_PRIVATE int sqlite3BtreePrevious(BtCursor *pCur, int *pRes){ int rc; MemPage *pPage; assert( cursorHoldsMutex(pCur) ); rc = restoreCursorPosition(pCur); if( rc!=SQLITE_OK ){ return rc; } pCur->atLast = 0; if( CURSOR_INVALID==pCur->eState ){ *pRes = 1; return SQLITE_OK; } if( pCur->skip<0 ){ pCur->skip = 0; *pRes = 0; return SQLITE_OK; } pCur->skip = 0; pPage = pCur->apPage[pCur->iPage]; assert( pPage->isInit ); if( !pPage->leaf ){ int idx = pCur->aiIdx[pCur->iPage]; rc = moveToChild(pCur, get4byte(findCell(pPage, idx))); if( rc ){ return rc; } rc = moveToRightmost(pCur); }else{ while( pCur->aiIdx[pCur->iPage]==0 ){ if( pCur->iPage==0 ){ pCur->eState = CURSOR_INVALID; *pRes = 1; return SQLITE_OK; } sqlite3BtreeMoveToParent(pCur); } pCur->info.nSize = 0; pCur->validNKey = 0; pCur->aiIdx[pCur->iPage]--; pPage = pCur->apPage[pCur->iPage]; if( pPage->intKey && !pPage->leaf ){ rc = sqlite3BtreePrevious(pCur, pRes); }else{ rc = SQLITE_OK; } } *pRes = 0; return rc; } static int allocateBtreePage( BtShared *pBt, MemPage **ppPage, Pgno *pPgno, Pgno nearby, u8 exact ){ MemPage *pPage1; int rc; int n; int k; MemPage *pTrunk = 0; MemPage *pPrevTrunk = 0; assert( sqlite3_mutex_held(pBt->mutex) ); pPage1 = pBt->pPage1; n = get4byte(&pPage1->aData[36]); if( n>0 ){ Pgno iTrunk; u8 searchList = 0; 
#ifndef SQLITE_OMIT_AUTOVACUUM 
 if( exact && nearby<=pagerPagecount(pBt) ){ u8 eType; assert( nearby>0 ); assert( pBt->autoVacuum ); rc = ptrmapGet(pBt, nearby, &eType, 0); if( rc ) return rc; if( eType==PTRMAP_FREEPAGE ){ searchList = 1; } *pPgno = nearby; } 
#endif 
 rc = sqlite3PagerWrite(pPage1->pDbPage); if( rc ) return rc; put4byte(&pPage1->aData[36], n-1); do { pPrevTrunk = pTrunk; if( pPrevTrunk ){ iTrunk = get4byte(&pPrevTrunk->aData[0]); }else{ iTrunk = get4byte(&pPage1->aData[32]); } rc = sqlite3BtreeGetPage(pBt, iTrunk, &pTrunk, 0); if( rc ){ pTrunk = 0; goto end_allocate_page; } k = get4byte(&pTrunk->aData[4]); if( k==0 && !searchList ){ assert( pPrevTrunk==0 ); rc = sqlite3PagerWrite(pTrunk->pDbPage); if( rc ){ goto end_allocate_page; } *pPgno = iTrunk; memcpy(&pPage1->aData[32], &pTrunk->aData[0], 4); *ppPage = pTrunk; pTrunk = 0; TRACE(("ALLOCATE: %d trunk - %d free pages left\n", *pPgno, n-1)); }else if( k>pBt->usableSize/4 - 2 ){ rc = SQLITE_CORRUPT_BKPT; goto end_allocate_page; 
#ifndef SQLITE_OMIT_AUTOVACUUM 
 }else if( searchList && nearby==iTrunk ){ assert( *pPgno==iTrunk ); *ppPage = pTrunk; searchList = 0; rc = sqlite3PagerWrite(pTrunk->pDbPage); if( rc ){ goto end_allocate_page; } if( k==0 ){ if( !pPrevTrunk ){ memcpy(&pPage1->aData[32], &pTrunk->aData[0], 4); }else{ memcpy(&pPrevTrunk->aData[0], &pTrunk->aData[0], 4); } }else{ MemPage *pNewTrunk; Pgno iNewTrunk = get4byte(&pTrunk->aData[8]); rc = sqlite3BtreeGetPage(pBt, iNewTrunk, &pNewTrunk, 0); if( rc!=SQLITE_OK ){ goto end_allocate_page; } rc = sqlite3PagerWrite(pNewTrunk->pDbPage); if( rc!=SQLITE_OK ){ releasePage(pNewTrunk); goto end_allocate_page; } memcpy(&pNewTrunk->aData[0], &pTrunk->aData[0], 4); put4byte(&pNewTrunk->aData[4], k-1); memcpy(&pNewTrunk->aData[8], &pTrunk->aData[12], (k-1)*4); releasePage(pNewTrunk); if( !pPrevTrunk ){ put4byte(&pPage1->aData[32], iNewTrunk); }else{ rc = sqlite3PagerWrite(pPrevTrunk->pDbPage); if( rc ){ goto end_allocate_page; } put4byte(&pPrevTrunk->aData[0], iNewTrunk); } } pTrunk = 0; TRACE(("ALLOCATE: %d trunk - %d free pages left\n", *pPgno, n-1)); 
#endif 
 }else{ int closest; Pgno iPage; unsigned char *aData = pTrunk->aData; rc = sqlite3PagerWrite(pTrunk->pDbPage); if( rc ){ goto end_allocate_page; } if( nearby>0 ){ int i, dist; closest = 0; dist = get4byte(&aData[8]) - nearby; if( dist<0 ) dist = -dist; for(i=1; i<k; i++){ int d2 = get4byte(&aData[8+i*4]) - nearby; if( d2<0 ) d2 = -d2; if( d2<dist ){ closest = i; dist = d2; } } }else{ closest = 0; } iPage = get4byte(&aData[8+closest*4]); if( !searchList || iPage==nearby ){ Pgno nPage; *pPgno = iPage; nPage = pagerPagecount(pBt); if( *pPgno>nPage ){ rc = SQLITE_CORRUPT_BKPT; goto end_allocate_page; } TRACE(("ALLOCATE: %d was leaf %d of %d on trunk %d" ": %d more free pages\n", *pPgno, closest+1, k, pTrunk->pgno, n-1)); if( closest<k-1 ){ memcpy(&aData[8+closest*4], &aData[4+k*4], 4); } put4byte(&aData[4], k-1); rc = sqlite3BtreeGetPage(pBt, *pPgno, ppPage, 1); if( rc==SQLITE_OK ){ sqlite3PagerDontRollback((*ppPage)->pDbPage); rc = sqlite3PagerWrite((*ppPage)->pDbPage); if( rc!=SQLITE_OK ){ releasePage(*ppPage); } } searchList = 0; } } releasePage(pPrevTrunk); pPrevTrunk = 0; }while( searchList ); }else{ int nPage = pagerPagecount(pBt); *pPgno = nPage + 1; 
#ifndef SQLITE_OMIT_AUTOVACUUM 
 if( pBt->nTrunc ){ *pPgno = pBt->nTrunc+1; if( *pPgno==PENDING_BYTE_PAGE(pBt) ){ (*pPgno)++; } } if( pBt->autoVacuum && PTRMAP_ISPAGE(pBt, *pPgno) ){ TRACE(("ALLOCATE: %d from end of file (pointer-map page)\n", *pPgno)); assert( *pPgno!=PENDING_BYTE_PAGE(pBt) ); (*pPgno)++; if( *pPgno==PENDING_BYTE_PAGE(pBt) ){ (*pPgno)++; } } if( pBt->nTrunc ){ pBt->nTrunc = *pPgno; } 
#endif 
 assert( *pPgno!=PENDING_BYTE_PAGE(pBt) ); rc = sqlite3BtreeGetPage(pBt, *pPgno, ppPage, 0); if( rc ) return rc; rc = sqlite3PagerWrite((*ppPage)->pDbPage); if( rc!=SQLITE_OK ){ releasePage(*ppPage); } TRACE(("ALLOCATE: %d from end of file\n", *pPgno)); } assert( *pPgno!=PENDING_BYTE_PAGE(pBt) ); end_allocate_page: releasePage(pTrunk); releasePage(pPrevTrunk); if( rc==SQLITE_OK ){ if( sqlite3PagerPageRefcount((*ppPage)->pDbPage)>1 ){ releasePage(*ppPage); return SQLITE_CORRUPT_BKPT; } (*ppPage)->isInit = 0; } return rc; } static int freePage(MemPage *pPage){ BtShared *pBt = pPage->pBt; MemPage *pPage1 = pBt->pPage1; int rc, n, k; assert( sqlite3_mutex_held(pPage->pBt->mutex) ); assert( pPage->pgno>1 ); pPage->isInit = 0; rc = sqlite3PagerWrite(pPage1->pDbPage); if( rc ) return rc; n = get4byte(&pPage1->aData[36]); put4byte(&pPage1->aData[36], n+1); 
#ifdef SQLITE_SECURE_DELETE 
 rc = sqlite3PagerWrite(pPage->pDbPage); if( rc ) return rc; memset(pPage->aData, 0, pPage->pBt->pageSize); 
#endif 
 if( ISAUTOVACUUM ){ rc = ptrmapPut(pBt, pPage->pgno, PTRMAP_FREEPAGE, 0); if( rc ) return rc; } if( n==0 ){ rc = sqlite3PagerWrite(pPage->pDbPage); if( rc ) return rc; memset(pPage->aData, 0, 8); put4byte(&pPage1->aData[32], pPage->pgno); TRACE(("FREE-PAGE: %d first\n", pPage->pgno)); }else{ MemPage *pTrunk; rc = sqlite3BtreeGetPage(pBt, get4byte(&pPage1->aData[32]), &pTrunk, 0); if( rc ) return rc; k = get4byte(&pTrunk->aData[4]); if( k>=pBt->usableSize/4 - 8 ){ rc = sqlite3PagerWrite(pPage->pDbPage); if( rc==SQLITE_OK ){ put4byte(pPage->aData, pTrunk->pgno); put4byte(&pPage->aData[4], 0); put4byte(&pPage1->aData[32], pPage->pgno); TRACE(("FREE-PAGE: %d new trunk page replacing %d\n", pPage->pgno, pTrunk->pgno)); } }else if( k<0 ){ rc = SQLITE_CORRUPT; }else{ rc = sqlite3PagerWrite(pTrunk->pDbPage); if( rc==SQLITE_OK ){ put4byte(&pTrunk->aData[4], k+1); put4byte(&pTrunk->aData[8+k*4], pPage->pgno); 
#ifndef SQLITE_SECURE_DELETE 
 rc = sqlite3PagerDontWrite(pPage->pDbPage); 
#endif 
 } TRACE(("FREE-PAGE: %d leaf on trunk page %d\n",pPage->pgno,pTrunk->pgno)); } releasePage(pTrunk); } return rc; } static int clearCell(MemPage *pPage, unsigned char *pCell){ BtShared *pBt = pPage->pBt; CellInfo info; Pgno ovflPgno; int rc; int nOvfl; int ovflPageSize; assert( sqlite3_mutex_held(pPage->pBt->mutex) ); sqlite3BtreeParseCellPtr(pPage, pCell, &info); if( info.iOverflow==0 ){ return SQLITE_OK; } ovflPgno = get4byte(&pCell[info.iOverflow]); ovflPageSize = pBt->usableSize - 4; nOvfl = (info.nPayload - info.nLocal + ovflPageSize - 1)/ovflPageSize; assert( ovflPgno==0 || nOvfl>0 ); while( nOvfl-- ){ MemPage *pOvfl; if( ovflPgno==0 || ovflPgno>pagerPagecount(pBt) ){ return SQLITE_CORRUPT_BKPT; } rc = getOverflowPage(pBt, ovflPgno, &pOvfl, (nOvfl==0)?0:&ovflPgno); if( rc ) return rc; rc = freePage(pOvfl); sqlite3PagerUnref(pOvfl->pDbPage); if( rc ) return rc; } return SQLITE_OK; } static int fillInCell( MemPage *pPage, unsigned char *pCell, const void *pKey, i64 nKey, const void *pData,int nData, int nZero, int *pnSize ){ int nPayload; const u8 *pSrc; int nSrc, n, rc; int spaceLeft; MemPage *pOvfl = 0; MemPage *pToRelease = 0; unsigned char *pPrior; unsigned char *pPayload; BtShared *pBt = pPage->pBt; Pgno pgnoOvfl = 0; int nHeader; CellInfo info; assert( sqlite3_mutex_held(pPage->pBt->mutex) ); nHeader = 0; if( !pPage->leaf ){ nHeader += 4; } if( pPage->hasData ){ nHeader += putVarint(&pCell[nHeader], nData+nZero); }else{ nData = nZero = 0; } nHeader += putVarint(&pCell[nHeader], *(u64*)&nKey); sqlite3BtreeParseCellPtr(pPage, pCell, &info); assert( info.nHeader==nHeader ); assert( info.nKey==nKey ); assert( info.nData==(u32)(nData+nZero) ); nPayload = nData + nZero; if( pPage->intKey ){ pSrc = pData; nSrc = nData; nData = 0; }else{ nPayload += nKey; pSrc = pKey; nSrc = nKey; } *pnSize = info.nSize; spaceLeft = info.nLocal; pPayload = &pCell[nHeader]; pPrior = &pCell[info.iOverflow]; while( nPayload>0 ){ if( spaceLeft==0 ){ int isExact = 0; 
#ifndef SQLITE_OMIT_AUTOVACUUM 
 Pgno pgnoPtrmap = pgnoOvfl; if( pBt->autoVacuum ){ do{ pgnoOvfl++; } while( PTRMAP_ISPAGE(pBt, pgnoOvfl) || pgnoOvfl==PENDING_BYTE_PAGE(pBt) ); if( pgnoOvfl>1 ){ } } 
#endif 
 rc = allocateBtreePage(pBt, &pOvfl, &pgnoOvfl, pgnoOvfl, isExact); 
#ifndef SQLITE_OMIT_AUTOVACUUM 
 if( pBt->autoVacuum && rc==SQLITE_OK ){ u8 eType = (pgnoPtrmap?PTRMAP_OVERFLOW2:PTRMAP_OVERFLOW1); rc = ptrmapPut(pBt, pgnoOvfl, eType, pgnoPtrmap); if( rc ){ releasePage(pOvfl); } } 
#endif 
 if( rc ){ releasePage(pToRelease); return rc; } put4byte(pPrior, pgnoOvfl); releasePage(pToRelease); pToRelease = pOvfl; pPrior = pOvfl->aData; put4byte(pPrior, 0); pPayload = &pOvfl->aData[4]; spaceLeft = pBt->usableSize - 4; } n = nPayload; if( n>spaceLeft ) n = spaceLeft; if( nSrc>0 ){ if( n>nSrc ) n = nSrc; assert( pSrc ); memcpy(pPayload, pSrc, n); }else{ memset(pPayload, 0, n); } nPayload -= n; pPayload += n; pSrc += n; nSrc -= n; spaceLeft -= n; if( nSrc==0 ){ nSrc = nData; pSrc = pData; } } releasePage(pToRelease); return SQLITE_OK; } static int dropCell(MemPage *pPage, int idx, int sz){ int i; int pc; u8 *data; u8 *ptr; int rc; assert( idx>=0 && idx<pPage->nCell ); assert( sz==cellSize(pPage, idx) ); assert( sqlite3PagerIswriteable(pPage->pDbPage) ); assert( sqlite3_mutex_held(pPage->pBt->mutex) ); data = pPage->aData; ptr = &data[pPage->cellOffset + 2*idx]; pc = get2byte(ptr); if ( (pc<pPage->hdrOffset+6+(pPage->leaf?0:4)) || (pc+sz>pPage->pBt->usableSize) ) { return SQLITE_CORRUPT_BKPT; } rc = freeSpace(pPage, pc, sz); if( rc!=SQLITE_OK ){ return rc; } for(i=idx+1; i<pPage->nCell; i++, ptr+=2){ ptr[0] = ptr[2]; ptr[1] = ptr[3]; } pPage->nCell--; put2byte(&data[pPage->hdrOffset+3], pPage->nCell); pPage->nFree += 2; return SQLITE_OK; } static int insertCell( MemPage *pPage, int i, u8 *pCell, int sz, u8 *pTemp, u8 nSkip ){ int idx; int j; int top; int end; int ins; int hdr; int cellOffset; u8 *data; u8 *ptr; assert( i>=0 && i<=pPage->nCell+pPage->nOverflow ); assert( sz==cellSizePtr(pPage, pCell) ); assert( sqlite3_mutex_held(pPage->pBt->mutex) ); if( pPage->nOverflow || sz+2>pPage->nFree ){ if( pTemp ){ memcpy(pTemp+nSkip, pCell+nSkip, sz-nSkip); pCell = pTemp; } j = pPage->nOverflow++; assert( j<(int)(sizeof(pPage->aOvfl)/sizeof(pPage->aOvfl[0])) ); pPage->aOvfl[j].pCell = pCell; pPage->aOvfl[j].idx = i; pPage->nFree = 0; }else{ int rc = sqlite3PagerWrite(pPage->pDbPage); if( rc!=SQLITE_OK ){ return rc; } assert( sqlite3PagerIswriteable(pPage->pDbPage) ); data = pPage->aData; hdr = pPage->hdrOffset; top = get2byte(&data[hdr+5]); cellOffset = pPage->cellOffset; end = cellOffset + 2*pPage->nCell + 2; ins = cellOffset + 2*i; if( end > top - sz ){ rc = defragmentPage(pPage); if( rc!=SQLITE_OK ){ return rc; } top = get2byte(&data[hdr+5]); assert( end + sz <= top ); } idx = allocateSpace(pPage, sz); assert( idx>0 ); assert( end <= get2byte(&data[hdr+5]) ); if (idx+sz > pPage->pBt->usableSize) { return SQLITE_CORRUPT_BKPT; } pPage->nCell++; pPage->nFree -= 2; memcpy(&data[idx+nSkip], pCell+nSkip, sz-nSkip); for(j=end-2, ptr=&data[j]; j>ins; j-=2, ptr-=2){ ptr[0] = ptr[-2]; ptr[1] = ptr[-1]; } put2byte(&data[ins], idx); put2byte(&data[hdr+3], pPage->nCell); 
#ifndef SQLITE_OMIT_AUTOVACUUM 
 if( pPage->pBt->autoVacuum ){ CellInfo info; sqlite3BtreeParseCellPtr(pPage, pCell, &info); assert( (info.nData+(pPage->intKey?0:info.nKey))==info.nPayload ); if( (info.nData+(pPage->intKey?0:info.nKey))>info.nLocal ){ Pgno pgnoOvfl = get4byte(&pCell[info.iOverflow]); rc = ptrmapPut(pPage->pBt, pgnoOvfl, PTRMAP_OVERFLOW1, pPage->pgno); if( rc!=SQLITE_OK ) return rc; } } 
#endif 
 } return SQLITE_OK; } static void assemblePage( MemPage *pPage, int nCell, u8 **apCell, u16 *aSize ){ int i; int totalSize; int hdr; int cellptr; int cellbody; u8 *data; assert( pPage->nOverflow==0 ); assert( sqlite3_mutex_held(pPage->pBt->mutex) ); totalSize = 0; for(i=0; i<nCell; i++){ totalSize += aSize[i]; } assert( totalSize+2*nCell<=pPage->nFree ); assert( pPage->nCell==0 ); cellptr = pPage->cellOffset; data = pPage->aData; hdr = pPage->hdrOffset; put2byte(&data[hdr+3], nCell); if( nCell ){ cellbody = allocateSpace(pPage, totalSize); assert( cellbody>0 ); assert( pPage->nFree >= 2*nCell ); pPage->nFree -= 2*nCell; for(i=0; i<nCell; i++){ put2byte(&data[cellptr], cellbody); memcpy(&data[cellbody], apCell[i], aSize[i]); cellptr += 2; cellbody += aSize[i]; } assert( cellbody==pPage->pBt->usableSize ); } pPage->nCell = nCell; } 
#define NN 1 
#define NB (NN*2+1) 
static int balance(BtCursor*, int); 
#ifndef SQLITE_OMIT_QUICKBALANCE 
static int balance_quick(BtCursor *pCur){ int rc; MemPage *pNew = 0; Pgno pgnoNew; u8 *pCell; u16 szCell; CellInfo info; MemPage *pPage = pCur->apPage[pCur->iPage]; MemPage *pParent = pCur->apPage[pCur->iPage-1]; BtShared *pBt = pPage->pBt; int parentIdx = pParent->nCell; int parentSize; u8 parentCell[64]; assert( sqlite3_mutex_held(pPage->pBt->mutex) ); rc = allocateBtreePage(pBt, &pNew, &pgnoNew, 0, 0); if( rc==SQLITE_OK ){ pCell = pPage->aOvfl[0].pCell; szCell = cellSizePtr(pPage, pCell); zeroPage(pNew, pPage->aData[0]); assemblePage(pNew, 1, &pCell, &szCell); pPage->nOverflow = 0; assert( pPage->nCell>0 ); pCell = findCell(pPage, pPage->nCell-1); sqlite3BtreeParseCellPtr(pPage, pCell, &info); fillInCell(pParent, parentCell, 0, info.nKey, 0, 0, 0, &parentSize); assert( parentSize<64 ); assert( sqlite3PagerIswriteable(pParent->pDbPage) ); insertCell(pParent, parentIdx, parentCell, parentSize, 0, 4); put4byte(findOverflowCell(pParent,parentIdx), pPage->pgno); put4byte(&pParent->aData[pParent->hdrOffset+8], pgnoNew); if( ISAUTOVACUUM ){ rc = ptrmapPut(pBt, pgnoNew, PTRMAP_BTREE, pParent->pgno); if( rc==SQLITE_OK ){ rc = ptrmapPutOvfl(pNew, 0); } } releasePage(pNew); } pPage->isInit = 0; sqlite3BtreeInitPage(pPage); if( rc==SQLITE_OK ){ releasePage(pPage); pCur->iPage--; rc = balance(pCur, 0); } return rc; } 
#endif 
static int balance_nonroot(BtCursor *pCur){ MemPage *pPage; MemPage *pParent; BtShared *pBt; int nCell = 0; int nMaxCells = 0; int nOld; int nNew; int nDiv; int i, j, k; int idx; int nxDiv; int rc; int leafCorrection; int leafData; int usableSpace; int pageFlags; int subtotal; int iSpace1 = 0; int iSpace2 = 0; int szScratch; MemPage *apOld[NB]; Pgno pgnoOld[NB]; MemPage *apCopy[NB]; MemPage *apNew[NB+2]; Pgno pgnoNew[NB+2]; u8 *apDiv[NB]; int cntNew[NB+2]; int szNew[NB+2]; u8 **apCell = 0; u16 *szCell; u8 *aCopy[NB]; u8 *aSpace1; u8 *aSpace2 = 0; u8 *aFrom = 0; pPage = pCur->apPage[pCur->iPage]; assert( sqlite3_mutex_held(pPage->pBt->mutex) ); VVA_ONLY( pCur->pagesShuffled = 1 ); assert( pCur->iPage>0 ); assert( pPage->isInit ); assert( sqlite3PagerIswriteable(pPage->pDbPage) || pPage->nOverflow==1 ); pBt = pPage->pBt; pParent = pCur->apPage[pCur->iPage-1]; assert( pParent ); if( SQLITE_OK!=(rc = sqlite3PagerWrite(pParent->pDbPage)) ){ return rc; } TRACE(("BALANCE: begin page %d child of %d\n", pPage->pgno, pParent->pgno)); 
#ifndef SQLITE_OMIT_QUICKBALANCE 
 if( pPage->leaf && pPage->intKey && pPage->nOverflow==1 && pPage->aOvfl[0].idx==pPage->nCell && pParent->pgno!=1 && get4byte(&pParent->aData[pParent->hdrOffset+8])==pPage->pgno ){ assert( pPage->intKey ); return balance_quick(pCur); } 
#endif 
 if( SQLITE_OK!=(rc = sqlite3PagerWrite(pPage->pDbPage)) ){ return rc; } idx = pCur->aiIdx[pCur->iPage-1]; assertParentIndex(pParent, idx, pPage->pgno); nOld = nNew = 0; nxDiv = idx - NN; if( nxDiv + NB > pParent->nCell ){ nxDiv = pParent->nCell - NB + 1; } if( nxDiv<0 ){ nxDiv = 0; } nDiv = 0; for(i=0, k=nxDiv; i<NB; i++, k++){ if( k<pParent->nCell ){ apDiv[i] = findCell(pParent, k); nDiv++; assert( !pParent->leaf ); pgnoOld[i] = get4byte(apDiv[i]); }else if( k==pParent->nCell ){ pgnoOld[i] = get4byte(&pParent->aData[pParent->hdrOffset+8]); }else{ break; } rc = getAndInitPage(pBt, pgnoOld[i], &apOld[i]); if( rc ) goto balance_cleanup; apCopy[i] = 0; assert( i==nOld ); nOld++; nMaxCells += 1+apOld[i]->nCell+apOld[i]->nOverflow; } nMaxCells = (nMaxCells + 3)&~3; szScratch = nMaxCells*sizeof(u8*) + nMaxCells*sizeof(u16) + (ROUND8(sizeof(MemPage))+pBt->pageSize)*NB + pBt->pageSize + (ISAUTOVACUUM ? nMaxCells : 0); apCell = sqlite3ScratchMalloc( szScratch ); if( apCell==0 ){ rc = SQLITE_NOMEM; goto balance_cleanup; } szCell = (u16*)&apCell[nMaxCells]; aCopy[0] = (u8*)&szCell[nMaxCells]; assert( ((aCopy[0] - (u8*)apCell) & 7)==0 ); for(i=1; i<NB; i++){ aCopy[i] = &aCopy[i-1][pBt->pageSize+ROUND8(sizeof(MemPage))]; assert( ((aCopy[i] - (u8*)apCell) & 7)==0 ); } aSpace1 = &aCopy[NB-1][pBt->pageSize+ROUND8(sizeof(MemPage))]; assert( ((aSpace1 - (u8*)apCell) & 7)==0 ); if( ISAUTOVACUUM ){ aFrom = &aSpace1[pBt->pageSize]; } aSpace2 = sqlite3PageMalloc(pBt->pageSize); if( aSpace2==0 ){ rc = SQLITE_NOMEM; goto balance_cleanup; } for(i=0; i<nOld; i++){ MemPage *p = apCopy[i] = (MemPage*)aCopy[i]; memcpy(p, apOld[i], sizeof(MemPage)); p->aData = (void*)&p[1]; memcpy(p->aData, apOld[i]->aData, pBt->pageSize); } nCell = 0; leafCorrection = pPage->leaf*4; leafData = pPage->hasData; for(i=0; i<nOld; i++){ MemPage *pOld = apCopy[i]; int limit = pOld->nCell+pOld->nOverflow; for(j=0; j<limit; j++){ assert( nCell<nMaxCells ); apCell[nCell] = findOverflowCell(pOld, j); szCell[nCell] = cellSizePtr(pOld, apCell[nCell]); if( ISAUTOVACUUM ){ int a; aFrom[nCell] = i; for(a=0; a<pOld->nOverflow; a++){ if( pOld->aOvfl[a].pCell==apCell[nCell] ){ aFrom[nCell] = 0xFF; break; } } } nCell++; } if( i<nOld-1 ){ u16 sz = cellSizePtr(pParent, apDiv[i]); if( leafData ){ dropCell(pParent, nxDiv, sz); }else{ u8 *pTemp; assert( nCell<nMaxCells ); szCell[nCell] = sz; pTemp = &aSpace1[iSpace1]; iSpace1 += sz; assert( sz<=pBt->pageSize/4 ); assert( iSpace1<=pBt->pageSize ); memcpy(pTemp, apDiv[i], sz); apCell[nCell] = pTemp+leafCorrection; if( ISAUTOVACUUM ){ aFrom[nCell] = 0xFF; } dropCell(pParent, nxDiv, sz); szCell[nCell] -= leafCorrection; assert( get4byte(pTemp)==pgnoOld[i] ); if( !pOld->leaf ){ assert( leafCorrection==0 ); memcpy(apCell[nCell], &pOld->aData[pOld->hdrOffset+8], 4); }else{ assert( leafCorrection==4 ); if( szCell[nCell]<4 ){ szCell[nCell] = 4; } } nCell++; } } } usableSpace = pBt->usableSize - 12 + leafCorrection; for(subtotal=k=i=0; i<nCell; i++){ assert( i<nMaxCells ); subtotal += szCell[i] + 2; if( subtotal > usableSpace ){ szNew[k] = subtotal - szCell[i]; cntNew[k] = i; if( leafData ){ i--; } subtotal = 0; k++; } } szNew[k] = subtotal; cntNew[k] = nCell; k++; for(i=k-1; i>0; i--){ int szRight = szNew[i]; int szLeft = szNew[i-1]; int r; int d; r = cntNew[i-1] - 1; d = r + 1 - leafData; assert( d<nMaxCells ); assert( r<nMaxCells ); while( szRight==0 || szRight+szCell[d]+2<=szLeft-(szCell[r]+2) ){ szRight += szCell[d] + 2; szLeft -= szCell[r] + 2; cntNew[i-1]--; r = cntNew[i-1] - 1; d = r + 1 - leafData; } szNew[i] = szRight; szNew[i-1] = szLeft; } assert( cntNew[0]>0 || (pParent->pgno==1 && pParent->nCell==0) ); assert( pPage->pgno>1 ); pageFlags = pPage->aData[0]; for(i=0; i<k; i++){ MemPage *pNew; if( i<nOld ){ pNew = apNew[i] = apOld[i]; pgnoNew[i] = pgnoOld[i]; apOld[i] = 0; rc = sqlite3PagerWrite(pNew->pDbPage); nNew++; if( rc ) goto balance_cleanup; }else{ assert( i>0 ); rc = allocateBtreePage(pBt, &pNew, &pgnoNew[i], pgnoNew[i-1], 0); if( rc ) goto balance_cleanup; apNew[i] = pNew; nNew++; } } while( i<nOld ){ rc = freePage(apOld[i]); if( rc ) goto balance_cleanup; releasePage(apOld[i]); apOld[i] = 0; i++; } for(i=0; i<k-1; i++){ int minV = pgnoNew[i]; int minI = i; for(j=i+1; j<k; j++){ if( pgnoNew[j]<(unsigned)minV ){ minI = j; minV = pgnoNew[j]; } } if( minI>i ){ int t; MemPage *pT; t = pgnoNew[i]; pT = apNew[i]; pgnoNew[i] = pgnoNew[minI]; apNew[i] = apNew[minI]; pgnoNew[minI] = t; apNew[minI] = pT; } } TRACE(("BALANCE: old: %d %d %d new: %d(%d) %d(%d) %d(%d) %d(%d) %d(%d)\n", pgnoOld[0], nOld>=2 ? pgnoOld[1] : 0, nOld>=3 ? pgnoOld[2] : 0, pgnoNew[0], szNew[0], nNew>=2 ? pgnoNew[1] : 0, nNew>=2 ? szNew[1] : 0, nNew>=3 ? pgnoNew[2] : 0, nNew>=3 ? szNew[2] : 0, nNew>=4 ? pgnoNew[3] : 0, nNew>=4 ? szNew[3] : 0, nNew>=5 ? pgnoNew[4] : 0, nNew>=5 ? szNew[4] : 0)); j = 0; for(i=0; i<nNew; i++){ MemPage *pNew = apNew[i]; assert( j<nMaxCells ); assert( pNew->pgno==pgnoNew[i] ); zeroPage(pNew, pageFlags); assemblePage(pNew, cntNew[i]-j, &apCell[j], &szCell[j]); assert( pNew->nCell>0 || (nNew==1 && cntNew[0]==0) ); assert( pNew->nOverflow==0 ); if( ISAUTOVACUUM ){ for(k=j; k<cntNew[i]; k++){ assert( k<nMaxCells ); if( aFrom[k]==0xFF || apCopy[aFrom[k]]->pgno!=pNew->pgno ){ rc = ptrmapPutOvfl(pNew, k-j); if( rc==SQLITE_OK && leafCorrection==0 ){ rc = ptrmapPut(pBt, get4byte(apCell[k]), PTRMAP_BTREE, pNew->pgno); } if( rc!=SQLITE_OK ){ goto balance_cleanup; } } } } j = cntNew[i]; if( i<nNew-1 && j<nCell ){ u8 *pCell; u8 *pTemp; int sz; assert( j<nMaxCells ); pCell = apCell[j]; sz = szCell[j] + leafCorrection; pTemp = &aSpace2[iSpace2]; if( !pNew->leaf ){ memcpy(&pNew->aData[8], pCell, 4); if( ISAUTOVACUUM && (aFrom[j]==0xFF || apCopy[aFrom[j]]->pgno!=pNew->pgno) ){ rc = ptrmapPut(pBt, get4byte(pCell), PTRMAP_BTREE, pNew->pgno); if( rc!=SQLITE_OK ){ goto balance_cleanup; } } }else if( leafData ){ CellInfo info; j--; sqlite3BtreeParseCellPtr(pNew, apCell[j], &info); pCell = pTemp; fillInCell(pParent, pCell, 0, info.nKey, 0, 0, 0, &sz); pTemp = 0; }else{ pCell -= 4; if( szCell[j]==4 ){ assert(leafCorrection==4); sz = cellSizePtr(pParent, pCell); } } iSpace2 += sz; assert( sz<=pBt->pageSize/4 ); assert( iSpace2<=pBt->pageSize ); rc = insertCell(pParent, nxDiv, pCell, sz, pTemp, 4); if( rc!=SQLITE_OK ) goto balance_cleanup; put4byte(findOverflowCell(pParent,nxDiv), pNew->pgno); if( ISAUTOVACUUM && !leafData ){ rc = ptrmapPutOvfl(pParent, nxDiv); if( rc!=SQLITE_OK ){ goto balance_cleanup; } } j++; nxDiv++; } if( ISAUTOVACUUM ){ rc = ptrmapPut(pBt, pNew->pgno, PTRMAP_BTREE, pParent->pgno); if( rc!=SQLITE_OK ){ goto balance_cleanup; } } } assert( j==nCell ); assert( nOld>0 ); assert( nNew>0 ); if( (pageFlags & PTF_LEAF)==0 ){ u8 *zChild = &apCopy[nOld-1]->aData[8]; memcpy(&apNew[nNew-1]->aData[8], zChild, 4); if( ISAUTOVACUUM ){ rc = ptrmapPut(pBt, get4byte(zChild), PTRMAP_BTREE, apNew[nNew-1]->pgno); if( rc!=SQLITE_OK ){ goto balance_cleanup; } } } if( nxDiv==pParent->nCell+pParent->nOverflow ){ put4byte(&pParent->aData[pParent->hdrOffset+8], pgnoNew[nNew-1]); }else{ put4byte(findOverflowCell(pParent, nxDiv), pgnoNew[nNew-1]); } assert( pParent->isInit ); sqlite3ScratchFree(apCell); apCell = 0; releasePage(pPage); pCur->iPage--; rc = balance(pCur, 0); balance_cleanup: sqlite3PageFree(aSpace2); sqlite3ScratchFree(apCell); for(i=0; i<nOld; i++){ releasePage(apOld[i]); } for(i=0; i<nNew; i++){ releasePage(apNew[i]); } TRACE(("BALANCE: finished with %d: old=%d new=%d cells=%d\n", pPage->pgno, nOld, nNew, nCell)); return rc; } static int balance_shallower(BtCursor *pCur){ MemPage *pPage; MemPage *pChild; Pgno pgnoChild; int rc = SQLITE_OK; BtShared *pBt; int mxCellPerPage; u8 **apCell; u16 *szCell; assert( pCur->iPage==0 ); pPage = pCur->apPage[0]; assert( pPage->nCell==0 ); assert( sqlite3_mutex_held(pPage->pBt->mutex) ); pBt = pPage->pBt; mxCellPerPage = MX_CELL(pBt); apCell = sqlite3Malloc( mxCellPerPage*(sizeof(u8*)+sizeof(u16)) ); if( apCell==0 ) return SQLITE_NOMEM; szCell = (u16*)&apCell[mxCellPerPage]; if( pPage->leaf ){ TRACE(("BALANCE: empty table %d\n", pPage->pgno)); }else{ VVA_ONLY( pCur->pagesShuffled = 1 ); pgnoChild = get4byte(&pPage->aData[pPage->hdrOffset+8]); assert( pgnoChild>0 ); assert( pgnoChild<=pagerPagecount(pPage->pBt) ); rc = sqlite3BtreeGetPage(pPage->pBt, pgnoChild, &pChild, 0); if( rc ) goto end_shallow_balance; if( pPage->pgno==1 ){ rc = sqlite3BtreeInitPage(pChild); if( rc ) goto end_shallow_balance; assert( pChild->nOverflow==0 ); if( pChild->nFree>=100 ){ int i; zeroPage(pPage, pChild->aData[0]); for(i=0; i<pChild->nCell; i++){ apCell[i] = findCell(pChild,i); szCell[i] = cellSizePtr(pChild, apCell[i]); } assemblePage(pPage, pChild->nCell, apCell, szCell); put4byte(&pPage->aData[pPage->hdrOffset+8], get4byte(&pChild->aData[pChild->hdrOffset+8])); freePage(pChild); TRACE(("BALANCE: child %d transfer to page 1\n", pChild->pgno)); }else{ TRACE(("BALANCE: child %d will not fit on page 1\n", pChild->pgno)); } }else{ memcpy(pPage->aData, pChild->aData, pPage->pBt->usableSize); pPage->isInit = 0; rc = sqlite3BtreeInitPage(pPage); assert( rc==SQLITE_OK ); freePage(pChild); TRACE(("BALANCE: transfer child %d into root %d\n", pChild->pgno, pPage->pgno)); } assert( pPage->nOverflow==0 ); 
#ifndef SQLITE_OMIT_AUTOVACUUM 
 if( ISAUTOVACUUM ){ rc = setChildPtrmaps(pPage); } 
#endif 
 releasePage(pChild); } end_shallow_balance: sqlite3_free(apCell); return rc; } static int balance_deeper(BtCursor *pCur){ int rc; MemPage *pPage; MemPage *pChild; Pgno pgnoChild; BtShared *pBt; int usableSize; u8 *data; u8 *cdata; int hdr; int cbrk; assert( pCur->iPage==0 ); assert( pCur->apPage[0]->nOverflow>0 ); VVA_ONLY( pCur->pagesShuffled = 1 ); pPage = pCur->apPage[0]; pBt = pPage->pBt; assert( sqlite3_mutex_held(pBt->mutex) ); rc = allocateBtreePage(pBt, &pChild, &pgnoChild, pPage->pgno, 0); if( rc ) return rc; assert( sqlite3PagerIswriteable(pChild->pDbPage) ); usableSize = pBt->usableSize; data = pPage->aData; hdr = pPage->hdrOffset; cbrk = get2byte(&data[hdr+5]); cdata = pChild->aData; memcpy(cdata, &data[hdr], pPage->cellOffset+2*pPage->nCell-hdr); memcpy(&cdata[cbrk], &data[cbrk], usableSize-cbrk); assert( pChild->isInit==0 ); rc = sqlite3BtreeInitPage(pChild); if( rc==SQLITE_OK ){ int nCopy = pPage->nOverflow*sizeof(pPage->aOvfl[0]); memcpy(pChild->aOvfl, pPage->aOvfl, nCopy); pChild->nOverflow = pPage->nOverflow; if( pChild->nOverflow ){ pChild->nFree = 0; } assert( pChild->nCell==pPage->nCell ); zeroPage(pPage, pChild->aData[0] & ~PTF_LEAF); put4byte(&pPage->aData[pPage->hdrOffset+8], pgnoChild); TRACE(("BALANCE: copy root %d into %d\n", pPage->pgno, pChild->pgno)); if( ISAUTOVACUUM ){ rc = ptrmapPut(pBt, pChild->pgno, PTRMAP_BTREE, pPage->pgno); 
#ifndef SQLITE_OMIT_AUTOVACUUM 
 if( rc==SQLITE_OK ){ rc = setChildPtrmaps(pChild); } 
#endif 
 } } if( rc==SQLITE_OK ){ pCur->iPage++; pCur->apPage[1] = pChild; pCur->aiIdx[0] = 0; rc = balance_nonroot(pCur); }else{ releasePage(pChild); } return rc; } static int balance(BtCursor *pCur, int isInsert){ int rc = SQLITE_OK; MemPage *pPage = pCur->apPage[pCur->iPage]; assert( sqlite3_mutex_held(pPage->pBt->mutex) ); if( pCur->iPage==0 ){ rc = sqlite3PagerWrite(pPage->pDbPage); if( rc==SQLITE_OK && pPage->nOverflow>0 ){ rc = balance_deeper(pCur); } if( rc==SQLITE_OK && pPage->nCell==0 ){ rc = balance_shallower(pCur); } }else{ if( pPage->nOverflow>0 || (!isInsert && pPage->nFree>pPage->pBt->usableSize*2/3) ){ rc = balance_nonroot(pCur); } } return rc; } static int checkReadLocks( Btree *pBtree, Pgno pgnoRoot, BtCursor *pExclude, i64 iRow ){ BtCursor *p; BtShared *pBt = pBtree->pBt; sqlite3 *db = pBtree->db; assert( sqlite3BtreeHoldsMutex(pBtree) ); for(p=pBt->pCursor; p; p=p->pNext){ if( p==pExclude ) continue; if( p->pgnoRoot!=pgnoRoot ) continue; 
#ifndef SQLITE_OMIT_INCRBLOB 
 if( p->isIncrblobHandle && ( (!pExclude && iRow) || (pExclude && !pExclude->isIncrblobHandle && p->info.nKey==iRow) )){ p->eState = CURSOR_INVALID; } 
#endif 
 if( p->eState!=CURSOR_VALID ) continue; if( p->wrFlag==0 
#ifndef SQLITE_OMIT_INCRBLOB 
 || p->isIncrblobHandle 
#endif 
 ){ sqlite3 *dbOther = p->pBtree->db; if( dbOther==0 || (dbOther!=db && (dbOther->flags & SQLITE_ReadUncommitted)==0) ){ return SQLITE_LOCKED; } } } return SQLITE_OK; } SQLITE_PRIVATE int sqlite3BtreeInsert( BtCursor *pCur, const void *pKey, i64 nKey, const void *pData, int nData, int nZero, int appendBias ){ int rc; int loc; int szNew; int idx; MemPage *pPage; Btree *p = pCur->pBtree; BtShared *pBt = p->pBt; unsigned char *oldCell; unsigned char *newCell = 0; assert( cursorHoldsMutex(pCur) ); if( pBt->inTransaction!=TRANS_WRITE ){ rc = pBt->readOnly ? SQLITE_READONLY : SQLITE_ERROR; return rc; } assert( !pBt->readOnly ); if( !pCur->wrFlag ){ return SQLITE_PERM; } if( checkReadLocks(pCur->pBtree, pCur->pgnoRoot, pCur, nKey) ){ return SQLITE_LOCKED; } if( pCur->eState==CURSOR_FAULT ){ return pCur->skip; } sqlite3BtreeClearCursor(pCur); if( SQLITE_OK!=(rc = saveAllCursors(pBt, pCur->pgnoRoot, pCur)) || SQLITE_OK!=(rc = sqlite3BtreeMoveto(pCur, pKey, nKey, appendBias, &loc)) ){ return rc; } pPage = pCur->apPage[pCur->iPage]; assert( pPage->intKey || nKey>=0 ); assert( pPage->leaf || !pPage->intKey ); TRACE(("INSERT: table=%d nkey=%lld ndata=%d page=%d %s\n", pCur->pgnoRoot, nKey, nData, pPage->pgno, loc==0 ? "overwrite" : "new entry")); assert( pPage->isInit ); allocateTempSpace(pBt); newCell = pBt->pTmpSpace; if( newCell==0 ) return SQLITE_NOMEM; rc = fillInCell(pPage, newCell, pKey, nKey, pData, nData, nZero, &szNew); if( rc ) goto end_insert; assert( szNew==cellSizePtr(pPage, newCell) ); assert( szNew<=MX_CELL_SIZE(pBt) ); idx = pCur->aiIdx[pCur->iPage]; if( loc==0 && CURSOR_VALID==pCur->eState ){ u16 szOld; assert( idx<pPage->nCell ); rc = sqlite3PagerWrite(pPage->pDbPage); if( rc ){ goto end_insert; } oldCell = findCell(pPage, idx); if( !pPage->leaf ){ memcpy(newCell, oldCell, 4); } szOld = cellSizePtr(pPage, oldCell); rc = clearCell(pPage, oldCell); if( rc ) goto end_insert; rc = dropCell(pPage, idx, szOld); if( rc!=SQLITE_OK ) { goto end_insert; } }else if( loc<0 && pPage->nCell>0 ){ assert( pPage->leaf ); idx = ++pCur->aiIdx[pCur->iPage]; pCur->info.nSize = 0; pCur->validNKey = 0; }else{ assert( pPage->leaf ); } rc = insertCell(pPage, idx, newCell, szNew, 0, 0); if( rc!=SQLITE_OK ) goto end_insert; rc = balance(pCur, 1); if( rc==SQLITE_OK ){ moveToRoot(pCur); } end_insert: return rc; } SQLITE_PRIVATE int sqlite3BtreeDelete(BtCursor *pCur){ MemPage *pPage = pCur->apPage[pCur->iPage]; int idx; unsigned char *pCell; int rc; Pgno pgnoChild = 0; Btree *p = pCur->pBtree; BtShared *pBt = p->pBt; assert( cursorHoldsMutex(pCur) ); assert( pPage->isInit ); if( pBt->inTransaction!=TRANS_WRITE ){ rc = pBt->readOnly ? SQLITE_READONLY : SQLITE_ERROR; return rc; } assert( !pBt->readOnly ); if( pCur->eState==CURSOR_FAULT ){ return pCur->skip; } if( pCur->aiIdx[pCur->iPage]>=pPage->nCell ){ return SQLITE_ERROR; } if( !pCur->wrFlag ){ return SQLITE_PERM; } if( checkReadLocks(pCur->pBtree, pCur->pgnoRoot, pCur, pCur->info.nKey) ){ return SQLITE_LOCKED; } if( (rc = restoreCursorPosition(pCur))!=0 || (rc = saveAllCursors(pBt, pCur->pgnoRoot, pCur))!=0 || (rc = sqlite3PagerWrite(pPage->pDbPage))!=0 ){ return rc; } idx = pCur->aiIdx[pCur->iPage]; pCell = findCell(pPage, idx); if( !pPage->leaf ){ pgnoChild = get4byte(pCell); } rc = clearCell(pPage, pCell); if( rc ){ return rc; } if( !pPage->leaf ){ BtCursor leafCur; MemPage *pLeafPage; unsigned char *pNext; int notUsed; unsigned char *tempCell = 0; assert( !pPage->intKey ); sqlite3BtreeGetTempCursor(pCur, &leafCur); rc = sqlite3BtreeNext(&leafCur, &notUsed); if( rc==SQLITE_OK ){ assert( leafCur.aiIdx[leafCur.iPage]==0 ); pLeafPage = leafCur.apPage[leafCur.iPage]; rc = sqlite3PagerWrite(pLeafPage->pDbPage); } if( rc==SQLITE_OK ){ int leafCursorInvalid = 0; u16 szNext; TRACE(("DELETE: table=%d delete internal from %d replace from leaf %d\n", pCur->pgnoRoot, pPage->pgno, pLeafPage->pgno)); dropCell(pPage, idx, cellSizePtr(pPage, pCell)); pNext = findCell(pLeafPage, 0); szNext = cellSizePtr(pLeafPage, pNext); assert( MX_CELL_SIZE(pBt)>=szNext+4 ); allocateTempSpace(pBt); tempCell = pBt->pTmpSpace; if( tempCell==0 ){ rc = SQLITE_NOMEM; } if( rc==SQLITE_OK ){ rc = insertCell(pPage, idx, pNext-4, szNext+4, tempCell, 0); } testcase( pPage->nOverflow==0 && pPage->nFree<pBt->usableSize*2/3 && pLeafPage->nFree+2+szNext > pBt->usableSize*2/3 ); testcase( pPage->nOverflow==0 && pPage->nFree==pBt->usableSize*2/3 && pLeafPage->nFree+2+szNext > pBt->usableSize*2/3 ); testcase( pPage->nOverflow==0 && pPage->nFree==pBt->usableSize*2/3+1 && pLeafPage->nFree+2+szNext > pBt->usableSize*2/3 ); testcase( pPage->nOverflow>0 && pPage->nFree<=pBt->usableSize*2/3 && pLeafPage->nFree+2+szNext > pBt->usableSize*2/3 ); testcase( (pPage->nOverflow>0 || (pPage->nFree > pBt->usableSize*2/3)) && pLeafPage->nFree+2+szNext == pBt->usableSize*2/3 ); if( (pPage->nOverflow>0 || (pPage->nFree > pBt->usableSize*2/3)) && (pLeafPage->nFree+2+szNext > pBt->usableSize*2/3) ){ testcase( pPage->nFree==pBt->usableSize*2/3+1 ); testcase( pLeafPage->nFree+2+szNext==pBt->usableSize*2/3+1 ); leafCursorInvalid = 1; } if( rc==SQLITE_OK ){ put4byte(findOverflowCell(pPage, idx), pgnoChild); VVA_ONLY( pCur->pagesShuffled = 0 ); rc = balance(pCur, 0); } if( rc==SQLITE_OK && leafCursorInvalid ){ VVA_ONLY( Pgno leafPgno = pLeafPage->pgno ); rc = saveCursorPosition(&leafCur); if( rc==SQLITE_OK ){ rc = sqlite3BtreeNext(&leafCur, &notUsed); } pLeafPage = leafCur.apPage[leafCur.iPage]; assert( pLeafPage->pgno==leafPgno ); assert( leafCur.aiIdx[leafCur.iPage]==0 ); } if( rc==SQLITE_OK ){ rc = sqlite3PagerWrite(pLeafPage->pDbPage); } if( rc==SQLITE_OK ){ dropCell(pLeafPage, 0, szNext); VVA_ONLY( leafCur.pagesShuffled = 0 ); rc = balance(&leafCur, 0); assert( leafCursorInvalid || !leafCur.pagesShuffled || !pCur->pagesShuffled ); } } sqlite3BtreeReleaseTempCursor(&leafCur); }else{ TRACE(("DELETE: table=%d delete from leaf %d\n", pCur->pgnoRoot, pPage->pgno)); rc = dropCell(pPage, idx, cellSizePtr(pPage, pCell)); if( rc==SQLITE_OK ){ rc = balance(pCur, 0); } } if( rc==SQLITE_OK ){ moveToRoot(pCur); } return rc; } static int btreeCreateTable(Btree *p, int *piTable, int flags){ BtShared *pBt = p->pBt; MemPage *pRoot; Pgno pgnoRoot; int rc; assert( sqlite3BtreeHoldsMutex(p) ); if( pBt->inTransaction!=TRANS_WRITE ){ rc = pBt->readOnly ? SQLITE_READONLY : SQLITE_ERROR; return rc; } assert( !pBt->readOnly ); 
#ifdef SQLITE_OMIT_AUTOVACUUM 
 rc = allocateBtreePage(pBt, &pRoot, &pgnoRoot, 1, 0); if( rc ){ return rc; } 
#else 
 if( pBt->autoVacuum ){ Pgno pgnoMove; MemPage *pPageMove; invalidateAllOverflowCache(pBt); rc = sqlite3BtreeGetMeta(p, 4, &pgnoRoot); if( rc!=SQLITE_OK ){ return rc; } pgnoRoot++; while( pgnoRoot==PTRMAP_PAGENO(pBt, pgnoRoot) || pgnoRoot==PENDING_BYTE_PAGE(pBt) ){ pgnoRoot++; } assert( pgnoRoot>=3 ); rc = allocateBtreePage(pBt, &pPageMove, &pgnoMove, pgnoRoot, 1); if( rc!=SQLITE_OK ){ return rc; } if( pgnoMove!=pgnoRoot ){ u8 eType; Pgno iPtrPage; releasePage(pPageMove); rc = sqlite3BtreeGetPage(pBt, pgnoRoot, &pRoot, 0); if( rc!=SQLITE_OK ){ return rc; } rc = ptrmapGet(pBt, pgnoRoot, &eType, &iPtrPage); if( rc!=SQLITE_OK || eType==PTRMAP_ROOTPAGE || eType==PTRMAP_FREEPAGE ){ releasePage(pRoot); return rc; } assert( eType!=PTRMAP_ROOTPAGE ); assert( eType!=PTRMAP_FREEPAGE ); rc = sqlite3PagerWrite(pRoot->pDbPage); if( rc!=SQLITE_OK ){ releasePage(pRoot); return rc; } rc = relocatePage(pBt, pRoot, eType, iPtrPage, pgnoMove, 0); releasePage(pRoot); if( rc!=SQLITE_OK ){ return rc; } rc = sqlite3BtreeGetPage(pBt, pgnoRoot, &pRoot, 0); if( rc!=SQLITE_OK ){ return rc; } rc = sqlite3PagerWrite(pRoot->pDbPage); if( rc!=SQLITE_OK ){ releasePage(pRoot); return rc; } }else{ pRoot = pPageMove; } rc = ptrmapPut(pBt, pgnoRoot, PTRMAP_ROOTPAGE, 0); if( rc ){ releasePage(pRoot); return rc; } rc = sqlite3BtreeUpdateMeta(p, 4, pgnoRoot); if( rc ){ releasePage(pRoot); return rc; } }else{ rc = allocateBtreePage(pBt, &pRoot, &pgnoRoot, 1, 0); if( rc ) return rc; } 
#endif 
 assert( sqlite3PagerIswriteable(pRoot->pDbPage) ); zeroPage(pRoot, flags | PTF_LEAF); sqlite3PagerUnref(pRoot->pDbPage); *piTable = (int)pgnoRoot; return SQLITE_OK; } SQLITE_PRIVATE int sqlite3BtreeCreateTable(Btree *p, int *piTable, int flags){ int rc; sqlite3BtreeEnter(p); p->pBt->db = p->db; rc = btreeCreateTable(p, piTable, flags); sqlite3BtreeLeave(p); return rc; } static int clearDatabasePage( BtShared *pBt, Pgno pgno, int freePageFlag, int *pnChange ){ MemPage *pPage = 0; int rc; unsigned char *pCell; int i; assert( sqlite3_mutex_held(pBt->mutex) ); if( pgno>pagerPagecount(pBt) ){ return SQLITE_CORRUPT_BKPT; } rc = getAndInitPage(pBt, pgno, &pPage); if( rc ) goto cleardatabasepage_out; for(i=0; i<pPage->nCell; i++){ pCell = findCell(pPage, i); if( !pPage->leaf ){ rc = clearDatabasePage(pBt, get4byte(pCell), 1, pnChange); if( rc ) goto cleardatabasepage_out; } rc = clearCell(pPage, pCell); if( rc ) goto cleardatabasepage_out; } if( !pPage->leaf ){ rc = clearDatabasePage(pBt, get4byte(&pPage->aData[8]), 1, pnChange); if( rc ) goto cleardatabasepage_out; }else if( pnChange ){ assert( pPage->intKey ); *pnChange += pPage->nCell; } if( freePageFlag ){ rc = freePage(pPage); }else if( (rc = sqlite3PagerWrite(pPage->pDbPage))==0 ){ zeroPage(pPage, pPage->aData[0] | PTF_LEAF); } cleardatabasepage_out: releasePage(pPage); return rc; } SQLITE_PRIVATE int sqlite3BtreeClearTable(Btree *p, int iTable, int *pnChange){ int rc; BtShared *pBt = p->pBt; sqlite3BtreeEnter(p); pBt->db = p->db; if( p->inTrans!=TRANS_WRITE ){ rc = pBt->readOnly ? SQLITE_READONLY : SQLITE_ERROR; }else if( (rc = checkReadLocks(p, iTable, 0, 1))!=SQLITE_OK ){ }else if( SQLITE_OK!=(rc = saveAllCursors(pBt, iTable, 0)) ){ }else{ rc = clearDatabasePage(pBt, (Pgno)iTable, 0, pnChange); } sqlite3BtreeLeave(p); return rc; } static int btreeDropTable(Btree *p, Pgno iTable, int *piMoved){ int rc; MemPage *pPage = 0; BtShared *pBt = p->pBt; assert( sqlite3BtreeHoldsMutex(p) ); if( p->inTrans!=TRANS_WRITE ){ return pBt->readOnly ? SQLITE_READONLY : SQLITE_ERROR; } if( pBt->pCursor ){ return SQLITE_LOCKED; } rc = sqlite3BtreeGetPage(pBt, (Pgno)iTable, &pPage, 0); if( rc ) return rc; rc = sqlite3BtreeClearTable(p, iTable, 0); if( rc ){ releasePage(pPage); return rc; } *piMoved = 0; if( iTable>1 ){ 
#ifdef SQLITE_OMIT_AUTOVACUUM 
 rc = freePage(pPage); releasePage(pPage); 
#else 
 if( pBt->autoVacuum ){ Pgno maxRootPgno; rc = sqlite3BtreeGetMeta(p, 4, &maxRootPgno); if( rc!=SQLITE_OK ){ releasePage(pPage); return rc; } if( iTable==maxRootPgno ){ rc = freePage(pPage); releasePage(pPage); if( rc!=SQLITE_OK ){ return rc; } }else{ MemPage *pMove; releasePage(pPage); rc = sqlite3BtreeGetPage(pBt, maxRootPgno, &pMove, 0); if( rc!=SQLITE_OK ){ return rc; } rc = relocatePage(pBt, pMove, PTRMAP_ROOTPAGE, 0, iTable, 0); releasePage(pMove); if( rc!=SQLITE_OK ){ return rc; } rc = sqlite3BtreeGetPage(pBt, maxRootPgno, &pMove, 0); if( rc!=SQLITE_OK ){ return rc; } rc = freePage(pMove); releasePage(pMove); if( rc!=SQLITE_OK ){ return rc; } *piMoved = maxRootPgno; } maxRootPgno--; if( maxRootPgno==PENDING_BYTE_PAGE(pBt) ){ maxRootPgno--; } if( maxRootPgno==PTRMAP_PAGENO(pBt, maxRootPgno) ){ maxRootPgno--; } assert( maxRootPgno!=PENDING_BYTE_PAGE(pBt) ); rc = sqlite3BtreeUpdateMeta(p, 4, maxRootPgno); }else{ rc = freePage(pPage); releasePage(pPage); } 
#endif 
 }else{ zeroPage(pPage, PTF_INTKEY|PTF_LEAF ); releasePage(pPage); } return rc; } SQLITE_PRIVATE int sqlite3BtreeDropTable(Btree *p, int iTable, int *piMoved){ int rc; sqlite3BtreeEnter(p); p->pBt->db = p->db; rc = btreeDropTable(p, iTable, piMoved); sqlite3BtreeLeave(p); return rc; } SQLITE_PRIVATE int sqlite3BtreeGetMeta(Btree *p, int idx, u32 *pMeta){ DbPage *pDbPage; int rc; unsigned char *pP1; BtShared *pBt = p->pBt; sqlite3BtreeEnter(p); pBt->db = p->db; rc = queryTableLock(p, 1, READ_LOCK); if( rc!=SQLITE_OK ){ sqlite3BtreeLeave(p); return rc; } assert( idx>=0 && idx<=15 ); if( pBt->pPage1 ){ pP1 = (unsigned char *)pBt->pPage1->aData; }else{ rc = sqlite3PagerGet(pBt->pPager, 1, &pDbPage); if( rc ){ sqlite3BtreeLeave(p); return rc; } pP1 = (unsigned char *)sqlite3PagerGetData(pDbPage); } *pMeta = get4byte(&pP1[36 + idx*4]); if( !pBt->pPage1 ){ sqlite3PagerUnref(pDbPage); } 
#ifdef SQLITE_OMIT_AUTOVACUUM 
 if( idx==4 && *pMeta>0 ) pBt->readOnly = 1; 
#endif 
 rc = lockTable(p, 1, READ_LOCK); sqlite3BtreeLeave(p); return rc; } SQLITE_PRIVATE int sqlite3BtreeUpdateMeta(Btree *p, int idx, u32 iMeta){ BtShared *pBt = p->pBt; unsigned char *pP1; int rc; assert( idx>=1 && idx<=15 ); sqlite3BtreeEnter(p); pBt->db = p->db; if( p->inTrans!=TRANS_WRITE ){ rc = pBt->readOnly ? SQLITE_READONLY : SQLITE_ERROR; }else{ assert( pBt->pPage1!=0 ); pP1 = pBt->pPage1->aData; rc = sqlite3PagerWrite(pBt->pPage1->pDbPage); if( rc==SQLITE_OK ){ put4byte(&pP1[36 + idx*4], iMeta); 
#ifndef SQLITE_OMIT_AUTOVACUUM 
 if( idx==7 ){ assert( pBt->autoVacuum || iMeta==0 ); assert( iMeta==0 || iMeta==1 ); pBt->incrVacuum = iMeta; } 
#endif 
 } } sqlite3BtreeLeave(p); return rc; } SQLITE_PRIVATE int sqlite3BtreeFlags(BtCursor *pCur){ MemPage *pPage; restoreCursorPosition(pCur); pPage = pCur->apPage[pCur->iPage]; assert( cursorHoldsMutex(pCur) ); assert( pPage->pBt==pCur->pBt ); return pPage ? pPage->aData[pPage->hdrOffset] : 0; } SQLITE_PRIVATE Pager *sqlite3BtreePager(Btree *p){ return p->pBt->pPager; } 
#ifndef SQLITE_OMIT_INTEGRITY_CHECK 
static void checkAppendMsg( IntegrityCk *pCheck, char *zMsg1, const char *zFormat, ... ){ va_list ap; if( !pCheck->mxErr ) return; pCheck->mxErr--; pCheck->nErr++; va_start(ap, zFormat); if( pCheck->errMsg.nChar ){ sqlite3StrAccumAppend(&pCheck->errMsg, "\n", 1); } if( zMsg1 ){ sqlite3StrAccumAppend(&pCheck->errMsg, zMsg1, -1); } sqlite3VXPrintf(&pCheck->errMsg, 1, zFormat, ap); va_end(ap); if( pCheck->errMsg.mallocFailed ){ pCheck->mallocFailed = 1; } } 
#endif 
#ifndef SQLITE_OMIT_INTEGRITY_CHECK 
static int checkRef(IntegrityCk *pCheck, Pgno iPage, char *zContext){ if( iPage==0 ) return 1; if( iPage>pCheck->nPage ){ checkAppendMsg(pCheck, zContext, "invalid page number %d", iPage); return 1; } if( pCheck->anRef[iPage]==1 ){ checkAppendMsg(pCheck, zContext, "2nd reference to page %d", iPage); return 1; } return (pCheck->anRef[iPage]++)>1; } 
#ifndef SQLITE_OMIT_AUTOVACUUM 
static void checkPtrmap( IntegrityCk *pCheck, Pgno iChild, u8 eType, Pgno iParent, char *zContext ){ int rc; u8 ePtrmapType; Pgno iPtrmapParent; rc = ptrmapGet(pCheck->pBt, iChild, &ePtrmapType, &iPtrmapParent); if( rc!=SQLITE_OK ){ checkAppendMsg(pCheck, zContext, "Failed to read ptrmap key=%d", iChild); return; } if( ePtrmapType!=eType || iPtrmapParent!=iParent ){ checkAppendMsg(pCheck, zContext, "Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)", iChild, eType, iParent, ePtrmapType, iPtrmapParent); } } 
#endif 
static void checkList( IntegrityCk *pCheck, int isFreeList, int iPage, int N, char *zContext ){ int i; int expected = N; int iFirst = iPage; while( N-- > 0 && pCheck->mxErr ){ DbPage *pOvflPage; unsigned char *pOvflData; if( iPage<1 ){ checkAppendMsg(pCheck, zContext, "%d of %d pages missing from overflow list starting at %d", N+1, expected, iFirst); break; } if( checkRef(pCheck, iPage, zContext) ) break; if( sqlite3PagerGet(pCheck->pPager, (Pgno)iPage, &pOvflPage) ){ checkAppendMsg(pCheck, zContext, "failed to get page %d", iPage); break; } pOvflData = (unsigned char *)sqlite3PagerGetData(pOvflPage); if( isFreeList ){ int n = get4byte(&pOvflData[4]); 
#ifndef SQLITE_OMIT_AUTOVACUUM 
 if( pCheck->pBt->autoVacuum ){ checkPtrmap(pCheck, iPage, PTRMAP_FREEPAGE, 0, zContext); } 
#endif 
 if( n>pCheck->pBt->usableSize/4-2 ){ checkAppendMsg(pCheck, zContext, "freelist leaf count too big on page %d", iPage); N--; }else{ for(i=0; i<n; i++){ Pgno iFreePage = get4byte(&pOvflData[8+i*4]); 
#ifndef SQLITE_OMIT_AUTOVACUUM 
 if( pCheck->pBt->autoVacuum ){ checkPtrmap(pCheck, iFreePage, PTRMAP_FREEPAGE, 0, zContext); } 
#endif 
 checkRef(pCheck, iFreePage, zContext); } N -= n; } } 
#ifndef SQLITE_OMIT_AUTOVACUUM 
 else{ if( pCheck->pBt->autoVacuum && N>0 ){ i = get4byte(pOvflData); checkPtrmap(pCheck, i, PTRMAP_OVERFLOW2, iPage, zContext); } } 
#endif 
 iPage = get4byte(pOvflData); sqlite3PagerUnref(pOvflPage); } } 
#endif 
#ifndef SQLITE_OMIT_INTEGRITY_CHECK 
static int checkTreePage( IntegrityCk *pCheck, int iPage, char *zParentContext ){ MemPage *pPage; int i, rc, depth, d2, pgno, cnt; int hdr, cellStart; int nCell; u8 *data; BtShared *pBt; int usableSize; char zContext[100]; char *hit = 0; sqlite3_snprintf(sizeof(zContext), zContext, "Page %d: ", iPage); pBt = pCheck->pBt; usableSize = pBt->usableSize; if( iPage==0 ) return 0; if( checkRef(pCheck, iPage, zParentContext) ) return 0; if( (rc = sqlite3BtreeGetPage(pBt, (Pgno)iPage, &pPage, 0))!=0 ){ checkAppendMsg(pCheck, zContext, "unable to get the page. error code=%d", rc); return 0; } if( (rc = sqlite3BtreeInitPage(pPage))!=0 ){ checkAppendMsg(pCheck, zContext, "sqlite3BtreeInitPage() returns error code %d", rc); releasePage(pPage); return 0; } depth = 0; for(i=0; i<pPage->nCell && pCheck->mxErr; i++){ u8 *pCell; u32 sz; CellInfo info; sqlite3_snprintf(sizeof(zContext), zContext, "On tree page %d cell %d: ", iPage, i); pCell = findCell(pPage,i); sqlite3BtreeParseCellPtr(pPage, pCell, &info); sz = info.nData; if( !pPage->intKey ) sz += info.nKey; assert( sz==info.nPayload ); if( sz>info.nLocal ){ int nPage = (sz - info.nLocal + usableSize - 5)/(usableSize - 4); Pgno pgnoOvfl = get4byte(&pCell[info.iOverflow]); 
#ifndef SQLITE_OMIT_AUTOVACUUM 
 if( pBt->autoVacuum ){ checkPtrmap(pCheck, pgnoOvfl, PTRMAP_OVERFLOW1, iPage, zContext); } 
#endif 
 checkList(pCheck, 0, pgnoOvfl, nPage, zContext); } if( !pPage->leaf ){ pgno = get4byte(pCell); 
#ifndef SQLITE_OMIT_AUTOVACUUM 
 if( pBt->autoVacuum ){ checkPtrmap(pCheck, pgno, PTRMAP_BTREE, iPage, zContext); } 
#endif 
 d2 = checkTreePage(pCheck, pgno, zContext); if( i>0 && d2!=depth ){ checkAppendMsg(pCheck, zContext, "Child page depth differs"); } depth = d2; } } if( !pPage->leaf ){ pgno = get4byte(&pPage->aData[pPage->hdrOffset+8]); sqlite3_snprintf(sizeof(zContext), zContext, "On page %d at right child: ", iPage); 
#ifndef SQLITE_OMIT_AUTOVACUUM 
 if( pBt->autoVacuum ){ checkPtrmap(pCheck, pgno, PTRMAP_BTREE, iPage, 0); } 
#endif 
 checkTreePage(pCheck, pgno, zContext); } data = pPage->aData; hdr = pPage->hdrOffset; hit = sqlite3PageMalloc( pBt->pageSize ); if( hit==0 ){ pCheck->mallocFailed = 1; }else{ u16 contentOffset = get2byte(&data[hdr+5]); if (contentOffset > usableSize) { checkAppendMsg(pCheck, 0, "Corruption detected in header on page %d",iPage,0); goto check_page_abort; } memset(hit+contentOffset, 0, usableSize-contentOffset); memset(hit, 1, contentOffset); nCell = get2byte(&data[hdr+3]); cellStart = hdr + 12 - 4*pPage->leaf; for(i=0; i<nCell; i++){ int pc = get2byte(&data[cellStart+i*2]); u16 size = 1024; int j; if( pc<=usableSize ){ size = cellSizePtr(pPage, &data[pc]); } if( (pc+size-1)>=usableSize || pc<0 ){ checkAppendMsg(pCheck, 0, "Corruption detected in cell %d on page %d",i,iPage,0); }else{ for(j=pc+size-1; j>=pc; j--) hit[j]++; } } for(cnt=0, i=get2byte(&data[hdr+1]); i>0 && i<usableSize && cnt<10000; cnt++){ int size = get2byte(&data[i+2]); int j; if( (i+size-1)>=usableSize || i<0 ){ checkAppendMsg(pCheck, 0, "Corruption detected in cell %d on page %d",i,iPage,0); }else{ for(j=i+size-1; j>=i; j--) hit[j]++; } i = get2byte(&data[i]); } for(i=cnt=0; i<usableSize; i++){ if( hit[i]==0 ){ cnt++; }else if( hit[i]>1 ){ checkAppendMsg(pCheck, 0, "Multiple uses for byte %d of page %d", i, iPage); break; } } if( cnt!=data[hdr+7] ){ checkAppendMsg(pCheck, 0, "Fragmented space is %d byte reported as %d on page %d", cnt, data[hdr+7], iPage); } } check_page_abort: if (hit) sqlite3PageFree(hit); releasePage(pPage); return depth+1; } 
#endif 
#ifndef SQLITE_OMIT_INTEGRITY_CHECK 
SQLITE_PRIVATE char *sqlite3BtreeIntegrityCheck( Btree *p, int *aRoot, int nRoot, int mxErr, int *pnErr ){ Pgno i; int nRef; IntegrityCk sCheck; BtShared *pBt = p->pBt; char zErr[100]; sqlite3BtreeEnter(p); pBt->db = p->db; nRef = sqlite3PagerRefcount(pBt->pPager); if( lockBtreeWithRetry(p)!=SQLITE_OK ){ *pnErr = 1; sqlite3BtreeLeave(p); return sqlite3DbStrDup(0, "cannot acquire a read lock on the database"); } sCheck.pBt = pBt; sCheck.pPager = pBt->pPager; sCheck.nPage = pagerPagecount(sCheck.pBt); sCheck.mxErr = mxErr; sCheck.nErr = 0; sCheck.mallocFailed = 0; *pnErr = 0; 
#ifndef SQLITE_OMIT_AUTOVACUUM 
 if( pBt->nTrunc!=0 ){ sCheck.nPage = pBt->nTrunc; } 
#endif 
 if( sCheck.nPage==0 ){ unlockBtreeIfUnused(pBt); sqlite3BtreeLeave(p); return 0; } sCheck.anRef = sqlite3Malloc( (sCheck.nPage+1)*sizeof(sCheck.anRef[0]) ); if( !sCheck.anRef ){ unlockBtreeIfUnused(pBt); *pnErr = 1; sqlite3BtreeLeave(p); return 0; } for(i=0; i<=sCheck.nPage; i++){ sCheck.anRef[i] = 0; } i = PENDING_BYTE_PAGE(pBt); if( i<=sCheck.nPage ){ sCheck.anRef[i] = 1; } sqlite3StrAccumInit(&sCheck.errMsg, zErr, sizeof(zErr), 20000); checkList(&sCheck, 1, get4byte(&pBt->pPage1->aData[32]), get4byte(&pBt->pPage1->aData[36]), "Main freelist: "); for(i=0; (int)i<nRoot && sCheck.mxErr; i++){ if( aRoot[i]==0 ) continue; 
#ifndef SQLITE_OMIT_AUTOVACUUM 
 if( pBt->autoVacuum && aRoot[i]>1 ){ checkPtrmap(&sCheck, aRoot[i], PTRMAP_ROOTPAGE, 0, 0); } 
#endif 
 checkTreePage(&sCheck, aRoot[i], "List of tree roots: "); } for(i=1; i<=sCheck.nPage && sCheck.mxErr; i++){ 
#ifdef SQLITE_OMIT_AUTOVACUUM 
 if( sCheck.anRef[i]==0 ){ checkAppendMsg(&sCheck, 0, "Page %d is never used", i); } 
#else 
 if( sCheck.anRef[i]==0 && (PTRMAP_PAGENO(pBt, i)!=i || !pBt->autoVacuum) ){ checkAppendMsg(&sCheck, 0, "Page %d is never used", i); } if( sCheck.anRef[i]!=0 && (PTRMAP_PAGENO(pBt, i)==i && pBt->autoVacuum) ){ checkAppendMsg(&sCheck, 0, "Pointer map page %d is referenced", i); } 
#endif 
 } unlockBtreeIfUnused(pBt); if( nRef != sqlite3PagerRefcount(pBt->pPager) ){ checkAppendMsg(&sCheck, 0, "Outstanding page count goes from %d to %d during this analysis", nRef, sqlite3PagerRefcount(pBt->pPager) ); } sqlite3BtreeLeave(p); sqlite3_free(sCheck.anRef); if( sCheck.mallocFailed ){ sqlite3StrAccumReset(&sCheck.errMsg); *pnErr = sCheck.nErr+1; return 0; } *pnErr = sCheck.nErr; if( sCheck.nErr==0 ) sqlite3StrAccumReset(&sCheck.errMsg); return sqlite3StrAccumFinish(&sCheck.errMsg); } 
#endif 
SQLITE_PRIVATE const char *sqlite3BtreeGetFilename(Btree *p){ assert( p->pBt->pPager!=0 ); return sqlite3PagerFilename(p->pBt->pPager); } SQLITE_PRIVATE const char *sqlite3BtreeGetDirname(Btree *p){ assert( p->pBt->pPager!=0 ); return sqlite3PagerDirname(p->pBt->pPager); } SQLITE_PRIVATE const char *sqlite3BtreeGetJournalname(Btree *p){ assert( p->pBt->pPager!=0 ); return sqlite3PagerJournalname(p->pBt->pPager); } 
#ifndef SQLITE_OMIT_VACUUM 
static int btreeCopyFile(Btree *pTo, Btree *pFrom){ int rc = SQLITE_OK; Pgno i; Pgno nFromPage; Pgno nToPage; Pgno nNewPage; Pgno iSkip; int nToPageSize; int nFromPageSize; BtShared *pBtTo = pTo->pBt; BtShared *pBtFrom = pFrom->pBt; pBtTo->db = pTo->db; pBtFrom->db = pFrom->db; nToPageSize = pBtTo->pageSize; nFromPageSize = pBtFrom->pageSize; if( pTo->inTrans!=TRANS_WRITE || pFrom->inTrans!=TRANS_WRITE ){ return SQLITE_ERROR; } if( pBtTo->pCursor ){ return SQLITE_BUSY; } nToPage = pagerPagecount(pBtTo); nFromPage = pagerPagecount(pBtFrom); iSkip = PENDING_BYTE_PAGE(pBtTo); nNewPage = ((i64)nFromPage * (i64)nFromPageSize + (i64)nToPageSize - 1) / (i64)nToPageSize; for(i=1; rc==SQLITE_OK && (i<=nToPage || i<=nNewPage); i++){ if( i!=iSkip && i<=nToPage ){ DbPage *pDbPage = 0; rc = sqlite3PagerGet(pBtTo->pPager, i, &pDbPage); if( rc==SQLITE_OK ){ rc = sqlite3PagerWrite(pDbPage); if( rc==SQLITE_OK && i>nFromPage ){ rc = sqlite3PagerDontWrite(pDbPage); } sqlite3PagerUnref(pDbPage); } } if( rc==SQLITE_OK && i!=iSkip && i<=nNewPage ){ DbPage *pToPage = 0; sqlite3_int64 iOff; rc = sqlite3PagerGet(pBtTo->pPager, i, &pToPage); if( rc==SQLITE_OK ){ rc = sqlite3PagerWrite(pToPage); } for( iOff=(i-1)*nToPageSize; rc==SQLITE_OK && iOff<i*nToPageSize; iOff += nFromPageSize ){ DbPage *pFromPage = 0; Pgno iFrom = (iOff/nFromPageSize)+1; if( iFrom==PENDING_BYTE_PAGE(pBtFrom) ){ continue; } rc = sqlite3PagerGet(pBtFrom->pPager, iFrom, &pFromPage); if( rc==SQLITE_OK ){ char *zTo = sqlite3PagerGetData(pToPage); char *zFrom = sqlite3PagerGetData(pFromPage); int nCopy; if( nFromPageSize>=nToPageSize ){ zFrom += ((i-1)*nToPageSize - ((iFrom-1)*nFromPageSize)); nCopy = nToPageSize; }else{ zTo += (((iFrom-1)*nFromPageSize) - (i-1)*nToPageSize); nCopy = nFromPageSize; } memcpy(zTo, zFrom, nCopy); sqlite3PagerUnref(pFromPage); } } if( pToPage ){ MemPage *p = (MemPage *)sqlite3PagerGetExtra(pToPage); p->isInit = 0; sqlite3PagerUnref(pToPage); } } } if( rc==SQLITE_OK ){ if( nFromPageSize!=nToPageSize ){ sqlite3_file *pFile = sqlite3PagerFile(pBtTo->pPager); i64 iSize = (i64)nFromPageSize * (i64)nFromPage; i64 iNow = (i64)((nToPage>nNewPage)?nToPage:nNewPage) * (i64)nToPageSize; i64 iPending = ((i64)PENDING_BYTE_PAGE(pBtTo)-1) *(i64)nToPageSize; assert( iSize<=iNow ); pBtTo->db = pTo->db; rc = sqlite3PagerCommitPhaseOne(pBtTo->pPager, 0, 0, 1); if( iSize<iNow && rc==SQLITE_OK ){ rc = sqlite3OsTruncate(pFile, iSize); } if( rc==SQLITE_OK && nFromPageSize<nToPageSize && iSize>iPending){ i64 iOff; for( iOff=iPending; rc==SQLITE_OK && iOff<(iPending+nToPageSize); iOff += nFromPageSize ){ DbPage *pFromPage = 0; Pgno iFrom = (iOff/nFromPageSize)+1; if( iFrom==PENDING_BYTE_PAGE(pBtFrom) || iFrom>nFromPage ){ continue; } rc = sqlite3PagerGet(pBtFrom->pPager, iFrom, &pFromPage); if( rc==SQLITE_OK ){ char *zFrom = sqlite3PagerGetData(pFromPage); rc = sqlite3OsWrite(pFile, zFrom, nFromPageSize, iOff); sqlite3PagerUnref(pFromPage); } } } if( rc==SQLITE_OK ){ rc = sqlite3PagerSync(pBtTo->pPager); } }else{ rc = sqlite3PagerTruncate(pBtTo->pPager, nNewPage); } if( rc==SQLITE_OK ){ pBtTo->pageSizeFixed = 0; } } if( rc ){ sqlite3BtreeRollback(pTo); } return rc; } SQLITE_PRIVATE int sqlite3BtreeCopyFile(Btree *pTo, Btree *pFrom){ int rc; sqlite3BtreeEnter(pTo); sqlite3BtreeEnter(pFrom); rc = btreeCopyFile(pTo, pFrom); sqlite3BtreeLeave(pFrom); sqlite3BtreeLeave(pTo); return rc; } 
#endif 
SQLITE_PRIVATE int sqlite3BtreeIsInTrans(Btree *p){ assert( p==0 || sqlite3_mutex_held(p->db->mutex) ); return (p && (p->inTrans==TRANS_WRITE)); } SQLITE_PRIVATE int sqlite3BtreeIsInStmt(Btree *p){ assert( sqlite3BtreeHoldsMutex(p) ); return (p->pBt && p->pBt->inStmt); } SQLITE_PRIVATE int sqlite3BtreeIsInReadTrans(Btree *p){ assert( sqlite3_mutex_held(p->db->mutex) ); return (p && (p->inTrans!=TRANS_NONE)); } SQLITE_PRIVATE void *sqlite3BtreeSchema(Btree *p, int nBytes, void(*xFree)(void *)){ BtShared *pBt = p->pBt; sqlite3BtreeEnter(p); if( !pBt->pSchema && nBytes ){ pBt->pSchema = sqlite3MallocZero(nBytes); pBt->xFreeSchema = xFree; } sqlite3BtreeLeave(p); return pBt->pSchema; } SQLITE_PRIVATE int sqlite3BtreeSchemaLocked(Btree *p){ int rc; assert( sqlite3_mutex_held(p->db->mutex) ); sqlite3BtreeEnter(p); rc = (queryTableLock(p, MASTER_ROOT, READ_LOCK)!=SQLITE_OK); sqlite3BtreeLeave(p); return rc; } 
#ifndef SQLITE_OMIT_SHARED_CACHE 
SQLITE_PRIVATE int sqlite3BtreeLockTable(Btree *p, int iTab, u8 isWriteLock){ int rc = SQLITE_OK; if( p->sharable ){ u8 lockType = READ_LOCK + isWriteLock; assert( READ_LOCK+1==WRITE_LOCK ); assert( isWriteLock==0 || isWriteLock==1 ); sqlite3BtreeEnter(p); rc = queryTableLock(p, iTab, lockType); if( rc==SQLITE_OK ){ rc = lockTable(p, iTab, lockType); } sqlite3BtreeLeave(p); } return rc; } 
#endif 
#ifndef SQLITE_OMIT_INCRBLOB 
SQLITE_PRIVATE int sqlite3BtreePutData(BtCursor *pCsr, u32 offset, u32 amt, void *z){ assert( cursorHoldsMutex(pCsr) ); assert( sqlite3_mutex_held(pCsr->pBtree->db->mutex) ); assert(pCsr->isIncrblobHandle); restoreCursorPosition(pCsr); assert( pCsr->eState!=CURSOR_REQUIRESEEK ); if( pCsr->eState!=CURSOR_VALID ){ return SQLITE_ABORT; } if( !pCsr->wrFlag ){ return SQLITE_READONLY; } assert( !pCsr->pBt->readOnly && pCsr->pBt->inTransaction==TRANS_WRITE ); if( checkReadLocks(pCsr->pBtree, pCsr->pgnoRoot, pCsr, 0) ){ return SQLITE_LOCKED; } if( pCsr->eState==CURSOR_INVALID || !pCsr->apPage[pCsr->iPage]->intKey ){ return SQLITE_ERROR; } return accessPayload(pCsr, offset, amt, (unsigned char *)z, 0, 1); } SQLITE_PRIVATE void sqlite3BtreeCacheOverflow(BtCursor *pCur){ assert( cursorHoldsMutex(pCur) ); assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) ); assert(!pCur->isIncrblobHandle); assert(!pCur->aOverflow); pCur->isIncrblobHandle = 1; } 
#endif 
#define FIFOSIZE_FIRST (((128-sizeof(FifoPage))/8)+1) 
#ifdef SQLITE_MALLOC_SOFT_LIMIT 
#define FIFOSIZE_MAX (int)(((SQLITE_MALLOC_SOFT_LIMIT-sizeof(FifoPage))/8)+1) 
#else 
#define FIFOSIZE_MAX (int)(((262144-sizeof(FifoPage))/8)+1) 
#endif 
static FifoPage *allocateFifoPage(sqlite3 *db, int nEntry){ FifoPage *pPage; if( nEntry>FIFOSIZE_MAX ){ nEntry = FIFOSIZE_MAX; } pPage = sqlite3DbMallocRaw(db, sizeof(FifoPage) + sizeof(i64)*(nEntry-1) ); if( pPage ){ pPage->nSlot = nEntry; pPage->iWrite = 0; pPage->iRead = 0; pPage->pNext = 0; } return pPage; } SQLITE_PRIVATE void sqlite3VdbeFifoInit(Fifo *pFifo, sqlite3 *db){ memset(pFifo, 0, sizeof(*pFifo)); pFifo->db = db; } SQLITE_PRIVATE int sqlite3VdbeFifoPush(Fifo *pFifo, i64 val){ FifoPage *pPage; pPage = pFifo->pLast; if( pPage==0 ){ pPage = pFifo->pLast = pFifo->pFirst = allocateFifoPage(pFifo->db, FIFOSIZE_FIRST); if( pPage==0 ){ return SQLITE_NOMEM; } }else if( pPage->iWrite>=pPage->nSlot ){ pPage->pNext = allocateFifoPage(pFifo->db, pFifo->nEntry); if( pPage->pNext==0 ){ return SQLITE_NOMEM; } pPage = pFifo->pLast = pPage->pNext; } pPage->aSlot[pPage->iWrite++] = val; pFifo->nEntry++; return SQLITE_OK; } SQLITE_PRIVATE int sqlite3VdbeFifoPop(Fifo *pFifo, i64 *pVal){ FifoPage *pPage; if( pFifo->nEntry==0 ){ return SQLITE_DONE; } assert( pFifo->nEntry>0 ); pPage = pFifo->pFirst; assert( pPage!=0 ); assert( pPage->iWrite>pPage->iRead ); assert( pPage->iWrite<=pPage->nSlot ); assert( pPage->iRead<pPage->nSlot ); assert( pPage->iRead>=0 ); *pVal = pPage->aSlot[pPage->iRead++]; pFifo->nEntry--; if( pPage->iRead>=pPage->iWrite ){ pFifo->pFirst = pPage->pNext; sqlite3DbFree(pFifo->db, pPage); if( pFifo->nEntry==0 ){ assert( pFifo->pLast==pPage ); pFifo->pLast = 0; }else{ assert( pFifo->pFirst!=0 ); } }else{ assert( pFifo->nEntry>0 ); } return SQLITE_OK; } SQLITE_PRIVATE void sqlite3VdbeFifoClear(Fifo *pFifo){ FifoPage *pPage, *pNextPage; for(pPage=pFifo->pFirst; pPage; pPage=pNextPage){ pNextPage = pPage->pNext; sqlite3DbFree(pFifo->db, pPage); } sqlite3VdbeFifoInit(pFifo, pFifo->db); } 
#define expandBlob(P) (((P)->flags&MEM_Zero)?sqlite3VdbeMemExpandBlob(P):0) 
SQLITE_PRIVATE int sqlite3VdbeChangeEncoding(Mem *pMem, int desiredEnc){ int rc; if( !(pMem->flags&MEM_Str) || pMem->enc==desiredEnc ){ return SQLITE_OK; } assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) ); 
#ifdef SQLITE_OMIT_UTF16 
 return SQLITE_ERROR; 
#else 
 rc = sqlite3VdbeMemTranslate(pMem, desiredEnc); assert(rc==SQLITE_OK || rc==SQLITE_NOMEM); assert(rc==SQLITE_OK || pMem->enc!=desiredEnc); assert(rc==SQLITE_NOMEM || pMem->enc==desiredEnc); return rc; 
#endif 
} SQLITE_PRIVATE int sqlite3VdbeMemGrow(Mem *pMem, int n, int preserve){ assert( 1 >= ((pMem->zMalloc && pMem->zMalloc==pMem->z) ? 1 : 0) + (((pMem->flags&MEM_Dyn)&&pMem->xDel) ? 1 : 0) + ((pMem->flags&MEM_Ephem) ? 1 : 0) + ((pMem->flags&MEM_Static) ? 1 : 0) ); if( n<32 ) n = 32; if( sqlite3DbMallocSize(pMem->db, pMem->zMalloc)<n ){ if( preserve && pMem->z==pMem->zMalloc ){ pMem->z = pMem->zMalloc = sqlite3DbReallocOrFree(pMem->db, pMem->z, n); preserve = 0; }else{ sqlite3DbFree(pMem->db, pMem->zMalloc); pMem->zMalloc = sqlite3DbMallocRaw(pMem->db, n); } } if( preserve && pMem->z && pMem->zMalloc && pMem->z!=pMem->zMalloc ){ memcpy(pMem->zMalloc, pMem->z, pMem->n); } if( pMem->flags&MEM_Dyn && pMem->xDel ){ pMem->xDel((void *)(pMem->z)); } pMem->z = pMem->zMalloc; if( pMem->z==0 ){ pMem->flags = MEM_Null; }else{ pMem->flags &= ~(MEM_Ephem|MEM_Static); } pMem->xDel = 0; return (pMem->z ? SQLITE_OK : SQLITE_NOMEM); } SQLITE_PRIVATE int sqlite3VdbeMemMakeWriteable(Mem *pMem){ int f; assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) ); expandBlob(pMem); f = pMem->flags; if( (f&(MEM_Str|MEM_Blob)) && pMem->z!=pMem->zMalloc ){ if( sqlite3VdbeMemGrow(pMem, pMem->n + 2, 1) ){ return SQLITE_NOMEM; } pMem->z[pMem->n] = 0; pMem->z[pMem->n+1] = 0; pMem->flags |= MEM_Term; } return SQLITE_OK; } 
#ifndef SQLITE_OMIT_INCRBLOB 
SQLITE_PRIVATE int sqlite3VdbeMemExpandBlob(Mem *pMem){ if( pMem->flags & MEM_Zero ){ int nByte; assert( pMem->flags&MEM_Blob ); assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) ); nByte = pMem->n + pMem->u.i; if( nByte<=0 ){ nByte = 1; } if( sqlite3VdbeMemGrow(pMem, nByte, 1) ){ return SQLITE_NOMEM; } memset(&pMem->z[pMem->n], 0, pMem->u.i); pMem->n += pMem->u.i; pMem->flags &= ~(MEM_Zero|MEM_Term); } return SQLITE_OK; } 
#endif 
SQLITE_PRIVATE int sqlite3VdbeMemNulTerminate(Mem *pMem){ assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) ); if( (pMem->flags & MEM_Term)!=0 || (pMem->flags & MEM_Str)==0 ){ return SQLITE_OK; } if( sqlite3VdbeMemGrow(pMem, pMem->n+2, 1) ){ return SQLITE_NOMEM; } pMem->z[pMem->n] = 0; pMem->z[pMem->n+1] = 0; pMem->flags |= MEM_Term; return SQLITE_OK; } SQLITE_PRIVATE int sqlite3VdbeMemStringify(Mem *pMem, int enc){ int rc = SQLITE_OK; int fg = pMem->flags; const int nByte = 32; assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) ); assert( !(fg&MEM_Zero) ); assert( !(fg&(MEM_Str|MEM_Blob)) ); assert( fg&(MEM_Int|MEM_Real) ); if( sqlite3VdbeMemGrow(pMem, nByte, 0) ){ return SQLITE_NOMEM; } if( fg & MEM_Int ){ sqlite3_snprintf(nByte, pMem->z, "%lld", pMem->u.i); }else{ assert( fg & MEM_Real ); sqlite3_snprintf(nByte, pMem->z, "%!.15g", pMem->r); } pMem->n = strlen(pMem->z); pMem->enc = SQLITE_UTF8; pMem->flags |= MEM_Str|MEM_Term; sqlite3VdbeChangeEncoding(pMem, enc); return rc; } SQLITE_PRIVATE int sqlite3VdbeMemFinalize(Mem *pMem, FuncDef *pFunc){ int rc = SQLITE_OK; if( pFunc && pFunc->xFinalize ){ sqlite3_context ctx; assert( (pMem->flags & MEM_Null)!=0 || pFunc==pMem->u.pDef ); assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) ); memset(&ctx, 0, sizeof(ctx)); ctx.s.flags = MEM_Null; ctx.s.db = pMem->db; ctx.pMem = pMem; ctx.pFunc = pFunc; pFunc->xFinalize(&ctx); assert( 0==(pMem->flags&MEM_Dyn) && !pMem->xDel ); sqlite3DbFree(pMem->db, pMem->zMalloc); *pMem = ctx.s; rc = (ctx.isError?SQLITE_ERROR:SQLITE_OK); } return rc; } SQLITE_PRIVATE void sqlite3VdbeMemReleaseExternal(Mem *p){ assert( p->db==0 || sqlite3_mutex_held(p->db->mutex) ); if( p->flags&MEM_Agg ){ sqlite3VdbeMemFinalize(p, p->u.pDef); assert( (p->flags & MEM_Agg)==0 ); sqlite3VdbeMemRelease(p); }else if( p->flags&MEM_Dyn && p->xDel ){ p->xDel((void *)p->z); p->xDel = 0; } } SQLITE_PRIVATE void sqlite3VdbeMemRelease(Mem *p){ sqlite3VdbeMemReleaseExternal(p); sqlite3DbFree(p->db, p->zMalloc); p->z = 0; p->zMalloc = 0; p->xDel = 0; } static i64 doubleToInt64(double r){ static const i64 maxInt = LARGEST_INT64; static const i64 minInt = SMALLEST_INT64; if( r<(double)minInt ){ return minInt; }else if( r>(double)maxInt ){ return minInt; }else{ return (i64)r; } } SQLITE_PRIVATE i64 sqlite3VdbeIntValue(Mem *pMem){ int flags; assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) ); flags = pMem->flags; if( flags & MEM_Int ){ return pMem->u.i; }else if( flags & MEM_Real ){ return doubleToInt64(pMem->r); }else if( flags & (MEM_Str|MEM_Blob) ){ i64 value; pMem->flags |= MEM_Str; if( sqlite3VdbeChangeEncoding(pMem, SQLITE_UTF8) || sqlite3VdbeMemNulTerminate(pMem) ){ return 0; } assert( pMem->z ); sqlite3Atoi64(pMem->z, &value); return value; }else{ return 0; } } SQLITE_PRIVATE double sqlite3VdbeRealValue(Mem *pMem){ assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) ); if( pMem->flags & MEM_Real ){ return pMem->r; }else if( pMem->flags & MEM_Int ){ return (double)pMem->u.i; }else if( pMem->flags & (MEM_Str|MEM_Blob) ){ double val = 0.0; pMem->flags |= MEM_Str; if( sqlite3VdbeChangeEncoding(pMem, SQLITE_UTF8) || sqlite3VdbeMemNulTerminate(pMem) ){ return 0.0; } assert( pMem->z ); sqlite3AtoF(pMem->z, &val); return val; }else{ return 0.0; } } SQLITE_PRIVATE void sqlite3VdbeIntegerAffinity(Mem *pMem){ assert( pMem->flags & MEM_Real ); assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) ); pMem->u.i = doubleToInt64(pMem->r); if( pMem->r==(double)pMem->u.i ){ pMem->flags |= MEM_Int; } } static void setTypeFlag(Mem *pMem, int f){ MemSetTypeFlag(pMem, f); } SQLITE_PRIVATE int sqlite3VdbeMemIntegerify(Mem *pMem){ assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) ); pMem->u.i = sqlite3VdbeIntValue(pMem); setTypeFlag(pMem, MEM_Int); return SQLITE_OK; } SQLITE_PRIVATE int sqlite3VdbeMemRealify(Mem *pMem){ assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) ); pMem->r = sqlite3VdbeRealValue(pMem); setTypeFlag(pMem, MEM_Real); return SQLITE_OK; } SQLITE_PRIVATE int sqlite3VdbeMemNumerify(Mem *pMem){ double r1, r2; i64 i; assert( (pMem->flags & (MEM_Int|MEM_Real|MEM_Null))==0 ); assert( (pMem->flags & (MEM_Blob|MEM_Str))!=0 ); assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) ); r1 = sqlite3VdbeRealValue(pMem); i = doubleToInt64(r1); r2 = (double)i; if( r1==r2 ){ sqlite3VdbeMemIntegerify(pMem); }else{ pMem->r = r1; setTypeFlag(pMem, MEM_Real); } return SQLITE_OK; } SQLITE_PRIVATE void sqlite3VdbeMemSetNull(Mem *pMem){ setTypeFlag(pMem, MEM_Null); pMem->type = SQLITE_NULL; } SQLITE_PRIVATE void sqlite3VdbeMemSetZeroBlob(Mem *pMem, int n){ sqlite3VdbeMemRelease(pMem); setTypeFlag(pMem, MEM_Blob); pMem->flags = MEM_Blob|MEM_Zero; pMem->type = SQLITE_BLOB; pMem->n = 0; if( n<0 ) n = 0; pMem->u.i = n; pMem->enc = SQLITE_UTF8; } SQLITE_PRIVATE void sqlite3VdbeMemSetInt64(Mem *pMem, i64 val){ sqlite3VdbeMemRelease(pMem); pMem->u.i = val; pMem->flags = MEM_Int; pMem->type = SQLITE_INTEGER; } SQLITE_PRIVATE void sqlite3VdbeMemSetDouble(Mem *pMem, double val){ if( sqlite3IsNaN(val) ){ sqlite3VdbeMemSetNull(pMem); }else{ sqlite3VdbeMemRelease(pMem); pMem->r = val; pMem->flags = MEM_Real; pMem->type = SQLITE_FLOAT; } } SQLITE_PRIVATE int sqlite3VdbeMemTooBig(Mem *p){ assert( p->db!=0 ); if( p->flags & (MEM_Str|MEM_Blob) ){ int n = p->n; if( p->flags & MEM_Zero ){ n += p->u.i; } return n>p->db->aLimit[SQLITE_LIMIT_LENGTH]; } return 0; } 
#define MEMCELLSIZE (size_t)(&(((Mem *)0)->zMalloc)) 
SQLITE_PRIVATE void sqlite3VdbeMemShallowCopy(Mem *pTo, const Mem *pFrom, int srcType){ sqlite3VdbeMemReleaseExternal(pTo); memcpy(pTo, pFrom, MEMCELLSIZE); pTo->xDel = 0; if( (pFrom->flags&MEM_Dyn)!=0 || pFrom->z==pFrom->zMalloc ){ pTo->flags &= ~(MEM_Dyn|MEM_Static|MEM_Ephem); assert( srcType==MEM_Ephem || srcType==MEM_Static ); pTo->flags |= srcType; } } SQLITE_PRIVATE int sqlite3VdbeMemCopy(Mem *pTo, const Mem *pFrom){ int rc = SQLITE_OK; sqlite3VdbeMemReleaseExternal(pTo); memcpy(pTo, pFrom, MEMCELLSIZE); pTo->flags &= ~MEM_Dyn; if( pTo->flags&(MEM_Str|MEM_Blob) ){ if( 0==(pFrom->flags&MEM_Static) ){ pTo->flags |= MEM_Ephem; rc = sqlite3VdbeMemMakeWriteable(pTo); } } return rc; } SQLITE_PRIVATE void sqlite3VdbeMemMove(Mem *pTo, Mem *pFrom){ assert( pFrom->db==0 || sqlite3_mutex_held(pFrom->db->mutex) ); assert( pTo->db==0 || sqlite3_mutex_held(pTo->db->mutex) ); assert( pFrom->db==0 || pTo->db==0 || pFrom->db==pTo->db ); sqlite3VdbeMemRelease(pTo); memcpy(pTo, pFrom, sizeof(Mem)); pFrom->flags = MEM_Null; pFrom->xDel = 0; pFrom->zMalloc = 0; } SQLITE_PRIVATE int sqlite3VdbeMemSetStr( Mem *pMem, const char *z, int n, u8 enc, void (*xDel)(void*) ){ int nByte = n; int iLimit; int flags = 0; assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) ); if( !z ){ sqlite3VdbeMemSetNull(pMem); return SQLITE_OK; } if( pMem->db ){ iLimit = pMem->db->aLimit[SQLITE_LIMIT_LENGTH]; }else{ iLimit = SQLITE_MAX_LENGTH; } flags = (enc==0?MEM_Blob:MEM_Str); if( nByte<0 ){ assert( enc!=0 ); if( enc==SQLITE_UTF8 ){ for(nByte=0; nByte<=iLimit && z[nByte]; nByte++){} }else{ for(nByte=0; nByte<=iLimit && (z[nByte] | z[nByte+1]); nByte+=2){} } flags |= MEM_Term; } if( xDel==SQLITE_TRANSIENT ){ int nAlloc = nByte; if( flags&MEM_Term ){ nAlloc += (enc==SQLITE_UTF8?1:2); } if( nByte>iLimit ){ return SQLITE_TOOBIG; } if( sqlite3VdbeMemGrow(pMem, nAlloc, 0) ){ return SQLITE_NOMEM; } memcpy(pMem->z, z, nAlloc); }else if( xDel==SQLITE_DYNAMIC ){ sqlite3VdbeMemRelease(pMem); pMem->zMalloc = pMem->z = (char *)z; pMem->xDel = 0; }else{ sqlite3VdbeMemRelease(pMem); pMem->z = (char *)z; pMem->xDel = xDel; flags |= ((xDel==SQLITE_STATIC)?MEM_Static:MEM_Dyn); } if( nByte>iLimit ){ return SQLITE_TOOBIG; } pMem->n = nByte; pMem->flags = flags; pMem->enc = (enc==0 ? SQLITE_UTF8 : enc); pMem->type = (enc==0 ? SQLITE_BLOB : SQLITE_TEXT); 
#ifndef SQLITE_OMIT_UTF16 
 if( pMem->enc!=SQLITE_UTF8 && sqlite3VdbeMemHandleBom(pMem) ){ return SQLITE_NOMEM; } 
#endif 
 return SQLITE_OK; } SQLITE_PRIVATE int sqlite3MemCompare(const Mem *pMem1, const Mem *pMem2, const CollSeq *pColl){ int rc; int f1, f2; int combined_flags; f1 = pMem1->flags; f2 = pMem2->flags; combined_flags = f1|f2; if( combined_flags&MEM_Null ){ return (f2&MEM_Null) - (f1&MEM_Null); } if( combined_flags&(MEM_Int|MEM_Real) ){ if( !(f1&(MEM_Int|MEM_Real)) ){ return 1; } if( !(f2&(MEM_Int|MEM_Real)) ){ return -1; } if( (f1 & f2 & MEM_Int)==0 ){ double r1, r2; if( (f1&MEM_Real)==0 ){ r1 = pMem1->u.i; }else{ r1 = pMem1->r; } if( (f2&MEM_Real)==0 ){ r2 = pMem2->u.i; }else{ r2 = pMem2->r; } if( r1<r2 ) return -1; if( r1>r2 ) return 1; return 0; }else{ assert( f1&MEM_Int ); assert( f2&MEM_Int ); if( pMem1->u.i < pMem2->u.i ) return -1; if( pMem1->u.i > pMem2->u.i ) return 1; return 0; } } if( combined_flags&MEM_Str ){ if( (f1 & MEM_Str)==0 ){ return 1; } if( (f2 & MEM_Str)==0 ){ return -1; } assert( pMem1->enc==pMem2->enc ); assert( pMem1->enc==SQLITE_UTF8 || pMem1->enc==SQLITE_UTF16LE || pMem1->enc==SQLITE_UTF16BE ); assert( !pColl || pColl->xCmp ); if( pColl ){ if( pMem1->enc==pColl->enc ){ return pColl->xCmp(pColl->pUser,pMem1->n,pMem1->z,pMem2->n,pMem2->z); }else{ const void *v1, *v2; int n1, n2; Mem c1; Mem c2; memset(&c1, 0, sizeof(c1)); memset(&c2, 0, sizeof(c2)); sqlite3VdbeMemShallowCopy(&c1, pMem1, MEM_Ephem); sqlite3VdbeMemShallowCopy(&c2, pMem2, MEM_Ephem); v1 = sqlite3ValueText((sqlite3_value*)&c1, pColl->enc); n1 = v1==0 ? 0 : c1.n; v2 = sqlite3ValueText((sqlite3_value*)&c2, pColl->enc); n2 = v2==0 ? 0 : c2.n; rc = pColl->xCmp(pColl->pUser, n1, v1, n2, v2); sqlite3VdbeMemRelease(&c1); sqlite3VdbeMemRelease(&c2); return rc; } } } rc = memcmp(pMem1->z, pMem2->z, (pMem1->n>pMem2->n)?pMem2->n:pMem1->n); if( rc==0 ){ rc = pMem1->n - pMem2->n; } return rc; } SQLITE_PRIVATE int sqlite3VdbeMemFromBtree( BtCursor *pCur, int offset, int amt, int key, Mem *pMem ){ char *zData; int available = 0; sqlite3 *db; int rc = SQLITE_OK; db = sqlite3BtreeCursorDb(pCur); assert( sqlite3_mutex_held(db->mutex) ); if( key ){ zData = (char *)sqlite3BtreeKeyFetch(pCur, &available); }else{ zData = (char *)sqlite3BtreeDataFetch(pCur, &available); } assert( zData!=0 ); if( offset+amt<=available && ((pMem->flags&MEM_Dyn)==0 || pMem->xDel) ){ sqlite3VdbeMemRelease(pMem); pMem->z = &zData[offset]; pMem->flags = MEM_Blob|MEM_Ephem; }else if( SQLITE_OK==(rc = sqlite3VdbeMemGrow(pMem, amt+2, 0)) ){ pMem->flags = MEM_Blob|MEM_Dyn|MEM_Term; pMem->enc = 0; pMem->type = SQLITE_BLOB; if( key ){ rc = sqlite3BtreeKey(pCur, offset, amt, pMem->z); }else{ rc = sqlite3BtreeData(pCur, offset, amt, pMem->z); } pMem->z[amt] = 0; pMem->z[amt+1] = 0; if( rc!=SQLITE_OK ){ sqlite3VdbeMemRelease(pMem); } } pMem->n = amt; return rc; } 
#if 0 
SQLITE_PRIVATE void sqlite3VdbeMemSanity(Mem *pMem){ int flags = pMem->flags; assert( flags!=0 ); if( flags & (MEM_Str|MEM_Blob) ){ int x = flags & (MEM_Static|MEM_Dyn|MEM_Ephem|MEM_Short); assert( x!=0 ); assert( (x & (x-1))==0 ); assert( pMem->z!=0 ); assert( (x & MEM_Short)==0 || pMem->z==pMem->zShort ); assert( (x & MEM_Short)!=0 || pMem->z!=pMem->zShort ); assert( pMem->xDel==0 || (pMem->flags & MEM_Dyn)!=0 ); if( (flags & MEM_Str) ){ assert( pMem->enc==SQLITE_UTF8 || pMem->enc==SQLITE_UTF16BE || pMem->enc==SQLITE_UTF16LE ); if( pMem->enc==SQLITE_UTF8 && (flags & MEM_Term) ){ assert( strlen(pMem->z)<=pMem->n ); assert( pMem->z[pMem->n]==0 ); } } }else{ assert( (pMem->flags & (MEM_Static|MEM_Dyn|MEM_Ephem|MEM_Short))==0 ); assert( pMem->xDel==0 ); } assert( (pMem->flags&(MEM_Str|MEM_Int|MEM_Real|MEM_Blob))==0 || (pMem->flags&MEM_Null)==0 ); assert( (pMem->flags & (MEM_Int|MEM_Real))!=(MEM_Int|MEM_Real) || pMem->r==pMem->u.i ); } 
#endif 
SQLITE_PRIVATE const void *sqlite3ValueText(sqlite3_value* pVal, u8 enc){ if( !pVal ) return 0; assert( pVal->db==0 || sqlite3_mutex_held(pVal->db->mutex) ); assert( (enc&3)==(enc&~SQLITE_UTF16_ALIGNED) ); if( pVal->flags&MEM_Null ){ return 0; } assert( (MEM_Blob>>3) == MEM_Str ); pVal->flags |= (pVal->flags & MEM_Blob)>>3; expandBlob(pVal); if( pVal->flags&MEM_Str ){ sqlite3VdbeChangeEncoding(pVal, enc & ~SQLITE_UTF16_ALIGNED); if( (enc & SQLITE_UTF16_ALIGNED)!=0 && 1==(1&SQLITE_PTR_TO_INT(pVal->z)) ){ assert( (pVal->flags & (MEM_Ephem|MEM_Static))!=0 ); if( sqlite3VdbeMemMakeWriteable(pVal)!=SQLITE_OK ){ return 0; } } sqlite3VdbeMemNulTerminate(pVal); }else{ assert( (pVal->flags&MEM_Blob)==0 ); sqlite3VdbeMemStringify(pVal, enc); assert( 0==(1&(int)pVal->z) ); } assert(pVal->enc==(enc & ~SQLITE_UTF16_ALIGNED) || pVal->db==0 || pVal->db->mallocFailed ); if( pVal->enc==(enc & ~SQLITE_UTF16_ALIGNED) ){ return pVal->z; }else{ return 0; } } SQLITE_PRIVATE sqlite3_value *sqlite3ValueNew(sqlite3 *db){ Mem *p = sqlite3DbMallocZero(db, sizeof(*p)); if( p ){ p->flags = MEM_Null; p->type = SQLITE_NULL; p->db = db; } return p; } SQLITE_PRIVATE int sqlite3ValueFromExpr( sqlite3 *db, Expr *pExpr, u8 enc, u8 affinity, sqlite3_value **ppVal ){ int op; char *zVal = 0; sqlite3_value *pVal = 0; if( !pExpr ){ *ppVal = 0; return SQLITE_OK; } op = pExpr->op; if( op==TK_STRING || op==TK_FLOAT || op==TK_INTEGER ){ zVal = sqlite3DbStrNDup(db, (char*)pExpr->token.z, pExpr->token.n); pVal = sqlite3ValueNew(db); if( !zVal || !pVal ) goto no_mem; sqlite3Dequote(zVal); sqlite3ValueSetStr(pVal, -1, zVal, SQLITE_UTF8, SQLITE_DYNAMIC); if( (op==TK_INTEGER || op==TK_FLOAT ) && affinity==SQLITE_AFF_NONE ){ sqlite3ValueApplyAffinity(pVal, SQLITE_AFF_NUMERIC, enc); }else{ sqlite3ValueApplyAffinity(pVal, affinity, enc); } }else if( op==TK_UMINUS ) { if( SQLITE_OK==sqlite3ValueFromExpr(db,pExpr->pLeft,enc,affinity,&pVal) ){ pVal->u.i = -1 * pVal->u.i; pVal->r = -1.0 * pVal->r; } } 
#ifndef SQLITE_OMIT_BLOB_LITERAL 
 else if( op==TK_BLOB ){ int nVal; assert( pExpr->token.n>=3 ); assert( pExpr->token.z[0]=='x' || pExpr->token.z[0]=='X' ); assert( pExpr->token.z[1]=='\'' ); assert( pExpr->token.z[pExpr->token.n-1]=='\'' ); pVal = sqlite3ValueNew(db); if( !pVal ) goto no_mem; nVal = pExpr->token.n - 3; zVal = (char*)pExpr->token.z + 2; sqlite3VdbeMemSetStr(pVal, sqlite3HexToBlob(db, zVal, nVal), nVal/2, 0, SQLITE_DYNAMIC); } 
#endif 
 *ppVal = pVal; return SQLITE_OK; no_mem: db->mallocFailed = 1; sqlite3DbFree(db, zVal); sqlite3ValueFree(pVal); *ppVal = 0; return SQLITE_NOMEM; } SQLITE_PRIVATE void sqlite3ValueSetStr( sqlite3_value *v, int n, const void *z, u8 enc, void (*xDel)(void*) ){ if( v ) sqlite3VdbeMemSetStr((Mem *)v, z, n, enc, xDel); } SQLITE_PRIVATE void sqlite3ValueFree(sqlite3_value *v){ if( !v ) return; sqlite3VdbeMemRelease((Mem *)v); sqlite3DbFree(((Mem*)v)->db, v); } SQLITE_PRIVATE int sqlite3ValueBytes(sqlite3_value *pVal, u8 enc){ Mem *p = (Mem*)pVal; if( (p->flags & MEM_Blob)!=0 || sqlite3ValueText(pVal, enc) ){ if( p->flags & MEM_Zero ){ return p->n+p->u.i; }else{ return p->n; } } return 0; } 
#ifdef SQLITE_DEBUG 
SQLITE_PRIVATE int sqlite3VdbeAddopTrace = 0; 
#endif 
SQLITE_PRIVATE Vdbe *sqlite3VdbeCreate(sqlite3 *db){ Vdbe *p; p = sqlite3DbMallocZero(db, sizeof(Vdbe) ); if( p==0 ) return 0; p->db = db; if( db->pVdbe ){ db->pVdbe->pPrev = p; } p->pNext = db->pVdbe; p->pPrev = 0; db->pVdbe = p; p->magic = VDBE_MAGIC_INIT; return p; } SQLITE_PRIVATE void sqlite3VdbeSetSql(Vdbe *p, const char *z, int n){ if( p==0 ) return; assert( p->zSql==0 ); p->zSql = sqlite3DbStrNDup(p->db, z, n); } SQLITE_API const char *sqlite3_sql(sqlite3_stmt *pStmt){ return ((Vdbe *)pStmt)->zSql; } SQLITE_PRIVATE void sqlite3VdbeSwap(Vdbe *pA, Vdbe *pB){ Vdbe tmp, *pTmp; char *zTmp; int nTmp; tmp = *pA; *pA = *pB; *pB = tmp; pTmp = pA->pNext; pA->pNext = pB->pNext; pB->pNext = pTmp; pTmp = pA->pPrev; pA->pPrev = pB->pPrev; pB->pPrev = pTmp; zTmp = pA->zSql; pA->zSql = pB->zSql; pB->zSql = zTmp; nTmp = pA->nSql; pA->nSql = pB->nSql; pB->nSql = nTmp; } 
#ifdef SQLITE_DEBUG 
SQLITE_PRIVATE void sqlite3VdbeTrace(Vdbe *p, FILE *trace){ p->trace = trace; } 
#endif 
static int growOpArray(Vdbe *p){ VdbeOp *pNew; int nNew = (p->nOpAlloc ? p->nOpAlloc*2 : (int)(1024/sizeof(Op))); pNew = sqlite3DbRealloc(p->db, p->aOp, nNew*sizeof(Op)); if( pNew ){ p->nOpAlloc = nNew; p->aOp = pNew; } return (pNew ? SQLITE_OK : SQLITE_NOMEM); } SQLITE_PRIVATE int sqlite3VdbeAddOp3(Vdbe *p, int op, int p1, int p2, int p3){ int i; VdbeOp *pOp; i = p->nOp; assert( p->magic==VDBE_MAGIC_INIT ); if( p->nOpAlloc<=i ){ if( growOpArray(p) ){ return 0; } } p->nOp++; pOp = &p->aOp[i]; pOp->opcode = op; pOp->p5 = 0; pOp->p1 = p1; pOp->p2 = p2; pOp->p3 = p3; pOp->p4.p = 0; pOp->p4type = P4_NOTUSED; p->expired = 0; 
#ifdef SQLITE_DEBUG 
 pOp->zComment = 0; if( sqlite3VdbeAddopTrace ) sqlite3VdbePrintOp(0, i, &p->aOp[i]); 
#endif 
#ifdef VDBE_PROFILE 
 pOp->cycles = 0; pOp->cnt = 0; 
#endif 
 return i; } SQLITE_PRIVATE int sqlite3VdbeAddOp0(Vdbe *p, int op){ return sqlite3VdbeAddOp3(p, op, 0, 0, 0); } SQLITE_PRIVATE int sqlite3VdbeAddOp1(Vdbe *p, int op, int p1){ return sqlite3VdbeAddOp3(p, op, p1, 0, 0); } SQLITE_PRIVATE int sqlite3VdbeAddOp2(Vdbe *p, int op, int p1, int p2){ return sqlite3VdbeAddOp3(p, op, p1, p2, 0); } SQLITE_PRIVATE int sqlite3VdbeAddOp4( Vdbe *p, int op, int p1, int p2, int p3, const char *zP4, int p4type ){ int addr = sqlite3VdbeAddOp3(p, op, p1, p2, p3); sqlite3VdbeChangeP4(p, addr, zP4, p4type); return addr; } SQLITE_PRIVATE int sqlite3VdbeMakeLabel(Vdbe *p){ int i; i = p->nLabel++; assert( p->magic==VDBE_MAGIC_INIT ); if( i>=p->nLabelAlloc ){ p->nLabelAlloc = p->nLabelAlloc*2 + 10; p->aLabel = sqlite3DbReallocOrFree(p->db, p->aLabel, p->nLabelAlloc*sizeof(p->aLabel[0])); } if( p->aLabel ){ p->aLabel[i] = -1; } return -1-i; } SQLITE_PRIVATE void sqlite3VdbeResolveLabel(Vdbe *p, int x){ int j = -1-x; assert( p->magic==VDBE_MAGIC_INIT ); assert( j>=0 && j<p->nLabel ); if( p->aLabel ){ p->aLabel[j] = p->nOp; } } static void resolveP2Values(Vdbe *p, int *pMaxFuncArgs){ int i; int nMaxArgs = 0; Op *pOp; int *aLabel = p->aLabel; int doesStatementRollback = 0; int hasStatementBegin = 0; p->readOnly = 1; p->usesStmtJournal = 0; for(pOp=p->aOp, i=p->nOp-1; i>=0; i--, pOp++){ u8 opcode = pOp->opcode; if( opcode==OP_Function || opcode==OP_AggStep ){ if( pOp->p5>nMaxArgs ) nMaxArgs = pOp->p5; 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 }else if( opcode==OP_VUpdate ){ if( pOp->p2>nMaxArgs ) nMaxArgs = pOp->p2; 
#endif 
 } if( opcode==OP_Halt ){ if( pOp->p1==SQLITE_CONSTRAINT && pOp->p2==OE_Abort ){ doesStatementRollback = 1; } }else if( opcode==OP_Statement ){ hasStatementBegin = 1; p->usesStmtJournal = 1; }else if( opcode==OP_Destroy ){ doesStatementRollback = 1; }else if( opcode==OP_Transaction && pOp->p2!=0 ){ p->readOnly = 0; 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 }else if( opcode==OP_VUpdate || opcode==OP_VRename ){ doesStatementRollback = 1; }else if( opcode==OP_VFilter ){ int n; assert( p->nOp - i >= 3 ); assert( pOp[-1].opcode==OP_Integer ); n = pOp[-1].p1; if( n>nMaxArgs ) nMaxArgs = n; 
#endif 
 } if( sqlite3VdbeOpcodeHasProperty(opcode, OPFLG_JUMP) && pOp->p2<0 ){ assert( -1-pOp->p2<p->nLabel ); pOp->p2 = aLabel[-1-pOp->p2]; } } sqlite3DbFree(p->db, p->aLabel); p->aLabel = 0; *pMaxFuncArgs = nMaxArgs; if( hasStatementBegin && !doesStatementRollback ){ p->usesStmtJournal = 0; for(pOp=p->aOp, i=p->nOp-1; i>=0; i--, pOp++){ if( pOp->opcode==OP_Statement ){ pOp->opcode = OP_Noop; } } } } SQLITE_PRIVATE int sqlite3VdbeCurrentAddr(Vdbe *p){ assert( p->magic==VDBE_MAGIC_INIT ); return p->nOp; } SQLITE_PRIVATE int sqlite3VdbeAddOpList(Vdbe *p, int nOp, VdbeOpList const *aOp){ int addr; assert( p->magic==VDBE_MAGIC_INIT ); if( p->nOp + nOp > p->nOpAlloc && growOpArray(p) ){ return 0; } addr = p->nOp; if( nOp>0 ){ int i; VdbeOpList const *pIn = aOp; for(i=0; i<nOp; i++, pIn++){ int p2 = pIn->p2; VdbeOp *pOut = &p->aOp[i+addr]; pOut->opcode = pIn->opcode; pOut->p1 = pIn->p1; if( p2<0 && sqlite3VdbeOpcodeHasProperty(pOut->opcode, OPFLG_JUMP) ){ pOut->p2 = addr + ADDR(p2); }else{ pOut->p2 = p2; } pOut->p3 = pIn->p3; pOut->p4type = P4_NOTUSED; pOut->p4.p = 0; pOut->p5 = 0; 
#ifdef SQLITE_DEBUG 
 pOut->zComment = 0; if( sqlite3VdbeAddopTrace ){ sqlite3VdbePrintOp(0, i+addr, &p->aOp[i+addr]); } 
#endif 
 } p->nOp += nOp; } return addr; } SQLITE_PRIVATE void sqlite3VdbeChangeP1(Vdbe *p, int addr, int val){ assert( p==0 || p->magic==VDBE_MAGIC_INIT ); if( p && addr>=0 && p->nOp>addr && p->aOp ){ p->aOp[addr].p1 = val; } } SQLITE_PRIVATE void sqlite3VdbeChangeP2(Vdbe *p, int addr, int val){ assert( p==0 || p->magic==VDBE_MAGIC_INIT ); if( p && addr>=0 && p->nOp>addr && p->aOp ){ p->aOp[addr].p2 = val; } } SQLITE_PRIVATE void sqlite3VdbeChangeP3(Vdbe *p, int addr, int val){ assert( p==0 || p->magic==VDBE_MAGIC_INIT ); if( p && addr>=0 && p->nOp>addr && p->aOp ){ p->aOp[addr].p3 = val; } } SQLITE_PRIVATE void sqlite3VdbeChangeP5(Vdbe *p, u8 val){ assert( p==0 || p->magic==VDBE_MAGIC_INIT ); if( p && p->aOp ){ assert( p->nOp>0 ); p->aOp[p->nOp-1].p5 = val; } } SQLITE_PRIVATE void sqlite3VdbeJumpHere(Vdbe *p, int addr){ sqlite3VdbeChangeP2(p, addr, p->nOp); } static void freeEphemeralFunction(sqlite3 *db, FuncDef *pDef){ if( pDef && (pDef->flags & SQLITE_FUNC_EPHEM)!=0 ){ sqlite3DbFree(db, pDef); } } static void freeP4(sqlite3 *db, int p4type, void *p4){ if( p4 ){ switch( p4type ){ case P4_REAL: case P4_INT64: case P4_MPRINTF: case P4_DYNAMIC: case P4_KEYINFO: case P4_INTARRAY: case P4_KEYINFO_HANDOFF: { sqlite3DbFree(db, p4); break; } case P4_VDBEFUNC: { VdbeFunc *pVdbeFunc = (VdbeFunc *)p4; freeEphemeralFunction(db, pVdbeFunc->pFunc); sqlite3VdbeDeleteAuxData(pVdbeFunc, 0); sqlite3DbFree(db, pVdbeFunc); break; } case P4_FUNCDEF: { freeEphemeralFunction(db, (FuncDef*)p4); break; } case P4_MEM: { sqlite3ValueFree((sqlite3_value*)p4); break; } } } } SQLITE_PRIVATE void sqlite3VdbeChangeToNoop(Vdbe *p, int addr, int N){ if( p && p->aOp ){ VdbeOp *pOp = &p->aOp[addr]; sqlite3 *db = p->db; while( N-- ){ freeP4(db, pOp->p4type, pOp->p4.p); memset(pOp, 0, sizeof(pOp[0])); pOp->opcode = OP_Noop; pOp++; } } } SQLITE_PRIVATE void sqlite3VdbeChangeP4(Vdbe *p, int addr, const char *zP4, int n){ Op *pOp; sqlite3 *db; assert( p!=0 ); db = p->db; assert( p->magic==VDBE_MAGIC_INIT ); if( p->aOp==0 || db->mallocFailed ){ if (n != P4_KEYINFO) { freeP4(db, n, (void*)*(char**)&zP4); } return; } assert( addr<p->nOp ); if( addr<0 ){ addr = p->nOp - 1; if( addr<0 ) return; } pOp = &p->aOp[addr]; freeP4(db, pOp->p4type, pOp->p4.p); pOp->p4.p = 0; if( n==P4_INT32 ){ pOp->p4.i = SQLITE_PTR_TO_INT(zP4); pOp->p4type = n; }else if( zP4==0 ){ pOp->p4.p = 0; pOp->p4type = P4_NOTUSED; }else if( n==P4_KEYINFO ){ KeyInfo *pKeyInfo; int nField, nByte; nField = ((KeyInfo*)zP4)->nField; nByte = sizeof(*pKeyInfo) + (nField-1)*sizeof(pKeyInfo->aColl[0]) + nField; pKeyInfo = sqlite3Malloc( nByte ); pOp->p4.pKeyInfo = pKeyInfo; if( pKeyInfo ){ u8 *aSortOrder; memcpy(pKeyInfo, zP4, nByte); aSortOrder = pKeyInfo->aSortOrder; if( aSortOrder ){ pKeyInfo->aSortOrder = (unsigned char*)&pKeyInfo->aColl[nField]; memcpy(pKeyInfo->aSortOrder, aSortOrder, nField); } pOp->p4type = P4_KEYINFO; }else{ p->db->mallocFailed = 1; pOp->p4type = P4_NOTUSED; } }else if( n==P4_KEYINFO_HANDOFF ){ pOp->p4.p = (void*)zP4; pOp->p4type = P4_KEYINFO; }else if( n<0 ){ pOp->p4.p = (void*)zP4; pOp->p4type = n; }else{ if( n==0 ) n = strlen(zP4); pOp->p4.z = sqlite3DbStrNDup(p->db, zP4, n); pOp->p4type = P4_DYNAMIC; } } 
#ifndef NDEBUG 
SQLITE_PRIVATE void sqlite3VdbeComment(Vdbe *p, const char *zFormat, ...){ va_list ap; assert( p->nOp>0 || p->aOp==0 ); assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed ); if( p->nOp ){ char **pz = &p->aOp[p->nOp-1].zComment; va_start(ap, zFormat); sqlite3DbFree(p->db, *pz); *pz = sqlite3VMPrintf(p->db, zFormat, ap); va_end(ap); } } SQLITE_PRIVATE void sqlite3VdbeNoopComment(Vdbe *p, const char *zFormat, ...){ va_list ap; sqlite3VdbeAddOp0(p, OP_Noop); assert( p->nOp>0 || p->aOp==0 ); assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed ); if( p->nOp ){ char **pz = &p->aOp[p->nOp-1].zComment; va_start(ap, zFormat); sqlite3DbFree(p->db, *pz); *pz = sqlite3VMPrintf(p->db, zFormat, ap); va_end(ap); } } 
#endif 
SQLITE_PRIVATE VdbeOp *sqlite3VdbeGetOp(Vdbe *p, int addr){ assert( p->magic==VDBE_MAGIC_INIT ); assert( (addr>=0 && addr<p->nOp) || p->db->mallocFailed ); return ((addr>=0 && addr<p->nOp)?(&p->aOp[addr]):0); } 
#if !defined(SQLITE_OMIT_EXPLAIN) || !defined(NDEBUG) || defined(VDBE_PROFILE) || defined(SQLITE_DEBUG) 
static char *displayP4(Op *pOp, char *zTemp, int nTemp){ char *zP4 = zTemp; assert( nTemp>=20 ); switch( pOp->p4type ){ case P4_KEYINFO_STATIC: case P4_KEYINFO: { int i, j; KeyInfo *pKeyInfo = pOp->p4.pKeyInfo; sqlite3_snprintf(nTemp, zTemp, "keyinfo(%d", pKeyInfo->nField); i = strlen(zTemp); for(j=0; j<pKeyInfo->nField; j++){ CollSeq *pColl = pKeyInfo->aColl[j]; if( pColl ){ int n = strlen(pColl->zName); if( i+n>nTemp-6 ){ memcpy(&zTemp[i],",...",4); break; } zTemp[i++] = ','; if( pKeyInfo->aSortOrder && pKeyInfo->aSortOrder[j] ){ zTemp[i++] = '-'; } memcpy(&zTemp[i], pColl->zName,n+1); i += n; }else if( i+4<nTemp-6 ){ memcpy(&zTemp[i],",nil",4); i += 4; } } zTemp[i++] = ')'; zTemp[i] = 0; assert( i<nTemp ); break; } case P4_COLLSEQ: { CollSeq *pColl = pOp->p4.pColl; sqlite3_snprintf(nTemp, zTemp, "collseq(%.20s)", pColl->zName); break; } case P4_FUNCDEF: { FuncDef *pDef = pOp->p4.pFunc; sqlite3_snprintf(nTemp, zTemp, "%s(%d)", pDef->zName, pDef->nArg); break; } case P4_INT64: { sqlite3_snprintf(nTemp, zTemp, "%lld", *pOp->p4.pI64); break; } case P4_INT32: { sqlite3_snprintf(nTemp, zTemp, "%d", pOp->p4.i); break; } case P4_REAL: { sqlite3_snprintf(nTemp, zTemp, "%.16g", *pOp->p4.pReal); break; } case P4_MEM: { Mem *pMem = pOp->p4.pMem; assert( (pMem->flags & MEM_Null)==0 ); if( pMem->flags & MEM_Str ){ zP4 = pMem->z; }else if( pMem->flags & MEM_Int ){ sqlite3_snprintf(nTemp, zTemp, "%lld", pMem->u.i); }else if( pMem->flags & MEM_Real ){ sqlite3_snprintf(nTemp, zTemp, "%.16g", pMem->r); } break; } 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 case P4_VTAB: { sqlite3_vtab *pVtab = pOp->p4.pVtab; sqlite3_snprintf(nTemp, zTemp, "vtab:%p:%p", pVtab, pVtab->pModule); break; } 
#endif 
 case P4_INTARRAY: { sqlite3_snprintf(nTemp, zTemp, "intarray"); break; } default: { zP4 = pOp->p4.z; if( zP4==0 ){ zP4 = zTemp; zTemp[0] = 0; } } } assert( zP4!=0 ); return zP4; } 
#endif 
SQLITE_PRIVATE void sqlite3VdbeUsesBtree(Vdbe *p, int i){ int mask; assert( i>=0 && i<p->db->nDb ); assert( i<(int)sizeof(p->btreeMask)*8 ); mask = 1<<i; if( (p->btreeMask & mask)==0 ){ p->btreeMask |= mask; sqlite3BtreeMutexArrayInsert(&p->aMutex, p->db->aDb[i].pBt); } } 
#if defined(VDBE_PROFILE) || defined(SQLITE_DEBUG) 
SQLITE_PRIVATE void sqlite3VdbePrintOp(FILE *pOut, int pc, Op *pOp){ char *zP4; char zPtr[50]; static const char *zFormat1 = "%4d %-13s %4d %4d %4d %-4s %.2X %s\n"; if( pOut==0 ) pOut = stdout; zP4 = displayP4(pOp, zPtr, sizeof(zPtr)); fprintf(pOut, zFormat1, pc, sqlite3OpcodeName(pOp->opcode), pOp->p1, pOp->p2, pOp->p3, zP4, pOp->p5, 
#ifdef SQLITE_DEBUG 
 pOp->zComment ? pOp->zComment : "" 
#else 
 "" 
#endif 
 ); fflush(pOut); } 
#endif 
static void releaseMemArray(Mem *p, int N){ if( p && N ){ Mem *pEnd; sqlite3 *db = p->db; int malloc_failed = db->mallocFailed; for(pEnd=&p[N]; p<pEnd; p++){ assert( (&p[1])==pEnd || p[0].db==p[1].db ); if( p->flags&(MEM_Agg|MEM_Dyn) ){ sqlite3VdbeMemRelease(p); }else if( p->zMalloc ){ sqlite3DbFree(db, p->zMalloc); p->zMalloc = 0; } p->flags = MEM_Null; } db->mallocFailed = malloc_failed; } } 
#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT 
SQLITE_PRIVATE int sqlite3VdbeReleaseBuffers(Vdbe *p){ int ii; int nFree = 0; assert( sqlite3_mutex_held(p->db->mutex) ); for(ii=1; ii<=p->nMem; ii++){ Mem *pMem = &p->aMem[ii]; if( pMem->z && pMem->flags&MEM_Dyn ){ assert( !pMem->xDel ); nFree += sqlite3DbMallocSize(pMem->db, pMem->z); sqlite3VdbeMemRelease(pMem); } } return nFree; } 
#endif 
#ifndef SQLITE_OMIT_EXPLAIN 
SQLITE_PRIVATE int sqlite3VdbeList( Vdbe *p ){ sqlite3 *db = p->db; int i; int rc = SQLITE_OK; Mem *pMem = p->pResultSet = &p->aMem[1]; assert( p->explain ); if( p->magic!=VDBE_MAGIC_RUN ) return SQLITE_MISUSE; assert( db->magic==SQLITE_MAGIC_BUSY ); assert( p->rc==SQLITE_OK || p->rc==SQLITE_BUSY ); releaseMemArray(pMem, p->nMem); do{ i = p->pc++; }while( i<p->nOp && p->explain==2 && p->aOp[i].opcode!=OP_Explain ); if( i>=p->nOp ){ p->rc = SQLITE_OK; rc = SQLITE_DONE; }else if( db->u1.isInterrupted ){ p->rc = SQLITE_INTERRUPT; rc = SQLITE_ERROR; sqlite3SetString(&p->zErrMsg, db, "%s", sqlite3ErrStr(p->rc)); }else{ char *z; Op *pOp = &p->aOp[i]; if( p->explain==1 ){ pMem->flags = MEM_Int; pMem->type = SQLITE_INTEGER; pMem->u.i = i; pMem++; pMem->flags = MEM_Static|MEM_Str|MEM_Term; pMem->z = (char*)sqlite3OpcodeName(pOp->opcode); assert( pMem->z!=0 ); pMem->n = strlen(pMem->z); pMem->type = SQLITE_TEXT; pMem->enc = SQLITE_UTF8; pMem++; } pMem->flags = MEM_Int; pMem->u.i = pOp->p1; pMem->type = SQLITE_INTEGER; pMem++; pMem->flags = MEM_Int; pMem->u.i = pOp->p2; pMem->type = SQLITE_INTEGER; pMem++; if( p->explain==1 ){ pMem->flags = MEM_Int; pMem->u.i = pOp->p3; pMem->type = SQLITE_INTEGER; pMem++; } if( sqlite3VdbeMemGrow(pMem, 32, 0) ){ p->db->mallocFailed = 1; return SQLITE_NOMEM; } pMem->flags = MEM_Dyn|MEM_Str|MEM_Term; z = displayP4(pOp, pMem->z, 32); if( z!=pMem->z ){ sqlite3VdbeMemSetStr(pMem, z, -1, SQLITE_UTF8, 0); }else{ assert( pMem->z!=0 ); pMem->n = strlen(pMem->z); pMem->enc = SQLITE_UTF8; } pMem->type = SQLITE_TEXT; pMem++; if( p->explain==1 ){ if( sqlite3VdbeMemGrow(pMem, 4, 0) ){ p->db->mallocFailed = 1; return SQLITE_NOMEM; } pMem->flags = MEM_Dyn|MEM_Str|MEM_Term; pMem->n = 2; sqlite3_snprintf(3, pMem->z, "%.2x", pOp->p5); pMem->type = SQLITE_TEXT; pMem->enc = SQLITE_UTF8; pMem++; 
#ifdef SQLITE_DEBUG 
 if( pOp->zComment ){ pMem->flags = MEM_Str|MEM_Term; pMem->z = pOp->zComment; pMem->n = strlen(pMem->z); pMem->enc = SQLITE_UTF8; pMem->type = SQLITE_TEXT; }else 
#endif 
 { pMem->flags = MEM_Null; pMem->type = SQLITE_NULL; } } p->nResColumn = 8 - 5*(p->explain-1); p->rc = SQLITE_OK; rc = SQLITE_ROW; } return rc; } 
#endif 
#ifdef SQLITE_DEBUG 
SQLITE_PRIVATE void sqlite3VdbePrintSql(Vdbe *p){ int nOp = p->nOp; VdbeOp *pOp; if( nOp<1 ) return; pOp = &p->aOp[0]; if( pOp->opcode==OP_Trace && pOp->p4.z!=0 ){ const char *z = pOp->p4.z; while( isspace(*(u8*)z) ) z++; printf("SQL: [%s]\n", z); } } 
#endif 
#if !defined(SQLITE_OMIT_TRACE) && defined(SQLITE_ENABLE_IOTRACE) 
SQLITE_PRIVATE void sqlite3VdbeIOTraceSql(Vdbe *p){ int nOp = p->nOp; VdbeOp *pOp; if( sqlite3IoTrace==0 ) return; if( nOp<1 ) return; pOp = &p->aOp[0]; if( pOp->opcode==OP_Trace && pOp->p4.z!=0 ){ int i, j; char z[1000]; sqlite3_snprintf(sizeof(z), z, "%s", pOp->p4.z); for(i=0; isspace((unsigned char)z[i]); i++){} for(j=0; z[i]; i++){ if( isspace((unsigned char)z[i]) ){ if( z[i-1]!=' ' ){ z[j++] = ' '; } }else{ z[j++] = z[i]; } } z[j] = 0; sqlite3IoTrace("SQL %s\n", z); } } 
#endif 
SQLITE_PRIVATE void sqlite3VdbeMakeReady( Vdbe *p, int nVar, int nMem, int nCursor, int isExplain ){ int n; sqlite3 *db = p->db; assert( p!=0 ); assert( p->magic==VDBE_MAGIC_INIT ); assert( p->nOp>0 ); p->magic = VDBE_MAGIC_RUN; nMem += nCursor; if( p->aMem==0 ){ int nArg; resolveP2Values(p, &nArg); assert( nVar>=0 ); if( isExplain && nMem<10 ){ nMem = 10; } p->aMem = sqlite3DbMallocZero(db, nMem*sizeof(Mem) + nVar*sizeof(Mem) + nArg*sizeof(Mem*) + nVar*sizeof(char*) + nCursor*sizeof(VdbeCursor*)+1 ); if( !db->mallocFailed ){ p->aMem--; p->nMem = nMem; p->aVar = &p->aMem[nMem+1]; p->nVar = nVar; p->okVar = 0; p->apArg = (Mem**)&p->aVar[nVar]; p->azVar = (char**)&p->apArg[nArg]; p->apCsr = (VdbeCursor**)&p->azVar[nVar]; p->nCursor = nCursor; for(n=0; n<nVar; n++){ p->aVar[n].flags = MEM_Null; p->aVar[n].db = db; } for(n=1; n<=nMem; n++){ p->aMem[n].flags = MEM_Null; p->aMem[n].db = db; } } } 
#ifdef SQLITE_DEBUG 
 for(n=1; n<p->nMem; n++){ assert( p->aMem[n].db==db ); } 
#endif 
 p->pc = -1; p->rc = SQLITE_OK; p->uniqueCnt = 0; p->errorAction = OE_Abort; p->explain |= isExplain; p->magic = VDBE_MAGIC_RUN; p->nChange = 0; p->cacheCtr = 1; p->minWriteFileFormat = 255; p->openedStatement = 0; 
#ifdef VDBE_PROFILE 
 { int i; for(i=0; i<p->nOp; i++){ p->aOp[i].cnt = 0; p->aOp[i].cycles = 0; } } 
#endif 
} SQLITE_PRIVATE void sqlite3VdbeFreeCursor(Vdbe *p, VdbeCursor *pCx){ if( pCx==0 ){ return; } if( pCx->pBt ){ sqlite3BtreeClose(pCx->pBt); }else if( pCx->pCursor ){ sqlite3BtreeCloseCursor(pCx->pCursor); } 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 if( pCx->pVtabCursor ){ sqlite3_vtab_cursor *pVtabCursor = pCx->pVtabCursor; const sqlite3_module *pModule = pCx->pModule; p->inVtabMethod = 1; (void)sqlite3SafetyOff(p->db); pModule->xClose(pVtabCursor); (void)sqlite3SafetyOn(p->db); p->inVtabMethod = 0; } 
#endif 
 if( !pCx->ephemPseudoTable ){ sqlite3DbFree(p->db, pCx->pData); } } static void closeAllCursorsExceptActiveVtabs(Vdbe *p){ int i; if( p->apCsr==0 ) return; for(i=0; i<p->nCursor; i++){ VdbeCursor *pC = p->apCsr[i]; if( pC && (!p->inVtabMethod || !pC->pVtabCursor) ){ sqlite3VdbeFreeCursor(p, pC); p->apCsr[i] = 0; } } } static void Cleanup(Vdbe *p){ int i; sqlite3 *db = p->db; closeAllCursorsExceptActiveVtabs(p); for(i=1; i<=p->nMem; i++){ MemSetTypeFlag(&p->aMem[i], MEM_Null); } releaseMemArray(&p->aMem[1], p->nMem); sqlite3VdbeFifoClear(&p->sFifo); if( p->contextStack ){ for(i=0; i<p->contextStackTop; i++){ sqlite3VdbeFifoClear(&p->contextStack[i].sFifo); } sqlite3DbFree(db, p->contextStack); } p->contextStack = 0; p->contextStackDepth = 0; p->contextStackTop = 0; sqlite3DbFree(db, p->zErrMsg); p->zErrMsg = 0; p->pResultSet = 0; } SQLITE_PRIVATE void sqlite3VdbeSetNumCols(Vdbe *p, int nResColumn){ Mem *pColName; int n; sqlite3 *db = p->db; releaseMemArray(p->aColName, p->nResColumn*COLNAME_N); sqlite3DbFree(db, p->aColName); n = nResColumn*COLNAME_N; p->nResColumn = nResColumn; p->aColName = pColName = (Mem*)sqlite3DbMallocZero(db, sizeof(Mem)*n ); if( p->aColName==0 ) return; while( n-- > 0 ){ pColName->flags = MEM_Null; pColName->db = p->db; pColName++; } } SQLITE_PRIVATE int sqlite3VdbeSetColName( Vdbe *p, int idx, int var, const char *zName, void (*xDel)(void*) ){ int rc; Mem *pColName; assert( idx<p->nResColumn ); assert( var<COLNAME_N ); if( p->db->mallocFailed ){ assert( !zName || xDel!=SQLITE_DYNAMIC ); return SQLITE_NOMEM; } assert( p->aColName!=0 ); pColName = &(p->aColName[idx+var*p->nResColumn]); rc = sqlite3VdbeMemSetStr(pColName, zName, -1, SQLITE_UTF8, xDel); assert( rc!=0 || !zName || (pColName->flags&MEM_Term)!=0 ); return rc; } static int vdbeCommit(sqlite3 *db, Vdbe *p){ int i; int nTrans = 0; int rc = SQLITE_OK; int needXcommit = 0; rc = sqlite3VtabSync(db, &p->zErrMsg); if( rc!=SQLITE_OK ){ return rc; } for(i=0; i<db->nDb; i++){ Btree *pBt = db->aDb[i].pBt; if( sqlite3BtreeIsInTrans(pBt) ){ needXcommit = 1; if( i!=1 ) nTrans++; } } if( needXcommit && db->xCommitCallback ){ (void)sqlite3SafetyOff(db); rc = db->xCommitCallback(db->pCommitArg); (void)sqlite3SafetyOn(db); if( rc ){ return SQLITE_CONSTRAINT; } } if( 0==strlen(sqlite3BtreeGetFilename(db->aDb[0].pBt)) || nTrans<=1 ){ for(i=0; rc==SQLITE_OK && i<db->nDb; i++){ Btree *pBt = db->aDb[i].pBt; if( pBt ){ rc = sqlite3BtreeCommitPhaseOne(pBt, 0); } } for(i=0; rc==SQLITE_OK && i<db->nDb; i++){ Btree *pBt = db->aDb[i].pBt; if( pBt ){ rc = sqlite3BtreeCommitPhaseTwo(pBt); } } if( rc==SQLITE_OK ){ sqlite3VtabCommit(db); } } 
#ifndef SQLITE_OMIT_DISKIO 
 else{ sqlite3_vfs *pVfs = db->pVfs; int needSync = 0; char *zMaster = 0; char const *zMainFile = sqlite3BtreeGetFilename(db->aDb[0].pBt); sqlite3_file *pMaster = 0; i64 offset = 0; int res; do { u32 random; sqlite3DbFree(db, zMaster); sqlite3_randomness(sizeof(random), &random); zMaster = sqlite3MPrintf(db, "%s-mj%08X", zMainFile, random&0x7fffffff); if( !zMaster ){ return SQLITE_NOMEM; } rc = sqlite3OsAccess(pVfs, zMaster, SQLITE_ACCESS_EXISTS, &res); }while( rc==SQLITE_OK && res ); if( rc==SQLITE_OK ){ rc = sqlite3OsOpenMalloc(pVfs, zMaster, &pMaster, SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE| SQLITE_OPEN_EXCLUSIVE|SQLITE_OPEN_MASTER_JOURNAL, 0 ); } if( rc!=SQLITE_OK ){ sqlite3DbFree(db, zMaster); return rc; } for(i=0; i<db->nDb; i++){ Btree *pBt = db->aDb[i].pBt; if( i==1 ) continue; if( sqlite3BtreeIsInTrans(pBt) ){ char const *zFile = sqlite3BtreeGetJournalname(pBt); if( zFile[0]==0 ) continue; if( !needSync && !sqlite3BtreeSyncDisabled(pBt) ){ needSync = 1; } rc = sqlite3OsWrite(pMaster, zFile, strlen(zFile)+1, offset); offset += strlen(zFile)+1; if( rc!=SQLITE_OK ){ sqlite3OsCloseFree(pMaster); sqlite3OsDelete(pVfs, zMaster, 0); sqlite3DbFree(db, zMaster); return rc; } } } zMainFile = sqlite3BtreeGetDirname(db->aDb[0].pBt); if( (needSync && (0==(sqlite3OsDeviceCharacteristics(pMaster)&SQLITE_IOCAP_SEQUENTIAL)) && (rc=sqlite3OsSync(pMaster, SQLITE_SYNC_NORMAL))!=SQLITE_OK) ){ sqlite3OsCloseFree(pMaster); sqlite3OsDelete(pVfs, zMaster, 0); sqlite3DbFree(db, zMaster); return rc; } for(i=0; rc==SQLITE_OK && i<db->nDb; i++){ Btree *pBt = db->aDb[i].pBt; if( pBt ){ rc = sqlite3BtreeCommitPhaseOne(pBt, zMaster); } } sqlite3OsCloseFree(pMaster); if( rc!=SQLITE_OK ){ sqlite3DbFree(db, zMaster); return rc; } rc = sqlite3OsDelete(pVfs, zMaster, 1); sqlite3DbFree(db, zMaster); zMaster = 0; if( rc ){ return rc; } disable_simulated_io_errors(); sqlite3BeginBenignMalloc(); for(i=0; i<db->nDb; i++){ Btree *pBt = db->aDb[i].pBt; if( pBt ){ sqlite3BtreeCommitPhaseTwo(pBt); } } sqlite3EndBenignMalloc(); enable_simulated_io_errors(); sqlite3VtabCommit(db); } 
#endif 
 return rc; } 
#ifndef NDEBUG 
static void checkActiveVdbeCnt(sqlite3 *db){ Vdbe *p; int cnt = 0; int nWrite = 0; p = db->pVdbe; while( p ){ if( p->magic==VDBE_MAGIC_RUN && p->pc>=0 ){ cnt++; if( p->readOnly==0 ) nWrite++; } p = p->pNext; } assert( cnt==db->activeVdbeCnt ); assert( nWrite==db->writeVdbeCnt ); } 
#else 
#define checkActiveVdbeCnt(x) 
#endif 
static void invalidateCursorsOnModifiedBtrees(sqlite3 *db){ int i; for(i=0; i<db->nDb; i++){ Btree *p = db->aDb[i].pBt; if( p && sqlite3BtreeIsInTrans(p) ){ sqlite3BtreeTripAllCursors(p, SQLITE_ABORT); } } } SQLITE_PRIVATE int sqlite3VdbeHalt(Vdbe *p){ sqlite3 *db = p->db; int i; int (*xFunc)(Btree *pBt) = 0; int isSpecialError; if( p->db->mallocFailed ){ p->rc = SQLITE_NOMEM; } closeAllCursorsExceptActiveVtabs(p); if( p->magic!=VDBE_MAGIC_RUN ){ return SQLITE_OK; } checkActiveVdbeCnt(db); if( p->pc>=0 ){ int mrc; sqlite3BtreeMutexArrayEnter(&p->aMutex); mrc = p->rc & 0xff; isSpecialError = mrc==SQLITE_NOMEM || mrc==SQLITE_IOERR || mrc==SQLITE_INTERRUPT || mrc==SQLITE_FULL; if( isSpecialError ){ if( !p->readOnly || mrc!=SQLITE_INTERRUPT ){ if( p->rc==SQLITE_IOERR_BLOCKED && p->usesStmtJournal ){ xFunc = sqlite3BtreeRollbackStmt; p->rc = SQLITE_BUSY; }else if( (mrc==SQLITE_NOMEM || mrc==SQLITE_FULL) && p->usesStmtJournal ){ xFunc = sqlite3BtreeRollbackStmt; }else{ invalidateCursorsOnModifiedBtrees(db); sqlite3RollbackAll(db); db->autoCommit = 1; } } } if( !sqlite3VtabInSync(db) && db->autoCommit && db->writeVdbeCnt==(p->readOnly==0) ){ if( p->rc==SQLITE_OK || (p->errorAction==OE_Fail && !isSpecialError) ){ int rc = vdbeCommit(db, p); if( rc==SQLITE_BUSY ){ sqlite3BtreeMutexArrayLeave(&p->aMutex); return SQLITE_BUSY; }else if( rc!=SQLITE_OK ){ p->rc = rc; sqlite3RollbackAll(db); }else{ sqlite3CommitInternalChanges(db); } }else{ sqlite3RollbackAll(db); } }else if( !xFunc ){ if( p->rc==SQLITE_OK || p->errorAction==OE_Fail ){ if( p->openedStatement ){ xFunc = sqlite3BtreeCommitStmt; } }else if( p->errorAction==OE_Abort ){ xFunc = sqlite3BtreeRollbackStmt; }else{ invalidateCursorsOnModifiedBtrees(db); sqlite3RollbackAll(db); db->autoCommit = 1; } } assert(!xFunc || xFunc==sqlite3BtreeCommitStmt || xFunc==sqlite3BtreeRollbackStmt ); for(i=0; xFunc && i<db->nDb; i++){ int rc; Btree *pBt = db->aDb[i].pBt; if( pBt ){ rc = xFunc(pBt); if( rc && (p->rc==SQLITE_OK || p->rc==SQLITE_CONSTRAINT) ){ p->rc = rc; sqlite3DbFree(db, p->zErrMsg); p->zErrMsg = 0; } } } if( p->changeCntOn && p->pc>=0 ){ if( !xFunc || xFunc==sqlite3BtreeCommitStmt ){ sqlite3VdbeSetChanges(db, p->nChange); }else{ sqlite3VdbeSetChanges(db, 0); } p->nChange = 0; } if( p->rc!=SQLITE_OK && db->flags&SQLITE_InternChanges ){ sqlite3ResetInternalSchema(db, 0); db->flags = (db->flags | SQLITE_InternChanges); } sqlite3BtreeMutexArrayLeave(&p->aMutex); } if( p->pc>=0 ){ db->activeVdbeCnt--; if( !p->readOnly ){ db->writeVdbeCnt--; } assert( db->activeVdbeCnt>=db->writeVdbeCnt ); } p->magic = VDBE_MAGIC_HALT; checkActiveVdbeCnt(db); if( p->db->mallocFailed ){ p->rc = SQLITE_NOMEM; } return SQLITE_OK; } SQLITE_PRIVATE void sqlite3VdbeResetStepResult(Vdbe *p){ p->rc = SQLITE_OK; } SQLITE_PRIVATE int sqlite3VdbeReset(Vdbe *p){ sqlite3 *db; db = p->db; (void)sqlite3SafetyOn(db); sqlite3VdbeHalt(p); (void)sqlite3SafetyOff(db); if( p->pc>=0 ){ if( p->zErrMsg ){ sqlite3BeginBenignMalloc(); sqlite3ValueSetStr(db->pErr,-1,p->zErrMsg,SQLITE_UTF8,SQLITE_TRANSIENT); sqlite3EndBenignMalloc(); db->errCode = p->rc; sqlite3DbFree(db, p->zErrMsg); p->zErrMsg = 0; }else if( p->rc ){ sqlite3Error(db, p->rc, 0); }else{ sqlite3Error(db, SQLITE_OK, 0); } }else if( p->rc && p->expired ){ sqlite3Error(db, p->rc, 0); sqlite3ValueSetStr(db->pErr, -1, p->zErrMsg, SQLITE_UTF8, SQLITE_TRANSIENT); sqlite3DbFree(db, p->zErrMsg); p->zErrMsg = 0; } Cleanup(p); 
#ifdef VDBE_PROFILE 
 { FILE *out = fopen("vdbe_profile.out", "a"); if( out ){ int i; fprintf(out, "---- "); for(i=0; i<p->nOp; i++){ fprintf(out, "%02x", p->aOp[i].opcode); } fprintf(out, "\n"); for(i=0; i<p->nOp; i++){ fprintf(out, "%6d %10lld %8lld ", p->aOp[i].cnt, p->aOp[i].cycles, p->aOp[i].cnt>0 ? p->aOp[i].cycles/p->aOp[i].cnt : 0 ); sqlite3VdbePrintOp(out, i, &p->aOp[i]); } fclose(out); } } 
#endif 
 p->magic = VDBE_MAGIC_INIT; return p->rc & db->errMask; } SQLITE_PRIVATE int sqlite3VdbeFinalize(Vdbe *p){ int rc = SQLITE_OK; if( p->magic==VDBE_MAGIC_RUN || p->magic==VDBE_MAGIC_HALT ){ rc = sqlite3VdbeReset(p); assert( (rc & p->db->errMask)==rc ); }else if( p->magic!=VDBE_MAGIC_INIT ){ return SQLITE_MISUSE; } sqlite3VdbeDelete(p); return rc; } SQLITE_PRIVATE void sqlite3VdbeDeleteAuxData(VdbeFunc *pVdbeFunc, int mask){ int i; for(i=0; i<pVdbeFunc->nAux; i++){ struct AuxData *pAux = &pVdbeFunc->apAux[i]; if( (i>31 || !(mask&(1<<i))) && pAux->pAux ){ if( pAux->xDelete ){ pAux->xDelete(pAux->pAux); } pAux->pAux = 0; } } } SQLITE_PRIVATE void sqlite3VdbeDelete(Vdbe *p){ int i; sqlite3 *db; if( p==0 ) return; db = p->db; if( p->pPrev ){ p->pPrev->pNext = p->pNext; }else{ assert( db->pVdbe==p ); db->pVdbe = p->pNext; } if( p->pNext ){ p->pNext->pPrev = p->pPrev; } if( p->aOp ){ Op *pOp = p->aOp; for(i=0; i<p->nOp; i++, pOp++){ freeP4(db, pOp->p4type, pOp->p4.p); 
#ifdef SQLITE_DEBUG 
 sqlite3DbFree(db, pOp->zComment); 
#endif 
 } sqlite3DbFree(db, p->aOp); } releaseMemArray(p->aVar, p->nVar); sqlite3DbFree(db, p->aLabel); if( p->aMem ){ sqlite3DbFree(db, &p->aMem[1]); } releaseMemArray(p->aColName, p->nResColumn*COLNAME_N); sqlite3DbFree(db, p->aColName); sqlite3DbFree(db, p->zSql); p->magic = VDBE_MAGIC_DEAD; sqlite3DbFree(db, p); } SQLITE_PRIVATE int sqlite3VdbeCursorMoveto(VdbeCursor *p){ if( p->deferredMoveto ){ int res, rc; 
#ifdef SQLITE_TEST 
 extern int sqlite3_search_count; 
#endif 
 assert( p->isTable ); rc = sqlite3BtreeMovetoUnpacked(p->pCursor, 0, p->movetoTarget, 0, &res); if( rc ) return rc; p->lastRowid = keyToInt(p->movetoTarget); p->rowidIsValid = res==0; if( res<0 ){ rc = sqlite3BtreeNext(p->pCursor, &res); if( rc ) return rc; } 
#ifdef SQLITE_TEST 
 sqlite3_search_count++; 
#endif 
 p->deferredMoveto = 0; p->cacheStatus = CACHE_STALE; }else if( p->pCursor ){ int hasMoved; int rc = sqlite3BtreeCursorHasMoved(p->pCursor, &hasMoved); if( rc ) return rc; if( hasMoved ){ p->cacheStatus = CACHE_STALE; p->nullRow = 1; } } return SQLITE_OK; } SQLITE_PRIVATE u32 sqlite3VdbeSerialType(Mem *pMem, int file_format){ int flags = pMem->flags; int n; if( flags&MEM_Null ){ return 0; } if( flags&MEM_Int ){ 
#define MAX_6BYTE ((((i64)0x00008000)<<32)-1) 
 i64 i = pMem->u.i; u64 u; if( file_format>=4 && (i&1)==i ){ return 8+i; } u = i<0 ? -i : i; if( u<=127 ) return 1; if( u<=32767 ) return 2; if( u<=8388607 ) return 3; if( u<=2147483647 ) return 4; if( u<=MAX_6BYTE ) return 5; return 6; } if( flags&MEM_Real ){ return 7; } assert( pMem->db->mallocFailed || flags&(MEM_Str|MEM_Blob) ); n = pMem->n; if( flags & MEM_Zero ){ n += pMem->u.i; } assert( n>=0 ); return ((n*2) + 12 + ((flags&MEM_Str)!=0)); } SQLITE_PRIVATE int sqlite3VdbeSerialTypeLen(u32 serial_type){ if( serial_type>=12 ){ return (serial_type-12)/2; }else{ static const u8 aSize[] = { 0, 1, 2, 3, 4, 6, 8, 8, 0, 0, 0, 0 }; return aSize[serial_type]; } } 
#ifdef SQLITE_MIXED_ENDIAN_64BIT_FLOAT 
static u64 floatSwap(u64 in){ union { u64 r; u32 i[2]; } u; u32 t; u.r = in; t = u.i[0]; u.i[0] = u.i[1]; u.i[1] = t; return u.r; } 
#define swapMixedEndianFloat(X) X = floatSwap(X) 
#else 
#define swapMixedEndianFloat(X) 
#endif 
 SQLITE_PRIVATE int sqlite3VdbeSerialPut(u8 *buf, int nBuf, Mem *pMem, int file_format){ u32 serial_type = sqlite3VdbeSerialType(pMem, file_format); int len; if( serial_type<=7 && serial_type>0 ){ u64 v; int i; if( serial_type==7 ){ assert( sizeof(v)==sizeof(pMem->r) ); memcpy(&v, &pMem->r, sizeof(v)); swapMixedEndianFloat(v); }else{ v = pMem->u.i; } len = i = sqlite3VdbeSerialTypeLen(serial_type); assert( len<=nBuf ); while( i-- ){ buf[i] = (v&0xFF); v >>= 8; } return len; } if( serial_type>=12 ){ assert( pMem->n + ((pMem->flags & MEM_Zero)?pMem->u.i:0) == sqlite3VdbeSerialTypeLen(serial_type) ); assert( pMem->n<=nBuf ); len = pMem->n; memcpy(buf, pMem->z, len); if( pMem->flags & MEM_Zero ){ len += pMem->u.i; if( len>nBuf ){ len = nBuf; } memset(&buf[pMem->n], 0, len-pMem->n); } return len; } return 0; } SQLITE_PRIVATE int sqlite3VdbeSerialGet( const unsigned char *buf, u32 serial_type, Mem *pMem ){ switch( serial_type ){ case 10: case 11: case 0: { pMem->flags = MEM_Null; break; } case 1: { pMem->u.i = (signed char)buf[0]; pMem->flags = MEM_Int; return 1; } case 2: { pMem->u.i = (((signed char)buf[0])<<8) | buf[1]; pMem->flags = MEM_Int; return 2; } case 3: { pMem->u.i = (((signed char)buf[0])<<16) | (buf[1]<<8) | buf[2]; pMem->flags = MEM_Int; return 3; } case 4: { pMem->u.i = (buf[0]<<24) | (buf[1]<<16) | (buf[2]<<8) | buf[3]; pMem->flags = MEM_Int; return 4; } case 5: { u64 x = (((signed char)buf[0])<<8) | buf[1]; u32 y = (buf[2]<<24) | (buf[3]<<16) | (buf[4]<<8) | buf[5]; x = (x<<32) | y; pMem->u.i = *(i64*)&x; pMem->flags = MEM_Int; return 6; } case 6: case 7: { u64 x; u32 y; 
#if !defined(NDEBUG) && !defined(SQLITE_OMIT_FLOATING_POINT) 
 static const u64 t1 = ((u64)0x3ff00000)<<32; static const double r1 = 1.0; u64 t2 = t1; swapMixedEndianFloat(t2); assert( sizeof(r1)==sizeof(t2) && memcmp(&r1, &t2, sizeof(r1))==0 ); 
#endif 
 x = (buf[0]<<24) | (buf[1]<<16) | (buf[2]<<8) | buf[3]; y = (buf[4]<<24) | (buf[5]<<16) | (buf[6]<<8) | buf[7]; x = (x<<32) | y; if( serial_type==6 ){ pMem->u.i = *(i64*)&x; pMem->flags = MEM_Int; }else{ assert( sizeof(x)==8 && sizeof(pMem->r)==8 ); swapMixedEndianFloat(x); memcpy(&pMem->r, &x, sizeof(x)); pMem->flags = sqlite3IsNaN(pMem->r) ? MEM_Null : MEM_Real; } return 8; } case 8: case 9: { pMem->u.i = serial_type-8; pMem->flags = MEM_Int; return 0; } default: { int len = (serial_type-12)/2; pMem->z = (char *)buf; pMem->n = len; pMem->xDel = 0; if( serial_type&0x01 ){ pMem->flags = MEM_Str | MEM_Ephem; }else{ pMem->flags = MEM_Blob | MEM_Ephem; } return len; } } return 0; } SQLITE_PRIVATE UnpackedRecord *sqlite3VdbeRecordUnpack( KeyInfo *pKeyInfo, int nKey, const void *pKey, UnpackedRecord *pSpace, int szSpace ){ const unsigned char *aKey = (const unsigned char *)pKey; UnpackedRecord *p; int nByte, d; u32 idx; u16 u; u32 szHdr; Mem *pMem; assert( sizeof(Mem)>sizeof(*p) ); nByte = sizeof(Mem)*(pKeyInfo->nField+2); if( nByte>szSpace ){ p = sqlite3DbMallocRaw(pKeyInfo->db, nByte); if( p==0 ) return 0; p->flags = UNPACKED_NEED_FREE | UNPACKED_NEED_DESTROY; }else{ p = pSpace; p->flags = UNPACKED_NEED_DESTROY; } p->pKeyInfo = pKeyInfo; p->nField = pKeyInfo->nField + 1; p->aMem = pMem = &((Mem*)p)[1]; idx = getVarint32(aKey, szHdr); d = szHdr; u = 0; while( idx<szHdr && u<p->nField ){ u32 serial_type; idx += getVarint32(&aKey[idx], serial_type); if( d>=nKey && sqlite3VdbeSerialTypeLen(serial_type)>0 ) break; pMem->enc = pKeyInfo->enc; pMem->db = pKeyInfo->db; pMem->flags = 0; pMem->zMalloc = 0; d += sqlite3VdbeSerialGet(&aKey[d], serial_type, pMem); pMem++; u++; } assert( u<=pKeyInfo->nField + 1 ); p->nField = u; return (void*)p; } SQLITE_PRIVATE void sqlite3VdbeDeleteUnpackedRecord(UnpackedRecord *p){ if( p ){ if( p->flags & UNPACKED_NEED_DESTROY ){ int i; Mem *pMem; for(i=0, pMem=p->aMem; i<p->nField; i++, pMem++){ if( pMem->zMalloc ){ sqlite3VdbeMemRelease(pMem); } } } if( p->flags & UNPACKED_NEED_FREE ){ sqlite3DbFree(p->pKeyInfo->db, p); } } } SQLITE_PRIVATE int sqlite3VdbeRecordCompare( int nKey1, const void *pKey1, UnpackedRecord *pPKey2 ){ int d1; u32 idx1; u32 szHdr1; int i = 0; int nField; int rc = 0; const unsigned char *aKey1 = (const unsigned char *)pKey1; KeyInfo *pKeyInfo; Mem mem1; pKeyInfo = pPKey2->pKeyInfo; mem1.enc = pKeyInfo->enc; mem1.db = pKeyInfo->db; mem1.flags = 0; mem1.zMalloc = 0; idx1 = getVarint32(aKey1, szHdr1); d1 = szHdr1; if( pPKey2->flags & UNPACKED_IGNORE_ROWID ){ szHdr1--; } nField = pKeyInfo->nField; while( idx1<szHdr1 && i<pPKey2->nField ){ u32 serial_type1; idx1 += getVarint32( aKey1+idx1, serial_type1 ); if( d1>=nKey1 && sqlite3VdbeSerialTypeLen(serial_type1)>0 ) break; d1 += sqlite3VdbeSerialGet(&aKey1[d1], serial_type1, &mem1); rc = sqlite3MemCompare(&mem1, &pPKey2->aMem[i], i<nField ? pKeyInfo->aColl[i] : 0); if( rc!=0 ){ break; } i++; } if( mem1.zMalloc ) sqlite3VdbeMemRelease(&mem1); if( rc==0 ){ if( pPKey2->flags & UNPACKED_INCRKEY ){ rc = -1; }else if( pPKey2->flags & UNPACKED_PREFIX_MATCH ){ }else if( idx1<szHdr1 ){ rc = 1; } }else if( pKeyInfo->aSortOrder && i<pKeyInfo->nField && pKeyInfo->aSortOrder[i] ){ rc = -rc; } return rc; } SQLITE_PRIVATE int sqlite3VdbeIdxRowid(BtCursor *pCur, i64 *rowid){ i64 nCellKey = 0; int rc; u32 szHdr; u32 typeRowid; u32 lenRowid; Mem m, v; sqlite3BtreeKeySize(pCur, &nCellKey); if( nCellKey<=0 ){ return SQLITE_CORRUPT_BKPT; } m.flags = 0; m.db = 0; m.zMalloc = 0; rc = sqlite3VdbeMemFromBtree(pCur, 0, nCellKey, 1, &m); if( rc ){ return rc; } (void)getVarint32((u8*)m.z, szHdr); (void)getVarint32((u8*)&m.z[szHdr-1], typeRowid); lenRowid = sqlite3VdbeSerialTypeLen(typeRowid); sqlite3VdbeSerialGet((u8*)&m.z[m.n-lenRowid], typeRowid, &v); *rowid = v.u.i; sqlite3VdbeMemRelease(&m); return SQLITE_OK; } SQLITE_PRIVATE int sqlite3VdbeIdxKeyCompare( VdbeCursor *pC, UnpackedRecord *pUnpacked, int *res ){ i64 nCellKey = 0; int rc; BtCursor *pCur = pC->pCursor; Mem m; sqlite3BtreeKeySize(pCur, &nCellKey); if( nCellKey<=0 ){ *res = 0; return SQLITE_OK; } m.db = 0; m.flags = 0; m.zMalloc = 0; rc = sqlite3VdbeMemFromBtree(pC->pCursor, 0, nCellKey, 1, &m); if( rc ){ return rc; } assert( pUnpacked->flags & UNPACKED_IGNORE_ROWID ); *res = sqlite3VdbeRecordCompare(m.n, m.z, pUnpacked); sqlite3VdbeMemRelease(&m); return SQLITE_OK; } SQLITE_PRIVATE void sqlite3VdbeSetChanges(sqlite3 *db, int nChange){ assert( sqlite3_mutex_held(db->mutex) ); db->nChange = nChange; db->nTotalChange += nChange; } SQLITE_PRIVATE void sqlite3VdbeCountChanges(Vdbe *v){ v->changeCntOn = 1; } SQLITE_PRIVATE void sqlite3ExpirePreparedStatements(sqlite3 *db){ Vdbe *p; for(p = db->pVdbe; p; p=p->pNext){ p->expired = 1; } } SQLITE_PRIVATE sqlite3 *sqlite3VdbeDb(Vdbe *v){ return v->db; } 
#if 0 && defined(SQLITE_ENABLE_MEMORY_MANAGEMENT) 
struct StatementLruList { Vdbe *pFirst; Vdbe *pLast; }; static struct StatementLruList sqlite3LruStatements; 
#ifndef NDEBUG 
static int stmtLruCheck(){ Vdbe *p; for(p=sqlite3LruStatements.pFirst; p; p=p->pLruNext){ assert(p->pLruNext || p==sqlite3LruStatements.pLast); assert(!p->pLruNext || p->pLruNext->pLruPrev==p); assert(p->pLruPrev || p==sqlite3LruStatements.pFirst); assert(!p->pLruPrev || p->pLruPrev->pLruNext==p); } return 1; } 
#endif 
static void stmtLruAdd(Vdbe *p){ sqlite3_mutex_enter(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_LRU2)); if( p->pLruPrev || p->pLruNext || sqlite3LruStatements.pFirst==p ){ sqlite3_mutex_leave(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_LRU2)); return; } assert( stmtLruCheck() ); if( !sqlite3LruStatements.pFirst ){ assert( !sqlite3LruStatements.pLast ); sqlite3LruStatements.pFirst = p; sqlite3LruStatements.pLast = p; }else{ assert( !sqlite3LruStatements.pLast->pLruNext ); p->pLruPrev = sqlite3LruStatements.pLast; sqlite3LruStatements.pLast->pLruNext = p; sqlite3LruStatements.pLast = p; } assert( stmtLruCheck() ); sqlite3_mutex_leave(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_LRU2)); } static void stmtLruRemoveNomutex(Vdbe *p){ if( p->pLruPrev || p->pLruNext || p==sqlite3LruStatements.pFirst ){ assert( stmtLruCheck() ); if( p->pLruNext ){ p->pLruNext->pLruPrev = p->pLruPrev; }else{ sqlite3LruStatements.pLast = p->pLruPrev; } if( p->pLruPrev ){ p->pLruPrev->pLruNext = p->pLruNext; }else{ sqlite3LruStatements.pFirst = p->pLruNext; } p->pLruNext = 0; p->pLruPrev = 0; assert( stmtLruCheck() ); } } static void stmtLruRemove(Vdbe *p){ sqlite3_mutex_enter(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_LRU2)); stmtLruRemoveNomutex(p); sqlite3_mutex_leave(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_LRU2)); } SQLITE_PRIVATE int sqlite3VdbeReleaseMemory(int n){ Vdbe *p; Vdbe *pNext; int nFree = 0; sqlite3_mutex_enter(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_LRU2)); for(p=sqlite3LruStatements.pFirst; p && nFree<n; p=pNext){ pNext = p->pLruNext; if( SQLITE_OK==sqlite3_mutex_try(p->db->mutex) ){ nFree += sqlite3VdbeReleaseBuffers(p); stmtLruRemoveNomutex(p); sqlite3_mutex_leave(p->db->mutex); } } sqlite3_mutex_leave(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_LRU2)); return nFree; } int vdbeReprepare(Vdbe *p){ stmtLruRemove(p); return sqlite3Reprepare(p); } 
#else 
#define stmtLruRemove(x) 
#define stmtLruAdd(x) 
#define vdbeReprepare(x) sqlite3Reprepare(x) 
#endif 
#ifndef SQLITE_OMIT_DEPRECATED 
SQLITE_API int sqlite3_expired(sqlite3_stmt *pStmt){ Vdbe *p = (Vdbe*)pStmt; return p==0 || p->expired; } 
#endif 
SQLITE_API int sqlite3_finalize(sqlite3_stmt *pStmt){ int rc; if( pStmt==0 ){ rc = SQLITE_OK; }else{ Vdbe *v = (Vdbe*)pStmt; 
#if SQLITE_THREADSAFE 
 sqlite3_mutex *mutex = v->db->mutex; 
#endif 
 sqlite3_mutex_enter(mutex); stmtLruRemove(v); rc = sqlite3VdbeFinalize(v); sqlite3_mutex_leave(mutex); } return rc; } SQLITE_API int sqlite3_reset(sqlite3_stmt *pStmt){ int rc; if( pStmt==0 ){ rc = SQLITE_OK; }else{ Vdbe *v = (Vdbe*)pStmt; sqlite3_mutex_enter(v->db->mutex); rc = sqlite3VdbeReset(v); stmtLruAdd(v); sqlite3VdbeMakeReady(v, -1, 0, 0, 0); assert( (rc & (v->db->errMask))==rc ); sqlite3_mutex_leave(v->db->mutex); } return rc; } SQLITE_API int sqlite3_clear_bindings(sqlite3_stmt *pStmt){ int i; int rc = SQLITE_OK; Vdbe *p = (Vdbe*)pStmt; 
#if SQLITE_THREADSAFE 
 sqlite3_mutex *mutex = ((Vdbe*)pStmt)->db->mutex; 
#endif 
 sqlite3_mutex_enter(mutex); for(i=0; i<p->nVar; i++){ sqlite3VdbeMemRelease(&p->aVar[i]); p->aVar[i].flags = MEM_Null; } sqlite3_mutex_leave(mutex); return rc; } SQLITE_API const void *sqlite3_value_blob(sqlite3_value *pVal){ Mem *p = (Mem*)pVal; if( p->flags & (MEM_Blob|MEM_Str) ){ sqlite3VdbeMemExpandBlob(p); p->flags &= ~MEM_Str; p->flags |= MEM_Blob; return p->z; }else{ return sqlite3_value_text(pVal); } } SQLITE_API int sqlite3_value_bytes(sqlite3_value *pVal){ return sqlite3ValueBytes(pVal, SQLITE_UTF8); } SQLITE_API int sqlite3_value_bytes16(sqlite3_value *pVal){ return sqlite3ValueBytes(pVal, SQLITE_UTF16NATIVE); } SQLITE_API double sqlite3_value_double(sqlite3_value *pVal){ return sqlite3VdbeRealValue((Mem*)pVal); } SQLITE_API int sqlite3_value_int(sqlite3_value *pVal){ return sqlite3VdbeIntValue((Mem*)pVal); } SQLITE_API sqlite_int64 sqlite3_value_int64(sqlite3_value *pVal){ return sqlite3VdbeIntValue((Mem*)pVal); } SQLITE_API const unsigned char *sqlite3_value_text(sqlite3_value *pVal){ return (const unsigned char *)sqlite3ValueText(pVal, SQLITE_UTF8); } 
#ifndef SQLITE_OMIT_UTF16 
SQLITE_API const void *sqlite3_value_text16(sqlite3_value* pVal){ return sqlite3ValueText(pVal, SQLITE_UTF16NATIVE); } SQLITE_API const void *sqlite3_value_text16be(sqlite3_value *pVal){ return sqlite3ValueText(pVal, SQLITE_UTF16BE); } SQLITE_API const void *sqlite3_value_text16le(sqlite3_value *pVal){ return sqlite3ValueText(pVal, SQLITE_UTF16LE); } 
#endif 
SQLITE_API int sqlite3_value_type(sqlite3_value* pVal){ return pVal->type; } SQLITE_API void sqlite3_result_blob( sqlite3_context *pCtx, const void *z, int n, void (*xDel)(void *) ){ assert( n>=0 ); assert( sqlite3_mutex_held(pCtx->s.db->mutex) ); sqlite3VdbeMemSetStr(&pCtx->s, z, n, 0, xDel); } SQLITE_API void sqlite3_result_double(sqlite3_context *pCtx, double rVal){ assert( sqlite3_mutex_held(pCtx->s.db->mutex) ); sqlite3VdbeMemSetDouble(&pCtx->s, rVal); } SQLITE_API void sqlite3_result_error(sqlite3_context *pCtx, const char *z, int n){ assert( sqlite3_mutex_held(pCtx->s.db->mutex) ); pCtx->isError = SQLITE_ERROR; sqlite3VdbeMemSetStr(&pCtx->s, z, n, SQLITE_UTF8, SQLITE_TRANSIENT); } 
#ifndef SQLITE_OMIT_UTF16 
SQLITE_API void sqlite3_result_error16(sqlite3_context *pCtx, const void *z, int n){ assert( sqlite3_mutex_held(pCtx->s.db->mutex) ); pCtx->isError = SQLITE_ERROR; sqlite3VdbeMemSetStr(&pCtx->s, z, n, SQLITE_UTF16NATIVE, SQLITE_TRANSIENT); } 
#endif 
SQLITE_API void sqlite3_result_int(sqlite3_context *pCtx, int iVal){ assert( sqlite3_mutex_held(pCtx->s.db->mutex) ); sqlite3VdbeMemSetInt64(&pCtx->s, (i64)iVal); } SQLITE_API void sqlite3_result_int64(sqlite3_context *pCtx, i64 iVal){ assert( sqlite3_mutex_held(pCtx->s.db->mutex) ); sqlite3VdbeMemSetInt64(&pCtx->s, iVal); } SQLITE_API void sqlite3_result_null(sqlite3_context *pCtx){ assert( sqlite3_mutex_held(pCtx->s.db->mutex) ); sqlite3VdbeMemSetNull(&pCtx->s); } SQLITE_API void sqlite3_result_text( sqlite3_context *pCtx, const char *z, int n, void (*xDel)(void *) ){ assert( sqlite3_mutex_held(pCtx->s.db->mutex) ); sqlite3VdbeMemSetStr(&pCtx->s, z, n, SQLITE_UTF8, xDel); } 
#ifndef SQLITE_OMIT_UTF16 
SQLITE_API void sqlite3_result_text16( sqlite3_context *pCtx, const void *z, int n, void (*xDel)(void *) ){ assert( sqlite3_mutex_held(pCtx->s.db->mutex) ); sqlite3VdbeMemSetStr(&pCtx->s, z, n, SQLITE_UTF16NATIVE, xDel); } SQLITE_API void sqlite3_result_text16be( sqlite3_context *pCtx, const void *z, int n, void (*xDel)(void *) ){ assert( sqlite3_mutex_held(pCtx->s.db->mutex) ); sqlite3VdbeMemSetStr(&pCtx->s, z, n, SQLITE_UTF16BE, xDel); } SQLITE_API void sqlite3_result_text16le( sqlite3_context *pCtx, const void *z, int n, void (*xDel)(void *) ){ assert( sqlite3_mutex_held(pCtx->s.db->mutex) ); sqlite3VdbeMemSetStr(&pCtx->s, z, n, SQLITE_UTF16LE, xDel); } 
#endif 
SQLITE_API void sqlite3_result_value(sqlite3_context *pCtx, sqlite3_value *pValue){ assert( sqlite3_mutex_held(pCtx->s.db->mutex) ); sqlite3VdbeMemCopy(&pCtx->s, pValue); } SQLITE_API void sqlite3_result_zeroblob(sqlite3_context *pCtx, int n){ assert( sqlite3_mutex_held(pCtx->s.db->mutex) ); sqlite3VdbeMemSetZeroBlob(&pCtx->s, n); } SQLITE_API void sqlite3_result_error_code(sqlite3_context *pCtx, int errCode){ pCtx->isError = errCode; } SQLITE_API void sqlite3_result_error_toobig(sqlite3_context *pCtx){ assert( sqlite3_mutex_held(pCtx->s.db->mutex) ); pCtx->isError = SQLITE_TOOBIG; sqlite3VdbeMemSetStr(&pCtx->s, "string or blob too big", -1, SQLITE_UTF8, SQLITE_STATIC); } SQLITE_API void sqlite3_result_error_nomem(sqlite3_context *pCtx){ assert( sqlite3_mutex_held(pCtx->s.db->mutex) ); sqlite3VdbeMemSetNull(&pCtx->s); pCtx->isError = SQLITE_NOMEM; pCtx->s.db->mallocFailed = 1; } static int sqlite3Step(Vdbe *p){ sqlite3 *db; int rc; assert(p); if( p->magic!=VDBE_MAGIC_RUN ){ return SQLITE_MISUSE; } db = p->db; if( db->mallocFailed ){ return SQLITE_NOMEM; } if( p->pc<=0 && p->expired ){ if( p->rc==SQLITE_OK ){ p->rc = SQLITE_SCHEMA; } rc = SQLITE_ERROR; goto end_of_step; } if( sqlite3SafetyOn(db) ){ p->rc = SQLITE_MISUSE; return SQLITE_MISUSE; } if( p->pc<0 ){ if( db->activeVdbeCnt==0 ){ db->u1.isInterrupted = 0; } 
#ifndef SQLITE_OMIT_TRACE 
 if( db->xProfile && !db->init.busy ){ double rNow; sqlite3OsCurrentTime(db->pVfs, &rNow); p->startTime = (rNow - (int)rNow)*3600.0*24.0*1000000000.0; } 
#endif 
 db->activeVdbeCnt++; if( p->readOnly==0 ) db->writeVdbeCnt++; p->pc = 0; stmtLruRemove(p); } 
#ifndef SQLITE_OMIT_EXPLAIN 
 if( p->explain ){ rc = sqlite3VdbeList(p); }else 
#endif 
 { rc = sqlite3VdbeExec(p); } if( sqlite3SafetyOff(db) ){ rc = SQLITE_MISUSE; } 
#ifndef SQLITE_OMIT_TRACE 
 if( rc!=SQLITE_ROW && db->xProfile && !db->init.busy && p->nOp>0 && p->aOp[0].opcode==OP_Trace && p->aOp[0].p4.z!=0 ){ double rNow; u64 elapseTime; sqlite3OsCurrentTime(db->pVfs, &rNow); elapseTime = (rNow - (int)rNow)*3600.0*24.0*1000000000.0 - p->startTime; db->xProfile(db->pProfileArg, p->aOp[0].p4.z, elapseTime); } 
#endif 
 db->errCode = rc; p->rc = sqlite3ApiExit(p->db, p->rc); end_of_step: assert( (rc&0xff)==rc ); if( p->zSql && (rc&0xff)<SQLITE_ROW ){ p->db->errCode = p->rc; return p->rc; }else{ return rc; } } 
#ifdef SQLITE_OMIT_PARSER 
SQLITE_API int sqlite3_step(sqlite3_stmt *pStmt){ int rc = SQLITE_MISUSE; if( pStmt ){ Vdbe *v; v = (Vdbe*)pStmt; sqlite3_mutex_enter(v->db->mutex); rc = sqlite3Step(v); sqlite3_mutex_leave(v->db->mutex); } return rc; } 
#else 
SQLITE_API int sqlite3_step(sqlite3_stmt *pStmt){ int rc = SQLITE_MISUSE; if( pStmt ){ int cnt = 0; Vdbe *v = (Vdbe*)pStmt; sqlite3 *db = v->db; sqlite3_mutex_enter(db->mutex); while( (rc = sqlite3Step(v))==SQLITE_SCHEMA && cnt++ < 5 && vdbeReprepare(v) ){ sqlite3_reset(pStmt); v->expired = 0; } if( rc==SQLITE_SCHEMA && v->zSql && db->pErr ){ const char *zErr = (const char *)sqlite3_value_text(db->pErr); sqlite3DbFree(db, v->zErrMsg); if( !db->mallocFailed ){ v->zErrMsg = sqlite3DbStrDup(db, zErr); } else { v->zErrMsg = 0; v->rc = SQLITE_NOMEM; } } rc = sqlite3ApiExit(db, rc); sqlite3_mutex_leave(db->mutex); } return rc; } 
#endif 
SQLITE_API void *sqlite3_user_data(sqlite3_context *p){ assert( p && p->pFunc ); return p->pFunc->pUserData; } SQLITE_API sqlite3 *sqlite3_context_db_handle(sqlite3_context *p){ assert( p && p->pFunc ); return p->s.db; } SQLITE_PRIVATE void sqlite3InvalidFunction( sqlite3_context *context, int NotUsed, sqlite3_value **NotUsed2 ){ const char *zName = context->pFunc->zName; char *zErr; UNUSED_PARAMETER2(NotUsed, NotUsed2); zErr = sqlite3MPrintf(0, "unable to use function %s in the requested context", zName); sqlite3_result_error(context, zErr, -1); sqlite3_free(zErr); } SQLITE_API void *sqlite3_aggregate_context(sqlite3_context *p, int nByte){ Mem *pMem; assert( p && p->pFunc && p->pFunc->xStep ); assert( sqlite3_mutex_held(p->s.db->mutex) ); pMem = p->pMem; if( (pMem->flags & MEM_Agg)==0 ){ if( nByte==0 ){ sqlite3VdbeMemReleaseExternal(pMem); pMem->flags = MEM_Null; pMem->z = 0; }else{ sqlite3VdbeMemGrow(pMem, nByte, 0); pMem->flags = MEM_Agg; pMem->u.pDef = p->pFunc; if( pMem->z ){ memset(pMem->z, 0, nByte); } } } return (void*)pMem->z; } SQLITE_API void *sqlite3_get_auxdata(sqlite3_context *pCtx, int iArg){ VdbeFunc *pVdbeFunc; assert( sqlite3_mutex_held(pCtx->s.db->mutex) ); pVdbeFunc = pCtx->pVdbeFunc; if( !pVdbeFunc || iArg>=pVdbeFunc->nAux || iArg<0 ){ return 0; } return pVdbeFunc->apAux[iArg].pAux; } SQLITE_API void sqlite3_set_auxdata( sqlite3_context *pCtx, int iArg, void *pAux, void (*xDelete)(void*) ){ struct AuxData *pAuxData; VdbeFunc *pVdbeFunc; if( iArg<0 ) goto failed; assert( sqlite3_mutex_held(pCtx->s.db->mutex) ); pVdbeFunc = pCtx->pVdbeFunc; if( !pVdbeFunc || pVdbeFunc->nAux<=iArg ){ int nAux = (pVdbeFunc ? pVdbeFunc->nAux : 0); int nMalloc = sizeof(VdbeFunc) + sizeof(struct AuxData)*iArg; pVdbeFunc = sqlite3DbRealloc(pCtx->s.db, pVdbeFunc, nMalloc); if( !pVdbeFunc ){ goto failed; } pCtx->pVdbeFunc = pVdbeFunc; memset(&pVdbeFunc->apAux[nAux], 0, sizeof(struct AuxData)*(iArg+1-nAux)); pVdbeFunc->nAux = iArg+1; pVdbeFunc->pFunc = pCtx->pFunc; } pAuxData = &pVdbeFunc->apAux[iArg]; if( pAuxData->pAux && pAuxData->xDelete ){ pAuxData->xDelete(pAuxData->pAux); } pAuxData->pAux = pAux; pAuxData->xDelete = xDelete; return; failed: if( xDelete ){ xDelete(pAux); } } 
#ifndef SQLITE_OMIT_DEPRECATED 
SQLITE_API int sqlite3_aggregate_count(sqlite3_context *p){ assert( p && p->pFunc && p->pFunc->xStep ); return p->pMem->n; } 
#endif 
SQLITE_API int sqlite3_column_count(sqlite3_stmt *pStmt){ Vdbe *pVm = (Vdbe *)pStmt; return pVm ? pVm->nResColumn : 0; } SQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt){ Vdbe *pVm = (Vdbe *)pStmt; if( pVm==0 || pVm->pResultSet==0 ) return 0; return pVm->nResColumn; } static Mem *columnMem(sqlite3_stmt *pStmt, int i){ Vdbe *pVm; int vals; Mem *pOut; pVm = (Vdbe *)pStmt; if( pVm && pVm->pResultSet!=0 && i<pVm->nResColumn && i>=0 ){ sqlite3_mutex_enter(pVm->db->mutex); vals = sqlite3_data_count(pStmt); pOut = &pVm->pResultSet[i]; }else{ static const Mem nullMem = {{0}, 0.0, 0, "", 0, MEM_Null, SQLITE_NULL, 0, 0, 0 }; if( pVm->db ){ sqlite3_mutex_enter(pVm->db->mutex); sqlite3Error(pVm->db, SQLITE_RANGE, 0); } pOut = (Mem*)&nullMem; } return pOut; } static void columnMallocFailure(sqlite3_stmt *pStmt) { Vdbe *p = (Vdbe *)pStmt; if( p ){ p->rc = sqlite3ApiExit(p->db, p->rc); sqlite3_mutex_leave(p->db->mutex); } } SQLITE_API const void *sqlite3_column_blob(sqlite3_stmt *pStmt, int i){ const void *val; val = sqlite3_value_blob( columnMem(pStmt,i) ); columnMallocFailure(pStmt); return val; } SQLITE_API int sqlite3_column_bytes(sqlite3_stmt *pStmt, int i){ int val = sqlite3_value_bytes( columnMem(pStmt,i) ); columnMallocFailure(pStmt); return val; } SQLITE_API int sqlite3_column_bytes16(sqlite3_stmt *pStmt, int i){ int val = sqlite3_value_bytes16( columnMem(pStmt,i) ); columnMallocFailure(pStmt); return val; } SQLITE_API double sqlite3_column_double(sqlite3_stmt *pStmt, int i){ double val = sqlite3_value_double( columnMem(pStmt,i) ); columnMallocFailure(pStmt); return val; } SQLITE_API int sqlite3_column_int(sqlite3_stmt *pStmt, int i){ int val = sqlite3_value_int( columnMem(pStmt,i) ); columnMallocFailure(pStmt); return val; } SQLITE_API sqlite_int64 sqlite3_column_int64(sqlite3_stmt *pStmt, int i){ sqlite_int64 val = sqlite3_value_int64( columnMem(pStmt,i) ); columnMallocFailure(pStmt); return val; } SQLITE_API const unsigned char *sqlite3_column_text(sqlite3_stmt *pStmt, int i){ const unsigned char *val = sqlite3_value_text( columnMem(pStmt,i) ); columnMallocFailure(pStmt); return val; } SQLITE_API sqlite3_value *sqlite3_column_value(sqlite3_stmt *pStmt, int i){ Mem *pOut = columnMem(pStmt, i); if( pOut->flags&MEM_Static ){ pOut->flags &= ~MEM_Static; pOut->flags |= MEM_Ephem; } columnMallocFailure(pStmt); return (sqlite3_value *)pOut; } 
#ifndef SQLITE_OMIT_UTF16 
SQLITE_API const void *sqlite3_column_text16(sqlite3_stmt *pStmt, int i){ const void *val = sqlite3_value_text16( columnMem(pStmt,i) ); columnMallocFailure(pStmt); return val; } 
#endif 
SQLITE_API int sqlite3_column_type(sqlite3_stmt *pStmt, int i){ int iType = sqlite3_value_type( columnMem(pStmt,i) ); columnMallocFailure(pStmt); return iType; } static const void *columnName( sqlite3_stmt *pStmt, int N, const void *(*xFunc)(Mem*), int useType ){ const void *ret = 0; Vdbe *p = (Vdbe *)pStmt; int n; if( p!=0 ){ n = sqlite3_column_count(pStmt); if( N<n && N>=0 ){ N += useType*n; sqlite3_mutex_enter(p->db->mutex); ret = xFunc(&p->aColName[N]); if( p->db && p->db->mallocFailed ){ p->db->mallocFailed = 0; ret = 0; } sqlite3_mutex_leave(p->db->mutex); } } return ret; } SQLITE_API const char *sqlite3_column_name(sqlite3_stmt *pStmt, int N){ return columnName( pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, COLNAME_NAME); } 
#ifndef SQLITE_OMIT_UTF16 
SQLITE_API const void *sqlite3_column_name16(sqlite3_stmt *pStmt, int N){ return columnName( pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, COLNAME_NAME); } 
#endif 
#if defined(SQLITE_OMIT_DECLTYPE) && defined(SQLITE_ENABLE_COLUMN_METADATA) 
#error "Must not define both SQLITE_OMIT_DECLTYPE and SQLITE_ENABLE_COLUMN_METADATA" 
#endif 
#ifndef SQLITE_OMIT_DECLTYPE 
SQLITE_API const char *sqlite3_column_decltype(sqlite3_stmt *pStmt, int N){ return columnName( pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, COLNAME_DECLTYPE); } 
#ifndef SQLITE_OMIT_UTF16 
SQLITE_API const void *sqlite3_column_decltype16(sqlite3_stmt *pStmt, int N){ return columnName( pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, COLNAME_DECLTYPE); } 
#endif 
#endif 
#ifdef SQLITE_ENABLE_COLUMN_METADATA 
SQLITE_API const char *sqlite3_column_database_name(sqlite3_stmt *pStmt, int N){ return columnName( pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, COLNAME_DATABASE); } 
#ifndef SQLITE_OMIT_UTF16 
SQLITE_API const void *sqlite3_column_database_name16(sqlite3_stmt *pStmt, int N){ return columnName( pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, COLNAME_DATABASE); } 
#endif 
SQLITE_API const char *sqlite3_column_table_name(sqlite3_stmt *pStmt, int N){ return columnName( pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, COLNAME_TABLE); } 
#ifndef SQLITE_OMIT_UTF16 
SQLITE_API const void *sqlite3_column_table_name16(sqlite3_stmt *pStmt, int N){ return columnName( pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, COLNAME_TABLE); } 
#endif 
SQLITE_API const char *sqlite3_column_origin_name(sqlite3_stmt *pStmt, int N){ return columnName( pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, COLNAME_COLUMN); } 
#ifndef SQLITE_OMIT_UTF16 
SQLITE_API const void *sqlite3_column_origin_name16(sqlite3_stmt *pStmt, int N){ return columnName( pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, COLNAME_COLUMN); } 
#endif 
#endif 
static int vdbeUnbind(Vdbe *p, int i){ Mem *pVar; if( p==0 ) return SQLITE_MISUSE; sqlite3_mutex_enter(p->db->mutex); if( p->magic!=VDBE_MAGIC_RUN || p->pc>=0 ){ sqlite3Error(p->db, SQLITE_MISUSE, 0); sqlite3_mutex_leave(p->db->mutex); return SQLITE_MISUSE; } if( i<1 || i>p->nVar ){ sqlite3Error(p->db, SQLITE_RANGE, 0); sqlite3_mutex_leave(p->db->mutex); return SQLITE_RANGE; } i--; pVar = &p->aVar[i]; sqlite3VdbeMemRelease(pVar); pVar->flags = MEM_Null; sqlite3Error(p->db, SQLITE_OK, 0); return SQLITE_OK; } static int bindText( sqlite3_stmt *pStmt, int i, const void *zData, int nData, void (*xDel)(void*), int encoding ){ Vdbe *p = (Vdbe *)pStmt; Mem *pVar; int rc; rc = vdbeUnbind(p, i); if( rc==SQLITE_OK ){ if( zData!=0 ){ pVar = &p->aVar[i-1]; rc = sqlite3VdbeMemSetStr(pVar, zData, nData, encoding, xDel); if( rc==SQLITE_OK && encoding!=0 ){ rc = sqlite3VdbeChangeEncoding(pVar, ENC(p->db)); } sqlite3Error(p->db, rc, 0); rc = sqlite3ApiExit(p->db, rc); } sqlite3_mutex_leave(p->db->mutex); } return rc; } SQLITE_API int sqlite3_bind_blob( sqlite3_stmt *pStmt, int i, const void *zData, int nData, void (*xDel)(void*) ){ return bindText(pStmt, i, zData, nData, xDel, 0); } SQLITE_API int sqlite3_bind_double(sqlite3_stmt *pStmt, int i, double rValue){ int rc; Vdbe *p = (Vdbe *)pStmt; rc = vdbeUnbind(p, i); if( rc==SQLITE_OK ){ sqlite3VdbeMemSetDouble(&p->aVar[i-1], rValue); sqlite3_mutex_leave(p->db->mutex); } return rc; } SQLITE_API int sqlite3_bind_int(sqlite3_stmt *p, int i, int iValue){ return sqlite3_bind_int64(p, i, (i64)iValue); } SQLITE_API int sqlite3_bind_int64(sqlite3_stmt *pStmt, int i, sqlite_int64 iValue){ int rc; Vdbe *p = (Vdbe *)pStmt; rc = vdbeUnbind(p, i); if( rc==SQLITE_OK ){ sqlite3VdbeMemSetInt64(&p->aVar[i-1], iValue); sqlite3_mutex_leave(p->db->mutex); } return rc; } SQLITE_API int sqlite3_bind_null(sqlite3_stmt *pStmt, int i){ int rc; Vdbe *p = (Vdbe*)pStmt; rc = vdbeUnbind(p, i); if( rc==SQLITE_OK ){ sqlite3_mutex_leave(p->db->mutex); } return rc; } SQLITE_API int sqlite3_bind_text( sqlite3_stmt *pStmt, int i, const char *zData, int nData, void (*xDel)(void*) ){ return bindText(pStmt, i, zData, nData, xDel, SQLITE_UTF8); } 
#ifndef SQLITE_OMIT_UTF16 
SQLITE_API int sqlite3_bind_text16( sqlite3_stmt *pStmt, int i, const void *zData, int nData, void (*xDel)(void*) ){ return bindText(pStmt, i, zData, nData, xDel, SQLITE_UTF16NATIVE); } 
#endif 
SQLITE_API int sqlite3_bind_value(sqlite3_stmt *pStmt, int i, const sqlite3_value *pValue){ int rc; Vdbe *p = (Vdbe *)pStmt; rc = vdbeUnbind(p, i); if( rc==SQLITE_OK ){ rc = sqlite3VdbeMemCopy(&p->aVar[i-1], pValue); if( rc==SQLITE_OK ){ rc = sqlite3VdbeChangeEncoding(&p->aVar[i-1], ENC(p->db)); } sqlite3_mutex_leave(p->db->mutex); } rc = sqlite3ApiExit(p->db, rc); return rc; } SQLITE_API int sqlite3_bind_zeroblob(sqlite3_stmt *pStmt, int i, int n){ int rc; Vdbe *p = (Vdbe *)pStmt; rc = vdbeUnbind(p, i); if( rc==SQLITE_OK ){ sqlite3VdbeMemSetZeroBlob(&p->aVar[i-1], n); sqlite3_mutex_leave(p->db->mutex); } return rc; } SQLITE_API int sqlite3_bind_parameter_count(sqlite3_stmt *pStmt){ Vdbe *p = (Vdbe*)pStmt; return p ? p->nVar : 0; } static void createVarMap(Vdbe *p){ if( !p->okVar ){ sqlite3_mutex_enter(p->db->mutex); if( !p->okVar ){ int j; Op *pOp; for(j=0, pOp=p->aOp; j<p->nOp; j++, pOp++){ if( pOp->opcode==OP_Variable ){ assert( pOp->p1>0 && pOp->p1<=p->nVar ); p->azVar[pOp->p1-1] = pOp->p4.z; } } p->okVar = 1; } sqlite3_mutex_leave(p->db->mutex); } } SQLITE_API const char *sqlite3_bind_parameter_name(sqlite3_stmt *pStmt, int i){ Vdbe *p = (Vdbe*)pStmt; if( p==0 || i<1 || i>p->nVar ){ return 0; } createVarMap(p); return p->azVar[i-1]; } SQLITE_API int sqlite3_bind_parameter_index(sqlite3_stmt *pStmt, const char *zName){ Vdbe *p = (Vdbe*)pStmt; int i; if( p==0 ){ return 0; } createVarMap(p); if( zName ){ for(i=0; i<p->nVar; i++){ const char *z = p->azVar[i]; if( z && strcmp(z,zName)==0 ){ return i+1; } } } return 0; } SQLITE_PRIVATE int sqlite3TransferBindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt){ Vdbe *pFrom = (Vdbe*)pFromStmt; Vdbe *pTo = (Vdbe*)pToStmt; int i, rc = SQLITE_OK; if( (pFrom->magic!=VDBE_MAGIC_RUN && pFrom->magic!=VDBE_MAGIC_HALT) || (pTo->magic!=VDBE_MAGIC_RUN && pTo->magic!=VDBE_MAGIC_HALT) || pTo->db!=pFrom->db ){ return SQLITE_MISUSE; } if( pFrom->nVar!=pTo->nVar ){ return SQLITE_ERROR; } sqlite3_mutex_enter(pTo->db->mutex); for(i=0; rc==SQLITE_OK && i<pFrom->nVar; i++){ sqlite3VdbeMemMove(&pTo->aVar[i], &pFrom->aVar[i]); } sqlite3_mutex_leave(pTo->db->mutex); assert( rc==SQLITE_OK || rc==SQLITE_NOMEM ); return rc; } 
#ifndef SQLITE_OMIT_DEPRECATED 
SQLITE_API int sqlite3_transfer_bindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt){ return sqlite3TransferBindings(pFromStmt, pToStmt); } 
#endif 
SQLITE_API sqlite3 *sqlite3_db_handle(sqlite3_stmt *pStmt){ return pStmt ? ((Vdbe*)pStmt)->db : 0; } SQLITE_API sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt){ sqlite3_stmt *pNext; sqlite3_mutex_enter(pDb->mutex); if( pStmt==0 ){ pNext = (sqlite3_stmt*)pDb->pVdbe; }else{ pNext = (sqlite3_stmt*)((Vdbe*)pStmt)->pNext; } sqlite3_mutex_leave(pDb->mutex); return pNext; } SQLITE_API int sqlite3_stmt_status(sqlite3_stmt *pStmt, int op, int resetFlag){ Vdbe *pVdbe = (Vdbe*)pStmt; int v = pVdbe->aCounter[op-1]; if( resetFlag ) pVdbe->aCounter[op-1] = 0; return v; } 
#ifdef SQLITE_TEST 
SQLITE_API int sqlite3_search_count = 0; 
#endif 
#ifdef SQLITE_TEST 
SQLITE_API int sqlite3_interrupt_count = 0; 
#endif 
#ifdef SQLITE_TEST 
SQLITE_API int sqlite3_sort_count = 0; 
#endif 
#ifdef SQLITE_TEST 
SQLITE_API int sqlite3_max_blobsize = 0; static void updateMaxBlobsize(Mem *p){ if( (p->flags & (MEM_Str|MEM_Blob))!=0 && p->n>sqlite3_max_blobsize ){ sqlite3_max_blobsize = p->n; } } 
#endif 
#if defined(SQLITE_TEST) && !defined(SQLITE_OMIT_BUILTIN_TEST) 
#define UPDATE_MAX_BLOBSIZE(P) updateMaxBlobsize(P) 
#else 
#define UPDATE_MAX_BLOBSIZE(P) 
#endif 
#define Stringify(P, enc) if(((P)->flags&(MEM_Str|MEM_Blob))==0 && sqlite3VdbeMemStringify(P,enc)) { goto no_mem; } 
#define Deephemeralize(P) if( ((P)->flags&MEM_Ephem)!=0 && sqlite3VdbeMemMakeWriteable(P) ){ goto no_mem;} 
#define ExpandBlob(P) (((P)->flags&MEM_Zero)?sqlite3VdbeMemExpandBlob(P):0) 
#define storeTypeInfo(A,B) _storeTypeInfo(A) 
static void _storeTypeInfo(Mem *pMem){ int flags = pMem->flags; if( flags & MEM_Null ){ pMem->type = SQLITE_NULL; } else if( flags & MEM_Int ){ pMem->type = SQLITE_INTEGER; } else if( flags & MEM_Real ){ pMem->type = SQLITE_FLOAT; } else if( flags & MEM_Str ){ pMem->type = SQLITE_TEXT; }else{ pMem->type = SQLITE_BLOB; } } static const unsigned char opcodeProperty[] = OPFLG_INITIALIZER; SQLITE_PRIVATE int sqlite3VdbeOpcodeHasProperty(int opcode, int mask){ assert( opcode>0 && opcode<(int)sizeof(opcodeProperty) ); return (opcodeProperty[opcode]&mask)!=0; } static VdbeCursor *allocateCursor( Vdbe *p, int iCur, Op *pOp, int iDb, int isBtreeCursor ){ Mem *pMem = &p->aMem[p->nMem-iCur]; int nByte; VdbeCursor *pCx = 0; int nField = 0; if( pOp->opcode==OP_SetNumColumns || pOp->opcode==OP_OpenEphemeral ){ nField = pOp->p2; } nByte = sizeof(VdbeCursor) + (isBtreeCursor?sqlite3BtreeCursorSize():0) + 2*nField*sizeof(u32); assert( iCur<p->nCursor ); if( p->apCsr[iCur] ){ sqlite3VdbeFreeCursor(p, p->apCsr[iCur]); p->apCsr[iCur] = 0; } if( SQLITE_OK==sqlite3VdbeMemGrow(pMem, nByte, 0) ){ p->apCsr[iCur] = pCx = (VdbeCursor*)pMem->z; memset(pMem->z, 0, nByte); pCx->iDb = iDb; pCx->nField = nField; if( nField ){ pCx->aType = (u32 *)&pMem->z[sizeof(VdbeCursor)]; } if( isBtreeCursor ){ pCx->pCursor = (BtCursor*) &pMem->z[sizeof(VdbeCursor)+2*nField*sizeof(u32)]; } } return pCx; } static void applyNumericAffinity(Mem *pRec){ if( (pRec->flags & (MEM_Real|MEM_Int))==0 ){ int realnum; sqlite3VdbeMemNulTerminate(pRec); if( (pRec->flags&MEM_Str) && sqlite3IsNumber(pRec->z, &realnum, pRec->enc) ){ i64 value; sqlite3VdbeChangeEncoding(pRec, SQLITE_UTF8); if( !realnum && sqlite3Atoi64(pRec->z, &value) ){ pRec->u.i = value; MemSetTypeFlag(pRec, MEM_Int); }else{ sqlite3VdbeMemRealify(pRec); } } } } static void applyAffinity( Mem *pRec, char affinity, u8 enc ){ if( affinity==SQLITE_AFF_TEXT ){ if( 0==(pRec->flags&MEM_Str) && (pRec->flags&(MEM_Real|MEM_Int)) ){ sqlite3VdbeMemStringify(pRec, enc); } pRec->flags &= ~(MEM_Real|MEM_Int); }else if( affinity!=SQLITE_AFF_NONE ){ assert( affinity==SQLITE_AFF_INTEGER || affinity==SQLITE_AFF_REAL || affinity==SQLITE_AFF_NUMERIC ); applyNumericAffinity(pRec); if( pRec->flags & MEM_Real ){ sqlite3VdbeIntegerAffinity(pRec); } } } SQLITE_API int sqlite3_value_numeric_type(sqlite3_value *pVal){ Mem *pMem = (Mem*)pVal; applyNumericAffinity(pMem); storeTypeInfo(pMem, 0); return pMem->type; } SQLITE_PRIVATE void sqlite3ValueApplyAffinity( sqlite3_value *pVal, u8 affinity, u8 enc ){ applyAffinity((Mem *)pVal, affinity, enc); } 
#ifdef SQLITE_DEBUG 
SQLITE_PRIVATE void sqlite3VdbeMemPrettyPrint(Mem *pMem, char *zBuf){ char *zCsr = zBuf; int f = pMem->flags; static const char *const encnames[] = {"(X)", "(8)", "(16LE)", "(16BE)"}; if( f&MEM_Blob ){ int i; char c; if( f & MEM_Dyn ){ c = 'z'; assert( (f & (MEM_Static|MEM_Ephem))==0 ); }else if( f & MEM_Static ){ c = 't'; assert( (f & (MEM_Dyn|MEM_Ephem))==0 ); }else if( f & MEM_Ephem ){ c = 'e'; assert( (f & (MEM_Static|MEM_Dyn))==0 ); }else{ c = 's'; } sqlite3_snprintf(100, zCsr, "%c", c); zCsr += strlen(zCsr); sqlite3_snprintf(100, zCsr, "%d[", pMem->n); zCsr += strlen(zCsr); for(i=0; i<16 && i<pMem->n; i++){ sqlite3_snprintf(100, zCsr, "%02X", ((int)pMem->z[i] & 0xFF)); zCsr += strlen(zCsr); } for(i=0; i<16 && i<pMem->n; i++){ char z = pMem->z[i]; if( z<32 || z>126 ) *zCsr++ = '.'; else *zCsr++ = z; } sqlite3_snprintf(100, zCsr, "]%s", encnames[pMem->enc]); zCsr += strlen(zCsr); if( f & MEM_Zero ){ sqlite3_snprintf(100, zCsr,"+%lldz",pMem->u.i); zCsr += strlen(zCsr); } *zCsr = '\0'; }else if( f & MEM_Str ){ int j, k; zBuf[0] = ' '; if( f & MEM_Dyn ){ zBuf[1] = 'z'; assert( (f & (MEM_Static|MEM_Ephem))==0 ); }else if( f & MEM_Static ){ zBuf[1] = 't'; assert( (f & (MEM_Dyn|MEM_Ephem))==0 ); }else if( f & MEM_Ephem ){ zBuf[1] = 'e'; assert( (f & (MEM_Static|MEM_Dyn))==0 ); }else{ zBuf[1] = 's'; } k = 2; sqlite3_snprintf(100, &zBuf[k], "%d", pMem->n); k += strlen(&zBuf[k]); zBuf[k++] = '['; for(j=0; j<15 && j<pMem->n; j++){ u8 c = pMem->z[j]; if( c>=0x20 && c<0x7f ){ zBuf[k++] = c; }else{ zBuf[k++] = '.'; } } zBuf[k++] = ']'; sqlite3_snprintf(100,&zBuf[k], encnames[pMem->enc]); k += strlen(&zBuf[k]); zBuf[k++] = 0; } } 
#endif 
#ifdef SQLITE_DEBUG 
static void memTracePrint(FILE *out, Mem *p){ if( p->flags & MEM_Null ){ fprintf(out, " NULL"); }else if( (p->flags & (MEM_Int|MEM_Str))==(MEM_Int|MEM_Str) ){ fprintf(out, " si:%lld", p->u.i); }else if( p->flags & MEM_Int ){ fprintf(out, " i:%lld", p->u.i); }else if( p->flags & MEM_Real ){ fprintf(out, " r:%g", p->r); }else{ char zBuf[200]; sqlite3VdbeMemPrettyPrint(p, zBuf); fprintf(out, " "); fprintf(out, "%s", zBuf); } } static void registerTrace(FILE *out, int iReg, Mem *p){ fprintf(out, "REG[%d] = ", iReg); memTracePrint(out, p); fprintf(out, "\n"); } 
#endif 
#ifdef SQLITE_DEBUG 
#define REGISTER_TRACE(R,M) if(p->trace)registerTrace(p->trace,R,M) 
#else 
#define REGISTER_TRACE(R,M) 
#endif 
#ifdef VDBE_PROFILE 
#ifndef _HWTIME_H_ 
#define _HWTIME_H_ 
#if (defined(__GNUC__) || defined(_MSC_VER)) && (defined(i386) || defined(__i386__) || defined(_M_IX86)) 
#if defined(__GNUC__) 
 __inline__ sqlite_uint64 sqlite3Hwtime(void){ unsigned int lo, hi; __asm__ __volatile__ ("rdtsc" : "=a" (lo), "=d" (hi)); return (sqlite_uint64)hi << 32 | lo; } 
#elif defined(_MSC_VER) 
 __declspec(naked) __inline sqlite_uint64 __cdecl sqlite3Hwtime(void){ __asm { rdtsc ret ; return value at EDX:EAX } } 
#endif 
#elif (defined(__GNUC__) && defined(__x86_64__)) 
 __inline__ sqlite_uint64 sqlite3Hwtime(void){ unsigned long val; __asm__ __volatile__ ("rdtsc" : "=A" (val)); return val; } 
#elif (defined(__GNUC__) && defined(__ppc__)) 
 __inline__ sqlite_uint64 sqlite3Hwtime(void){ unsigned long long retval; unsigned long junk; __asm__ __volatile__ ("\n 1: mftbu %1\n mftb %L0\n mftbu %0\n cmpw %0,%1\n bne 1b" : "=r" (retval), "=r" (junk)); return retval; } 
#else 
#error Need implementation of sqlite3Hwtime() for your platform. 
 SQLITE_PRIVATE sqlite_uint64 sqlite3Hwtime(void){ return ((sqlite_uint64)0); } 
#endif 
#endif 
#endif 
#define CHECK_FOR_INTERRUPT if( db->u1.isInterrupted ) goto abort_due_to_interrupt; 
#ifdef SQLITE_DEBUG 
static int fileExists(sqlite3 *db, const char *zFile){ int res = 0; int rc = SQLITE_OK; 
#ifdef SQLITE_TEST 
 extern int sqlite3_io_error_pending; if( sqlite3_io_error_pending<=0 ) 
#endif 
 rc = sqlite3OsAccess(db->pVfs, zFile, SQLITE_ACCESS_EXISTS, &res); return (res && rc==SQLITE_OK); } 
#endif 
SQLITE_PRIVATE int sqlite3VdbeExec( Vdbe *p ){ int pc; Op *pOp; int rc = SQLITE_OK; sqlite3 *db = p->db; u8 encoding = ENC(db); Mem *pIn1, *pIn2, *pIn3; Mem *pOut; u8 opProperty; int iCompare = 0; int *aPermute = 0; 
#ifdef VDBE_PROFILE 
 u64 start; int origPc; 
#endif 
#ifndef SQLITE_OMIT_PROGRESS_CALLBACK 
 int nProgressOps = 0; 
#endif 
 UnpackedRecord aTempRec[16]; assert( p->magic==VDBE_MAGIC_RUN ); assert( db->magic==SQLITE_MAGIC_BUSY ); sqlite3BtreeMutexArrayEnter(&p->aMutex); if( p->rc==SQLITE_NOMEM ){ goto no_mem; } assert( p->rc==SQLITE_OK || p->rc==SQLITE_BUSY ); p->rc = SQLITE_OK; assert( p->explain==0 ); p->pResultSet = 0; db->busyHandler.nBusy = 0; CHECK_FOR_INTERRUPT; sqlite3VdbeIOTraceSql(p); 
#ifdef SQLITE_DEBUG 
 sqlite3BeginBenignMalloc(); if( p->pc==0 && ((p->db->flags & SQLITE_VdbeListing) || fileExists(db, "vdbe_explain")) ){ int i; printf("VDBE Program Listing:\n"); sqlite3VdbePrintSql(p); for(i=0; i<p->nOp; i++){ sqlite3VdbePrintOp(stdout, i, &p->aOp[i]); } } if( fileExists(db, "vdbe_trace") ){ p->trace = stdout; } sqlite3EndBenignMalloc(); 
#endif 
 for(pc=p->pc; rc==SQLITE_OK; pc++){ assert( pc>=0 && pc<p->nOp ); if( db->mallocFailed ) goto no_mem; 
#ifdef VDBE_PROFILE 
 origPc = pc; start = sqlite3Hwtime(); 
#endif 
 pOp = &p->aOp[pc]; 
#ifdef SQLITE_DEBUG 
 if( p->trace ){ if( pc==0 ){ printf("VDBE Execution Trace:\n"); sqlite3VdbePrintSql(p); } sqlite3VdbePrintOp(p->trace, pc, pOp); } if( p->trace==0 && pc==0 ){ sqlite3BeginBenignMalloc(); if( fileExists(db, "vdbe_sqltrace") ){ sqlite3VdbePrintSql(p); } sqlite3EndBenignMalloc(); } 
#endif 
 
#ifdef SQLITE_TEST 
 if( sqlite3_interrupt_count>0 ){ sqlite3_interrupt_count--; if( sqlite3_interrupt_count==0 ){ sqlite3_interrupt(db); } } 
#endif 
#ifndef SQLITE_OMIT_PROGRESS_CALLBACK 
 if( db->xProgress ){ if( db->nProgressOps==nProgressOps ){ int prc; if( sqlite3SafetyOff(db) ) goto abort_due_to_misuse; prc =db->xProgress(db->pProgressArg); if( sqlite3SafetyOn(db) ) goto abort_due_to_misuse; if( prc!=0 ){ rc = SQLITE_INTERRUPT; goto vdbe_error_halt; } nProgressOps = 0; } nProgressOps++; } 
#endif 
 opProperty = opcodeProperty[pOp->opcode]; if( (opProperty & OPFLG_OUT2_PRERELEASE)!=0 ){ assert( pOp->p2>0 ); assert( pOp->p2<=p->nMem ); pOut = &p->aMem[pOp->p2]; sqlite3VdbeMemReleaseExternal(pOut); pOut->flags = MEM_Null; }else if( (opProperty & OPFLG_IN1)!=0 ){ assert( pOp->p1>0 ); assert( pOp->p1<=p->nMem ); pIn1 = &p->aMem[pOp->p1]; REGISTER_TRACE(pOp->p1, pIn1); if( (opProperty & OPFLG_IN2)!=0 ){ assert( pOp->p2>0 ); assert( pOp->p2<=p->nMem ); pIn2 = &p->aMem[pOp->p2]; REGISTER_TRACE(pOp->p2, pIn2); if( (opProperty & OPFLG_OUT3)!=0 ){ assert( pOp->p3>0 ); assert( pOp->p3<=p->nMem ); pOut = &p->aMem[pOp->p3]; } }else if( (opProperty & OPFLG_IN3)!=0 ){ assert( pOp->p3>0 ); assert( pOp->p3<=p->nMem ); pIn3 = &p->aMem[pOp->p3]; REGISTER_TRACE(pOp->p3, pIn3); } }else if( (opProperty & OPFLG_IN2)!=0 ){ assert( pOp->p2>0 ); assert( pOp->p2<=p->nMem ); pIn2 = &p->aMem[pOp->p2]; REGISTER_TRACE(pOp->p2, pIn2); }else if( (opProperty & OPFLG_IN3)!=0 ){ assert( pOp->p3>0 ); assert( pOp->p3<=p->nMem ); pIn3 = &p->aMem[pOp->p3]; REGISTER_TRACE(pOp->p3, pIn3); } switch( pOp->opcode ){ case OP_Goto: { CHECK_FOR_INTERRUPT; pc = pOp->p2 - 1; break; } case OP_Gosub: { assert( pOp->p1>0 ); assert( pOp->p1<=p->nMem ); pIn1 = &p->aMem[pOp->p1]; assert( (pIn1->flags & MEM_Dyn)==0 ); pIn1->flags = MEM_Int; pIn1->u.i = pc; REGISTER_TRACE(pOp->p1, pIn1); pc = pOp->p2 - 1; break; } case OP_Return: { assert( pIn1->flags & MEM_Int ); pc = pIn1->u.i; break; } case OP_Yield: { int pcDest; assert( pOp->p1>0 ); assert( pOp->p1<=p->nMem ); pIn1 = &p->aMem[pOp->p1]; assert( (pIn1->flags & MEM_Dyn)==0 ); pIn1->flags = MEM_Int; pcDest = pIn1->u.i; pIn1->u.i = pc; REGISTER_TRACE(pOp->p1, pIn1); pc = pcDest; break; } case OP_Halt: { p->rc = pOp->p1; p->pc = pc; p->errorAction = pOp->p2; if( pOp->p4.z ){ sqlite3SetString(&p->zErrMsg, db, "%s", pOp->p4.z); } rc = sqlite3VdbeHalt(p); assert( rc==SQLITE_BUSY || rc==SQLITE_OK ); if( rc==SQLITE_BUSY ){ p->rc = rc = SQLITE_BUSY; }else{ rc = p->rc ? SQLITE_ERROR : SQLITE_DONE; } goto vdbe_return; } case OP_Integer: { pOut->flags = MEM_Int; pOut->u.i = pOp->p1; break; } case OP_Int64: { assert( pOp->p4.pI64!=0 ); pOut->flags = MEM_Int; pOut->u.i = *pOp->p4.pI64; break; } case OP_Real: { pOut->flags = MEM_Real; assert( !sqlite3IsNaN(*pOp->p4.pReal) ); pOut->r = *pOp->p4.pReal; break; } case OP_String8: { assert( pOp->p4.z!=0 ); pOp->opcode = OP_String; pOp->p1 = strlen(pOp->p4.z); 
#ifndef SQLITE_OMIT_UTF16 
 if( encoding!=SQLITE_UTF8 ){ sqlite3VdbeMemSetStr(pOut, pOp->p4.z, -1, SQLITE_UTF8, SQLITE_STATIC); if( SQLITE_OK!=sqlite3VdbeChangeEncoding(pOut, encoding) ) goto no_mem; if( SQLITE_OK!=sqlite3VdbeMemMakeWriteable(pOut) ) goto no_mem; pOut->zMalloc = 0; pOut->flags |= MEM_Static; pOut->flags &= ~MEM_Dyn; if( pOp->p4type==P4_DYNAMIC ){ sqlite3DbFree(db, pOp->p4.z); } pOp->p4type = P4_DYNAMIC; pOp->p4.z = pOut->z; pOp->p1 = pOut->n; if( pOp->p1>db->aLimit[SQLITE_LIMIT_LENGTH] ){ goto too_big; } UPDATE_MAX_BLOBSIZE(pOut); break; } 
#endif 
 if( pOp->p1>db->aLimit[SQLITE_LIMIT_LENGTH] ){ goto too_big; } } case OP_String: { assert( pOp->p4.z!=0 ); pOut->flags = MEM_Str|MEM_Static|MEM_Term; pOut->z = pOp->p4.z; pOut->n = pOp->p1; pOut->enc = encoding; UPDATE_MAX_BLOBSIZE(pOut); break; } case OP_Null: { break; } 
#ifndef SQLITE_OMIT_BLOB_LITERAL 
case OP_Blob: { assert( pOp->p1 <= SQLITE_MAX_LENGTH ); sqlite3VdbeMemSetStr(pOut, pOp->p4.z, pOp->p1, 0, 0); pOut->enc = encoding; UPDATE_MAX_BLOBSIZE(pOut); break; } 
#endif 
case OP_Variable: { int j = pOp->p1 - 1; Mem *pVar; assert( j>=0 && j<p->nVar ); pVar = &p->aVar[j]; if( sqlite3VdbeMemTooBig(pVar) ){ goto too_big; } sqlite3VdbeMemShallowCopy(pOut, &p->aVar[j], MEM_Static); UPDATE_MAX_BLOBSIZE(pOut); break; } case OP_Move: { char *zMalloc; int n = pOp->p3; int p1 = pOp->p1; int p2 = pOp->p2; assert( n>0 ); assert( p1>0 ); assert( p1+n<p->nMem ); pIn1 = &p->aMem[p1]; assert( p2>0 ); assert( p2+n<p->nMem ); pOut = &p->aMem[p2]; assert( p1+n<=p2 || p2+n<=p1 ); while( n-- ){ zMalloc = pOut->zMalloc; pOut->zMalloc = 0; sqlite3VdbeMemMove(pOut, pIn1); pIn1->zMalloc = zMalloc; REGISTER_TRACE(p2++, pOut); pIn1++; pOut++; } break; } case OP_Copy: { assert( pOp->p1>0 ); assert( pOp->p1<=p->nMem ); pIn1 = &p->aMem[pOp->p1]; assert( pOp->p2>0 ); assert( pOp->p2<=p->nMem ); pOut = &p->aMem[pOp->p2]; assert( pOut!=pIn1 ); sqlite3VdbeMemShallowCopy(pOut, pIn1, MEM_Ephem); Deephemeralize(pOut); REGISTER_TRACE(pOp->p2, pOut); break; } case OP_SCopy: { assert( pOp->p1>0 ); assert( pOp->p1<=p->nMem ); pIn1 = &p->aMem[pOp->p1]; REGISTER_TRACE(pOp->p1, pIn1); assert( pOp->p2>0 ); assert( pOp->p2<=p->nMem ); pOut = &p->aMem[pOp->p2]; assert( pOut!=pIn1 ); sqlite3VdbeMemShallowCopy(pOut, pIn1, MEM_Ephem); REGISTER_TRACE(pOp->p2, pOut); break; } case OP_ResultRow: { Mem *pMem; int i; assert( p->nResColumn==pOp->p2 ); assert( pOp->p1>0 ); assert( pOp->p1+pOp->p2<=p->nMem ); p->cacheCtr = (p->cacheCtr + 2)|1; pMem = p->pResultSet = &p->aMem[pOp->p1]; for(i=0; i<pOp->p2; i++){ sqlite3VdbeMemNulTerminate(&pMem[i]); storeTypeInfo(&pMem[i], encoding); REGISTER_TRACE(pOp->p1+i, &pMem[i]); } if( db->mallocFailed ) goto no_mem; p->nCallback++; p->pc = pc + 1; rc = SQLITE_ROW; goto vdbe_return; } case OP_Concat: { i64 nByte; assert( pIn1!=pOut ); if( (pIn1->flags | pIn2->flags) & MEM_Null ){ sqlite3VdbeMemSetNull(pOut); break; } ExpandBlob(pIn1); Stringify(pIn1, encoding); ExpandBlob(pIn2); Stringify(pIn2, encoding); nByte = pIn1->n + pIn2->n; if( nByte>db->aLimit[SQLITE_LIMIT_LENGTH] ){ goto too_big; } MemSetTypeFlag(pOut, MEM_Str); if( sqlite3VdbeMemGrow(pOut, nByte+2, pOut==pIn2) ){ goto no_mem; } if( pOut!=pIn2 ){ memcpy(pOut->z, pIn2->z, pIn2->n); } memcpy(&pOut->z[pIn2->n], pIn1->z, pIn1->n); pOut->z[nByte] = 0; pOut->z[nByte+1] = 0; pOut->flags |= MEM_Term; pOut->n = nByte; pOut->enc = encoding; UPDATE_MAX_BLOBSIZE(pOut); break; } case OP_Add: case OP_Subtract: case OP_Multiply: case OP_Divide: case OP_Remainder: { int flags; applyNumericAffinity(pIn1); applyNumericAffinity(pIn2); flags = pIn1->flags | pIn2->flags; if( (flags & MEM_Null)!=0 ) goto arithmetic_result_is_null; if( (pIn1->flags & pIn2->flags & MEM_Int)==MEM_Int ){ i64 a, b; a = pIn1->u.i; b = pIn2->u.i; switch( pOp->opcode ){ case OP_Add: b += a; break; case OP_Subtract: b -= a; break; case OP_Multiply: b *= a; break; case OP_Divide: { if( a==0 ) goto arithmetic_result_is_null; if( a==-1 && b==SMALLEST_INT64 ) a = 1; b /= a; break; } default: { if( a==0 ) goto arithmetic_result_is_null; if( a==-1 ) a = 1; b %= a; break; } } pOut->u.i = b; MemSetTypeFlag(pOut, MEM_Int); }else{ double a, b; a = sqlite3VdbeRealValue(pIn1); b = sqlite3VdbeRealValue(pIn2); switch( pOp->opcode ){ case OP_Add: b += a; break; case OP_Subtract: b -= a; break; case OP_Multiply: b *= a; break; case OP_Divide: { if( a==0.0 ) goto arithmetic_result_is_null; b /= a; break; } default: { i64 ia = (i64)a; i64 ib = (i64)b; if( ia==0 ) goto arithmetic_result_is_null; if( ia==-1 ) ia = 1; b = ib % ia; break; } } if( sqlite3IsNaN(b) ){ goto arithmetic_result_is_null; } pOut->r = b; MemSetTypeFlag(pOut, MEM_Real); if( (flags & MEM_Real)==0 ){ sqlite3VdbeIntegerAffinity(pOut); } } break; arithmetic_result_is_null: sqlite3VdbeMemSetNull(pOut); break; } case OP_CollSeq: { assert( pOp->p4type==P4_COLLSEQ ); break; } case OP_Function: { int i; Mem *pArg; sqlite3_context ctx; sqlite3_value **apVal; int n = pOp->p5; apVal = p->apArg; assert( apVal || n==0 ); assert( n==0 || (pOp->p2>0 && pOp->p2+n<=p->nMem) ); assert( pOp->p3<pOp->p2 || pOp->p3>=pOp->p2+n ); pArg = &p->aMem[pOp->p2]; for(i=0; i<n; i++, pArg++){ apVal[i] = pArg; storeTypeInfo(pArg, encoding); REGISTER_TRACE(pOp->p2, pArg); } assert( pOp->p4type==P4_FUNCDEF || pOp->p4type==P4_VDBEFUNC ); if( pOp->p4type==P4_FUNCDEF ){ ctx.pFunc = pOp->p4.pFunc; ctx.pVdbeFunc = 0; }else{ ctx.pVdbeFunc = (VdbeFunc*)pOp->p4.pVdbeFunc; ctx.pFunc = ctx.pVdbeFunc->pFunc; } assert( pOp->p3>0 && pOp->p3<=p->nMem ); pOut = &p->aMem[pOp->p3]; ctx.s.flags = MEM_Null; ctx.s.db = db; ctx.s.xDel = 0; ctx.s.zMalloc = 0; sqlite3VdbeMemMove(&ctx.s, pOut); MemSetTypeFlag(&ctx.s, MEM_Null); ctx.isError = 0; if( ctx.pFunc->flags & SQLITE_FUNC_NEEDCOLL ){ assert( pOp>p->aOp ); assert( pOp[-1].p4type==P4_COLLSEQ ); assert( pOp[-1].opcode==OP_CollSeq ); ctx.pColl = pOp[-1].p4.pColl; } if( sqlite3SafetyOff(db) ) goto abort_due_to_misuse; (*ctx.pFunc->xFunc)(&ctx, n, apVal); if( sqlite3SafetyOn(db) ){ sqlite3VdbeMemRelease(&ctx.s); goto abort_due_to_misuse; } if( db->mallocFailed ){ sqlite3VdbeMemRelease(&ctx.s); goto no_mem; } if( ctx.pVdbeFunc ){ sqlite3VdbeDeleteAuxData(ctx.pVdbeFunc, pOp->p1); pOp->p4.pVdbeFunc = ctx.pVdbeFunc; pOp->p4type = P4_VDBEFUNC; } if( ctx.isError ){ sqlite3SetString(&p->zErrMsg, db, "%s", sqlite3_value_text(&ctx.s)); rc = ctx.isError; } sqlite3VdbeChangeEncoding(&ctx.s, encoding); sqlite3VdbeMemMove(pOut, &ctx.s); if( sqlite3VdbeMemTooBig(pOut) ){ goto too_big; } REGISTER_TRACE(pOp->p3, pOut); UPDATE_MAX_BLOBSIZE(pOut); break; } case OP_BitAnd: case OP_BitOr: case OP_ShiftLeft: case OP_ShiftRight: { i64 a, b; if( (pIn1->flags | pIn2->flags) & MEM_Null ){ sqlite3VdbeMemSetNull(pOut); break; } a = sqlite3VdbeIntValue(pIn2); b = sqlite3VdbeIntValue(pIn1); switch( pOp->opcode ){ case OP_BitAnd: a &= b; break; case OP_BitOr: a |= b; break; case OP_ShiftLeft: a <<= b; break; default: assert( pOp->opcode==OP_ShiftRight ); a >>= b; break; } pOut->u.i = a; MemSetTypeFlag(pOut, MEM_Int); break; } case OP_AddImm: { sqlite3VdbeMemIntegerify(pIn1); pIn1->u.i += pOp->p2; break; } case OP_ForceInt: { i64 v; applyAffinity(pIn1, SQLITE_AFF_NUMERIC, encoding); if( (pIn1->flags & (MEM_Int|MEM_Real))==0 ){ pc = pOp->p2 - 1; break; } if( pIn1->flags & MEM_Int ){ v = pIn1->u.i + (pOp->p3!=0); }else{ assert( pIn1->flags & MEM_Real ); v = (sqlite3_int64)pIn1->r; if( pIn1->r>(double)v ) v++; if( pOp->p3 && pIn1->r==(double)v ) v++; } pIn1->u.i = v; MemSetTypeFlag(pIn1, MEM_Int); break; } case OP_MustBeInt: { applyAffinity(pIn1, SQLITE_AFF_NUMERIC, encoding); if( (pIn1->flags & MEM_Int)==0 ){ if( pOp->p2==0 ){ rc = SQLITE_MISMATCH; goto abort_due_to_error; }else{ pc = pOp->p2 - 1; } }else{ MemSetTypeFlag(pIn1, MEM_Int); } break; } case OP_RealAffinity: { if( pIn1->flags & MEM_Int ){ sqlite3VdbeMemRealify(pIn1); } break; } 
#ifndef SQLITE_OMIT_CAST 
case OP_ToText: { if( pIn1->flags & MEM_Null ) break; assert( MEM_Str==(MEM_Blob>>3) ); pIn1->flags |= (pIn1->flags&MEM_Blob)>>3; applyAffinity(pIn1, SQLITE_AFF_TEXT, encoding); rc = ExpandBlob(pIn1); assert( pIn1->flags & MEM_Str || db->mallocFailed ); pIn1->flags &= ~(MEM_Int|MEM_Real|MEM_Blob); UPDATE_MAX_BLOBSIZE(pIn1); break; } case OP_ToBlob: { if( pIn1->flags & MEM_Null ) break; if( (pIn1->flags & MEM_Blob)==0 ){ applyAffinity(pIn1, SQLITE_AFF_TEXT, encoding); assert( pIn1->flags & MEM_Str || db->mallocFailed ); } MemSetTypeFlag(pIn1, MEM_Blob); UPDATE_MAX_BLOBSIZE(pIn1); break; } case OP_ToNumeric: { if( (pIn1->flags & (MEM_Null|MEM_Int|MEM_Real))==0 ){ sqlite3VdbeMemNumerify(pIn1); } break; } 
#endif 
case OP_ToInt: { if( (pIn1->flags & MEM_Null)==0 ){ sqlite3VdbeMemIntegerify(pIn1); } break; } 
#ifndef SQLITE_OMIT_CAST 
case OP_ToReal: { if( (pIn1->flags & MEM_Null)==0 ){ sqlite3VdbeMemRealify(pIn1); } break; } 
#endif 
case OP_Eq: case OP_Ne: case OP_Lt: case OP_Le: case OP_Gt: case OP_Ge: { int flags; int res; char affinity; flags = pIn1->flags|pIn3->flags; if( flags&MEM_Null ){ if( pOp->p5 & SQLITE_STOREP2 ){ pOut = &p->aMem[pOp->p2]; MemSetTypeFlag(pOut, MEM_Null); REGISTER_TRACE(pOp->p2, pOut); }else if( pOp->p5 & SQLITE_JUMPIFNULL ){ pc = pOp->p2-1; } break; } affinity = pOp->p5 & SQLITE_AFF_MASK; if( affinity ){ applyAffinity(pIn1, affinity, encoding); applyAffinity(pIn3, affinity, encoding); } assert( pOp->p4type==P4_COLLSEQ || pOp->p4.pColl==0 ); ExpandBlob(pIn1); ExpandBlob(pIn3); res = sqlite3MemCompare(pIn3, pIn1, pOp->p4.pColl); switch( pOp->opcode ){ case OP_Eq: res = res==0; break; case OP_Ne: res = res!=0; break; case OP_Lt: res = res<0; break; case OP_Le: res = res<=0; break; case OP_Gt: res = res>0; break; default: res = res>=0; break; } if( pOp->p5 & SQLITE_STOREP2 ){ pOut = &p->aMem[pOp->p2]; MemSetTypeFlag(pOut, MEM_Int); pOut->u.i = res; REGISTER_TRACE(pOp->p2, pOut); }else if( res ){ pc = pOp->p2-1; } break; } case OP_Permutation: { assert( pOp->p4type==P4_INTARRAY ); assert( pOp->p4.ai ); aPermute = pOp->p4.ai; break; } case OP_Compare: { int n = pOp->p3; int i, p1, p2; const KeyInfo *pKeyInfo = pOp->p4.pKeyInfo; assert( n>0 ); assert( pKeyInfo!=0 ); p1 = pOp->p1; assert( p1>0 && p1+n-1<p->nMem ); p2 = pOp->p2; assert( p2>0 && p2+n-1<p->nMem ); for(i=0; i<n; i++){ int idx = aPermute ? aPermute[i] : i; CollSeq *pColl; int bRev; REGISTER_TRACE(p1+idx, &p->aMem[p1+idx]); REGISTER_TRACE(p2+idx, &p->aMem[p2+idx]); assert( i<pKeyInfo->nField ); pColl = pKeyInfo->aColl[i]; bRev = pKeyInfo->aSortOrder[i]; iCompare = sqlite3MemCompare(&p->aMem[p1+idx], &p->aMem[p2+idx], pColl); if( iCompare ){ if( bRev ) iCompare = -iCompare; break; } } aPermute = 0; break; } case OP_Jump: { if( iCompare<0 ){ pc = pOp->p1 - 1; }else if( iCompare==0 ){ pc = pOp->p2 - 1; }else{ pc = pOp->p3 - 1; } break; } case OP_And: case OP_Or: { int v1, v2; if( pIn1->flags & MEM_Null ){ v1 = 2; }else{ v1 = sqlite3VdbeIntValue(pIn1)!=0; } if( pIn2->flags & MEM_Null ){ v2 = 2; }else{ v2 = sqlite3VdbeIntValue(pIn2)!=0; } if( pOp->opcode==OP_And ){ static const unsigned char and_logic[] = { 0, 0, 0, 0, 1, 2, 0, 2, 2 }; v1 = and_logic[v1*3+v2]; }else{ static const unsigned char or_logic[] = { 0, 1, 2, 1, 1, 1, 2, 1, 2 }; v1 = or_logic[v1*3+v2]; } if( v1==2 ){ MemSetTypeFlag(pOut, MEM_Null); }else{ pOut->u.i = v1; MemSetTypeFlag(pOut, MEM_Int); } break; } case OP_Not: { if( pIn1->flags & MEM_Null ) break; sqlite3VdbeMemIntegerify(pIn1); pIn1->u.i = !pIn1->u.i; assert( pIn1->flags&MEM_Int ); break; } case OP_BitNot: { if( pIn1->flags & MEM_Null ) break; sqlite3VdbeMemIntegerify(pIn1); pIn1->u.i = ~pIn1->u.i; assert( pIn1->flags&MEM_Int ); break; } case OP_If: case OP_IfNot: { int c; if( pIn1->flags & MEM_Null ){ c = pOp->p3; }else{ 
#ifdef SQLITE_OMIT_FLOATING_POINT 
 c = sqlite3VdbeIntValue(pIn1); 
#else 
 c = sqlite3VdbeRealValue(pIn1)!=0.0; 
#endif 
 if( pOp->opcode==OP_IfNot ) c = !c; } if( c ){ pc = pOp->p2-1; } break; } case OP_IsNull: { int n = pOp->p3; assert( pOp->p3==0 || pOp->p1>0 ); do{ if( (pIn1->flags & MEM_Null)!=0 ){ pc = pOp->p2 - 1; break; } pIn1++; }while( --n > 0 ); break; } case OP_NotNull: { if( (pIn1->flags & MEM_Null)==0 ){ pc = pOp->p2 - 1; } break; } case OP_SetNumColumns: { break; } case OP_Column: { int payloadSize; int p1 = pOp->p1; int p2 = pOp->p2; VdbeCursor *pC = 0; char *zRec; BtCursor *pCrsr; u32 *aType; u32 *aOffset; int nField; int len; int i; char *zData; Mem *pDest; Mem sMem; sMem.flags = 0; sMem.db = 0; sMem.zMalloc = 0; assert( p1<p->nCursor ); assert( pOp->p3>0 && pOp->p3<=p->nMem ); pDest = &p->aMem[pOp->p3]; MemSetTypeFlag(pDest, MEM_Null); pC = p->apCsr[p1]; assert( pC!=0 ); 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 assert( pC->pVtabCursor==0 ); 
#endif 
 if( pC->pCursor!=0 ){ rc = sqlite3VdbeCursorMoveto(pC); if( rc ) goto abort_due_to_error; zRec = 0; pCrsr = pC->pCursor; if( pC->nullRow ){ payloadSize = 0; }else if( pC->cacheStatus==p->cacheCtr ){ payloadSize = pC->payloadSize; zRec = (char*)pC->aRow; }else if( pC->isIndex ){ i64 payloadSize64; sqlite3BtreeKeySize(pCrsr, &payloadSize64); payloadSize = payloadSize64; }else{ sqlite3BtreeDataSize(pCrsr, (u32 *)&payloadSize); } nField = pC->nField; }else{ assert( pC->pseudoTable ); payloadSize = pC->nData; zRec = pC->pData; pC->cacheStatus = CACHE_STALE; assert( payloadSize==0 || zRec!=0 ); nField = pC->nField; pCrsr = 0; } if( payloadSize==0 ){ assert( pDest->flags&MEM_Null ); goto op_column_out; } if( payloadSize>db->aLimit[SQLITE_LIMIT_LENGTH] ){ goto too_big; } assert( p2<nField ); aType = pC->aType; if( pC->cacheStatus==p->cacheCtr ){ aOffset = pC->aOffset; }else{ u8 *zIdx; u8 *zEndHdr; int offset; int szHdrSz; int avail; assert(aType); pC->aOffset = aOffset = &aType[nField]; pC->payloadSize = payloadSize; pC->cacheStatus = p->cacheCtr; if( zRec ){ zData = zRec; }else{ if( pC->isIndex ){ zData = (char*)sqlite3BtreeKeyFetch(pCrsr, &avail); }else{ zData = (char*)sqlite3BtreeDataFetch(pCrsr, &avail); } if( avail>=payloadSize ){ zRec = zData; pC->aRow = (u8*)zData; }else{ pC->aRow = 0; } } szHdrSz = getVarint32((u8*)zData, offset); if( !zRec && avail<offset ){ sMem.flags = 0; sMem.db = 0; rc = sqlite3VdbeMemFromBtree(pCrsr, 0, offset, pC->isIndex, &sMem); if( rc!=SQLITE_OK ){ goto op_column_out; } zData = sMem.z; } zEndHdr = (u8 *)&zData[offset]; zIdx = (u8 *)&zData[szHdrSz]; for(i=0; i<nField; i++){ if( zIdx<zEndHdr ){ aOffset[i] = offset; zIdx += getVarint32(zIdx, aType[i]); offset += sqlite3VdbeSerialTypeLen(aType[i]); }else{ aOffset[i] = 0; } } sqlite3VdbeMemRelease(&sMem); sMem.flags = MEM_Null; if( zIdx>zEndHdr || offset>payloadSize || (zIdx==zEndHdr && offset!=payloadSize) ){ rc = SQLITE_CORRUPT_BKPT; goto op_column_out; } } if( aOffset[p2] ){ assert( rc==SQLITE_OK ); if( zRec ){ sqlite3VdbeMemReleaseExternal(pDest); sqlite3VdbeSerialGet((u8 *)&zRec[aOffset[p2]], aType[p2], pDest); }else{ len = sqlite3VdbeSerialTypeLen(aType[p2]); sqlite3VdbeMemMove(&sMem, pDest); rc = sqlite3VdbeMemFromBtree(pCrsr, aOffset[p2], len, pC->isIndex, &sMem); if( rc!=SQLITE_OK ){ goto op_column_out; } zData = sMem.z; sqlite3VdbeSerialGet((u8*)zData, aType[p2], pDest); } pDest->enc = encoding; }else{ if( pOp->p4type==P4_MEM ){ sqlite3VdbeMemShallowCopy(pDest, pOp->p4.pMem, MEM_Static); }else{ assert( pDest->flags&MEM_Null ); } } if( sMem.zMalloc ){ assert( sMem.z==sMem.zMalloc ); assert( !(pDest->flags & MEM_Dyn) ); assert( !(pDest->flags & (MEM_Blob|MEM_Str)) || pDest->z==sMem.z ); pDest->flags &= ~(MEM_Ephem|MEM_Static); pDest->flags |= MEM_Term; pDest->z = sMem.z; pDest->zMalloc = sMem.zMalloc; } rc = sqlite3VdbeMemMakeWriteable(pDest); op_column_out: UPDATE_MAX_BLOBSIZE(pDest); REGISTER_TRACE(pOp->p3, pDest); break; } case OP_Affinity: { char *zAffinity = pOp->p4.z; Mem *pData0 = &p->aMem[pOp->p1]; Mem *pLast = &pData0[pOp->p2-1]; Mem *pRec; for(pRec=pData0; pRec<=pLast; pRec++){ ExpandBlob(pRec); applyAffinity(pRec, zAffinity[pRec-pData0], encoding); } break; } case OP_MakeRecord: { u8 *zNewRecord; Mem *pRec; u64 nData = 0; int nHdr = 0; i64 nByte = 0; int nZero = 0; int nVarint; u32 serial_type; Mem *pData0; Mem *pLast; int nField; char *zAffinity; int file_format; int i; nField = pOp->p1; zAffinity = pOp->p4.z; assert( nField>0 && pOp->p2>0 && pOp->p2+nField<=p->nMem ); pData0 = &p->aMem[nField]; nField = pOp->p2; pLast = &pData0[nField-1]; file_format = p->minWriteFileFormat; for(pRec=pData0; pRec<=pLast; pRec++){ int len; if( zAffinity ){ applyAffinity(pRec, zAffinity[pRec-pData0], encoding); } if( pRec->flags&MEM_Zero && pRec->n>0 ){ sqlite3VdbeMemExpandBlob(pRec); } serial_type = sqlite3VdbeSerialType(pRec, file_format); len = sqlite3VdbeSerialTypeLen(serial_type); nData += len; nHdr += sqlite3VarintLen(serial_type); if( pRec->flags & MEM_Zero ){ nZero += pRec->u.i; }else if( len ){ nZero = 0; } } nHdr += nVarint = sqlite3VarintLen(nHdr); if( nVarint<sqlite3VarintLen(nHdr) ){ nHdr++; } nByte = nHdr+nData-nZero; if( nByte>db->aLimit[SQLITE_LIMIT_LENGTH] ){ goto too_big; } assert( pOp->p3<pOp->p1 || pOp->p3>=pOp->p1+pOp->p2 ); pOut = &p->aMem[pOp->p3]; if( sqlite3VdbeMemGrow(pOut, nByte, 0) ){ goto no_mem; } zNewRecord = (u8 *)pOut->z; i = putVarint32(zNewRecord, nHdr); for(pRec=pData0; pRec<=pLast; pRec++){ serial_type = sqlite3VdbeSerialType(pRec, file_format); i += putVarint32(&zNewRecord[i], serial_type); } for(pRec=pData0; pRec<=pLast; pRec++){ i += sqlite3VdbeSerialPut(&zNewRecord[i], nByte-i, pRec, file_format); } assert( i==nByte ); assert( pOp->p3>0 && pOp->p3<=p->nMem ); pOut->n = nByte; pOut->flags = MEM_Blob | MEM_Dyn; pOut->xDel = 0; if( nZero ){ pOut->u.i = nZero; pOut->flags |= MEM_Zero; } pOut->enc = SQLITE_UTF8; REGISTER_TRACE(pOp->p3, pOut); UPDATE_MAX_BLOBSIZE(pOut); break; } case OP_Statement: { if( db->autoCommit==0 || db->activeVdbeCnt>1 ){ int i = pOp->p1; Btree *pBt; assert( i>=0 && i<db->nDb ); assert( db->aDb[i].pBt!=0 ); pBt = db->aDb[i].pBt; assert( sqlite3BtreeIsInTrans(pBt) ); assert( (p->btreeMask & (1<<i))!=0 ); if( !sqlite3BtreeIsInStmt(pBt) ){ rc = sqlite3BtreeBeginStmt(pBt); p->openedStatement = 1; } } break; } case OP_AutoCommit: { int desiredAutoCommit = pOp->p1; int rollback = pOp->p2; int turnOnAC = desiredAutoCommit && !db->autoCommit; assert( desiredAutoCommit==1 || desiredAutoCommit==0 ); assert( desiredAutoCommit==1 || rollback==0 ); assert( db->activeVdbeCnt>0 ); if( turnOnAC && rollback && db->activeVdbeCnt>1 ){ sqlite3SetString(&p->zErrMsg, db, "cannot rollback transaction - " "SQL statements in progress"); rc = SQLITE_BUSY; }else if( turnOnAC && !rollback && db->writeVdbeCnt>1 ){ sqlite3SetString(&p->zErrMsg, db, "cannot commit transaction - " "SQL statements in progress"); rc = SQLITE_BUSY; }else if( desiredAutoCommit!=db->autoCommit ){ if( pOp->p2 ){ assert( desiredAutoCommit==1 ); sqlite3RollbackAll(db); db->autoCommit = 1; }else{ db->autoCommit = desiredAutoCommit; if( sqlite3VdbeHalt(p)==SQLITE_BUSY ){ p->pc = pc; db->autoCommit = 1-desiredAutoCommit; p->rc = rc = SQLITE_BUSY; goto vdbe_return; } } if( p->rc==SQLITE_OK ){ rc = SQLITE_DONE; }else{ rc = SQLITE_ERROR; } goto vdbe_return; }else{ sqlite3SetString(&p->zErrMsg, db, (!desiredAutoCommit)?"cannot start a transaction within a transaction":( (rollback)?"cannot rollback - no transaction is active": "cannot commit - no transaction is active")); rc = SQLITE_ERROR; } break; } case OP_Transaction: { int i = pOp->p1; Btree *pBt; assert( i>=0 && i<db->nDb ); assert( (p->btreeMask & (1<<i))!=0 ); pBt = db->aDb[i].pBt; if( pBt ){ rc = sqlite3BtreeBeginTrans(pBt, pOp->p2); if( rc==SQLITE_BUSY ){ p->pc = pc; p->rc = rc = SQLITE_BUSY; goto vdbe_return; } if( rc!=SQLITE_OK && rc!=SQLITE_READONLY ){ goto abort_due_to_error; } } break; } case OP_ReadCookie: { int iMeta; int iDb = pOp->p1; int iCookie = pOp->p3; assert( pOp->p3<SQLITE_N_BTREE_META ); if( iDb<0 ){ iDb = (-1*(iDb+1)); iCookie *= -1; } assert( iDb>=0 && iDb<db->nDb ); assert( db->aDb[iDb].pBt!=0 ); assert( (p->btreeMask & (1<<iDb))!=0 ); rc = sqlite3BtreeGetMeta(db->aDb[iDb].pBt, 1 + iCookie, (u32 *)&iMeta); pOut->u.i = iMeta; MemSetTypeFlag(pOut, MEM_Int); break; } case OP_SetCookie: { Db *pDb; assert( pOp->p2<SQLITE_N_BTREE_META ); assert( pOp->p1>=0 && pOp->p1<db->nDb ); assert( (p->btreeMask & (1<<pOp->p1))!=0 ); pDb = &db->aDb[pOp->p1]; assert( pDb->pBt!=0 ); sqlite3VdbeMemIntegerify(pIn3); rc = sqlite3BtreeUpdateMeta(pDb->pBt, 1+pOp->p2, (int)pIn3->u.i); if( pOp->p2==0 ){ pDb->pSchema->schema_cookie = pIn3->u.i; db->flags |= SQLITE_InternChanges; }else if( pOp->p2==1 ){ pDb->pSchema->file_format = pIn3->u.i; } if( pOp->p1==1 ){ sqlite3ExpirePreparedStatements(db); } break; } case OP_VerifyCookie: { int iMeta; Btree *pBt; assert( pOp->p1>=0 && pOp->p1<db->nDb ); assert( (p->btreeMask & (1<<pOp->p1))!=0 ); pBt = db->aDb[pOp->p1].pBt; if( pBt ){ rc = sqlite3BtreeGetMeta(pBt, 1, (u32 *)&iMeta); }else{ rc = SQLITE_OK; iMeta = 0; } if( rc==SQLITE_OK && iMeta!=pOp->p2 ){ sqlite3DbFree(db, p->zErrMsg); p->zErrMsg = sqlite3DbStrDup(db, "database schema has changed"); if( db->aDb[pOp->p1].pSchema->schema_cookie!=iMeta ){ sqlite3ResetInternalSchema(db, pOp->p1); } sqlite3ExpirePreparedStatements(db); rc = SQLITE_SCHEMA; } break; } case OP_OpenRead: case OP_OpenWrite: { int i = pOp->p1; int p2 = pOp->p2; int iDb = pOp->p3; int wrFlag; Btree *pX; VdbeCursor *pCur; Db *pDb; assert( iDb>=0 && iDb<db->nDb ); assert( (p->btreeMask & (1<<iDb))!=0 ); pDb = &db->aDb[iDb]; pX = pDb->pBt; assert( pX!=0 ); if( pOp->opcode==OP_OpenWrite ){ wrFlag = 1; if( pDb->pSchema->file_format < p->minWriteFileFormat ){ p->minWriteFileFormat = pDb->pSchema->file_format; } }else{ wrFlag = 0; } if( pOp->p5 ){ assert( p2>0 ); assert( p2<=p->nMem ); pIn2 = &p->aMem[p2]; sqlite3VdbeMemIntegerify(pIn2); p2 = pIn2->u.i; if( p2<2 ) { rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } } assert( i>=0 ); pCur = allocateCursor(p, i, &pOp[-1], iDb, 1); if( pCur==0 ) goto no_mem; pCur->nullRow = 1; rc = sqlite3BtreeCursor(pX, p2, wrFlag, pOp->p4.p, pCur->pCursor); if( pOp->p4type==P4_KEYINFO ){ pCur->pKeyInfo = pOp->p4.pKeyInfo; pCur->pKeyInfo->enc = ENC(p->db); }else{ pCur->pKeyInfo = 0; } switch( rc ){ case SQLITE_BUSY: { p->pc = pc; p->rc = rc = SQLITE_BUSY; goto vdbe_return; } case SQLITE_OK: { int flags = sqlite3BtreeFlags(pCur->pCursor); if( (flags & 0xf0)!=0 || ((flags & 0x07)!=5 && (flags & 0x07)!=2) ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } pCur->isTable = (flags & BTREE_INTKEY)!=0; pCur->isIndex = (flags & BTREE_ZERODATA)!=0; if( (pCur->isTable && pOp->p4type==P4_KEYINFO) || (pCur->isIndex && pOp->p4type!=P4_KEYINFO) ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } break; } case SQLITE_EMPTY: { pCur->isTable = pOp->p4type!=P4_KEYINFO; pCur->isIndex = !pCur->isTable; pCur->pCursor = 0; rc = SQLITE_OK; break; } default: { goto abort_due_to_error; } } break; } case OP_OpenEphemeral: { int i = pOp->p1; VdbeCursor *pCx; static const int openFlags = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE | SQLITE_OPEN_EXCLUSIVE | SQLITE_OPEN_DELETEONCLOSE | SQLITE_OPEN_TRANSIENT_DB; assert( i>=0 ); pCx = allocateCursor(p, i, pOp, -1, 1); if( pCx==0 ) goto no_mem; pCx->nullRow = 1; rc = sqlite3BtreeFactory(db, 0, 1, SQLITE_DEFAULT_TEMP_CACHE_SIZE, openFlags, &pCx->pBt); if( rc==SQLITE_OK ){ rc = sqlite3BtreeBeginTrans(pCx->pBt, 1); } if( rc==SQLITE_OK ){ if( pOp->p4.pKeyInfo ){ int pgno; assert( pOp->p4type==P4_KEYINFO ); rc = sqlite3BtreeCreateTable(pCx->pBt, &pgno, BTREE_ZERODATA); if( rc==SQLITE_OK ){ assert( pgno==MASTER_ROOT+1 ); rc = sqlite3BtreeCursor(pCx->pBt, pgno, 1, (KeyInfo*)pOp->p4.z, pCx->pCursor); pCx->pKeyInfo = pOp->p4.pKeyInfo; pCx->pKeyInfo->enc = ENC(p->db); } pCx->isTable = 0; }else{ rc = sqlite3BtreeCursor(pCx->pBt, MASTER_ROOT, 1, 0, pCx->pCursor); pCx->isTable = 1; } } pCx->isIndex = !pCx->isTable; break; } case OP_OpenPseudo: { int i = pOp->p1; VdbeCursor *pCx; assert( i>=0 ); pCx = allocateCursor(p, i, &pOp[-1], -1, 0); if( pCx==0 ) goto no_mem; pCx->nullRow = 1; pCx->pseudoTable = 1; pCx->ephemPseudoTable = pOp->p2; pCx->isTable = 1; pCx->isIndex = 0; break; } case OP_Close: { int i = pOp->p1; assert( i>=0 && i<p->nCursor ); sqlite3VdbeFreeCursor(p, p->apCsr[i]); p->apCsr[i] = 0; break; } case OP_MoveLt: case OP_MoveLe: case OP_MoveGe: case OP_MoveGt: { int i = pOp->p1; VdbeCursor *pC; assert( i>=0 && i<p->nCursor ); pC = p->apCsr[i]; assert( pC!=0 ); if( pC->pCursor!=0 ){ int res, oc; oc = pOp->opcode; pC->nullRow = 0; if( pC->isTable ){ i64 iKey = sqlite3VdbeIntValue(pIn3); if( pOp->p2==0 ){ assert( pOp->opcode==OP_MoveGe ); pC->movetoTarget = iKey; pC->rowidIsValid = 0; pC->deferredMoveto = 1; break; } rc = sqlite3BtreeMovetoUnpacked(pC->pCursor, 0, (u64)iKey, 0, &res); if( rc!=SQLITE_OK ){ goto abort_due_to_error; } pC->lastRowid = iKey; pC->rowidIsValid = res==0; }else{ UnpackedRecord r; int nField = pOp->p4.i; assert( pOp->p4type==P4_INT32 ); assert( nField>0 ); r.pKeyInfo = pC->pKeyInfo; r.nField = nField; if( oc==OP_MoveGt || oc==OP_MoveLe ){ r.flags = UNPACKED_INCRKEY; }else{ r.flags = 0; } r.aMem = &p->aMem[pOp->p3]; rc = sqlite3BtreeMovetoUnpacked(pC->pCursor, &r, 0, 0, &res); if( rc!=SQLITE_OK ){ goto abort_due_to_error; } pC->rowidIsValid = 0; } pC->deferredMoveto = 0; pC->cacheStatus = CACHE_STALE; 
#ifdef SQLITE_TEST 
 sqlite3_search_count++; 
#endif 
 if( oc==OP_MoveGe || oc==OP_MoveGt ){ if( res<0 ){ rc = sqlite3BtreeNext(pC->pCursor, &res); if( rc!=SQLITE_OK ) goto abort_due_to_error; pC->rowidIsValid = 0; }else{ res = 0; } }else{ assert( oc==OP_MoveLt || oc==OP_MoveLe ); if( res>=0 ){ rc = sqlite3BtreePrevious(pC->pCursor, &res); if( rc!=SQLITE_OK ) goto abort_due_to_error; pC->rowidIsValid = 0; }else{ res = sqlite3BtreeEof(pC->pCursor); } } assert( pOp->p2>0 ); if( res ){ pc = pOp->p2 - 1; } }else if( !pC->pseudoTable ){ pc = pOp->p2 - 1; } break; } case OP_NotFound: case OP_Found: { int i = pOp->p1; int alreadyExists = 0; VdbeCursor *pC; assert( i>=0 && i<p->nCursor ); assert( p->apCsr[i]!=0 ); if( (pC = p->apCsr[i])->pCursor!=0 ){ int res; UnpackedRecord *pIdxKey; assert( pC->isTable==0 ); assert( pIn3->flags & MEM_Blob ); pIdxKey = sqlite3VdbeRecordUnpack(pC->pKeyInfo, pIn3->n, pIn3->z, aTempRec, sizeof(aTempRec)); if( pIdxKey==0 ){ goto no_mem; } if( pOp->opcode==OP_Found ){ pIdxKey->flags |= UNPACKED_PREFIX_MATCH; } rc = sqlite3BtreeMovetoUnpacked(pC->pCursor, pIdxKey, 0, 0, &res); sqlite3VdbeDeleteUnpackedRecord(pIdxKey); if( rc!=SQLITE_OK ){ break; } alreadyExists = (res==0); pC->deferredMoveto = 0; pC->cacheStatus = CACHE_STALE; } if( pOp->opcode==OP_Found ){ if( alreadyExists ) pc = pOp->p2 - 1; }else{ if( !alreadyExists ) pc = pOp->p2 - 1; } break; } case OP_IsUnique: { int i = pOp->p1; VdbeCursor *pCx; BtCursor *pCrsr; Mem *pK; i64 R; assert( pOp->p4type==P4_INT32 ); assert( pOp->p4.i>0 && pOp->p4.i<=p->nMem ); pK = &p->aMem[pOp->p4.i]; sqlite3VdbeMemIntegerify(pIn3); R = pIn3->u.i; assert( i>=0 && i<p->nCursor ); pCx = p->apCsr[i]; assert( pCx!=0 ); pCrsr = pCx->pCursor; if( pCrsr!=0 ){ int res; i64 v; UnpackedRecord *pIdxKey; assert( pK->flags & MEM_Blob ); pIdxKey = sqlite3VdbeRecordUnpack(pCx->pKeyInfo, pK->n, pK->z, aTempRec, sizeof(aTempRec)); if( pIdxKey==0 ){ goto no_mem; } pIdxKey->flags |= UNPACKED_IGNORE_ROWID; assert( pCx->deferredMoveto==0 ); pCx->cacheStatus = CACHE_STALE; rc = sqlite3BtreeMovetoUnpacked(pCrsr, pIdxKey, 0, 0, &res); if( rc!=SQLITE_OK ){ sqlite3VdbeDeleteUnpackedRecord(pIdxKey); goto abort_due_to_error; } if( res<0 ){ rc = sqlite3BtreeNext(pCrsr, &res); if( res ){ pc = pOp->p2 - 1; sqlite3VdbeDeleteUnpackedRecord(pIdxKey); break; } } rc = sqlite3VdbeIdxKeyCompare(pCx, pIdxKey, &res); sqlite3VdbeDeleteUnpackedRecord(pIdxKey); if( rc!=SQLITE_OK ) goto abort_due_to_error; if( res>0 ){ pc = pOp->p2 - 1; break; } rc = sqlite3VdbeIdxRowid(pCrsr, &v); if( rc!=SQLITE_OK ){ goto abort_due_to_error; } if( v==R ){ pc = pOp->p2 - 1; break; } pIn3->u.i = v; assert( pIn3->flags&MEM_Int ); } break; } case OP_NotExists: { int i = pOp->p1; VdbeCursor *pC; BtCursor *pCrsr; assert( i>=0 && i<p->nCursor ); assert( p->apCsr[i]!=0 ); if( (pCrsr = (pC = p->apCsr[i])->pCursor)!=0 ){ int res; u64 iKey; assert( pIn3->flags & MEM_Int ); assert( p->apCsr[i]->isTable ); iKey = intToKey(pIn3->u.i); rc = sqlite3BtreeMovetoUnpacked(pCrsr, 0, iKey, 0,&res); pC->lastRowid = pIn3->u.i; pC->rowidIsValid = res==0; pC->nullRow = 0; pC->cacheStatus = CACHE_STALE; if( res!=0 ){ pc = pOp->p2 - 1; assert( pC->rowidIsValid==0 ); } }else if( !pC->pseudoTable ){ assert( pC->isTable ); pc = pOp->p2 - 1; assert( pC->rowidIsValid==0 ); } break; } case OP_Sequence: { int i = pOp->p1; assert( i>=0 && i<p->nCursor ); assert( p->apCsr[i]!=0 ); pOut->u.i = p->apCsr[i]->seqCount++; MemSetTypeFlag(pOut, MEM_Int); break; } case OP_NewRowid: { int i = pOp->p1; i64 v = 0; VdbeCursor *pC; assert( i>=0 && i<p->nCursor ); assert( p->apCsr[i]!=0 ); if( (pC = p->apCsr[i])->pCursor==0 ){ }else{ int res, rx=SQLITE_OK, cnt; i64 x; cnt = 0; if( (sqlite3BtreeFlags(pC->pCursor)&(BTREE_INTKEY|BTREE_ZERODATA)) != BTREE_INTKEY ){ rc = SQLITE_CORRUPT_BKPT; goto abort_due_to_error; } assert( (sqlite3BtreeFlags(pC->pCursor) & BTREE_INTKEY)!=0 ); assert( (sqlite3BtreeFlags(pC->pCursor) & BTREE_ZERODATA)==0 ); 
#ifdef SQLITE_32BIT_ROWID 
#define MAX_ROWID 0x7fffffff 
#else 
 
#define MAX_ROWID (i64)( (((u64)0x7fffffff)<<32) | (u64)0xffffffff ) 
#endif 
 if( !pC->useRandomRowid ){ if( pC->nextRowidValid ){ v = pC->nextRowid; }else{ rc = sqlite3BtreeLast(pC->pCursor, &res); if( rc!=SQLITE_OK ){ goto abort_due_to_error; } if( res ){ v = 1; }else{ sqlite3BtreeKeySize(pC->pCursor, &v); v = keyToInt(v); if( v==MAX_ROWID ){ pC->useRandomRowid = 1; }else{ v++; } } } 
#ifndef SQLITE_OMIT_AUTOINCREMENT 
 if( pOp->p3 ){ Mem *pMem; assert( pOp->p3>0 && pOp->p3<=p->nMem ); pMem = &p->aMem[pOp->p3]; REGISTER_TRACE(pOp->p3, pMem); sqlite3VdbeMemIntegerify(pMem); assert( (pMem->flags & MEM_Int)!=0 ); if( pMem->u.i==MAX_ROWID || pC->useRandomRowid ){ rc = SQLITE_FULL; goto abort_due_to_error; } if( v<pMem->u.i+1 ){ v = pMem->u.i + 1; } pMem->u.i = v; } 
#endif 
 if( v<MAX_ROWID ){ pC->nextRowidValid = 1; pC->nextRowid = v+1; }else{ pC->nextRowidValid = 0; } } if( pC->useRandomRowid ){ assert( pOp->p3==0 ); v = db->priorNewRowid; cnt = 0; do{ if( cnt==0 && (v&0xffffff)==v ){ v++; }else{ sqlite3_randomness(sizeof(v), &v); if( cnt<5 ) v &= 0xffffff; } if( v==0 ) continue; x = intToKey(v); rx = sqlite3BtreeMovetoUnpacked(pC->pCursor, 0, (u64)x, 0, &res); cnt++; }while( cnt<100 && rx==SQLITE_OK && res==0 ); db->priorNewRowid = v; if( rx==SQLITE_OK && res==0 ){ rc = SQLITE_FULL; goto abort_due_to_error; } } pC->rowidIsValid = 0; pC->deferredMoveto = 0; pC->cacheStatus = CACHE_STALE; } MemSetTypeFlag(pOut, MEM_Int); pOut->u.i = v; break; } case OP_Insert: { Mem *pData = &p->aMem[pOp->p2]; Mem *pKey = &p->aMem[pOp->p3]; i64 iKey; int i = pOp->p1; VdbeCursor *pC; assert( i>=0 && i<p->nCursor ); pC = p->apCsr[i]; assert( pC!=0 ); assert( pC->pCursor!=0 || pC->pseudoTable ); assert( pKey->flags & MEM_Int ); assert( pC->isTable ); REGISTER_TRACE(pOp->p2, pData); REGISTER_TRACE(pOp->p3, pKey); iKey = intToKey(pKey->u.i); if( pOp->p5 & OPFLAG_NCHANGE ) p->nChange++; if( pOp->p5 & OPFLAG_LASTROWID ) db->lastRowid = pKey->u.i; if( pC->nextRowidValid && pKey->u.i>=pC->nextRowid ){ pC->nextRowidValid = 0; } if( pData->flags & MEM_Null ){ pData->z = 0; pData->n = 0; }else{ assert( pData->flags & (MEM_Blob|MEM_Str) ); } if( pC->pseudoTable ){ if( !pC->ephemPseudoTable ){ sqlite3DbFree(db, pC->pData); } pC->iKey = iKey; pC->nData = pData->n; if( pData->z==pData->zMalloc || pC->ephemPseudoTable ){ pC->pData = pData->z; if( !pC->ephemPseudoTable ){ pData->flags &= ~MEM_Dyn; pData->flags |= MEM_Ephem; pData->zMalloc = 0; } }else{ pC->pData = sqlite3Malloc( pC->nData+2 ); if( !pC->pData ) goto no_mem; memcpy(pC->pData, pData->z, pC->nData); pC->pData[pC->nData] = 0; pC->pData[pC->nData+1] = 0; } pC->nullRow = 0; }else{ int nZero; if( pData->flags & MEM_Zero ){ nZero = pData->u.i; }else{ nZero = 0; } rc = sqlite3BtreeInsert(pC->pCursor, 0, iKey, pData->z, pData->n, nZero, pOp->p5 & OPFLAG_APPEND); } pC->rowidIsValid = 0; pC->deferredMoveto = 0; pC->cacheStatus = CACHE_STALE; if( rc==SQLITE_OK && db->xUpdateCallback && pOp->p4.z ){ const char *zDb = db->aDb[pC->iDb].zName; const char *zTbl = pOp->p4.z; int op = ((pOp->p5 & OPFLAG_ISUPDATE) ? SQLITE_UPDATE : SQLITE_INSERT); assert( pC->isTable ); db->xUpdateCallback(db->pUpdateArg, op, zDb, zTbl, iKey); assert( pC->iDb>=0 ); } break; } case OP_Delete: { int i = pOp->p1; i64 iKey; VdbeCursor *pC; assert( i>=0 && i<p->nCursor ); pC = p->apCsr[i]; assert( pC!=0 ); assert( pC->pCursor!=0 ); if( db->xUpdateCallback && pOp->p4.z ){ assert( pC->isTable ); assert( pC->rowidIsValid ); iKey = pC->lastRowid; } rc = sqlite3VdbeCursorMoveto(pC); if( rc ) goto abort_due_to_error; rc = sqlite3BtreeDelete(pC->pCursor); pC->nextRowidValid = 0; pC->cacheStatus = CACHE_STALE; if( rc==SQLITE_OK && db->xUpdateCallback && pOp->p4.z ){ const char *zDb = db->aDb[pC->iDb].zName; const char *zTbl = pOp->p4.z; db->xUpdateCallback(db->pUpdateArg, SQLITE_DELETE, zDb, zTbl, iKey); assert( pC->iDb>=0 ); } if( pOp->p2 & OPFLAG_NCHANGE ) p->nChange++; break; } case OP_ResetCount: { if( pOp->p1 ){ sqlite3VdbeSetChanges(db, p->nChange); } p->nChange = 0; break; } case OP_RowKey: case OP_RowData: { int i = pOp->p1; VdbeCursor *pC; BtCursor *pCrsr; u32 n; pOut = &p->aMem[pOp->p2]; assert( i>=0 && i<p->nCursor ); pC = p->apCsr[i]; assert( pC->isTable || pOp->opcode==OP_RowKey ); assert( pC->isIndex || pOp->opcode==OP_RowData ); assert( pC!=0 ); assert( pC->nullRow==0 ); assert( pC->pseudoTable==0 ); assert( pC->pCursor!=0 ); pCrsr = pC->pCursor; rc = sqlite3VdbeCursorMoveto(pC); if( rc ) goto abort_due_to_error; if( pC->isIndex ){ i64 n64; assert( !pC->isTable ); sqlite3BtreeKeySize(pCrsr, &n64); if( n64>db->aLimit[SQLITE_LIMIT_LENGTH] ){ goto too_big; } n = n64; }else{ sqlite3BtreeDataSize(pCrsr, &n); if( (int)n>db->aLimit[SQLITE_LIMIT_LENGTH] ){ goto too_big; } } if( sqlite3VdbeMemGrow(pOut, n, 0) ){ goto no_mem; } pOut->n = n; MemSetTypeFlag(pOut, MEM_Blob); if( pC->isIndex ){ rc = sqlite3BtreeKey(pCrsr, 0, n, pOut->z); }else{ rc = sqlite3BtreeData(pCrsr, 0, n, pOut->z); } pOut->enc = SQLITE_UTF8; UPDATE_MAX_BLOBSIZE(pOut); break; } case OP_Rowid: { int i = pOp->p1; VdbeCursor *pC; i64 v; assert( i>=0 && i<p->nCursor ); pC = p->apCsr[i]; assert( pC!=0 ); rc = sqlite3VdbeCursorMoveto(pC); if( rc ) goto abort_due_to_error; if( pC->rowidIsValid ){ v = pC->lastRowid; }else if( pC->pseudoTable ){ v = keyToInt(pC->iKey); }else if( pC->nullRow ){ break; }else{ assert( pC->pCursor!=0 ); sqlite3BtreeKeySize(pC->pCursor, &v); v = keyToInt(v); } pOut->u.i = v; MemSetTypeFlag(pOut, MEM_Int); break; } case OP_NullRow: { int i = pOp->p1; VdbeCursor *pC; assert( i>=0 && i<p->nCursor ); pC = p->apCsr[i]; assert( pC!=0 ); pC->nullRow = 1; pC->rowidIsValid = 0; if( pC->pCursor ){ sqlite3BtreeClearCursor(pC->pCursor); } break; } case OP_Last: { int i = pOp->p1; VdbeCursor *pC; BtCursor *pCrsr; int res; assert( i>=0 && i<p->nCursor ); pC = p->apCsr[i]; assert( pC!=0 ); pCrsr = pC->pCursor; assert( pCrsr!=0 ); rc = sqlite3BtreeLast(pCrsr, &res); pC->nullRow = res; pC->deferredMoveto = 0; pC->cacheStatus = CACHE_STALE; if( res && pOp->p2>0 ){ pc = pOp->p2 - 1; } break; } case OP_Sort: { 
#ifdef SQLITE_TEST 
 sqlite3_sort_count++; sqlite3_search_count--; 
#endif 
 p->aCounter[SQLITE_STMTSTATUS_SORT-1]++; } case OP_Rewind: { int i = pOp->p1; VdbeCursor *pC; BtCursor *pCrsr; int res; assert( i>=0 && i<p->nCursor ); pC = p->apCsr[i]; assert( pC!=0 ); if( (pCrsr = pC->pCursor)!=0 ){ rc = sqlite3BtreeFirst(pCrsr, &res); pC->atFirst = res==0; pC->deferredMoveto = 0; pC->cacheStatus = CACHE_STALE; }else{ res = 1; } pC->nullRow = res; assert( pOp->p2>0 && pOp->p2<p->nOp ); if( res ){ pc = pOp->p2 - 1; } break; } case OP_Prev: case OP_Next: { VdbeCursor *pC; BtCursor *pCrsr; int res; CHECK_FOR_INTERRUPT; assert( pOp->p1>=0 && pOp->p1<p->nCursor ); pC = p->apCsr[pOp->p1]; if( pC==0 ){ break; } pCrsr = pC->pCursor; assert( pCrsr ); res = 1; assert( pC->deferredMoveto==0 ); rc = pOp->opcode==OP_Next ? sqlite3BtreeNext(pCrsr, &res) : sqlite3BtreePrevious(pCrsr, &res); pC->nullRow = res; pC->cacheStatus = CACHE_STALE; if( res==0 ){ pc = pOp->p2 - 1; if( pOp->p5 ) p->aCounter[pOp->p5-1]++; 
#ifdef SQLITE_TEST 
 sqlite3_search_count++; 
#endif 
 } pC->rowidIsValid = 0; break; } case OP_IdxInsert: { int i = pOp->p1; VdbeCursor *pC; BtCursor *pCrsr; assert( i>=0 && i<p->nCursor ); assert( p->apCsr[i]!=0 ); assert( pIn2->flags & MEM_Blob ); if( (pCrsr = (pC = p->apCsr[i])->pCursor)!=0 ){ assert( pC->isTable==0 ); rc = ExpandBlob(pIn2); if( rc==SQLITE_OK ){ int nKey = pIn2->n; const char *zKey = pIn2->z; rc = sqlite3BtreeInsert(pCrsr, zKey, nKey, "", 0, 0, pOp->p3); assert( pC->deferredMoveto==0 ); pC->cacheStatus = CACHE_STALE; } } break; } case OP_IdxDelete: { int i = pOp->p1; VdbeCursor *pC; BtCursor *pCrsr; assert( pOp->p3>0 ); assert( pOp->p2>0 && pOp->p2+pOp->p3<=p->nMem ); assert( i>=0 && i<p->nCursor ); assert( p->apCsr[i]!=0 ); if( (pCrsr = (pC = p->apCsr[i])->pCursor)!=0 ){ int res; UnpackedRecord r; r.pKeyInfo = pC->pKeyInfo; r.nField = pOp->p3; r.flags = 0; r.aMem = &p->aMem[pOp->p2]; rc = sqlite3BtreeMovetoUnpacked(pCrsr, &r, 0, 0, &res); if( rc==SQLITE_OK && res==0 ){ rc = sqlite3BtreeDelete(pCrsr); } assert( pC->deferredMoveto==0 ); pC->cacheStatus = CACHE_STALE; } break; } case OP_IdxRowid: { int i = pOp->p1; BtCursor *pCrsr; VdbeCursor *pC; assert( i>=0 && i<p->nCursor ); assert( p->apCsr[i]!=0 ); if( (pCrsr = (pC = p->apCsr[i])->pCursor)!=0 ){ i64 rowid; assert( pC->deferredMoveto==0 ); assert( pC->isTable==0 ); if( !pC->nullRow ){ rc = sqlite3VdbeIdxRowid(pCrsr, &rowid); if( rc!=SQLITE_OK ){ goto abort_due_to_error; } MemSetTypeFlag(pOut, MEM_Int); pOut->u.i = rowid; } } break; } case OP_IdxLT: case OP_IdxGE: { int i= pOp->p1; VdbeCursor *pC; assert( i>=0 && i<p->nCursor ); assert( p->apCsr[i]!=0 ); if( (pC = p->apCsr[i])->pCursor!=0 ){ int res; UnpackedRecord r; assert( pC->deferredMoveto==0 ); assert( pOp->p5==0 || pOp->p5==1 ); assert( pOp->p4type==P4_INT32 ); r.pKeyInfo = pC->pKeyInfo; r.nField = pOp->p4.i; if( pOp->p5 ){ r.flags = UNPACKED_INCRKEY | UNPACKED_IGNORE_ROWID; }else{ r.flags = UNPACKED_IGNORE_ROWID; } r.aMem = &p->aMem[pOp->p3]; rc = sqlite3VdbeIdxKeyCompare(pC, &r, &res); if( pOp->opcode==OP_IdxLT ){ res = -res; }else{ assert( pOp->opcode==OP_IdxGE ); res++; } if( res>0 ){ pc = pOp->p2 - 1 ; } } break; } case OP_Destroy: { int iMoved; int iCnt; 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 Vdbe *pVdbe; iCnt = 0; for(pVdbe=db->pVdbe; pVdbe; pVdbe=pVdbe->pNext){ if( pVdbe->magic==VDBE_MAGIC_RUN && pVdbe->inVtabMethod<2 && pVdbe->pc>=0 ){ iCnt++; } } 
#else 
 iCnt = db->activeVdbeCnt; 
#endif 
 if( iCnt>1 ){ rc = SQLITE_LOCKED; p->errorAction = OE_Abort; }else{ int iDb = pOp->p3; assert( iCnt==1 ); assert( (p->btreeMask & (1<<iDb))!=0 ); rc = sqlite3BtreeDropTable(db->aDb[iDb].pBt, pOp->p1, &iMoved); MemSetTypeFlag(pOut, MEM_Int); pOut->u.i = iMoved; 
#ifndef SQLITE_OMIT_AUTOVACUUM 
 if( rc==SQLITE_OK && iMoved!=0 ){ sqlite3RootPageMoved(&db->aDb[iDb], iMoved, pOp->p1); } 
#endif 
 } break; } case OP_Clear: { int nChange = 0; assert( (p->btreeMask & (1<<pOp->p2))!=0 ); rc = sqlite3BtreeClearTable( db->aDb[pOp->p2].pBt, pOp->p1, (pOp->p3 ? &nChange : 0) ); if( pOp->p3 ){ p->nChange += nChange; if( pOp->p3>0 ){ p->aMem[pOp->p3].u.i += nChange; } } break; } case OP_CreateIndex: case OP_CreateTable: { int pgno; int flags; Db *pDb; assert( pOp->p1>=0 && pOp->p1<db->nDb ); assert( (p->btreeMask & (1<<pOp->p1))!=0 ); pDb = &db->aDb[pOp->p1]; assert( pDb->pBt!=0 ); if( pOp->opcode==OP_CreateTable ){ flags = BTREE_LEAFDATA|BTREE_INTKEY; }else{ flags = BTREE_ZERODATA; } rc = sqlite3BtreeCreateTable(pDb->pBt, &pgno, flags); if( rc==SQLITE_OK ){ pOut->u.i = pgno; MemSetTypeFlag(pOut, MEM_Int); } break; } case OP_ParseSchema: { char *zSql; int iDb = pOp->p1; const char *zMaster; InitData initData; assert( iDb>=0 && iDb<db->nDb ); if( !pOp->p2 && !DbHasProperty(db, iDb, DB_SchemaLoaded) ){ break; } zMaster = SCHEMA_TABLE(iDb); initData.db = db; initData.iDb = pOp->p1; initData.pzErrMsg = &p->zErrMsg; zSql = sqlite3MPrintf(db, "SELECT name, rootpage, sql FROM '%q'.%s WHERE %s", db->aDb[iDb].zName, zMaster, pOp->p4.z); if( zSql==0 ) goto no_mem; (void)sqlite3SafetyOff(db); assert( db->init.busy==0 ); db->init.busy = 1; initData.rc = SQLITE_OK; assert( !db->mallocFailed ); rc = sqlite3_exec(db, zSql, sqlite3InitCallback, &initData, 0); if( rc==SQLITE_OK ) rc = initData.rc; sqlite3DbFree(db, zSql); db->init.busy = 0; (void)sqlite3SafetyOn(db); if( rc==SQLITE_NOMEM ){ goto no_mem; } break; } 
#if !defined(SQLITE_OMIT_ANALYZE) && !defined(SQLITE_OMIT_PARSER) 
case OP_LoadAnalysis: { int iDb = pOp->p1; assert( iDb>=0 && iDb<db->nDb ); rc = sqlite3AnalysisLoad(db, iDb); break; } 
#endif 
case OP_DropTable: { sqlite3UnlinkAndDeleteTable(db, pOp->p1, pOp->p4.z); break; } case OP_DropIndex: { sqlite3UnlinkAndDeleteIndex(db, pOp->p1, pOp->p4.z); break; } case OP_DropTrigger: { sqlite3UnlinkAndDeleteTrigger(db, pOp->p1, pOp->p4.z); break; } 
#ifndef SQLITE_OMIT_INTEGRITY_CHECK 
case OP_IntegrityCk: { int nRoot; int *aRoot; int j; int nErr; char *z; Mem *pnErr; nRoot = pOp->p2; assert( nRoot>0 ); aRoot = sqlite3DbMallocRaw(db, sizeof(int)*(nRoot+1) ); if( aRoot==0 ) goto no_mem; assert( pOp->p3>0 && pOp->p3<=p->nMem ); pnErr = &p->aMem[pOp->p3]; assert( (pnErr->flags & MEM_Int)!=0 ); assert( (pnErr->flags & (MEM_Str|MEM_Blob))==0 ); pIn1 = &p->aMem[pOp->p1]; for(j=0; j<nRoot; j++){ aRoot[j] = sqlite3VdbeIntValue(&pIn1[j]); } aRoot[j] = 0; assert( pOp->p5<db->nDb ); assert( (p->btreeMask & (1<<pOp->p5))!=0 ); z = sqlite3BtreeIntegrityCheck(db->aDb[pOp->p5].pBt, aRoot, nRoot, pnErr->u.i, &nErr); sqlite3DbFree(db, aRoot); pnErr->u.i -= nErr; sqlite3VdbeMemSetNull(pIn1); if( nErr==0 ){ assert( z==0 ); }else if( z==0 ){ goto no_mem; }else{ sqlite3VdbeMemSetStr(pIn1, z, -1, SQLITE_UTF8, sqlite3_free); } UPDATE_MAX_BLOBSIZE(pIn1); sqlite3VdbeChangeEncoding(pIn1, encoding); break; } 
#endif 
case OP_FifoWrite: { p->sFifo.db = db; if( sqlite3VdbeFifoPush(&p->sFifo, sqlite3VdbeIntValue(pIn1))==SQLITE_NOMEM ){ goto no_mem; } break; } case OP_FifoRead: { CHECK_FOR_INTERRUPT; assert( pOp->p1>0 && pOp->p1<=p->nMem ); pOut = &p->aMem[pOp->p1]; MemSetTypeFlag(pOut, MEM_Int); if( sqlite3VdbeFifoPop(&p->sFifo, &pOut->u.i)==SQLITE_DONE ){ pc = pOp->p2 - 1; } break; } 
#ifndef SQLITE_OMIT_TRIGGER 
case OP_ContextPush: { int i = p->contextStackTop++; Context *pContext; assert( i>=0 ); if( i>=p->contextStackDepth ){ p->contextStackDepth = i+1; p->contextStack = sqlite3DbReallocOrFree(db, p->contextStack, sizeof(Context)*(i+1)); if( p->contextStack==0 ) goto no_mem; } pContext = &p->contextStack[i]; pContext->lastRowid = db->lastRowid; pContext->nChange = p->nChange; pContext->sFifo = p->sFifo; sqlite3VdbeFifoInit(&p->sFifo, db); break; } case OP_ContextPop: { Context *pContext = &p->contextStack[--p->contextStackTop]; assert( p->contextStackTop>=0 ); db->lastRowid = pContext->lastRowid; p->nChange = pContext->nChange; sqlite3VdbeFifoClear(&p->sFifo); p->sFifo = pContext->sFifo; break; } 
#endif 
#ifndef SQLITE_OMIT_AUTOINCREMENT 
case OP_MemMax: { sqlite3VdbeMemIntegerify(pIn1); sqlite3VdbeMemIntegerify(pIn2); if( pIn1->u.i<pIn2->u.i){ pIn1->u.i = pIn2->u.i; } break; } 
#endif 
case OP_IfPos: { assert( pIn1->flags&MEM_Int ); if( pIn1->u.i>0 ){ pc = pOp->p2 - 1; } break; } case OP_IfNeg: { assert( pIn1->flags&MEM_Int ); if( pIn1->u.i<0 ){ pc = pOp->p2 - 1; } break; } case OP_IfZero: { assert( pIn1->flags&MEM_Int ); if( pIn1->u.i==0 ){ pc = pOp->p2 - 1; } break; } case OP_AggStep: { int n = pOp->p5; int i; Mem *pMem, *pRec; sqlite3_context ctx; sqlite3_value **apVal; assert( n>=0 ); pRec = &p->aMem[pOp->p2]; apVal = p->apArg; assert( apVal || n==0 ); for(i=0; i<n; i++, pRec++){ apVal[i] = pRec; storeTypeInfo(pRec, encoding); } ctx.pFunc = pOp->p4.pFunc; assert( pOp->p3>0 && pOp->p3<=p->nMem ); ctx.pMem = pMem = &p->aMem[pOp->p3]; pMem->n++; ctx.s.flags = MEM_Null; ctx.s.z = 0; ctx.s.zMalloc = 0; ctx.s.xDel = 0; ctx.s.db = db; ctx.isError = 0; ctx.pColl = 0; if( ctx.pFunc->flags & SQLITE_FUNC_NEEDCOLL ){ assert( pOp>p->aOp ); assert( pOp[-1].p4type==P4_COLLSEQ ); assert( pOp[-1].opcode==OP_CollSeq ); ctx.pColl = pOp[-1].p4.pColl; } (ctx.pFunc->xStep)(&ctx, n, apVal); if( ctx.isError ){ sqlite3SetString(&p->zErrMsg, db, "%s", sqlite3_value_text(&ctx.s)); rc = ctx.isError; } sqlite3VdbeMemRelease(&ctx.s); break; } case OP_AggFinal: { Mem *pMem; assert( pOp->p1>0 && pOp->p1<=p->nMem ); pMem = &p->aMem[pOp->p1]; assert( (pMem->flags & ~(MEM_Null|MEM_Agg))==0 ); rc = sqlite3VdbeMemFinalize(pMem, pOp->p4.pFunc); if( rc==SQLITE_ERROR ){ sqlite3SetString(&p->zErrMsg, db, "%s", sqlite3_value_text(pMem)); } sqlite3VdbeChangeEncoding(pMem, encoding); UPDATE_MAX_BLOBSIZE(pMem); if( sqlite3VdbeMemTooBig(pMem) ){ goto too_big; } break; } 
#if !defined(SQLITE_OMIT_VACUUM) && !defined(SQLITE_OMIT_ATTACH) 
case OP_Vacuum: { if( sqlite3SafetyOff(db) ) goto abort_due_to_misuse; rc = sqlite3RunVacuum(&p->zErrMsg, db); if( sqlite3SafetyOn(db) ) goto abort_due_to_misuse; break; } 
#endif 
#if !defined(SQLITE_OMIT_AUTOVACUUM) 
case OP_IncrVacuum: { Btree *pBt; assert( pOp->p1>=0 && pOp->p1<db->nDb ); assert( (p->btreeMask & (1<<pOp->p1))!=0 ); pBt = db->aDb[pOp->p1].pBt; rc = sqlite3BtreeIncrVacuum(pBt); if( rc==SQLITE_DONE ){ pc = pOp->p2 - 1; rc = SQLITE_OK; } break; } 
#endif 
case OP_Expire: { if( !pOp->p1 ){ sqlite3ExpirePreparedStatements(db); }else{ p->expired = 1; } break; } 
#ifndef SQLITE_OMIT_SHARED_CACHE 
case OP_TableLock: { int p1 = pOp->p1; u8 isWriteLock = pOp->p3; assert( p1>=0 && p1<db->nDb ); assert( (p->btreeMask & (1<<p1))!=0 ); assert( isWriteLock==0 || isWriteLock==1 ); rc = sqlite3BtreeLockTable(db->aDb[p1].pBt, pOp->p2, isWriteLock); if( rc==SQLITE_LOCKED ){ const char *z = pOp->p4.z; sqlite3SetString(&p->zErrMsg, db, "database table is locked: %s", z); } break; } 
#endif 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
case OP_VBegin: { sqlite3_vtab *pVtab = pOp->p4.pVtab; rc = sqlite3VtabBegin(db, pVtab); if( pVtab ){ sqlite3DbFree(db, p->zErrMsg); p->zErrMsg = pVtab->zErrMsg; pVtab->zErrMsg = 0; } break; } 
#endif 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
case OP_VCreate: { rc = sqlite3VtabCallCreate(db, pOp->p1, pOp->p4.z, &p->zErrMsg); break; } 
#endif 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
case OP_VDestroy: { p->inVtabMethod = 2; rc = sqlite3VtabCallDestroy(db, pOp->p1, pOp->p4.z); p->inVtabMethod = 0; break; } 
#endif 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
case OP_VOpen: { VdbeCursor *pCur = 0; sqlite3_vtab_cursor *pVtabCursor = 0; sqlite3_vtab *pVtab = pOp->p4.pVtab; sqlite3_module *pModule = (sqlite3_module *)pVtab->pModule; assert(pVtab && pModule); if( sqlite3SafetyOff(db) ) goto abort_due_to_misuse; rc = pModule->xOpen(pVtab, &pVtabCursor); sqlite3DbFree(db, p->zErrMsg); p->zErrMsg = pVtab->zErrMsg; pVtab->zErrMsg = 0; if( sqlite3SafetyOn(db) ) goto abort_due_to_misuse; if( SQLITE_OK==rc ){ pVtabCursor->pVtab = pVtab; pCur = allocateCursor(p, pOp->p1, &pOp[-1], -1, 0); if( pCur ){ pCur->pVtabCursor = pVtabCursor; pCur->pModule = pVtabCursor->pVtab->pModule; }else{ db->mallocFailed = 1; pModule->xClose(pVtabCursor); } } break; } 
#endif 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
case OP_VFilter: { int nArg; int iQuery; const sqlite3_module *pModule; Mem *pQuery = &p->aMem[pOp->p3]; Mem *pArgc = &pQuery[1]; sqlite3_vtab_cursor *pVtabCursor; sqlite3_vtab *pVtab; VdbeCursor *pCur = p->apCsr[pOp->p1]; REGISTER_TRACE(pOp->p3, pQuery); assert( pCur->pVtabCursor ); pVtabCursor = pCur->pVtabCursor; pVtab = pVtabCursor->pVtab; pModule = pVtab->pModule; assert( (pQuery->flags&MEM_Int)!=0 && pArgc->flags==MEM_Int ); nArg = pArgc->u.i; iQuery = pQuery->u.i; { int res = 0; int i; Mem **apArg = p->apArg; for(i = 0; i<nArg; i++){ apArg[i] = &pArgc[i+1]; storeTypeInfo(apArg[i], 0); } if( sqlite3SafetyOff(db) ) goto abort_due_to_misuse; sqlite3VtabLock(pVtab); p->inVtabMethod = 1; rc = pModule->xFilter(pVtabCursor, iQuery, pOp->p4.z, nArg, apArg); p->inVtabMethod = 0; sqlite3DbFree(db, p->zErrMsg); p->zErrMsg = pVtab->zErrMsg; pVtab->zErrMsg = 0; sqlite3VtabUnlock(db, pVtab); if( rc==SQLITE_OK ){ res = pModule->xEof(pVtabCursor); } if( sqlite3SafetyOn(db) ) goto abort_due_to_misuse; if( res ){ pc = pOp->p2 - 1; } } pCur->nullRow = 0; break; } 
#endif 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
case OP_VRowid: { sqlite3_vtab *pVtab; const sqlite3_module *pModule; sqlite_int64 iRow; VdbeCursor *pCur = p->apCsr[pOp->p1]; assert( pCur->pVtabCursor ); if( pCur->nullRow ){ break; } pVtab = pCur->pVtabCursor->pVtab; pModule = pVtab->pModule; assert( pModule->xRowid ); if( sqlite3SafetyOff(db) ) goto abort_due_to_misuse; rc = pModule->xRowid(pCur->pVtabCursor, &iRow); sqlite3DbFree(db, p->zErrMsg); p->zErrMsg = pVtab->zErrMsg; pVtab->zErrMsg = 0; if( sqlite3SafetyOn(db) ) goto abort_due_to_misuse; MemSetTypeFlag(pOut, MEM_Int); pOut->u.i = iRow; break; } 
#endif 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
case OP_VColumn: { sqlite3_vtab *pVtab; const sqlite3_module *pModule; Mem *pDest; sqlite3_context sContext; VdbeCursor *pCur = p->apCsr[pOp->p1]; assert( pCur->pVtabCursor ); assert( pOp->p3>0 && pOp->p3<=p->nMem ); pDest = &p->aMem[pOp->p3]; if( pCur->nullRow ){ sqlite3VdbeMemSetNull(pDest); break; } pVtab = pCur->pVtabCursor->pVtab; pModule = pVtab->pModule; assert( pModule->xColumn ); memset(&sContext, 0, sizeof(sContext)); sqlite3VdbeMemMove(&sContext.s, pDest); MemSetTypeFlag(&sContext.s, MEM_Null); if( sqlite3SafetyOff(db) ) goto abort_due_to_misuse; rc = pModule->xColumn(pCur->pVtabCursor, &sContext, pOp->p2); sqlite3DbFree(db, p->zErrMsg); p->zErrMsg = pVtab->zErrMsg; pVtab->zErrMsg = 0; sqlite3VdbeChangeEncoding(&sContext.s, encoding); REGISTER_TRACE(pOp->p3, pDest); sqlite3VdbeMemMove(pDest, &sContext.s); UPDATE_MAX_BLOBSIZE(pDest); if( sqlite3SafetyOn(db) ){ goto abort_due_to_misuse; } if( sqlite3VdbeMemTooBig(pDest) ){ goto too_big; } break; } 
#endif 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
case OP_VNext: { sqlite3_vtab *pVtab; const sqlite3_module *pModule; int res = 0; VdbeCursor *pCur = p->apCsr[pOp->p1]; assert( pCur->pVtabCursor ); if( pCur->nullRow ){ break; } pVtab = pCur->pVtabCursor->pVtab; pModule = pVtab->pModule; assert( pModule->xNext ); if( sqlite3SafetyOff(db) ) goto abort_due_to_misuse; sqlite3VtabLock(pVtab); p->inVtabMethod = 1; rc = pModule->xNext(pCur->pVtabCursor); p->inVtabMethod = 0; sqlite3DbFree(db, p->zErrMsg); p->zErrMsg = pVtab->zErrMsg; pVtab->zErrMsg = 0; sqlite3VtabUnlock(db, pVtab); if( rc==SQLITE_OK ){ res = pModule->xEof(pCur->pVtabCursor); } if( sqlite3SafetyOn(db) ) goto abort_due_to_misuse; if( !res ){ pc = pOp->p2 - 1; } break; } 
#endif 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
case OP_VRename: { sqlite3_vtab *pVtab = pOp->p4.pVtab; Mem *pName = &p->aMem[pOp->p1]; assert( pVtab->pModule->xRename ); REGISTER_TRACE(pOp->p1, pName); Stringify(pName, encoding); if( sqlite3SafetyOff(db) ) goto abort_due_to_misuse; sqlite3VtabLock(pVtab); rc = pVtab->pModule->xRename(pVtab, pName->z); sqlite3DbFree(db, p->zErrMsg); p->zErrMsg = pVtab->zErrMsg; pVtab->zErrMsg = 0; sqlite3VtabUnlock(db, pVtab); if( sqlite3SafetyOn(db) ) goto abort_due_to_misuse; break; } 
#endif 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
case OP_VUpdate: { sqlite3_vtab *pVtab = pOp->p4.pVtab; sqlite3_module *pModule = (sqlite3_module *)pVtab->pModule; int nArg = pOp->p2; assert( pOp->p4type==P4_VTAB ); if( pModule->xUpdate==0 ){ sqlite3SetString(&p->zErrMsg, db, "read-only table"); rc = SQLITE_ERROR; }else{ int i; sqlite_int64 rowid; Mem **apArg = p->apArg; Mem *pX = &p->aMem[pOp->p3]; for(i=0; i<nArg; i++){ storeTypeInfo(pX, 0); apArg[i] = pX; pX++; } if( sqlite3SafetyOff(db) ) goto abort_due_to_misuse; sqlite3VtabLock(pVtab); rc = pModule->xUpdate(pVtab, nArg, apArg, &rowid); sqlite3DbFree(db, p->zErrMsg); p->zErrMsg = pVtab->zErrMsg; pVtab->zErrMsg = 0; sqlite3VtabUnlock(db, pVtab); if( sqlite3SafetyOn(db) ) goto abort_due_to_misuse; if( pOp->p1 && rc==SQLITE_OK ){ assert( nArg>1 && apArg[0] && (apArg[0]->flags&MEM_Null) ); db->lastRowid = rowid; } p->nChange++; } break; } 
#endif 
#ifndef SQLITE_OMIT_PAGER_PRAGMAS 
case OP_Pagecount: { int p1 = pOp->p1; int nPage; Pager *pPager = sqlite3BtreePager(db->aDb[p1].pBt); rc = sqlite3PagerPagecount(pPager, &nPage); if( rc==SQLITE_OK ){ pOut->flags = MEM_Int; pOut->u.i = nPage; } break; } 
#endif 
#ifndef SQLITE_OMIT_TRACE 
case OP_Trace: { if( pOp->p4.z ){ if( db->xTrace ){ db->xTrace(db->pTraceArg, pOp->p4.z); } 
#ifdef SQLITE_DEBUG 
 if( (db->flags & SQLITE_SqlTrace)!=0 ){ sqlite3DebugPrintf("SQL-trace: %s\n", pOp->p4.z); } 
#endif 
 } break; } 
#endif 
default: { break; } } 
#ifdef VDBE_PROFILE 
 { u64 elapsed = sqlite3Hwtime() - start; pOp->cycles += elapsed; pOp->cnt++; 
#if 0 
 fprintf(stdout, "%10llu ", elapsed); sqlite3VdbePrintOp(stdout, origPc, &p->aOp[origPc]); 
#endif 
 } 
#endif 
 
#ifndef NDEBUG 
 assert( pc>=-1 && pc<p->nOp ); 
#ifdef SQLITE_DEBUG 
 if( p->trace ){ if( rc!=0 ) fprintf(p->trace,"rc=%d\n",rc); if( opProperty & OPFLG_OUT2_PRERELEASE ){ registerTrace(p->trace, pOp->p2, pOut); } if( opProperty & OPFLG_OUT3 ){ registerTrace(p->trace, pOp->p3, pOut); } } 
#endif 
#endif 
 } vdbe_error_halt: assert( rc ); p->rc = rc; sqlite3VdbeHalt(p); if( rc==SQLITE_IOERR_NOMEM ) db->mallocFailed = 1; rc = SQLITE_ERROR; vdbe_return: sqlite3BtreeMutexArrayLeave(&p->aMutex); return rc; too_big: sqlite3SetString(&p->zErrMsg, db, "string or blob too big"); rc = SQLITE_TOOBIG; goto vdbe_error_halt; no_mem: db->mallocFailed = 1; sqlite3SetString(&p->zErrMsg, db, "out of memory"); rc = SQLITE_NOMEM; goto vdbe_error_halt; abort_due_to_misuse: rc = SQLITE_MISUSE; abort_due_to_error: assert( p->zErrMsg==0 ); if( db->mallocFailed ) rc = SQLITE_NOMEM; if( rc!=SQLITE_IOERR_NOMEM ){ sqlite3SetString(&p->zErrMsg, db, "%s", sqlite3ErrStr(rc)); } goto vdbe_error_halt; abort_due_to_interrupt: assert( db->u1.isInterrupted ); rc = SQLITE_INTERRUPT; p->rc = rc; sqlite3SetString(&p->zErrMsg, db, "%s", sqlite3ErrStr(rc)); goto vdbe_error_halt; } 
#ifndef SQLITE_OMIT_INCRBLOB 
typedef struct Incrblob Incrblob; struct Incrblob { int flags; int nByte; int iOffset; BtCursor *pCsr; sqlite3_stmt *pStmt; sqlite3 *db; }; SQLITE_API int sqlite3_blob_open( sqlite3* db, const char *zDb, const char *zTable, const char *zColumn, sqlite_int64 iRow, int flags, sqlite3_blob **ppBlob ){ int nAttempt = 0; int iCol; static const VdbeOpList openBlob[] = { {OP_Transaction, 0, 0, 0}, {OP_VerifyCookie, 0, 0, 0}, {OP_SetNumColumns, 0, 0, 0}, {OP_OpenRead, 0, 0, 0}, {OP_SetNumColumns, 0, 0, 0}, {OP_OpenWrite, 0, 0, 0}, {OP_Variable, 1, 1, 0}, {OP_NotExists, 0, 10, 1}, {OP_Column, 0, 0, 1}, {OP_ResultRow, 1, 0, 0}, {OP_Close, 0, 0, 0}, {OP_Halt, 0, 0, 0}, }; Vdbe *v = 0; int rc = SQLITE_OK; char zErr[128]; zErr[0] = 0; sqlite3_mutex_enter(db->mutex); do { Parse sParse; Table *pTab; memset(&sParse, 0, sizeof(Parse)); sParse.db = db; if( sqlite3SafetyOn(db) ){ sqlite3_mutex_leave(db->mutex); return SQLITE_MISUSE; } sqlite3BtreeEnterAll(db); pTab = sqlite3LocateTable(&sParse, 0, zTable, zDb); if( pTab && IsVirtual(pTab) ){ pTab = 0; sqlite3ErrorMsg(&sParse, "cannot open virtual table: %s", zTable); } 
#ifndef SQLITE_OMIT_VIEW 
 if( pTab && pTab->pSelect ){ pTab = 0; sqlite3ErrorMsg(&sParse, "cannot open view: %s", zTable); } 
#endif 
 if( !pTab ){ if( sParse.zErrMsg ){ sqlite3_snprintf(sizeof(zErr), zErr, "%s", sParse.zErrMsg); } sqlite3DbFree(db, sParse.zErrMsg); rc = SQLITE_ERROR; (void)sqlite3SafetyOff(db); sqlite3BtreeLeaveAll(db); goto blob_open_out; } for(iCol=0; iCol < pTab->nCol; iCol++) { if( sqlite3StrICmp(pTab->aCol[iCol].zName, zColumn)==0 ){ break; } } if( iCol==pTab->nCol ){ sqlite3_snprintf(sizeof(zErr), zErr, "no such column: \"%s\"", zColumn); rc = SQLITE_ERROR; (void)sqlite3SafetyOff(db); sqlite3BtreeLeaveAll(db); goto blob_open_out; } if( flags ){ Index *pIdx; for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){ int j; for(j=0; j<pIdx->nColumn; j++){ if( pIdx->aiColumn[j]==iCol ){ sqlite3_snprintf(sizeof(zErr), zErr, "cannot open indexed column for writing"); rc = SQLITE_ERROR; (void)sqlite3SafetyOff(db); sqlite3BtreeLeaveAll(db); goto blob_open_out; } } } } v = sqlite3VdbeCreate(db); if( v ){ int iDb = sqlite3SchemaToIndex(db, pTab->pSchema); sqlite3VdbeAddOpList(v, sizeof(openBlob)/sizeof(VdbeOpList), openBlob); sqlite3VdbeChangeP1(v, 0, iDb); sqlite3VdbeChangeP2(v, 0, (flags ? 1 : 0)); sqlite3VdbeChangeP1(v, 1, iDb); sqlite3VdbeChangeP2(v, 1, pTab->pSchema->schema_cookie); sqlite3VdbeUsesBtree(v, iDb); sqlite3VdbeChangeToNoop(v, (flags ? 3 : 5), 1); sqlite3VdbeChangeP2(v, (flags ? 5 : 3), pTab->tnum); sqlite3VdbeChangeP3(v, (flags ? 5 : 3), iDb); sqlite3VdbeChangeP2(v, flags ? 4 : 2, pTab->nCol+1); sqlite3VdbeChangeP2(v, 8, pTab->nCol); if( !db->mallocFailed ){ sqlite3VdbeMakeReady(v, 1, 1, 1, 0); } } sqlite3BtreeLeaveAll(db); rc = sqlite3SafetyOff(db); if( rc!=SQLITE_OK || db->mallocFailed ){ goto blob_open_out; } sqlite3_bind_int64((sqlite3_stmt *)v, 1, iRow); rc = sqlite3_step((sqlite3_stmt *)v); if( rc!=SQLITE_ROW ){ nAttempt++; rc = sqlite3_finalize((sqlite3_stmt *)v); sqlite3_snprintf(sizeof(zErr), zErr, sqlite3_errmsg(db)); v = 0; } } while( nAttempt<5 && rc==SQLITE_SCHEMA ); if( rc==SQLITE_ROW ){ Incrblob *pBlob; u32 type = v->apCsr[0]->aType[iCol]; if( type<12 ){ sqlite3_snprintf(sizeof(zErr), zErr, "cannot open value of type %s", type==0?"null": type==7?"real": "integer" ); rc = SQLITE_ERROR; goto blob_open_out; } pBlob = (Incrblob *)sqlite3DbMallocZero(db, sizeof(Incrblob)); if( db->mallocFailed ){ sqlite3DbFree(db, pBlob); goto blob_open_out; } pBlob->flags = flags; pBlob->pCsr = v->apCsr[0]->pCursor; sqlite3BtreeEnterCursor(pBlob->pCsr); sqlite3BtreeCacheOverflow(pBlob->pCsr); sqlite3BtreeLeaveCursor(pBlob->pCsr); pBlob->pStmt = (sqlite3_stmt *)v; pBlob->iOffset = v->apCsr[0]->aOffset[iCol]; pBlob->nByte = sqlite3VdbeSerialTypeLen(type); pBlob->db = db; *ppBlob = (sqlite3_blob *)pBlob; rc = SQLITE_OK; }else if( rc==SQLITE_OK ){ sqlite3_snprintf(sizeof(zErr), zErr, "no such rowid: %lld", iRow); rc = SQLITE_ERROR; } blob_open_out: zErr[sizeof(zErr)-1] = '\0'; if( rc!=SQLITE_OK || db->mallocFailed ){ sqlite3_finalize((sqlite3_stmt *)v); } sqlite3Error(db, rc, (rc==SQLITE_OK?0:zErr)); rc = sqlite3ApiExit(db, rc); sqlite3_mutex_leave(db->mutex); return rc; } SQLITE_API int sqlite3_blob_close(sqlite3_blob *pBlob){ Incrblob *p = (Incrblob *)pBlob; int rc; rc = sqlite3_finalize(p->pStmt); sqlite3DbFree(p->db, p); return rc; } static int blobReadWrite( sqlite3_blob *pBlob, void *z, int n, int iOffset, int (*xCall)(BtCursor*, u32, u32, void*) ){ int rc; Incrblob *p = (Incrblob *)pBlob; Vdbe *v; sqlite3 *db = p->db; sqlite3_mutex_enter(db->mutex); v = (Vdbe*)p->pStmt; if( n<0 || iOffset<0 || (iOffset+n)>p->nByte ){ rc = SQLITE_ERROR; sqlite3Error(db, SQLITE_ERROR, 0); } else if( v==0 ){ rc = SQLITE_ABORT; }else{ assert( db == v->db ); sqlite3BtreeEnterCursor(p->pCsr); rc = xCall(p->pCsr, iOffset+p->iOffset, n, z); sqlite3BtreeLeaveCursor(p->pCsr); if( rc==SQLITE_ABORT ){ sqlite3VdbeFinalize(v); p->pStmt = 0; }else{ db->errCode = rc; v->rc = rc; } } rc = sqlite3ApiExit(db, rc); sqlite3_mutex_leave(db->mutex); return rc; } SQLITE_API int sqlite3_blob_read(sqlite3_blob *pBlob, void *z, int n, int iOffset){ return blobReadWrite(pBlob, z, n, iOffset, sqlite3BtreeData); } SQLITE_API int sqlite3_blob_write(sqlite3_blob *pBlob, const void *z, int n, int iOffset){ return blobReadWrite(pBlob, (void *)z, n, iOffset, sqlite3BtreePutData); } SQLITE_API int sqlite3_blob_bytes(sqlite3_blob *pBlob){ Incrblob *p = (Incrblob *)pBlob; return p->nByte; } 
#endif 
#ifdef SQLITE_ENABLE_ATOMIC_WRITE 
struct JournalFile { sqlite3_io_methods *pMethod; int nBuf; char *zBuf; int iSize; int flags; sqlite3_vfs *pVfs; sqlite3_file *pReal; const char *zJournal; }; typedef struct JournalFile JournalFile; static int createFile(JournalFile *p){ int rc = SQLITE_OK; if( !p->pReal ){ sqlite3_file *pReal = (sqlite3_file *)&p[1]; rc = sqlite3OsOpen(p->pVfs, p->zJournal, pReal, p->flags, 0); if( rc==SQLITE_OK ){ p->pReal = pReal; if( p->iSize>0 ){ assert(p->iSize<=p->nBuf); rc = sqlite3OsWrite(p->pReal, p->zBuf, p->iSize, 0); } } } return rc; } static int jrnlClose(sqlite3_file *pJfd){ JournalFile *p = (JournalFile *)pJfd; if( p->pReal ){ sqlite3OsClose(p->pReal); } sqlite3_free(p->zBuf); return SQLITE_OK; } static int jrnlRead( sqlite3_file *pJfd, void *zBuf, int iAmt, sqlite_int64 iOfst ){ int rc = SQLITE_OK; JournalFile *p = (JournalFile *)pJfd; if( p->pReal ){ rc = sqlite3OsRead(p->pReal, zBuf, iAmt, iOfst); }else{ assert( iAmt+iOfst<=p->iSize ); memcpy(zBuf, &p->zBuf[iOfst], iAmt); } return rc; } static int jrnlWrite( sqlite3_file *pJfd, const void *zBuf, int iAmt, sqlite_int64 iOfst ){ int rc = SQLITE_OK; JournalFile *p = (JournalFile *)pJfd; if( !p->pReal && (iOfst+iAmt)>p->nBuf ){ rc = createFile(p); } if( rc==SQLITE_OK ){ if( p->pReal ){ rc = sqlite3OsWrite(p->pReal, zBuf, iAmt, iOfst); }else{ memcpy(&p->zBuf[iOfst], zBuf, iAmt); if( p->iSize<(iOfst+iAmt) ){ p->iSize = (iOfst+iAmt); } } } return rc; } static int jrnlTruncate(sqlite3_file *pJfd, sqlite_int64 size){ int rc = SQLITE_OK; JournalFile *p = (JournalFile *)pJfd; if( p->pReal ){ rc = sqlite3OsTruncate(p->pReal, size); }else if( size<p->iSize ){ p->iSize = size; } return rc; } static int jrnlSync(sqlite3_file *pJfd, int flags){ int rc; JournalFile *p = (JournalFile *)pJfd; if( p->pReal ){ rc = sqlite3OsSync(p->pReal, flags); }else{ rc = SQLITE_OK; } return rc; } static int jrnlFileSize(sqlite3_file *pJfd, sqlite_int64 *pSize){ int rc = SQLITE_OK; JournalFile *p = (JournalFile *)pJfd; if( p->pReal ){ rc = sqlite3OsFileSize(p->pReal, pSize); }else{ *pSize = (sqlite_int64) p->iSize; } return rc; } static struct sqlite3_io_methods JournalFileMethods = { 1, jrnlClose, jrnlRead, jrnlWrite, jrnlTruncate, jrnlSync, jrnlFileSize, 0, 0, 0, 0, 0, 0 }; SQLITE_PRIVATE int sqlite3JournalOpen( sqlite3_vfs *pVfs, const char *zName, sqlite3_file *pJfd, int flags, int nBuf ){ JournalFile *p = (JournalFile *)pJfd; memset(p, 0, sqlite3JournalSize(pVfs)); if( nBuf>0 ){ p->zBuf = sqlite3MallocZero(nBuf); if( !p->zBuf ){ return SQLITE_NOMEM; } }else{ return sqlite3OsOpen(pVfs, zName, pJfd, flags, 0); } p->pMethod = &JournalFileMethods; p->nBuf = nBuf; p->flags = flags; p->zJournal = zName; p->pVfs = pVfs; return SQLITE_OK; } SQLITE_PRIVATE int sqlite3JournalCreate(sqlite3_file *p){ if( p->pMethods!=&JournalFileMethods ){ return SQLITE_OK; } return createFile((JournalFile *)p); } SQLITE_PRIVATE int sqlite3JournalSize(sqlite3_vfs *pVfs){ return (pVfs->szOsFile+sizeof(JournalFile)); } 
#endif 
typedef struct MemJournal MemJournal; typedef struct FilePoint FilePoint; typedef struct FileChunk FileChunk; 
#define JOURNAL_CHUNKSIZE 1024 
#ifndef MIN 
#define MIN(x,y) ((x)<(y)?(x):(y)) 
#endif 
struct FileChunk { FileChunk *pNext; u8 zChunk[JOURNAL_CHUNKSIZE]; }; struct FilePoint { sqlite3_int64 iOffset; FileChunk *pChunk; }; struct MemJournal { sqlite3_io_methods *pMethod; FileChunk *pFirst; FilePoint endpoint; FilePoint readpoint; }; static int memjrnlRead( sqlite3_file *pJfd, void *zBuf, int iAmt, sqlite_int64 iOfst ){ MemJournal *p = (MemJournal *)pJfd; u8 *zOut = zBuf; int nRead = iAmt; int iChunkOffset; FileChunk *pChunk; assert( iOfst+iAmt<=p->endpoint.iOffset ); if( p->readpoint.iOffset!=iOfst || iOfst==0 ){ sqlite3_int64 iOff = 0; for(pChunk=p->pFirst; pChunk && (iOff+JOURNAL_CHUNKSIZE)<=iOfst; pChunk=pChunk->pNext ){ iOff += JOURNAL_CHUNKSIZE; } }else{ pChunk = p->readpoint.pChunk; } iChunkOffset = (iOfst%JOURNAL_CHUNKSIZE); do { int iSpace = JOURNAL_CHUNKSIZE - iChunkOffset; int nCopy = MIN(nRead, (JOURNAL_CHUNKSIZE - iChunkOffset)); memcpy(zOut, &pChunk->zChunk[iChunkOffset], nCopy); zOut += nCopy; nRead -= iSpace; iChunkOffset = 0; } while( nRead>=0 && (pChunk=pChunk->pNext) && nRead>0 ); p->readpoint.iOffset = iOfst+iAmt; p->readpoint.pChunk = pChunk; return SQLITE_OK; } static int memjrnlWrite( sqlite3_file *pJfd, const void *zBuf, int iAmt, sqlite_int64 iOfst ){ MemJournal *p = (MemJournal *)pJfd; int nWrite = iAmt; u8 *zWrite = (u8 *)zBuf; assert(iOfst==p->endpoint.iOffset); UNUSED_PARAMETER(iOfst); while( nWrite>0 ){ FileChunk *pChunk = p->endpoint.pChunk; int iChunkOffset = p->endpoint.iOffset%JOURNAL_CHUNKSIZE; int iSpace = MIN(nWrite, JOURNAL_CHUNKSIZE - iChunkOffset); if( iChunkOffset==0 ){ FileChunk *pNew = sqlite3_malloc(sizeof(FileChunk)); if( !pNew ){ return SQLITE_IOERR_NOMEM; } pNew->pNext = 0; if( pChunk ){ assert( p->pFirst ); pChunk->pNext = pNew; }else{ assert( !p->pFirst ); p->pFirst = pNew; } p->endpoint.pChunk = pNew; } memcpy(&p->endpoint.pChunk->zChunk[iChunkOffset], zWrite, iSpace); zWrite += iSpace; nWrite -= iSpace; p->endpoint.iOffset += iSpace; } return SQLITE_OK; } static int memjrnlTruncate(sqlite3_file *pJfd, sqlite_int64 size){ MemJournal *p = (MemJournal *)pJfd; FileChunk *pChunk; assert(size==0); UNUSED_PARAMETER(size); pChunk = p->pFirst; while( pChunk ){ FileChunk *pTmp = pChunk; pChunk = pChunk->pNext; sqlite3_free(pTmp); } sqlite3MemJournalOpen(pJfd); return SQLITE_OK; } static int memjrnlClose(sqlite3_file *pJfd){ memjrnlTruncate(pJfd, 0); return SQLITE_OK; } static int memjrnlSync(sqlite3_file *NotUsed, int NotUsed2){ UNUSED_PARAMETER2(NotUsed, NotUsed2); return SQLITE_OK; } static int memjrnlFileSize(sqlite3_file *pJfd, sqlite_int64 *pSize){ MemJournal *p = (MemJournal *)pJfd; *pSize = (sqlite_int64) p->endpoint.iOffset; return SQLITE_OK; } static struct sqlite3_io_methods MemJournalMethods = { 1, memjrnlClose, memjrnlRead, memjrnlWrite, memjrnlTruncate, memjrnlSync, memjrnlFileSize, 0, 0, 0, 0, 0, 0 }; SQLITE_PRIVATE void sqlite3MemJournalOpen(sqlite3_file *pJfd){ MemJournal *p = (MemJournal *)pJfd; memset(p, 0, sqlite3MemJournalSize()); p->pMethod = &MemJournalMethods; } SQLITE_PRIVATE int sqlite3IsMemJournal(sqlite3_file *pJfd){ return pJfd->pMethods==&MemJournalMethods; } SQLITE_PRIVATE int sqlite3MemJournalSize(){ return sizeof(MemJournal); } SQLITE_PRIVATE int sqlite3WalkExpr(Walker *pWalker, Expr *pExpr){ int rc; if( pExpr==0 ) return WRC_Continue; rc = pWalker->xExprCallback(pWalker, pExpr); if( rc==WRC_Continue ){ if( sqlite3WalkExpr(pWalker, pExpr->pLeft) ) return WRC_Abort; if( sqlite3WalkExpr(pWalker, pExpr->pRight) ) return WRC_Abort; if( sqlite3WalkExprList(pWalker, pExpr->pList) ) return WRC_Abort; if( sqlite3WalkSelect(pWalker, pExpr->pSelect) ){ return WRC_Abort; } } return rc & WRC_Abort; } SQLITE_PRIVATE int sqlite3WalkExprList(Walker *pWalker, ExprList *p){ int i, rc = WRC_Continue; struct ExprList_item *pItem; if( p ){ for(i=p->nExpr, pItem=p->a; i>0; i--, pItem++){ if( sqlite3WalkExpr(pWalker, pItem->pExpr) ) return WRC_Abort; } } return rc & WRC_Continue; } SQLITE_PRIVATE int sqlite3WalkSelectExpr(Walker *pWalker, Select *p){ if( sqlite3WalkExprList(pWalker, p->pEList) ) return WRC_Abort; if( sqlite3WalkExpr(pWalker, p->pWhere) ) return WRC_Abort; if( sqlite3WalkExprList(pWalker, p->pGroupBy) ) return WRC_Abort; if( sqlite3WalkExpr(pWalker, p->pHaving) ) return WRC_Abort; if( sqlite3WalkExprList(pWalker, p->pOrderBy) ) return WRC_Abort; if( sqlite3WalkExpr(pWalker, p->pLimit) ) return WRC_Abort; if( sqlite3WalkExpr(pWalker, p->pOffset) ) return WRC_Abort; return WRC_Continue; } SQLITE_PRIVATE int sqlite3WalkSelectFrom(Walker *pWalker, Select *p){ SrcList *pSrc; int i; struct SrcList_item *pItem; pSrc = p->pSrc; if( pSrc ){ for(i=pSrc->nSrc, pItem=pSrc->a; i>0; i--, pItem++){ if( sqlite3WalkSelect(pWalker, pItem->pSelect) ){ return WRC_Abort; } } } return WRC_Continue; } SQLITE_PRIVATE int sqlite3WalkSelect(Walker *pWalker, Select *p){ int rc; if( p==0 || pWalker->xSelectCallback==0 ) return WRC_Continue; rc = WRC_Continue; while( p ){ rc = pWalker->xSelectCallback(pWalker, p); if( rc ) break; if( sqlite3WalkSelectExpr(pWalker, p) ) return WRC_Abort; if( sqlite3WalkSelectFrom(pWalker, p) ) return WRC_Abort; p = p->pPrior; } return rc & WRC_Abort; } static void resolveAlias( Parse *pParse, ExprList *pEList, int iCol, Expr *pExpr, const char *zType ){ Expr *pOrig; Expr *pDup; sqlite3 *db; assert( iCol>=0 && iCol<pEList->nExpr ); pOrig = pEList->a[iCol].pExpr; assert( pOrig!=0 ); assert( pOrig->flags & EP_Resolved ); db = pParse->db; pDup = sqlite3ExprDup(db, pOrig); if( pDup==0 ) return; if( pDup->op!=TK_COLUMN && zType[0]!='G' ){ pDup = sqlite3PExpr(pParse, TK_AS, pDup, 0, 0); if( pDup==0 ) return; if( pEList->a[iCol].iAlias==0 ){ pEList->a[iCol].iAlias = ++pParse->nAlias; } pDup->iTable = pEList->a[iCol].iAlias; } if( pExpr->flags & EP_ExpCollate ){ pDup->pColl = pExpr->pColl; pDup->flags |= EP_ExpCollate; } sqlite3ExprClear(db, pExpr); memcpy(pExpr, pDup, sizeof(*pExpr)); sqlite3DbFree(db, pDup); } static int lookupName( Parse *pParse, Token *pDbToken, Token *pTableToken, Token *pColumnToken, NameContext *pNC, Expr *pExpr ){ char *zDb = 0; char *zTab = 0; char *zCol = 0; int i, j; int cnt = 0; int cntTab = 0; sqlite3 *db = pParse->db; struct SrcList_item *pItem; struct SrcList_item *pMatch = 0; NameContext *pTopNC = pNC; Schema *pSchema = 0; assert( pColumnToken && pColumnToken->z ); zDb = sqlite3NameFromToken(db, pDbToken); zTab = sqlite3NameFromToken(db, pTableToken); zCol = sqlite3NameFromToken(db, pColumnToken); if( db->mallocFailed ){ goto lookupname_end; } pExpr->iTable = -1; pExpr->pTab = 0; while( pNC && cnt==0 ){ ExprList *pEList; SrcList *pSrcList = pNC->pSrcList; if( pSrcList ){ for(i=0, pItem=pSrcList->a; i<pSrcList->nSrc; i++, pItem++){ Table *pTab; int iDb; Column *pCol; pTab = pItem->pTab; assert( pTab!=0 && pTab->zName!=0 ); iDb = sqlite3SchemaToIndex(db, pTab->pSchema); assert( pTab->nCol>0 ); if( zTab ){ if( pItem->zAlias ){ char *zTabName = pItem->zAlias; if( sqlite3StrICmp(zTabName, zTab)!=0 ) continue; }else{ char *zTabName = pTab->zName; if( zTabName==0 || sqlite3StrICmp(zTabName, zTab)!=0 ) continue; if( zDb!=0 && sqlite3StrICmp(db->aDb[iDb].zName, zDb)!=0 ){ continue; } } } if( 0==(cntTab++) ){ pExpr->iTable = pItem->iCursor; pExpr->pTab = pTab; pSchema = pTab->pSchema; pMatch = pItem; } for(j=0, pCol=pTab->aCol; j<pTab->nCol; j++, pCol++){ if( sqlite3StrICmp(pCol->zName, zCol)==0 ){ IdList *pUsing; cnt++; pExpr->iTable = pItem->iCursor; pExpr->pTab = pTab; pMatch = pItem; pSchema = pTab->pSchema; pExpr->iColumn = j==pTab->iPKey ? -1 : j; if( i<pSrcList->nSrc-1 ){ if( pItem[1].jointype & JT_NATURAL ){ pItem++; i++; }else if( (pUsing = pItem[1].pUsing)!=0 ){ int k; for(k=0; k<pUsing->nId; k++){ if( sqlite3StrICmp(pUsing->a[k].zName, zCol)==0 ){ pItem++; i++; break; } } } } break; } } } } 
#ifndef SQLITE_OMIT_TRIGGER 
 if( zDb==0 && zTab!=0 && cnt==0 && pParse->trigStack!=0 ){ TriggerStack *pTriggerStack = pParse->trigStack; Table *pTab = 0; u32 *piColMask; if( pTriggerStack->newIdx != -1 && sqlite3StrICmp("new", zTab) == 0 ){ pExpr->iTable = pTriggerStack->newIdx; assert( pTriggerStack->pTab ); pTab = pTriggerStack->pTab; piColMask = &(pTriggerStack->newColMask); }else if( pTriggerStack->oldIdx != -1 && sqlite3StrICmp("old", zTab)==0 ){ pExpr->iTable = pTriggerStack->oldIdx; assert( pTriggerStack->pTab ); pTab = pTriggerStack->pTab; piColMask = &(pTriggerStack->oldColMask); } if( pTab ){ int iCol; Column *pCol = pTab->aCol; pSchema = pTab->pSchema; cntTab++; for(iCol=0; iCol < pTab->nCol; iCol++, pCol++) { if( sqlite3StrICmp(pCol->zName, zCol)==0 ){ cnt++; pExpr->iColumn = iCol==pTab->iPKey ? -1 : iCol; pExpr->pTab = pTab; if( iCol>=0 ){ testcase( iCol==31 ); testcase( iCol==32 ); *piColMask |= ((u32)1<<iCol) | (iCol>=32?0xffffffff:0); } break; } } } } 
#endif 
 if( cnt==0 && cntTab==1 && sqlite3IsRowid(zCol) ){ cnt = 1; pExpr->iColumn = -1; pExpr->affinity = SQLITE_AFF_INTEGER; } if( cnt==0 && (pEList = pNC->pEList)!=0 && zTab==0 ){ for(j=0; j<pEList->nExpr; j++){ char *zAs = pEList->a[j].zName; if( zAs!=0 && sqlite3StrICmp(zAs, zCol)==0 ){ Expr *pOrig; assert( pExpr->pLeft==0 && pExpr->pRight==0 ); assert( pExpr->pList==0 ); assert( pExpr->pSelect==0 ); pOrig = pEList->a[j].pExpr; if( !pNC->allowAgg && ExprHasProperty(pOrig, EP_Agg) ){ sqlite3ErrorMsg(pParse, "misuse of aliased aggregate %s", zAs); sqlite3DbFree(db, zCol); return 2; } resolveAlias(pParse, pEList, j, pExpr, ""); cnt = 1; pMatch = 0; assert( zTab==0 && zDb==0 ); goto lookupname_end_2; } } } if( cnt==0 ){ pNC = pNC->pNext; } } if( cnt==0 && zTab==0 && pColumnToken->z[0]=='"' ){ sqlite3DbFree(db, zCol); pExpr->op = TK_STRING; pExpr->pTab = 0; return 0; } if( cnt!=1 ){ const char *zErr; zErr = cnt==0 ? "no such column" : "ambiguous column name"; if( zDb ){ sqlite3ErrorMsg(pParse, "%s: %s.%s.%s", zErr, zDb, zTab, zCol); }else if( zTab ){ sqlite3ErrorMsg(pParse, "%s: %s.%s", zErr, zTab, zCol); }else{ sqlite3ErrorMsg(pParse, "%s: %s", zErr, zCol); } pTopNC->nErr++; } if( pExpr->iColumn>=0 && pMatch!=0 ){ int n = pExpr->iColumn; testcase( n==BMS-1 ); if( n>=BMS ){ n = BMS-1; } assert( pMatch->iCursor==pExpr->iTable ); pMatch->colUsed |= ((Bitmask)1)<<n; } lookupname_end: sqlite3DbFree(db, zDb); sqlite3DbFree(db, zTab); sqlite3ExprDelete(db, pExpr->pLeft); pExpr->pLeft = 0; sqlite3ExprDelete(db, pExpr->pRight); pExpr->pRight = 0; pExpr->op = TK_COLUMN; lookupname_end_2: sqlite3DbFree(db, zCol); if( cnt==1 ){ assert( pNC!=0 ); sqlite3AuthRead(pParse, pExpr, pSchema, pNC->pSrcList); for(;;){ assert( pTopNC!=0 ); pTopNC->nRef++; if( pTopNC==pNC ) break; pTopNC = pTopNC->pNext; } return 0; } else { return 1; } } static int resolveExprStep(Walker *pWalker, Expr *pExpr){ NameContext *pNC; Parse *pParse; pNC = pWalker->u.pNC; assert( pNC!=0 ); pParse = pNC->pParse; assert( pParse==pWalker->pParse ); if( ExprHasAnyProperty(pExpr, EP_Resolved) ) return WRC_Prune; ExprSetProperty(pExpr, EP_Resolved); 
#ifndef NDEBUG 
 if( pNC->pSrcList && pNC->pSrcList->nAlloc>0 ){ SrcList *pSrcList = pNC->pSrcList; int i; for(i=0; i<pNC->pSrcList->nSrc; i++){ assert( pSrcList->a[i].iCursor>=0 && pSrcList->a[i].iCursor<pParse->nTab); } } 
#endif 
 switch( pExpr->op ){ 
#if defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) && !defined(SQLITE_OMIT_SUBQUERY) 
 case TK_ROW: { SrcList *pSrcList = pNC->pSrcList; struct SrcList_item *pItem; assert( pSrcList && pSrcList->nSrc==1 ); pItem = pSrcList->a; pExpr->op = TK_COLUMN; pExpr->pTab = pItem->pTab; pExpr->iTable = pItem->iCursor; pExpr->iColumn = -1; pExpr->affinity = SQLITE_AFF_INTEGER; break; } 
#endif 
 case TK_ID: { lookupName(pParse, 0, 0, &pExpr->token, pNC, pExpr); return WRC_Prune; } case TK_DOT: { Token *pColumn; Token *pTable; Token *pDb; Expr *pRight; pRight = pExpr->pRight; if( pRight->op==TK_ID ){ pDb = 0; pTable = &pExpr->pLeft->token; pColumn = &pRight->token; }else{ assert( pRight->op==TK_DOT ); pDb = &pExpr->pLeft->token; pTable = &pRight->pLeft->token; pColumn = &pRight->pRight->token; } lookupName(pParse, pDb, pTable, pColumn, pNC, pExpr); return WRC_Prune; } case TK_CONST_FUNC: case TK_FUNCTION: { ExprList *pList = pExpr->pList; int n = pList ? pList->nExpr : 0; int no_such_func = 0; int wrong_num_args = 0; int is_agg = 0; int auth; int nId; const char *zId; FuncDef *pDef; int enc = ENC(pParse->db); zId = (char*)pExpr->token.z; nId = pExpr->token.n; pDef = sqlite3FindFunction(pParse->db, zId, nId, n, enc, 0); if( pDef==0 ){ pDef = sqlite3FindFunction(pParse->db, zId, nId, -1, enc, 0); if( pDef==0 ){ no_such_func = 1; }else{ wrong_num_args = 1; } }else{ is_agg = pDef->xFunc==0; } 
#ifndef SQLITE_OMIT_AUTHORIZATION 
 if( pDef ){ auth = sqlite3AuthCheck(pParse, SQLITE_FUNCTION, 0, pDef->zName, 0); if( auth!=SQLITE_OK ){ if( auth==SQLITE_DENY ){ sqlite3ErrorMsg(pParse, "not authorized to use function: %s", pDef->zName); pNC->nErr++; } pExpr->op = TK_NULL; return WRC_Prune; } } 
#endif 
 if( is_agg && !pNC->allowAgg ){ sqlite3ErrorMsg(pParse, "misuse of aggregate function %.*s()", nId,zId); pNC->nErr++; is_agg = 0; }else if( no_such_func ){ sqlite3ErrorMsg(pParse, "no such function: %.*s", nId, zId); pNC->nErr++; }else if( wrong_num_args ){ sqlite3ErrorMsg(pParse,"wrong number of arguments to function %.*s()", nId, zId); pNC->nErr++; } if( is_agg ){ pExpr->op = TK_AGG_FUNCTION; pNC->hasAgg = 1; } if( is_agg ) pNC->allowAgg = 0; sqlite3WalkExprList(pWalker, pList); if( is_agg ) pNC->allowAgg = 1; return WRC_Prune; } 
#ifndef SQLITE_OMIT_SUBQUERY 
 case TK_SELECT: case TK_EXISTS: 
#endif 
 case TK_IN: { if( pExpr->pSelect ){ int nRef = pNC->nRef; 
#ifndef SQLITE_OMIT_CHECK 
 if( pNC->isCheck ){ sqlite3ErrorMsg(pParse,"subqueries prohibited in CHECK constraints"); } 
#endif 
 sqlite3WalkSelect(pWalker, pExpr->pSelect); assert( pNC->nRef>=nRef ); if( nRef!=pNC->nRef ){ ExprSetProperty(pExpr, EP_VarSelect); } } break; } 
#ifndef SQLITE_OMIT_CHECK 
 case TK_VARIABLE: { if( pNC->isCheck ){ sqlite3ErrorMsg(pParse,"parameters prohibited in CHECK constraints"); } break; } 
#endif 
 } return (pParse->nErr || pParse->db->mallocFailed) ? WRC_Abort : WRC_Continue; } static int resolveAsName( Parse *pParse, ExprList *pEList, Expr *pE ){ int i; if( pE->op==TK_ID || (pE->op==TK_STRING && pE->token.z[0]!='\'') ){ sqlite3 *db = pParse->db; char *zCol = sqlite3NameFromToken(db, &pE->token); if( zCol==0 ){ return -1; } for(i=0; i<pEList->nExpr; i++){ char *zAs = pEList->a[i].zName; if( zAs!=0 && sqlite3StrICmp(zAs, zCol)==0 ){ sqlite3DbFree(db, zCol); return i+1; } } sqlite3DbFree(db, zCol); } return 0; } static int resolveOrderByTermToExprList( Parse *pParse, Select *pSelect, Expr *pE ){ int i; ExprList *pEList; NameContext nc; assert( sqlite3ExprIsInteger(pE, &i)==0 ); pEList = pSelect->pEList; memset(&nc, 0, sizeof(nc)); nc.pParse = pParse; nc.pSrcList = pSelect->pSrc; nc.pEList = pEList; nc.allowAgg = 1; nc.nErr = 0; if( sqlite3ResolveExprNames(&nc, pE) ){ sqlite3ErrorClear(pParse); return 0; } for(i=0; i<pEList->nExpr; i++){ if( sqlite3ExprCompare(pEList->a[i].pExpr, pE) ){ return i+1; } } return 0; } static void resolveOutOfRangeError( Parse *pParse, const char *zType, int i, int mx ){ sqlite3ErrorMsg(pParse, "%r %s BY term out of range - should be " "between 1 and %d", i, zType, mx); } static int resolveCompoundOrderBy( Parse *pParse, Select *pSelect ){ int i; ExprList *pOrderBy; ExprList *pEList; sqlite3 *db; int moreToDo = 1; pOrderBy = pSelect->pOrderBy; if( pOrderBy==0 ) return 0; db = pParse->db; 
#if SQLITE_MAX_COLUMN 
 if( pOrderBy->nExpr>db->aLimit[SQLITE_LIMIT_COLUMN] ){ sqlite3ErrorMsg(pParse, "too many terms in ORDER BY clause"); return 1; } 
#endif 
 for(i=0; i<pOrderBy->nExpr; i++){ pOrderBy->a[i].done = 0; } pSelect->pNext = 0; while( pSelect->pPrior ){ pSelect->pPrior->pNext = pSelect; pSelect = pSelect->pPrior; } while( pSelect && moreToDo ){ struct ExprList_item *pItem; moreToDo = 0; pEList = pSelect->pEList; assert( pEList!=0 ); for(i=0, pItem=pOrderBy->a; i<pOrderBy->nExpr; i++, pItem++){ int iCol = -1; Expr *pE, *pDup; if( pItem->done ) continue; pE = pItem->pExpr; if( sqlite3ExprIsInteger(pE, &iCol) ){ if( iCol<0 || iCol>pEList->nExpr ){ resolveOutOfRangeError(pParse, "ORDER", i+1, pEList->nExpr); return 1; } }else{ iCol = resolveAsName(pParse, pEList, pE); if( iCol==0 ){ pDup = sqlite3ExprDup(db, pE); if( !db->mallocFailed ){ assert(pDup); iCol = resolveOrderByTermToExprList(pParse, pSelect, pDup); } sqlite3ExprDelete(db, pDup); } if( iCol<0 ){ return 1; } } if( iCol>0 ){ CollSeq *pColl = pE->pColl; int flags = pE->flags & EP_ExpCollate; sqlite3ExprDelete(db, pE); pItem->pExpr = pE = sqlite3Expr(db, TK_INTEGER, 0, 0, 0); if( pE==0 ) return 1; pE->pColl = pColl; pE->flags |= EP_IntValue | flags; pE->iTable = iCol; pItem->iCol = iCol; pItem->done = 1; }else{ moreToDo = 1; } } pSelect = pSelect->pNext; } for(i=0; i<pOrderBy->nExpr; i++){ if( pOrderBy->a[i].done==0 ){ sqlite3ErrorMsg(pParse, "%r ORDER BY term does not match any " "column in the result set", i+1); return 1; } } return 0; } SQLITE_PRIVATE int sqlite3ResolveOrderGroupBy( Parse *pParse, Select *pSelect, ExprList *pOrderBy, const char *zType ){ int i; sqlite3 *db = pParse->db; ExprList *pEList; struct ExprList_item *pItem; if( pOrderBy==0 || pParse->db->mallocFailed ) return 0; 
#if SQLITE_MAX_COLUMN 
 if( pOrderBy->nExpr>db->aLimit[SQLITE_LIMIT_COLUMN] ){ sqlite3ErrorMsg(pParse, "too many terms in %s BY clause", zType); return 1; } 
#endif 
 pEList = pSelect->pEList; assert( pEList!=0 ); for(i=0, pItem=pOrderBy->a; i<pOrderBy->nExpr; i++, pItem++){ if( pItem->iCol ){ if( pItem->iCol>pEList->nExpr ){ resolveOutOfRangeError(pParse, zType, i+1, pEList->nExpr); return 1; } resolveAlias(pParse, pEList, pItem->iCol-1, pItem->pExpr, zType); } } return 0; } static int resolveOrderGroupBy( NameContext *pNC, Select *pSelect, ExprList *pOrderBy, const char *zType ){ int i; int iCol; struct ExprList_item *pItem; Parse *pParse; int nResult; if( pOrderBy==0 ) return 0; nResult = pSelect->pEList->nExpr; pParse = pNC->pParse; for(i=0, pItem=pOrderBy->a; i<pOrderBy->nExpr; i++, pItem++){ Expr *pE = pItem->pExpr; iCol = resolveAsName(pParse, pSelect->pEList, pE); if( iCol<0 ){ return 1; } if( iCol>0 ){ pItem->iCol = iCol; continue; } if( sqlite3ExprIsInteger(pE, &iCol) ){ if( iCol<1 ){ resolveOutOfRangeError(pParse, zType, i+1, nResult); return 1; } pItem->iCol = iCol; continue; } pItem->iCol = 0; if( sqlite3ResolveExprNames(pNC, pE) ){ return 1; } } return sqlite3ResolveOrderGroupBy(pParse, pSelect, pOrderBy, zType); } static int resolveSelectStep(Walker *pWalker, Select *p){ NameContext *pOuterNC; NameContext sNC; int isCompound; int nCompound; Parse *pParse; ExprList *pEList; int i; ExprList *pGroupBy; Select *pLeftmost; sqlite3 *db; assert( p!=0 ); if( p->selFlags & SF_Resolved ){ return WRC_Prune; } pOuterNC = pWalker->u.pNC; pParse = pWalker->pParse; db = pParse->db; if( (p->selFlags & SF_Expanded)==0 ){ sqlite3SelectPrep(pParse, p, pOuterNC); return (pParse->nErr || db->mallocFailed) ? WRC_Abort : WRC_Prune; } isCompound = p->pPrior!=0; nCompound = 0; pLeftmost = p; while( p ){ assert( (p->selFlags & SF_Expanded)!=0 ); assert( (p->selFlags & SF_Resolved)==0 ); p->selFlags |= SF_Resolved; memset(&sNC, 0, sizeof(sNC)); sNC.pParse = pParse; if( sqlite3ResolveExprNames(&sNC, p->pLimit) || sqlite3ResolveExprNames(&sNC, p->pOffset) ){ return WRC_Abort; } sNC.allowAgg = 1; sNC.pSrcList = p->pSrc; sNC.pNext = pOuterNC; pEList = p->pEList; assert( pEList!=0 ); for(i=0; i<pEList->nExpr; i++){ Expr *pX = pEList->a[i].pExpr; if( sqlite3ResolveExprNames(&sNC, pX) ){ return WRC_Abort; } } for(i=0; i<p->pSrc->nSrc; i++){ struct SrcList_item *pItem = &p->pSrc->a[i]; if( pItem->pSelect ){ const char *zSavedContext = pParse->zAuthContext; if( pItem->zName ) pParse->zAuthContext = pItem->zName; sqlite3ResolveSelectNames(pParse, pItem->pSelect, &sNC); pParse->zAuthContext = zSavedContext; if( pParse->nErr || db->mallocFailed ) return WRC_Abort; } } assert( (p->selFlags & SF_Aggregate)==0 ); pGroupBy = p->pGroupBy; if( pGroupBy || sNC.hasAgg ){ p->selFlags |= SF_Aggregate; }else{ sNC.allowAgg = 0; } if( p->pHaving && !pGroupBy ){ sqlite3ErrorMsg(pParse, "a GROUP BY clause is required before HAVING"); return WRC_Abort; } sNC.pEList = p->pEList; if( sqlite3ResolveExprNames(&sNC, p->pWhere) || sqlite3ResolveExprNames(&sNC, p->pHaving) ){ return WRC_Abort; } sNC.pNext = 0; sNC.allowAgg = 1; if( !isCompound && resolveOrderGroupBy(&sNC, p, p->pOrderBy, "ORDER") ){ return WRC_Abort; } if( db->mallocFailed ){ return WRC_Abort; } if( pGroupBy ){ struct ExprList_item *pItem; if( resolveOrderGroupBy(&sNC, p, pGroupBy, "GROUP") || db->mallocFailed ){ return WRC_Abort; } for(i=0, pItem=pGroupBy->a; i<pGroupBy->nExpr; i++, pItem++){ if( ExprHasProperty(pItem->pExpr, EP_Agg) ){ sqlite3ErrorMsg(pParse, "aggregate functions are not allowed in " "the GROUP BY clause"); return WRC_Abort; } } } p = p->pPrior; nCompound++; } if( isCompound && resolveCompoundOrderBy(pParse, pLeftmost) ){ return WRC_Abort; } return WRC_Prune; } SQLITE_PRIVATE int sqlite3ResolveExprNames( NameContext *pNC, Expr *pExpr ){ int savedHasAgg; Walker w; if( pExpr==0 ) return 0; 
#if SQLITE_MAX_EXPR_DEPTH>0 
 { Parse *pParse = pNC->pParse; if( sqlite3ExprCheckHeight(pParse, pExpr->nHeight+pNC->pParse->nHeight) ){ return 1; } pParse->nHeight += pExpr->nHeight; } 
#endif 
 savedHasAgg = pNC->hasAgg; pNC->hasAgg = 0; w.xExprCallback = resolveExprStep; w.xSelectCallback = resolveSelectStep; w.pParse = pNC->pParse; w.u.pNC = pNC; sqlite3WalkExpr(&w, pExpr); 
#if SQLITE_MAX_EXPR_DEPTH>0 
 pNC->pParse->nHeight -= pExpr->nHeight; 
#endif 
 if( pNC->nErr>0 ){ ExprSetProperty(pExpr, EP_Error); } if( pNC->hasAgg ){ ExprSetProperty(pExpr, EP_Agg); }else if( savedHasAgg ){ pNC->hasAgg = 1; } return ExprHasProperty(pExpr, EP_Error); } SQLITE_PRIVATE void sqlite3ResolveSelectNames( Parse *pParse, Select *p, NameContext *pOuterNC ){ Walker w; assert( p!=0 ); w.xExprCallback = resolveExprStep; w.xSelectCallback = resolveSelectStep; w.pParse = pParse; w.u.pNC = pOuterNC; sqlite3WalkSelect(&w, p); } SQLITE_PRIVATE char sqlite3ExprAffinity(Expr *pExpr){ int op = pExpr->op; if( op==TK_SELECT ){ return sqlite3ExprAffinity(pExpr->pSelect->pEList->a[0].pExpr); } 
#ifndef SQLITE_OMIT_CAST 
 if( op==TK_CAST ){ return sqlite3AffinityType(&pExpr->token); } 
#endif 
 if( (op==TK_AGG_COLUMN || op==TK_COLUMN || op==TK_REGISTER) && pExpr->pTab!=0 ){ int j = pExpr->iColumn; if( j<0 ) return SQLITE_AFF_INTEGER; assert( pExpr->pTab && j<pExpr->pTab->nCol ); return pExpr->pTab->aCol[j].affinity; } return pExpr->affinity; } SQLITE_PRIVATE Expr *sqlite3ExprSetColl(Parse *pParse, Expr *pExpr, Token *pCollName){ char *zColl = 0; CollSeq *pColl; sqlite3 *db = pParse->db; zColl = sqlite3NameFromToken(db, pCollName); if( pExpr && zColl ){ pColl = sqlite3LocateCollSeq(pParse, zColl, -1); if( pColl ){ pExpr->pColl = pColl; pExpr->flags |= EP_ExpCollate; } } sqlite3DbFree(db, zColl); return pExpr; } SQLITE_PRIVATE CollSeq *sqlite3ExprCollSeq(Parse *pParse, Expr *pExpr){ CollSeq *pColl = 0; Expr *p = pExpr; while( p ){ int op; pColl = p->pColl; if( pColl ) break; op = p->op; if( (op==TK_AGG_COLUMN || op==TK_COLUMN || op==TK_REGISTER) && p->pTab!=0 ){ const char *zColl; int j = p->iColumn; if( j>=0 ){ sqlite3 *db = pParse->db; zColl = p->pTab->aCol[j].zColl; pColl = sqlite3FindCollSeq(db, ENC(db), zColl, -1, 0); pExpr->pColl = pColl; } break; } if( op!=TK_CAST && op!=TK_UPLUS ){ break; } p = p->pLeft; } if( sqlite3CheckCollSeq(pParse, pColl) ){ pColl = 0; } return pColl; } SQLITE_PRIVATE char sqlite3CompareAffinity(Expr *pExpr, char aff2){ char aff1 = sqlite3ExprAffinity(pExpr); if( aff1 && aff2 ){ if( sqlite3IsNumericAffinity(aff1) || sqlite3IsNumericAffinity(aff2) ){ return SQLITE_AFF_NUMERIC; }else{ return SQLITE_AFF_NONE; } }else if( !aff1 && !aff2 ){ return SQLITE_AFF_NONE; }else{ assert( aff1==0 || aff2==0 ); return (aff1 + aff2); } } static char comparisonAffinity(Expr *pExpr){ char aff; assert( pExpr->op==TK_EQ || pExpr->op==TK_IN || pExpr->op==TK_LT || pExpr->op==TK_GT || pExpr->op==TK_GE || pExpr->op==TK_LE || pExpr->op==TK_NE ); assert( pExpr->pLeft ); aff = sqlite3ExprAffinity(pExpr->pLeft); if( pExpr->pRight ){ aff = sqlite3CompareAffinity(pExpr->pRight, aff); } else if( pExpr->pSelect ){ aff = sqlite3CompareAffinity(pExpr->pSelect->pEList->a[0].pExpr, aff); } else if( !aff ){ aff = SQLITE_AFF_NONE; } return aff; } SQLITE_PRIVATE int sqlite3IndexAffinityOk(Expr *pExpr, char idx_affinity){ char aff = comparisonAffinity(pExpr); switch( aff ){ case SQLITE_AFF_NONE: return 1; case SQLITE_AFF_TEXT: return idx_affinity==SQLITE_AFF_TEXT; default: return sqlite3IsNumericAffinity(idx_affinity); } } static u8 binaryCompareP5(Expr *pExpr1, Expr *pExpr2, int jumpIfNull){ u8 aff = (char)sqlite3ExprAffinity(pExpr2); aff = sqlite3CompareAffinity(pExpr1, aff) | jumpIfNull; return aff; } SQLITE_PRIVATE CollSeq *sqlite3BinaryCompareCollSeq( Parse *pParse, Expr *pLeft, Expr *pRight ){ CollSeq *pColl; assert( pLeft ); if( pLeft->flags & EP_ExpCollate ){ assert( pLeft->pColl ); pColl = pLeft->pColl; }else if( pRight && pRight->flags & EP_ExpCollate ){ assert( pRight->pColl ); pColl = pRight->pColl; }else{ pColl = sqlite3ExprCollSeq(pParse, pLeft); if( !pColl ){ pColl = sqlite3ExprCollSeq(pParse, pRight); } } return pColl; } static void codeCompareOperands( Parse *pParse, Expr *pLeft, int *pRegLeft, int *pFreeLeft, Expr *pRight, int *pRegRight, int *pFreeRight ){ while( pLeft->op==TK_UPLUS ) pLeft = pLeft->pLeft; pLeft->flags |= EP_AnyAff; *pRegLeft = sqlite3ExprCodeTemp(pParse, pLeft, pFreeLeft); while( pRight->op==TK_UPLUS ) pRight = pRight->pLeft; pRight->flags |= EP_AnyAff; *pRegRight = sqlite3ExprCodeTemp(pParse, pRight, pFreeRight); } static int codeCompare( Parse *pParse, Expr *pLeft, Expr *pRight, int opcode, int in1, int in2, int dest, int jumpIfNull ){ int p5; int addr; CollSeq *p4; p4 = sqlite3BinaryCompareCollSeq(pParse, pLeft, pRight); p5 = binaryCompareP5(pLeft, pRight, jumpIfNull); addr = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1, (void*)p4, P4_COLLSEQ); sqlite3VdbeChangeP5(pParse->pVdbe, p5); if( (p5 & SQLITE_AFF_MASK)!=SQLITE_AFF_NONE ){ sqlite3ExprCacheAffinityChange(pParse, in1, 1); sqlite3ExprCacheAffinityChange(pParse, in2, 1); } return addr; } 
#if SQLITE_MAX_EXPR_DEPTH>0 
SQLITE_PRIVATE int sqlite3ExprCheckHeight(Parse *pParse, int nHeight){ int rc = SQLITE_OK; int mxHeight = pParse->db->aLimit[SQLITE_LIMIT_EXPR_DEPTH]; if( nHeight>mxHeight ){ sqlite3ErrorMsg(pParse, "Expression tree is too large (maximum depth %d)", mxHeight ); rc = SQLITE_ERROR; } return rc; } static void heightOfExpr(Expr *p, int *pnHeight){ if( p ){ if( p->nHeight>*pnHeight ){ *pnHeight = p->nHeight; } } } static void heightOfExprList(ExprList *p, int *pnHeight){ if( p ){ int i; for(i=0; i<p->nExpr; i++){ heightOfExpr(p->a[i].pExpr, pnHeight); } } } static void heightOfSelect(Select *p, int *pnHeight){ if( p ){ heightOfExpr(p->pWhere, pnHeight); heightOfExpr(p->pHaving, pnHeight); heightOfExpr(p->pLimit, pnHeight); heightOfExpr(p->pOffset, pnHeight); heightOfExprList(p->pEList, pnHeight); heightOfExprList(p->pGroupBy, pnHeight); heightOfExprList(p->pOrderBy, pnHeight); heightOfSelect(p->pPrior, pnHeight); } } static void exprSetHeight(Expr *p){ int nHeight = 0; heightOfExpr(p->pLeft, &nHeight); heightOfExpr(p->pRight, &nHeight); heightOfExprList(p->pList, &nHeight); heightOfSelect(p->pSelect, &nHeight); p->nHeight = nHeight + 1; } SQLITE_PRIVATE void sqlite3ExprSetHeight(Parse *pParse, Expr *p){ exprSetHeight(p); sqlite3ExprCheckHeight(pParse, p->nHeight); } SQLITE_PRIVATE int sqlite3SelectExprHeight(Select *p){ int nHeight = 0; heightOfSelect(p, &nHeight); return nHeight; } 
#else 
#define exprSetHeight(y) 
#endif 
SQLITE_PRIVATE Expr *sqlite3Expr( sqlite3 *db, int op, Expr *pLeft, Expr *pRight, const Token *pToken ){ Expr *pNew; pNew = sqlite3DbMallocZero(db, sizeof(Expr)); if( pNew==0 ){ sqlite3ExprDelete(db, pLeft); sqlite3ExprDelete(db, pRight); return 0; } pNew->op = op; pNew->pLeft = pLeft; pNew->pRight = pRight; pNew->iAgg = -1; pNew->span.z = (u8*)""; if( pToken ){ assert( pToken->dyn==0 ); pNew->span = pNew->token = *pToken; }else if( pLeft ){ if( pRight ){ if( pRight->span.dyn==0 && pLeft->span.dyn==0 ){ sqlite3ExprSpan(pNew, &pLeft->span, &pRight->span); } if( pRight->flags & EP_ExpCollate ){ pNew->flags |= EP_ExpCollate; pNew->pColl = pRight->pColl; } } if( pLeft->flags & EP_ExpCollate ){ pNew->flags |= EP_ExpCollate; pNew->pColl = pLeft->pColl; } } exprSetHeight(pNew); return pNew; } SQLITE_PRIVATE Expr *sqlite3PExpr( Parse *pParse, int op, Expr *pLeft, Expr *pRight, const Token *pToken ){ Expr *p = sqlite3Expr(pParse->db, op, pLeft, pRight, pToken); if( p ){ sqlite3ExprCheckHeight(pParse, p->nHeight); } return p; } SQLITE_PRIVATE Expr *sqlite3RegisterExpr(Parse *pParse, Token *pToken){ Vdbe *v = pParse->pVdbe; Expr *p; if( pParse->nested==0 ){ sqlite3ErrorMsg(pParse, "near \"%T\": syntax error", pToken); return sqlite3PExpr(pParse, TK_NULL, 0, 0, 0); } if( v==0 ) return 0; p = sqlite3PExpr(pParse, TK_REGISTER, 0, 0, pToken); if( p==0 ){ return 0; } p->iTable = atoi((char*)&pToken->z[1]); return p; } SQLITE_PRIVATE Expr *sqlite3ExprAnd(sqlite3 *db, Expr *pLeft, Expr *pRight){ if( pLeft==0 ){ return pRight; }else if( pRight==0 ){ return pLeft; }else{ return sqlite3Expr(db, TK_AND, pLeft, pRight, 0); } } SQLITE_PRIVATE void sqlite3ExprSpan(Expr *pExpr, Token *pLeft, Token *pRight){ assert( pRight!=0 ); assert( pLeft!=0 ); if( pExpr ){ pExpr->span.z = pLeft->z; pExpr->span.n = pRight->n + (pRight->z - pLeft->z); } } SQLITE_PRIVATE Expr *sqlite3ExprFunction(Parse *pParse, ExprList *pList, Token *pToken){ Expr *pNew; sqlite3 *db = pParse->db; assert( pToken ); pNew = sqlite3DbMallocZero(db, sizeof(Expr) ); if( pNew==0 ){ sqlite3ExprListDelete(db, pList); return 0; } pNew->op = TK_FUNCTION; pNew->pList = pList; assert( pToken->dyn==0 ); pNew->token = *pToken; pNew->span = pNew->token; sqlite3ExprSetHeight(pParse, pNew); return pNew; } SQLITE_PRIVATE void sqlite3ExprAssignVarNumber(Parse *pParse, Expr *pExpr){ Token *pToken; sqlite3 *db = pParse->db; if( pExpr==0 ) return; pToken = &pExpr->token; assert( pToken->n>=1 ); assert( pToken->z!=0 ); assert( pToken->z[0]!=0 ); if( pToken->n==1 ){ pExpr->iTable = ++pParse->nVar; }else if( pToken->z[0]=='?' ){ int i; pExpr->iTable = i = atoi((char*)&pToken->z[1]); testcase( i==0 ); testcase( i==1 ); testcase( i==db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER]-1 ); testcase( i==db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER] ); if( i<1 || i>db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER] ){ sqlite3ErrorMsg(pParse, "variable number must be between ?1 and ?%d", db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER]); } if( i>pParse->nVar ){ pParse->nVar = i; } }else{ int i, n; n = pToken->n; for(i=0; i<pParse->nVarExpr; i++){ Expr *pE; if( (pE = pParse->apVarExpr[i])!=0 && pE->token.n==n && memcmp(pE->token.z, pToken->z, n)==0 ){ pExpr->iTable = pE->iTable; break; } } if( i>=pParse->nVarExpr ){ pExpr->iTable = ++pParse->nVar; if( pParse->nVarExpr>=pParse->nVarExprAlloc-1 ){ pParse->nVarExprAlloc += pParse->nVarExprAlloc + 10; pParse->apVarExpr = sqlite3DbReallocOrFree( db, pParse->apVarExpr, pParse->nVarExprAlloc*sizeof(pParse->apVarExpr[0]) ); } if( !db->mallocFailed ){ assert( pParse->apVarExpr!=0 ); pParse->apVarExpr[pParse->nVarExpr++] = pExpr; } } } if( !pParse->nErr && pParse->nVar>db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER] ){ sqlite3ErrorMsg(pParse, "too many SQL variables"); } } SQLITE_PRIVATE void sqlite3ExprClear(sqlite3 *db, Expr *p){ if( p->span.dyn ) sqlite3DbFree(db, (char*)p->span.z); if( p->token.dyn ) sqlite3DbFree(db, (char*)p->token.z); sqlite3ExprDelete(db, p->pLeft); sqlite3ExprDelete(db, p->pRight); sqlite3ExprListDelete(db, p->pList); sqlite3SelectDelete(db, p->pSelect); } SQLITE_PRIVATE void sqlite3ExprDelete(sqlite3 *db, Expr *p){ if( p==0 ) return; sqlite3ExprClear(db, p); sqlite3DbFree(db, p); } SQLITE_PRIVATE void sqlite3DequoteExpr(sqlite3 *db, Expr *p){ if( ExprHasAnyProperty(p, EP_Dequoted) ){ return; } ExprSetProperty(p, EP_Dequoted); if( p->token.dyn==0 ){ sqlite3TokenCopy(db, &p->token, &p->token); } sqlite3Dequote((char*)p->token.z); } SQLITE_PRIVATE Expr *sqlite3ExprDup(sqlite3 *db, Expr *p){ Expr *pNew; if( p==0 ) return 0; pNew = sqlite3DbMallocRaw(db, sizeof(*p) ); if( pNew==0 ) return 0; memcpy(pNew, p, sizeof(*pNew)); if( p->token.z!=0 ){ pNew->token.z = (u8*)sqlite3DbStrNDup(db, (char*)p->token.z, p->token.n); pNew->token.dyn = 1; }else{ assert( pNew->token.z==0 ); } pNew->span.z = 0; pNew->pLeft = sqlite3ExprDup(db, p->pLeft); pNew->pRight = sqlite3ExprDup(db, p->pRight); pNew->pList = sqlite3ExprListDup(db, p->pList); pNew->pSelect = sqlite3SelectDup(db, p->pSelect); return pNew; } SQLITE_PRIVATE void sqlite3TokenCopy(sqlite3 *db, Token *pTo, Token *pFrom){ if( pTo->dyn ) sqlite3DbFree(db, (char*)pTo->z); if( pFrom->z ){ pTo->n = pFrom->n; pTo->z = (u8*)sqlite3DbStrNDup(db, (char*)pFrom->z, pFrom->n); pTo->dyn = 1; }else{ pTo->z = 0; } } SQLITE_PRIVATE ExprList *sqlite3ExprListDup(sqlite3 *db, ExprList *p){ ExprList *pNew; struct ExprList_item *pItem, *pOldItem; int i; if( p==0 ) return 0; pNew = sqlite3DbMallocRaw(db, sizeof(*pNew) ); if( pNew==0 ) return 0; pNew->iECursor = 0; pNew->nExpr = pNew->nAlloc = p->nExpr; pNew->a = pItem = sqlite3DbMallocRaw(db, p->nExpr*sizeof(p->a[0]) ); if( pItem==0 ){ sqlite3DbFree(db, pNew); return 0; } pOldItem = p->a; for(i=0; i<p->nExpr; i++, pItem++, pOldItem++){ Expr *pNewExpr, *pOldExpr; pItem->pExpr = pNewExpr = sqlite3ExprDup(db, pOldExpr = pOldItem->pExpr); if( pOldExpr->span.z!=0 && pNewExpr ){ sqlite3TokenCopy(db, &pNewExpr->span, &pOldExpr->span); } assert( pNewExpr==0 || pNewExpr->span.z!=0 || pOldExpr->span.z==0 || db->mallocFailed ); pItem->zName = sqlite3DbStrDup(db, pOldItem->zName); pItem->sortOrder = pOldItem->sortOrder; pItem->done = 0; pItem->iCol = pOldItem->iCol; pItem->iAlias = pOldItem->iAlias; } return pNew; } 
#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_TRIGGER) || !defined(SQLITE_OMIT_SUBQUERY) 
SQLITE_PRIVATE SrcList *sqlite3SrcListDup(sqlite3 *db, SrcList *p){ SrcList *pNew; int i; int nByte; if( p==0 ) return 0; nByte = sizeof(*p) + (p->nSrc>0 ? sizeof(p->a[0]) * (p->nSrc-1) : 0); pNew = sqlite3DbMallocRaw(db, nByte ); if( pNew==0 ) return 0; pNew->nSrc = pNew->nAlloc = p->nSrc; for(i=0; i<p->nSrc; i++){ struct SrcList_item *pNewItem = &pNew->a[i]; struct SrcList_item *pOldItem = &p->a[i]; Table *pTab; pNewItem->zDatabase = sqlite3DbStrDup(db, pOldItem->zDatabase); pNewItem->zName = sqlite3DbStrDup(db, pOldItem->zName); pNewItem->zAlias = sqlite3DbStrDup(db, pOldItem->zAlias); pNewItem->jointype = pOldItem->jointype; pNewItem->iCursor = pOldItem->iCursor; pNewItem->isPopulated = pOldItem->isPopulated; pNewItem->zIndex = sqlite3DbStrDup(db, pOldItem->zIndex); pNewItem->notIndexed = pOldItem->notIndexed; pNewItem->pIndex = pOldItem->pIndex; pTab = pNewItem->pTab = pOldItem->pTab; if( pTab ){ pTab->nRef++; } pNewItem->pSelect = sqlite3SelectDup(db, pOldItem->pSelect); pNewItem->pOn = sqlite3ExprDup(db, pOldItem->pOn); pNewItem->pUsing = sqlite3IdListDup(db, pOldItem->pUsing); pNewItem->colUsed = pOldItem->colUsed; } return pNew; } SQLITE_PRIVATE IdList *sqlite3IdListDup(sqlite3 *db, IdList *p){ IdList *pNew; int i; if( p==0 ) return 0; pNew = sqlite3DbMallocRaw(db, sizeof(*pNew) ); if( pNew==0 ) return 0; pNew->nId = pNew->nAlloc = p->nId; pNew->a = sqlite3DbMallocRaw(db, p->nId*sizeof(p->a[0]) ); if( pNew->a==0 ){ sqlite3DbFree(db, pNew); return 0; } for(i=0; i<p->nId; i++){ struct IdList_item *pNewItem = &pNew->a[i]; struct IdList_item *pOldItem = &p->a[i]; pNewItem->zName = sqlite3DbStrDup(db, pOldItem->zName); pNewItem->idx = pOldItem->idx; } return pNew; } SQLITE_PRIVATE Select *sqlite3SelectDup(sqlite3 *db, Select *p){ Select *pNew; if( p==0 ) return 0; pNew = sqlite3DbMallocRaw(db, sizeof(*p) ); if( pNew==0 ) return 0; pNew->pEList = sqlite3ExprListDup(db, p->pEList); pNew->pSrc = sqlite3SrcListDup(db, p->pSrc); pNew->pWhere = sqlite3ExprDup(db, p->pWhere); pNew->pGroupBy = sqlite3ExprListDup(db, p->pGroupBy); pNew->pHaving = sqlite3ExprDup(db, p->pHaving); pNew->pOrderBy = sqlite3ExprListDup(db, p->pOrderBy); pNew->op = p->op; pNew->pPrior = sqlite3SelectDup(db, p->pPrior); pNew->pLimit = sqlite3ExprDup(db, p->pLimit); pNew->pOffset = sqlite3ExprDup(db, p->pOffset); pNew->iLimit = 0; pNew->iOffset = 0; pNew->selFlags = p->selFlags & ~SF_UsesEphemeral; pNew->pRightmost = 0; pNew->addrOpenEphm[0] = -1; pNew->addrOpenEphm[1] = -1; pNew->addrOpenEphm[2] = -1; return pNew; } 
#else 
SQLITE_PRIVATE Select *sqlite3SelectDup(sqlite3 *db, Select *p){ assert( p==0 ); return 0; } 
#endif 
SQLITE_PRIVATE ExprList *sqlite3ExprListAppend( Parse *pParse, ExprList *pList, Expr *pExpr, Token *pName ){ sqlite3 *db = pParse->db; if( pList==0 ){ pList = sqlite3DbMallocZero(db, sizeof(ExprList) ); if( pList==0 ){ goto no_mem; } assert( pList->nAlloc==0 ); } if( pList->nAlloc<=pList->nExpr ){ struct ExprList_item *a; int n = pList->nAlloc*2 + 4; a = sqlite3DbRealloc(db, pList->a, n*sizeof(pList->a[0])); if( a==0 ){ goto no_mem; } pList->a = a; pList->nAlloc = n; } assert( pList->a!=0 ); if( pExpr || pName ){ struct ExprList_item *pItem = &pList->a[pList->nExpr++]; memset(pItem, 0, sizeof(*pItem)); pItem->zName = sqlite3NameFromToken(db, pName); pItem->pExpr = pExpr; pItem->iAlias = 0; } return pList; no_mem: sqlite3ExprDelete(db, pExpr); sqlite3ExprListDelete(db, pList); return 0; } SQLITE_PRIVATE void sqlite3ExprListCheckLength( Parse *pParse, ExprList *pEList, const char *zObject ){ int mx = pParse->db->aLimit[SQLITE_LIMIT_COLUMN]; testcase( pEList && pEList->nExpr==mx ); testcase( pEList && pEList->nExpr==mx+1 ); if( pEList && pEList->nExpr>mx ){ sqlite3ErrorMsg(pParse, "too many columns in %s", zObject); } } SQLITE_PRIVATE void sqlite3ExprListDelete(sqlite3 *db, ExprList *pList){ int i; struct ExprList_item *pItem; if( pList==0 ) return; assert( pList->a!=0 || (pList->nExpr==0 && pList->nAlloc==0) ); assert( pList->nExpr<=pList->nAlloc ); for(pItem=pList->a, i=0; i<pList->nExpr; i++, pItem++){ sqlite3ExprDelete(db, pItem->pExpr); sqlite3DbFree(db, pItem->zName); } sqlite3DbFree(db, pList->a); sqlite3DbFree(db, pList); } static int exprNodeIsConstant(Walker *pWalker, Expr *pExpr){ if( pWalker->u.i==3 && ExprHasAnyProperty(pExpr, EP_FromJoin) ){ pWalker->u.i = 0; return WRC_Abort; } switch( pExpr->op ){ case TK_FUNCTION: if( pWalker->u.i==2 ) return 0; case TK_ID: case TK_COLUMN: case TK_DOT: case TK_AGG_FUNCTION: case TK_AGG_COLUMN: 
#ifndef SQLITE_OMIT_SUBQUERY 
 case TK_SELECT: case TK_EXISTS: testcase( pExpr->op==TK_SELECT ); testcase( pExpr->op==TK_EXISTS ); 
#endif 
 testcase( pExpr->op==TK_ID ); testcase( pExpr->op==TK_COLUMN ); testcase( pExpr->op==TK_DOT ); testcase( pExpr->op==TK_AGG_FUNCTION ); testcase( pExpr->op==TK_AGG_COLUMN ); pWalker->u.i = 0; return WRC_Abort; default: return WRC_Continue; } } static int selectNodeIsConstant(Walker *pWalker, Select *NotUsed){ UNUSED_PARAMETER(NotUsed); pWalker->u.i = 0; return WRC_Abort; } static int exprIsConst(Expr *p, int initFlag){ Walker w; w.u.i = initFlag; w.xExprCallback = exprNodeIsConstant; w.xSelectCallback = selectNodeIsConstant; sqlite3WalkExpr(&w, p); return w.u.i; } SQLITE_PRIVATE int sqlite3ExprIsConstant(Expr *p){ return exprIsConst(p, 1); } SQLITE_PRIVATE int sqlite3ExprIsConstantNotJoin(Expr *p){ return exprIsConst(p, 3); } SQLITE_PRIVATE int sqlite3ExprIsConstantOrFunction(Expr *p){ return exprIsConst(p, 2); } SQLITE_PRIVATE int sqlite3ExprIsInteger(Expr *p, int *pValue){ int rc = 0; if( p->flags & EP_IntValue ){ *pValue = p->iTable; return 1; } switch( p->op ){ case TK_INTEGER: { rc = sqlite3GetInt32((char*)p->token.z, pValue); break; } case TK_UPLUS: { rc = sqlite3ExprIsInteger(p->pLeft, pValue); break; } case TK_UMINUS: { int v; if( sqlite3ExprIsInteger(p->pLeft, &v) ){ *pValue = -v; rc = 1; } break; } default: break; } if( rc ){ p->op = TK_INTEGER; p->flags |= EP_IntValue; p->iTable = *pValue; } return rc; } SQLITE_PRIVATE int sqlite3IsRowid(const char *z){ if( sqlite3StrICmp(z, "_ROWID_")==0 ) return 1; if( sqlite3StrICmp(z, "ROWID")==0 ) return 1; if( sqlite3StrICmp(z, "OID")==0 ) return 1; return 0; } 
#ifdef SQLITE_TEST 
 int sqlite3_enable_in_opt = 1; 
#else 
#define sqlite3_enable_in_opt 1 
#endif 
#ifndef SQLITE_OMIT_SUBQUERY 
static int isCandidateForInOpt(Select *p){ SrcList *pSrc; ExprList *pEList; Table *pTab; if( !sqlite3_enable_in_opt ) return 0; if( p==0 ) return 0; if( p->pPrior ) return 0; if( p->selFlags & (SF_Distinct|SF_Aggregate) ){ return 0; } if( p->pGroupBy ) return 0; if( p->pLimit ) return 0; if( p->pOffset ) return 0; if( p->pWhere ) return 0; pSrc = p->pSrc; if( pSrc==0 ) return 0; if( pSrc->nSrc!=1 ) return 0; if( pSrc->a[0].pSelect ) return 0; pTab = pSrc->a[0].pTab; if( pTab==0 ) return 0; if( pTab->pSelect ) return 0; if( IsVirtual(pTab) ) return 0; pEList = p->pEList; if( pEList->nExpr!=1 ) return 0; if( pEList->a[0].pExpr->op!=TK_COLUMN ) return 0; return 1; } 
#endif 
#ifndef SQLITE_OMIT_SUBQUERY 
SQLITE_PRIVATE int sqlite3FindInIndex(Parse *pParse, Expr *pX, int *prNotFound){ Select *p; int eType = 0; int iTab = pParse->nTab++; int mustBeUnique = !prNotFound; p = pX->pSelect; if( isCandidateForInOpt(p) ){ sqlite3 *db = pParse->db; Index *pIdx; Expr *pExpr = p->pEList->a[0].pExpr; int iCol = pExpr->iColumn; Vdbe *v = sqlite3GetVdbe(pParse); assert(v); if( iCol<0 ){ int iMem = ++pParse->nMem; int iAddr; Table *pTab = p->pSrc->a[0].pTab; int iDb = sqlite3SchemaToIndex(db, pTab->pSchema); sqlite3VdbeUsesBtree(v, iDb); iAddr = sqlite3VdbeAddOp1(v, OP_If, iMem); sqlite3VdbeAddOp2(v, OP_Integer, 1, iMem); sqlite3OpenTable(pParse, iTab, iDb, pTab, OP_OpenRead); eType = IN_INDEX_ROWID; sqlite3VdbeJumpHere(v, iAddr); }else{ CollSeq *pReq = sqlite3BinaryCompareCollSeq(pParse, pX->pLeft, pExpr); Table *pTab = p->pSrc->a[0].pTab; char aff = comparisonAffinity(pX); int affinity_ok = (pTab->aCol[iCol].affinity==aff||aff==SQLITE_AFF_NONE); for(pIdx=pTab->pIndex; pIdx && eType==0 && affinity_ok; pIdx=pIdx->pNext){ if( (pIdx->aiColumn[0]==iCol) && (pReq==sqlite3FindCollSeq(db, ENC(db), pIdx->azColl[0], -1, 0)) && (!mustBeUnique || (pIdx->nColumn==1 && pIdx->onError!=OE_None)) ){ int iDb; int iMem = ++pParse->nMem; int iAddr; char *pKey; pKey = (char *)sqlite3IndexKeyinfo(pParse, pIdx); iDb = sqlite3SchemaToIndex(db, pIdx->pSchema); sqlite3VdbeUsesBtree(v, iDb); iAddr = sqlite3VdbeAddOp1(v, OP_If, iMem); sqlite3VdbeAddOp2(v, OP_Integer, 1, iMem); sqlite3VdbeAddOp2(v, OP_SetNumColumns, 0, pIdx->nColumn); sqlite3VdbeAddOp4(v, OP_OpenRead, iTab, pIdx->tnum, iDb, pKey,P4_KEYINFO_HANDOFF); VdbeComment((v, "%s", pIdx->zName)); eType = IN_INDEX_INDEX; sqlite3VdbeJumpHere(v, iAddr); if( prNotFound && !pTab->aCol[iCol].notNull ){ *prNotFound = ++pParse->nMem; } } } } } if( eType==0 ){ int rMayHaveNull = 0; eType = IN_INDEX_EPH; if( prNotFound ){ *prNotFound = rMayHaveNull = ++pParse->nMem; }else if( pX->pLeft->iColumn<0 && pX->pSelect==0 ){ eType = IN_INDEX_ROWID; } sqlite3CodeSubselect(pParse, pX, rMayHaveNull, eType==IN_INDEX_ROWID); }else{ pX->iTable = iTab; } return eType; } 
#endif 
#ifndef SQLITE_OMIT_SUBQUERY 
SQLITE_PRIVATE void sqlite3CodeSubselect( Parse *pParse, Expr *pExpr, int rMayHaveNull, int isRowid ){ int testAddr = 0; Vdbe *v = sqlite3GetVdbe(pParse); if( v==0 ) return; if( !ExprHasAnyProperty(pExpr, EP_VarSelect) && !pParse->trigStack ){ int mem = ++pParse->nMem; sqlite3VdbeAddOp1(v, OP_If, mem); testAddr = sqlite3VdbeAddOp2(v, OP_Integer, 1, mem); assert( testAddr>0 || pParse->db->mallocFailed ); } switch( pExpr->op ){ case TK_IN: { char affinity; KeyInfo keyInfo; int addr; Expr *pLeft = pExpr->pLeft; if( rMayHaveNull ){ sqlite3VdbeAddOp2(v, OP_Null, 0, rMayHaveNull); } affinity = sqlite3ExprAffinity(pLeft); pExpr->iTable = pParse->nTab++; addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pExpr->iTable, !isRowid); memset(&keyInfo, 0, sizeof(keyInfo)); keyInfo.nField = 1; if( pExpr->pSelect ){ SelectDest dest; ExprList *pEList; assert( !isRowid ); sqlite3SelectDestInit(&dest, SRT_Set, pExpr->iTable); dest.affinity = (int)affinity; assert( (pExpr->iTable&0x0000FFFF)==pExpr->iTable ); if( sqlite3Select(pParse, pExpr->pSelect, &dest) ){ return; } pEList = pExpr->pSelect->pEList; if( pEList && pEList->nExpr>0 ){ keyInfo.aColl[0] = sqlite3BinaryCompareCollSeq(pParse, pExpr->pLeft, pEList->a[0].pExpr); } }else if( pExpr->pList ){ int i; ExprList *pList = pExpr->pList; struct ExprList_item *pItem; int r1, r2, r3; if( !affinity ){ affinity = SQLITE_AFF_NONE; } keyInfo.aColl[0] = sqlite3ExprCollSeq(pParse, pExpr->pLeft); r1 = sqlite3GetTempReg(pParse); r2 = sqlite3GetTempReg(pParse); sqlite3VdbeAddOp2(v, OP_Null, 0, r2); for(i=pList->nExpr, pItem=pList->a; i>0; i--, pItem++){ Expr *pE2 = pItem->pExpr; if( testAddr && !sqlite3ExprIsConstant(pE2) ){ sqlite3VdbeChangeToNoop(v, testAddr-1, 2); testAddr = 0; } pParse->disableColCache++; r3 = sqlite3ExprCodeTarget(pParse, pE2, r1); assert( pParse->disableColCache>0 ); pParse->disableColCache--; if( isRowid ){ sqlite3VdbeAddOp2(v, OP_MustBeInt, r3, sqlite3VdbeCurrentAddr(v)+2); sqlite3VdbeAddOp3(v, OP_Insert, pExpr->iTable, r2, r3); }else{ sqlite3VdbeAddOp4(v, OP_MakeRecord, r3, 1, r2, &affinity, 1); sqlite3ExprCacheAffinityChange(pParse, r3, 1); sqlite3VdbeAddOp2(v, OP_IdxInsert, pExpr->iTable, r2); } } sqlite3ReleaseTempReg(pParse, r1); sqlite3ReleaseTempReg(pParse, r2); } if( !isRowid ){ sqlite3VdbeChangeP4(v, addr, (void *)&keyInfo, P4_KEYINFO); } break; } case TK_EXISTS: case TK_SELECT: { static const Token one = { (u8*)"1", 0, 1 }; Select *pSel; SelectDest dest; pSel = pExpr->pSelect; sqlite3SelectDestInit(&dest, 0, ++pParse->nMem); if( pExpr->op==TK_SELECT ){ dest.eDest = SRT_Mem; sqlite3VdbeAddOp2(v, OP_Null, 0, dest.iParm); VdbeComment((v, "Init subquery result")); }else{ dest.eDest = SRT_Exists; sqlite3VdbeAddOp2(v, OP_Integer, 0, dest.iParm); VdbeComment((v, "Init EXISTS result")); } sqlite3ExprDelete(pParse->db, pSel->pLimit); pSel->pLimit = sqlite3PExpr(pParse, TK_INTEGER, 0, 0, &one); if( sqlite3Select(pParse, pSel, &dest) ){ return; } pExpr->iColumn = dest.iParm; break; } } if( testAddr ){ sqlite3VdbeJumpHere(v, testAddr-1); } return; } 
#endif 
static char *dup8bytes(Vdbe *v, const char *in){ char *out = sqlite3DbMallocRaw(sqlite3VdbeDb(v), 8); if( out ){ memcpy(out, in, 8); } return out; } static void codeReal(Vdbe *v, const char *z, int n, int negateFlag, int iMem){ assert( z || v==0 || sqlite3VdbeDb(v)->mallocFailed ); assert( !z || !isdigit(z[n]) ); UNUSED_PARAMETER(n); if( z ){ double value; char *zV; sqlite3AtoF(z, &value); if( sqlite3IsNaN(value) ){ sqlite3VdbeAddOp2(v, OP_Null, 0, iMem); }else{ if( negateFlag ) value = -value; zV = dup8bytes(v, (char*)&value); sqlite3VdbeAddOp4(v, OP_Real, 0, iMem, 0, zV, P4_REAL); } } } static void codeInteger(Vdbe *v, Expr *pExpr, int negFlag, int iMem){ const char *z; if( pExpr->flags & EP_IntValue ){ int i = pExpr->iTable; if( negFlag ) i = -i; sqlite3VdbeAddOp2(v, OP_Integer, i, iMem); }else if( (z = (char*)pExpr->token.z)!=0 ){ int i; int n = pExpr->token.n; assert( !isdigit(z[n]) ); if( sqlite3GetInt32(z, &i) ){ if( negFlag ) i = -i; sqlite3VdbeAddOp2(v, OP_Integer, i, iMem); }else if( sqlite3FitsIn64Bits(z, negFlag) ){ i64 value; char *zV; sqlite3Atoi64(z, &value); if( negFlag ) value = -value; zV = dup8bytes(v, (char*)&value); sqlite3VdbeAddOp4(v, OP_Int64, 0, iMem, 0, zV, P4_INT64); }else{ codeReal(v, z, n, negFlag, iMem); } } } SQLITE_PRIVATE int sqlite3ExprCodeGetColumn( Parse *pParse, Table *pTab, int iColumn, int iTable, int iReg, int allowAffChng ){ Vdbe *v = pParse->pVdbe; int i; struct yColCache *p; for(i=0, p=pParse->aColCache; i<pParse->nColCache; i++, p++){ if( p->iTable==iTable && p->iColumn==iColumn && (!p->affChange || allowAffChng) ){ 
#if 0 
 sqlite3VdbeAddOp0(v, OP_Noop); VdbeComment((v, "OPT: tab%d.col%d -> r%d", iTable, iColumn, p->iReg)); 
#endif 
 return p->iReg; } } assert( v!=0 ); if( iColumn<0 ){ int op = (pTab && IsVirtual(pTab)) ? OP_VRowid : OP_Rowid; sqlite3VdbeAddOp2(v, op, iTable, iReg); }else if( pTab==0 ){ sqlite3VdbeAddOp3(v, OP_Column, iTable, iColumn, iReg); }else{ int op = IsVirtual(pTab) ? OP_VColumn : OP_Column; sqlite3VdbeAddOp3(v, op, iTable, iColumn, iReg); sqlite3ColumnDefault(v, pTab, iColumn); 
#ifndef SQLITE_OMIT_FLOATING_POINT 
 if( pTab->aCol[iColumn].affinity==SQLITE_AFF_REAL ){ sqlite3VdbeAddOp1(v, OP_RealAffinity, iReg); } 
#endif 
 } if( pParse->disableColCache==0 ){ i = pParse->iColCache; p = &pParse->aColCache[i]; p->iTable = iTable; p->iColumn = iColumn; p->iReg = iReg; p->affChange = 0; i++; if( i>=ArraySize(pParse->aColCache) ) i = 0; if( i>pParse->nColCache ) pParse->nColCache = i; pParse->iColCache = i; } return iReg; } SQLITE_PRIVATE void sqlite3ExprClearColumnCache(Parse *pParse, int iTable){ if( iTable<0 ){ pParse->nColCache = 0; pParse->iColCache = 0; }else{ int i; for(i=0; i<pParse->nColCache; i++){ if( pParse->aColCache[i].iTable==iTable ){ testcase( i==pParse->nColCache-1 ); pParse->aColCache[i] = pParse->aColCache[--pParse->nColCache]; pParse->iColCache = pParse->nColCache; } } } } SQLITE_PRIVATE void sqlite3ExprCacheAffinityChange(Parse *pParse, int iStart, int iCount){ int iEnd = iStart + iCount - 1; int i; for(i=0; i<pParse->nColCache; i++){ int r = pParse->aColCache[i].iReg; if( r>=iStart && r<=iEnd ){ pParse->aColCache[i].affChange = 1; } } } SQLITE_PRIVATE void sqlite3ExprCodeMove(Parse *pParse, int iFrom, int iTo, int nReg){ int i; if( iFrom==iTo ) return; sqlite3VdbeAddOp3(pParse->pVdbe, OP_Move, iFrom, iTo, nReg); for(i=0; i<pParse->nColCache; i++){ int x = pParse->aColCache[i].iReg; if( x>=iFrom && x<iFrom+nReg ){ pParse->aColCache[i].iReg += iTo-iFrom; } } } SQLITE_PRIVATE void sqlite3ExprCodeCopy(Parse *pParse, int iFrom, int iTo, int nReg){ int i; if( iFrom==iTo ) return; for(i=0; i<nReg; i++){ sqlite3VdbeAddOp2(pParse->pVdbe, OP_Copy, iFrom+i, iTo+i); } } static int usedAsColumnCache(Parse *pParse, int iFrom, int iTo){ int i; for(i=0; i<pParse->nColCache; i++){ int r = pParse->aColCache[i].iReg; if( r>=iFrom && r<=iTo ) return 1; } return 0; } SQLITE_PRIVATE int sqlite3ExprWritableRegister(Parse *pParse, int iCurrent, int iTarget){ int i; assert( pParse->pVdbe!=0 ); if( !usedAsColumnCache(pParse, iCurrent, iCurrent) ){ return iCurrent; } if( iCurrent!=iTarget ){ sqlite3VdbeAddOp2(pParse->pVdbe, OP_SCopy, iCurrent, iTarget); } for(i=0; i<pParse->nColCache; i++){ if( pParse->aColCache[i].iReg==iTarget ){ pParse->aColCache[i] = pParse->aColCache[--pParse->nColCache]; pParse->iColCache = pParse->nColCache; } } return iTarget; } SQLITE_PRIVATE void sqlite3ExprHardCopy(Parse *pParse, int iReg, int nReg){ int addr; VdbeOp *pOp; Vdbe *v; v = pParse->pVdbe; addr = sqlite3VdbeCurrentAddr(v); pOp = sqlite3VdbeGetOp(v, addr-1); assert( pOp || pParse->db->mallocFailed ); if( pOp && pOp->opcode==OP_SCopy && pOp->p1>=iReg && pOp->p1<iReg+nReg ){ pOp->opcode = OP_Copy; } } static int codeAlias(Parse *pParse, int iAlias, Expr *pExpr, int target){ sqlite3 *db = pParse->db; int iReg; if( pParse->aAlias==0 ){ pParse->aAlias = sqlite3DbMallocZero(db, sizeof(pParse->aAlias[0])*pParse->nAlias ); if( db->mallocFailed ) return 0; } assert( iAlias>0 && iAlias<=pParse->nAlias ); iReg = pParse->aAlias[iAlias-1]; if( iReg==0 ){ if( pParse->disableColCache ){ iReg = sqlite3ExprCodeTarget(pParse, pExpr, target); }else{ iReg = ++pParse->nMem; sqlite3ExprCode(pParse, pExpr, iReg); pParse->aAlias[iAlias-1] = iReg; } } return iReg; } SQLITE_PRIVATE int sqlite3ExprCodeTarget(Parse *pParse, Expr *pExpr, int target){ Vdbe *v = pParse->pVdbe; int op; int inReg = target; int regFree1 = 0; int regFree2 = 0; int r1, r2, r3, r4; sqlite3 *db; db = pParse->db; assert( v!=0 || db->mallocFailed ); assert( target>0 && target<=pParse->nMem ); if( v==0 ) return 0; if( pExpr==0 ){ op = TK_NULL; }else{ op = pExpr->op; } switch( op ){ case TK_AGG_COLUMN: { AggInfo *pAggInfo = pExpr->pAggInfo; struct AggInfo_col *pCol = &pAggInfo->aCol[pExpr->iAgg]; if( !pAggInfo->directMode ){ assert( pCol->iMem>0 ); inReg = pCol->iMem; break; }else if( pAggInfo->useSortingIdx ){ sqlite3VdbeAddOp3(v, OP_Column, pAggInfo->sortingIdx, pCol->iSorterColumn, target); break; } } case TK_COLUMN: { if( pExpr->iTable<0 ){ assert( pParse->ckBase>0 ); inReg = pExpr->iColumn + pParse->ckBase; }else{ testcase( (pExpr->flags & EP_AnyAff)!=0 ); inReg = sqlite3ExprCodeGetColumn(pParse, pExpr->pTab, pExpr->iColumn, pExpr->iTable, target, pExpr->flags & EP_AnyAff); } break; } case TK_INTEGER: { codeInteger(v, pExpr, 0, target); break; } case TK_FLOAT: { codeReal(v, (char*)pExpr->token.z, pExpr->token.n, 0, target); break; } case TK_STRING: { sqlite3DequoteExpr(db, pExpr); sqlite3VdbeAddOp4(v,OP_String8, 0, target, 0, (char*)pExpr->token.z, pExpr->token.n); break; } case TK_NULL: { sqlite3VdbeAddOp2(v, OP_Null, 0, target); break; } 
#ifndef SQLITE_OMIT_BLOB_LITERAL 
 case TK_BLOB: { int n; const char *z; char *zBlob; assert( pExpr->token.n>=3 ); assert( pExpr->token.z[0]=='x' || pExpr->token.z[0]=='X' ); assert( pExpr->token.z[1]=='\'' ); assert( pExpr->token.z[pExpr->token.n-1]=='\'' ); n = pExpr->token.n - 3; z = (char*)pExpr->token.z + 2; zBlob = sqlite3HexToBlob(sqlite3VdbeDb(v), z, n); sqlite3VdbeAddOp4(v, OP_Blob, n/2, target, 0, zBlob, P4_DYNAMIC); break; } 
#endif 
 case TK_VARIABLE: { sqlite3VdbeAddOp2(v, OP_Variable, pExpr->iTable, target); if( pExpr->token.n>1 ){ sqlite3VdbeChangeP4(v, -1, (char*)pExpr->token.z, pExpr->token.n); } break; } case TK_REGISTER: { inReg = pExpr->iTable; break; } case TK_AS: { inReg = codeAlias(pParse, pExpr->iTable, pExpr->pLeft, target); break; } 
#ifndef SQLITE_OMIT_CAST 
 case TK_CAST: { int aff, to_op; inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target); aff = sqlite3AffinityType(&pExpr->token); to_op = aff - SQLITE_AFF_TEXT + OP_ToText; assert( to_op==OP_ToText || aff!=SQLITE_AFF_TEXT ); assert( to_op==OP_ToBlob || aff!=SQLITE_AFF_NONE ); assert( to_op==OP_ToNumeric || aff!=SQLITE_AFF_NUMERIC ); assert( to_op==OP_ToInt || aff!=SQLITE_AFF_INTEGER ); assert( to_op==OP_ToReal || aff!=SQLITE_AFF_REAL ); testcase( to_op==OP_ToText ); testcase( to_op==OP_ToBlob ); testcase( to_op==OP_ToNumeric ); testcase( to_op==OP_ToInt ); testcase( to_op==OP_ToReal ); if( inReg!=target ){ sqlite3VdbeAddOp2(v, OP_SCopy, inReg, target); inReg = target; } sqlite3VdbeAddOp1(v, to_op, inReg); testcase( usedAsColumnCache(pParse, inReg, inReg) ); sqlite3ExprCacheAffinityChange(pParse, inReg, 1); break; } 
#endif 
 case TK_LT: case TK_LE: case TK_GT: case TK_GE: case TK_NE: case TK_EQ: { assert( TK_LT==OP_Lt ); assert( TK_LE==OP_Le ); assert( TK_GT==OP_Gt ); assert( TK_GE==OP_Ge ); assert( TK_EQ==OP_Eq ); assert( TK_NE==OP_Ne ); testcase( op==TK_LT ); testcase( op==TK_LE ); testcase( op==TK_GT ); testcase( op==TK_GE ); testcase( op==TK_EQ ); testcase( op==TK_NE ); codeCompareOperands(pParse, pExpr->pLeft, &r1, &regFree1, pExpr->pRight, &r2, &regFree2); codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op, r1, r2, inReg, SQLITE_STOREP2); testcase( regFree1==0 ); testcase( regFree2==0 ); break; } case TK_AND: case TK_OR: case TK_PLUS: case TK_STAR: case TK_MINUS: case TK_REM: case TK_BITAND: case TK_BITOR: case TK_SLASH: case TK_LSHIFT: case TK_RSHIFT: case TK_CONCAT: { assert( TK_AND==OP_And ); assert( TK_OR==OP_Or ); assert( TK_PLUS==OP_Add ); assert( TK_MINUS==OP_Subtract ); assert( TK_REM==OP_Remainder ); assert( TK_BITAND==OP_BitAnd ); assert( TK_BITOR==OP_BitOr ); assert( TK_SLASH==OP_Divide ); assert( TK_LSHIFT==OP_ShiftLeft ); assert( TK_RSHIFT==OP_ShiftRight ); assert( TK_CONCAT==OP_Concat ); testcase( op==TK_AND ); testcase( op==TK_OR ); testcase( op==TK_PLUS ); testcase( op==TK_MINUS ); testcase( op==TK_REM ); testcase( op==TK_BITAND ); testcase( op==TK_BITOR ); testcase( op==TK_SLASH ); testcase( op==TK_LSHIFT ); testcase( op==TK_RSHIFT ); testcase( op==TK_CONCAT ); r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1); r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2); sqlite3VdbeAddOp3(v, op, r2, r1, target); testcase( regFree1==0 ); testcase( regFree2==0 ); break; } case TK_UMINUS: { Expr *pLeft = pExpr->pLeft; assert( pLeft ); if( pLeft->op==TK_FLOAT || pLeft->op==TK_INTEGER ){ if( pLeft->op==TK_FLOAT ){ codeReal(v, (char*)pLeft->token.z, pLeft->token.n, 1, target); }else{ codeInteger(v, pLeft, 1, target); } }else{ regFree1 = r1 = sqlite3GetTempReg(pParse); sqlite3VdbeAddOp2(v, OP_Integer, 0, r1); r2 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree2); sqlite3VdbeAddOp3(v, OP_Subtract, r2, r1, target); testcase( regFree2==0 ); } inReg = target; break; } case TK_BITNOT: case TK_NOT: { assert( TK_BITNOT==OP_BitNot ); assert( TK_NOT==OP_Not ); testcase( op==TK_BITNOT ); testcase( op==TK_NOT ); inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target); testcase( inReg==target ); testcase( usedAsColumnCache(pParse, inReg, inReg) ); inReg = sqlite3ExprWritableRegister(pParse, inReg, target); sqlite3VdbeAddOp1(v, op, inReg); break; } case TK_ISNULL: case TK_NOTNULL: { int addr; assert( TK_ISNULL==OP_IsNull ); assert( TK_NOTNULL==OP_NotNull ); testcase( op==TK_ISNULL ); testcase( op==TK_NOTNULL ); sqlite3VdbeAddOp2(v, OP_Integer, 1, target); r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1); testcase( regFree1==0 ); addr = sqlite3VdbeAddOp1(v, op, r1); sqlite3VdbeAddOp2(v, OP_AddImm, target, -1); sqlite3VdbeJumpHere(v, addr); break; } case TK_AGG_FUNCTION: { AggInfo *pInfo = pExpr->pAggInfo; if( pInfo==0 ){ sqlite3ErrorMsg(pParse, "misuse of aggregate: %T", &pExpr->span); }else{ inReg = pInfo->aFunc[pExpr->iAgg].iMem; } break; } case TK_CONST_FUNC: case TK_FUNCTION: { ExprList *pList = pExpr->pList; int nExpr = pList ? pList->nExpr : 0; FuncDef *pDef; int nId; const char *zId; int constMask = 0; int i; u8 enc = ENC(db); CollSeq *pColl = 0; testcase( op==TK_CONST_FUNC ); testcase( op==TK_FUNCTION ); zId = (char*)pExpr->token.z; nId = pExpr->token.n; pDef = sqlite3FindFunction(db, zId, nId, nExpr, enc, 0); assert( pDef!=0 ); if( pList ){ nExpr = pList->nExpr; r1 = sqlite3GetTempRange(pParse, nExpr); sqlite3ExprCodeExprList(pParse, pList, r1, 1); }else{ nExpr = r1 = 0; } 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 if( nExpr>=2 && (pExpr->flags & EP_InfixFunc) ){ pDef = sqlite3VtabOverloadFunction(db, pDef, nExpr, pList->a[1].pExpr); }else if( nExpr>0 ){ pDef = sqlite3VtabOverloadFunction(db, pDef, nExpr, pList->a[0].pExpr); } 
#endif 
 for(i=0; i<nExpr && i<32; i++){ if( sqlite3ExprIsConstant(pList->a[i].pExpr) ){ constMask |= (1<<i); } if( (pDef->flags & SQLITE_FUNC_NEEDCOLL)!=0 && !pColl ){ pColl = sqlite3ExprCollSeq(pParse, pList->a[i].pExpr); } } if( pDef->flags & SQLITE_FUNC_NEEDCOLL ){ if( !pColl ) pColl = db->pDfltColl; sqlite3VdbeAddOp4(v, OP_CollSeq, 0, 0, 0, (char *)pColl, P4_COLLSEQ); } sqlite3VdbeAddOp4(v, OP_Function, constMask, r1, target, (char*)pDef, P4_FUNCDEF); sqlite3VdbeChangeP5(v, nExpr); if( nExpr ){ sqlite3ReleaseTempRange(pParse, r1, nExpr); } sqlite3ExprCacheAffinityChange(pParse, r1, nExpr); break; } 
#ifndef SQLITE_OMIT_SUBQUERY 
 case TK_EXISTS: case TK_SELECT: { testcase( op==TK_EXISTS ); testcase( op==TK_SELECT ); if( pExpr->iColumn==0 ){ sqlite3CodeSubselect(pParse, pExpr, 0, 0); } inReg = pExpr->iColumn; break; } case TK_IN: { int rNotFound = 0; int rMayHaveNull = 0; int j2, j3, j4, j5; char affinity; int eType; VdbeNoopComment((v, "begin IN expr r%d", target)); eType = sqlite3FindInIndex(pParse, pExpr, &rMayHaveNull); if( rMayHaveNull ){ rNotFound = ++pParse->nMem; } affinity = comparisonAffinity(pExpr); pParse->disableColCache++; sqlite3ExprCode(pParse, pExpr->pLeft, target); pParse->disableColCache--; j2 = sqlite3VdbeAddOp1(v, OP_IsNull, target); if( eType==IN_INDEX_ROWID ){ j3 = sqlite3VdbeAddOp1(v, OP_MustBeInt, target); j4 = sqlite3VdbeAddOp3(v, OP_NotExists, pExpr->iTable, 0, target); sqlite3VdbeAddOp2(v, OP_Integer, 1, target); j5 = sqlite3VdbeAddOp0(v, OP_Goto); sqlite3VdbeJumpHere(v, j3); sqlite3VdbeJumpHere(v, j4); sqlite3VdbeAddOp2(v, OP_Integer, 0, target); }else{ r2 = regFree2 = sqlite3GetTempReg(pParse); sqlite3VdbeAddOp4(v, OP_MakeRecord, target, 1, r2, &affinity, 1); sqlite3VdbeAddOp2(v, OP_Integer, 1, target); j5 = sqlite3VdbeAddOp3(v, OP_Found, pExpr->iTable, 0, r2); if( rNotFound==0 ){ sqlite3VdbeAddOp2(v, OP_Integer, 0, target); }else{ static const char nullRecord[] = { 0x02, 0x00 }; j3 = sqlite3VdbeAddOp1(v, OP_NotNull, rMayHaveNull); sqlite3VdbeAddOp2(v, OP_Null, 0, rNotFound); sqlite3VdbeAddOp4(v, OP_Blob, 2, rMayHaveNull, 0, nullRecord, P4_STATIC); j4 = sqlite3VdbeAddOp3(v, OP_Found, pExpr->iTable, 0, rMayHaveNull); sqlite3VdbeAddOp2(v, OP_Integer, 0, rNotFound); sqlite3VdbeJumpHere(v, j4); sqlite3VdbeJumpHere(v, j3); sqlite3VdbeAddOp2(v, OP_Copy, rNotFound, target); } } sqlite3VdbeJumpHere(v, j2); sqlite3VdbeJumpHere(v, j5); VdbeComment((v, "end IN expr r%d", target)); break; } 
#endif 
 case TK_BETWEEN: { Expr *pLeft = pExpr->pLeft; struct ExprList_item *pLItem = pExpr->pList->a; Expr *pRight = pLItem->pExpr; codeCompareOperands(pParse, pLeft, &r1, &regFree1, pRight, &r2, &regFree2); testcase( regFree1==0 ); testcase( regFree2==0 ); r3 = sqlite3GetTempReg(pParse); r4 = sqlite3GetTempReg(pParse); codeCompare(pParse, pLeft, pRight, OP_Ge, r1, r2, r3, SQLITE_STOREP2); pLItem++; pRight = pLItem->pExpr; sqlite3ReleaseTempReg(pParse, regFree2); r2 = sqlite3ExprCodeTemp(pParse, pRight, &regFree2); testcase( regFree2==0 ); codeCompare(pParse, pLeft, pRight, OP_Le, r1, r2, r4, SQLITE_STOREP2); sqlite3VdbeAddOp3(v, OP_And, r3, r4, target); sqlite3ReleaseTempReg(pParse, r3); sqlite3ReleaseTempReg(pParse, r4); break; } case TK_UPLUS: { inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target); break; } case TK_CASE: { int endLabel; int nextCase; int nExpr; int i; ExprList *pEList; struct ExprList_item *aListelem; Expr opCompare; Expr cacheX; Expr *pX; Expr *pTest; assert(pExpr->pList); assert((pExpr->pList->nExpr % 2) == 0); assert(pExpr->pList->nExpr > 0); pEList = pExpr->pList; aListelem = pEList->a; nExpr = pEList->nExpr; endLabel = sqlite3VdbeMakeLabel(v); if( (pX = pExpr->pLeft)!=0 ){ cacheX = *pX; testcase( pX->op==TK_COLUMN || pX->op==TK_REGISTER ); cacheX.iTable = sqlite3ExprCodeTemp(pParse, pX, &regFree1); testcase( regFree1==0 ); cacheX.op = TK_REGISTER; opCompare.op = TK_EQ; opCompare.pLeft = &cacheX; pTest = &opCompare; } pParse->disableColCache++; for(i=0; i<nExpr; i=i+2){ if( pX ){ opCompare.pRight = aListelem[i].pExpr; }else{ pTest = aListelem[i].pExpr; } nextCase = sqlite3VdbeMakeLabel(v); testcase( pTest->op==TK_COLUMN || pTest->op==TK_REGISTER ); sqlite3ExprIfFalse(pParse, pTest, nextCase, SQLITE_JUMPIFNULL); testcase( aListelem[i+1].pExpr->op==TK_COLUMN ); testcase( aListelem[i+1].pExpr->op==TK_REGISTER ); sqlite3ExprCode(pParse, aListelem[i+1].pExpr, target); sqlite3VdbeAddOp2(v, OP_Goto, 0, endLabel); sqlite3VdbeResolveLabel(v, nextCase); } if( pExpr->pRight ){ sqlite3ExprCode(pParse, pExpr->pRight, target); }else{ sqlite3VdbeAddOp2(v, OP_Null, 0, target); } sqlite3VdbeResolveLabel(v, endLabel); assert( pParse->disableColCache>0 ); pParse->disableColCache--; break; } 
#ifndef SQLITE_OMIT_TRIGGER 
 case TK_RAISE: { if( !pParse->trigStack ){ sqlite3ErrorMsg(pParse, "RAISE() may only be used within a trigger-program"); return 0; } if( pExpr->iColumn!=OE_Ignore ){ assert( pExpr->iColumn==OE_Rollback || pExpr->iColumn == OE_Abort || pExpr->iColumn == OE_Fail ); sqlite3DequoteExpr(db, pExpr); sqlite3VdbeAddOp4(v, OP_Halt, SQLITE_CONSTRAINT, pExpr->iColumn, 0, (char*)pExpr->token.z, pExpr->token.n); } else { assert( pExpr->iColumn == OE_Ignore ); sqlite3VdbeAddOp2(v, OP_ContextPop, 0, 0); sqlite3VdbeAddOp2(v, OP_Goto, 0, pParse->trigStack->ignoreJump); VdbeComment((v, "raise(IGNORE)")); } break; } 
#endif 
 } sqlite3ReleaseTempReg(pParse, regFree1); sqlite3ReleaseTempReg(pParse, regFree2); return inReg; } SQLITE_PRIVATE int sqlite3ExprCodeTemp(Parse *pParse, Expr *pExpr, int *pReg){ int r1 = sqlite3GetTempReg(pParse); int r2 = sqlite3ExprCodeTarget(pParse, pExpr, r1); if( r2==r1 ){ *pReg = r1; }else{ sqlite3ReleaseTempReg(pParse, r1); *pReg = 0; } return r2; } SQLITE_PRIVATE int sqlite3ExprCode(Parse *pParse, Expr *pExpr, int target){ int inReg; assert( target>0 && target<=pParse->nMem ); inReg = sqlite3ExprCodeTarget(pParse, pExpr, target); assert( pParse->pVdbe || pParse->db->mallocFailed ); if( inReg!=target && pParse->pVdbe ){ sqlite3VdbeAddOp2(pParse->pVdbe, OP_SCopy, inReg, target); } return target; } SQLITE_PRIVATE int sqlite3ExprCodeAndCache(Parse *pParse, Expr *pExpr, int target){ Vdbe *v = pParse->pVdbe; int inReg; inReg = sqlite3ExprCode(pParse, pExpr, target); assert( target>0 ); if( pExpr->op!=TK_REGISTER ){ int iMem; iMem = ++pParse->nMem; sqlite3VdbeAddOp2(v, OP_Copy, inReg, iMem); pExpr->iTable = iMem; pExpr->op = TK_REGISTER; } return inReg; } static int isAppropriateForFactoring(Expr *p){ if( !sqlite3ExprIsConstantNotJoin(p) ){ return 0; } if( (p->flags & EP_FixedDest)==0 ){ return 1; } while( p->op==TK_UPLUS ) p = p->pLeft; switch( p->op ){ 
#ifndef SQLITE_OMIT_BLOB_LITERAL 
 case TK_BLOB: 
#endif 
 case TK_VARIABLE: case TK_INTEGER: case TK_FLOAT: case TK_NULL: case TK_STRING: { testcase( p->op==TK_BLOB ); testcase( p->op==TK_VARIABLE ); testcase( p->op==TK_INTEGER ); testcase( p->op==TK_FLOAT ); testcase( p->op==TK_NULL ); testcase( p->op==TK_STRING ); return 0; } case TK_UMINUS: { if( p->pLeft->op==TK_FLOAT || p->pLeft->op==TK_INTEGER ){ return 0; } break; } default: { break; } } return 1; } static int evalConstExpr(Walker *pWalker, Expr *pExpr){ Parse *pParse = pWalker->pParse; switch( pExpr->op ){ case TK_REGISTER: { return 1; } case TK_FUNCTION: case TK_AGG_FUNCTION: case TK_CONST_FUNC: { ExprList *pList = pExpr->pList; if( pList ){ int i = pList->nExpr; struct ExprList_item *pItem = pList->a; for(; i>0; i--, pItem++){ if( pItem->pExpr ) pItem->pExpr->flags |= EP_FixedDest; } } break; } } if( isAppropriateForFactoring(pExpr) ){ int r1 = ++pParse->nMem; int r2; r2 = sqlite3ExprCodeTarget(pParse, pExpr, r1); if( r1!=r2 ) sqlite3ReleaseTempReg(pParse, r1); pExpr->op = TK_REGISTER; pExpr->iTable = r2; return WRC_Prune; } return WRC_Continue; } SQLITE_PRIVATE void sqlite3ExprCodeConstants(Parse *pParse, Expr *pExpr){ Walker w; w.xExprCallback = evalConstExpr; w.xSelectCallback = 0; w.pParse = pParse; sqlite3WalkExpr(&w, pExpr); } SQLITE_PRIVATE int sqlite3ExprCodeExprList( Parse *pParse, ExprList *pList, int target, int doHardCopy ){ struct ExprList_item *pItem; int i, n; assert( pList!=0 ); assert( target>0 ); n = pList->nExpr; for(pItem=pList->a, i=0; i<n; i++, pItem++){ if( pItem->iAlias ){ int iReg = codeAlias(pParse, pItem->iAlias, pItem->pExpr, target+i); Vdbe *v = sqlite3GetVdbe(pParse); if( iReg!=target+i ){ sqlite3VdbeAddOp2(v, OP_SCopy, iReg, target+i); } }else{ sqlite3ExprCode(pParse, pItem->pExpr, target+i); } if( doHardCopy ){ sqlite3ExprHardCopy(pParse, target, n); } } return n; } SQLITE_PRIVATE void sqlite3ExprIfTrue(Parse *pParse, Expr *pExpr, int dest, int jumpIfNull){ Vdbe *v = pParse->pVdbe; int op = 0; int regFree1 = 0; int regFree2 = 0; int r1, r2; assert( jumpIfNull==SQLITE_JUMPIFNULL || jumpIfNull==0 ); if( v==0 || pExpr==0 ) return; op = pExpr->op; switch( op ){ case TK_AND: { int d2 = sqlite3VdbeMakeLabel(v); testcase( jumpIfNull==0 ); testcase( pParse->disableColCache==0 ); sqlite3ExprIfFalse(pParse, pExpr->pLeft, d2,jumpIfNull^SQLITE_JUMPIFNULL); pParse->disableColCache++; sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull); assert( pParse->disableColCache>0 ); pParse->disableColCache--; sqlite3VdbeResolveLabel(v, d2); break; } case TK_OR: { testcase( jumpIfNull==0 ); testcase( pParse->disableColCache==0 ); sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull); pParse->disableColCache++; sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull); assert( pParse->disableColCache>0 ); pParse->disableColCache--; break; } case TK_NOT: { testcase( jumpIfNull==0 ); sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull); break; } case TK_LT: case TK_LE: case TK_GT: case TK_GE: case TK_NE: case TK_EQ: { assert( TK_LT==OP_Lt ); assert( TK_LE==OP_Le ); assert( TK_GT==OP_Gt ); assert( TK_GE==OP_Ge ); assert( TK_EQ==OP_Eq ); assert( TK_NE==OP_Ne ); testcase( op==TK_LT ); testcase( op==TK_LE ); testcase( op==TK_GT ); testcase( op==TK_GE ); testcase( op==TK_EQ ); testcase( op==TK_NE ); testcase( jumpIfNull==0 ); codeCompareOperands(pParse, pExpr->pLeft, &r1, &regFree1, pExpr->pRight, &r2, &regFree2); codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op, r1, r2, dest, jumpIfNull); testcase( regFree1==0 ); testcase( regFree2==0 ); break; } case TK_ISNULL: case TK_NOTNULL: { assert( TK_ISNULL==OP_IsNull ); assert( TK_NOTNULL==OP_NotNull ); testcase( op==TK_ISNULL ); testcase( op==TK_NOTNULL ); r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1); sqlite3VdbeAddOp2(v, op, r1, dest); testcase( regFree1==0 ); break; } case TK_BETWEEN: { Expr exprAnd; Expr compLeft; Expr compRight; Expr exprX; exprX = *pExpr->pLeft; exprAnd.op = TK_AND; exprAnd.pLeft = &compLeft; exprAnd.pRight = &compRight; compLeft.op = TK_GE; compLeft.pLeft = &exprX; compLeft.pRight = pExpr->pList->a[0].pExpr; compRight.op = TK_LE; compRight.pLeft = &exprX; compRight.pRight = pExpr->pList->a[1].pExpr; exprX.iTable = sqlite3ExprCodeTemp(pParse, &exprX, &regFree1); testcase( regFree1==0 ); exprX.op = TK_REGISTER; testcase( jumpIfNull==0 ); sqlite3ExprIfTrue(pParse, &exprAnd, dest, jumpIfNull); break; } default: { r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1); sqlite3VdbeAddOp3(v, OP_If, r1, dest, jumpIfNull!=0); testcase( regFree1==0 ); testcase( jumpIfNull==0 ); break; } } sqlite3ReleaseTempReg(pParse, regFree1); sqlite3ReleaseTempReg(pParse, regFree2); } SQLITE_PRIVATE void sqlite3ExprIfFalse(Parse *pParse, Expr *pExpr, int dest, int jumpIfNull){ Vdbe *v = pParse->pVdbe; int op = 0; int regFree1 = 0; int regFree2 = 0; int r1, r2; assert( jumpIfNull==SQLITE_JUMPIFNULL || jumpIfNull==0 ); if( v==0 || pExpr==0 ) return; op = ((pExpr->op+(TK_ISNULL&1))^1)-(TK_ISNULL&1); assert( pExpr->op!=TK_ISNULL || op==OP_NotNull ); assert( pExpr->op!=TK_NOTNULL || op==OP_IsNull ); assert( pExpr->op!=TK_NE || op==OP_Eq ); assert( pExpr->op!=TK_EQ || op==OP_Ne ); assert( pExpr->op!=TK_LT || op==OP_Ge ); assert( pExpr->op!=TK_LE || op==OP_Gt ); assert( pExpr->op!=TK_GT || op==OP_Le ); assert( pExpr->op!=TK_GE || op==OP_Lt ); switch( pExpr->op ){ case TK_AND: { testcase( jumpIfNull==0 ); testcase( pParse->disableColCache==0 ); sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull); pParse->disableColCache++; sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull); assert( pParse->disableColCache>0 ); pParse->disableColCache--; break; } case TK_OR: { int d2 = sqlite3VdbeMakeLabel(v); testcase( jumpIfNull==0 ); testcase( pParse->disableColCache==0 ); sqlite3ExprIfTrue(pParse, pExpr->pLeft, d2, jumpIfNull^SQLITE_JUMPIFNULL); pParse->disableColCache++; sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull); assert( pParse->disableColCache>0 ); pParse->disableColCache--; sqlite3VdbeResolveLabel(v, d2); break; } case TK_NOT: { sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull); break; } case TK_LT: case TK_LE: case TK_GT: case TK_GE: case TK_NE: case TK_EQ: { testcase( op==TK_LT ); testcase( op==TK_LE ); testcase( op==TK_GT ); testcase( op==TK_GE ); testcase( op==TK_EQ ); testcase( op==TK_NE ); testcase( jumpIfNull==0 ); codeCompareOperands(pParse, pExpr->pLeft, &r1, &regFree1, pExpr->pRight, &r2, &regFree2); codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op, r1, r2, dest, jumpIfNull); testcase( regFree1==0 ); testcase( regFree2==0 ); break; } case TK_ISNULL: case TK_NOTNULL: { testcase( op==TK_ISNULL ); testcase( op==TK_NOTNULL ); r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1); sqlite3VdbeAddOp2(v, op, r1, dest); testcase( regFree1==0 ); break; } case TK_BETWEEN: { Expr exprAnd; Expr compLeft; Expr compRight; Expr exprX; exprX = *pExpr->pLeft; exprAnd.op = TK_AND; exprAnd.pLeft = &compLeft; exprAnd.pRight = &compRight; compLeft.op = TK_GE; compLeft.pLeft = &exprX; compLeft.pRight = pExpr->pList->a[0].pExpr; compRight.op = TK_LE; compRight.pLeft = &exprX; compRight.pRight = pExpr->pList->a[1].pExpr; exprX.iTable = sqlite3ExprCodeTemp(pParse, &exprX, &regFree1); testcase( regFree1==0 ); exprX.op = TK_REGISTER; testcase( jumpIfNull==0 ); sqlite3ExprIfFalse(pParse, &exprAnd, dest, jumpIfNull); break; } default: { r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1); sqlite3VdbeAddOp3(v, OP_IfNot, r1, dest, jumpIfNull!=0); testcase( regFree1==0 ); testcase( jumpIfNull==0 ); break; } } sqlite3ReleaseTempReg(pParse, regFree1); sqlite3ReleaseTempReg(pParse, regFree2); } SQLITE_PRIVATE int sqlite3ExprCompare(Expr *pA, Expr *pB){ int i; if( pA==0||pB==0 ){ return pB==pA; } if( pA->op!=pB->op ) return 0; if( (pA->flags & EP_Distinct)!=(pB->flags & EP_Distinct) ) return 0; if( !sqlite3ExprCompare(pA->pLeft, pB->pLeft) ) return 0; if( !sqlite3ExprCompare(pA->pRight, pB->pRight) ) return 0; if( pA->pList ){ if( pB->pList==0 ) return 0; if( pA->pList->nExpr!=pB->pList->nExpr ) return 0; for(i=0; i<pA->pList->nExpr; i++){ if( !sqlite3ExprCompare(pA->pList->a[i].pExpr, pB->pList->a[i].pExpr) ){ return 0; } } }else if( pB->pList ){ return 0; } if( pA->pSelect || pB->pSelect ) return 0; if( pA->iTable!=pB->iTable || pA->iColumn!=pB->iColumn ) return 0; if( pA->op!=TK_COLUMN && pA->token.z ){ if( pB->token.z==0 ) return 0; if( pB->token.n!=pA->token.n ) return 0; if( sqlite3StrNICmp((char*)pA->token.z,(char*)pB->token.z,pB->token.n)!=0 ){ return 0; } } return 1; } static int addAggInfoColumn(sqlite3 *db, AggInfo *pInfo){ int i; pInfo->aCol = sqlite3ArrayAllocate( db, pInfo->aCol, sizeof(pInfo->aCol[0]), 3, &pInfo->nColumn, &pInfo->nColumnAlloc, &i ); return i; } static int addAggInfoFunc(sqlite3 *db, AggInfo *pInfo){ int i; pInfo->aFunc = sqlite3ArrayAllocate( db, pInfo->aFunc, sizeof(pInfo->aFunc[0]), 3, &pInfo->nFunc, &pInfo->nFuncAlloc, &i ); return i; } static int analyzeAggregate(Walker *pWalker, Expr *pExpr){ int i; NameContext *pNC = pWalker->u.pNC; Parse *pParse = pNC->pParse; SrcList *pSrcList = pNC->pSrcList; AggInfo *pAggInfo = pNC->pAggInfo; switch( pExpr->op ){ case TK_AGG_COLUMN: case TK_COLUMN: { testcase( pExpr->op==TK_AGG_COLUMN ); testcase( pExpr->op==TK_COLUMN ); if( pSrcList ){ struct SrcList_item *pItem = pSrcList->a; for(i=0; i<pSrcList->nSrc; i++, pItem++){ struct AggInfo_col *pCol; if( pExpr->iTable==pItem->iCursor ){ int k; pCol = pAggInfo->aCol; for(k=0; k<pAggInfo->nColumn; k++, pCol++){ if( pCol->iTable==pExpr->iTable && pCol->iColumn==pExpr->iColumn ){ break; } } if( (k>=pAggInfo->nColumn) && (k = addAggInfoColumn(pParse->db, pAggInfo))>=0 ){ pCol = &pAggInfo->aCol[k]; pCol->pTab = pExpr->pTab; pCol->iTable = pExpr->iTable; pCol->iColumn = pExpr->iColumn; pCol->iMem = ++pParse->nMem; pCol->iSorterColumn = -1; pCol->pExpr = pExpr; if( pAggInfo->pGroupBy ){ int j, n; ExprList *pGB = pAggInfo->pGroupBy; struct ExprList_item *pTerm = pGB->a; n = pGB->nExpr; for(j=0; j<n; j++, pTerm++){ Expr *pE = pTerm->pExpr; if( pE->op==TK_COLUMN && pE->iTable==pExpr->iTable && pE->iColumn==pExpr->iColumn ){ pCol->iSorterColumn = j; break; } } } if( pCol->iSorterColumn<0 ){ pCol->iSorterColumn = pAggInfo->nSortingColumn++; } } pExpr->pAggInfo = pAggInfo; pExpr->op = TK_AGG_COLUMN; pExpr->iAgg = k; break; } } } return WRC_Prune; } case TK_AGG_FUNCTION: { if( pNC->nDepth==0 ){ struct AggInfo_func *pItem = pAggInfo->aFunc; for(i=0; i<pAggInfo->nFunc; i++, pItem++){ if( sqlite3ExprCompare(pItem->pExpr, pExpr) ){ break; } } if( i>=pAggInfo->nFunc ){ u8 enc = ENC(pParse->db); i = addAggInfoFunc(pParse->db, pAggInfo); if( i>=0 ){ pItem = &pAggInfo->aFunc[i]; pItem->pExpr = pExpr; pItem->iMem = ++pParse->nMem; pItem->pFunc = sqlite3FindFunction(pParse->db, (char*)pExpr->token.z, pExpr->token.n, pExpr->pList ? pExpr->pList->nExpr : 0, enc, 0); if( pExpr->flags & EP_Distinct ){ pItem->iDistinct = pParse->nTab++; }else{ pItem->iDistinct = -1; } } } pExpr->iAgg = i; pExpr->pAggInfo = pAggInfo; return WRC_Prune; } } } return WRC_Continue; } static int analyzeAggregatesInSelect(Walker *pWalker, Select *pSelect){ NameContext *pNC = pWalker->u.pNC; if( pNC->nDepth==0 ){ pNC->nDepth++; sqlite3WalkSelect(pWalker, pSelect); pNC->nDepth--; return WRC_Prune; }else{ return WRC_Continue; } } SQLITE_PRIVATE void sqlite3ExprAnalyzeAggregates(NameContext *pNC, Expr *pExpr){ Walker w; w.xExprCallback = analyzeAggregate; w.xSelectCallback = analyzeAggregatesInSelect; w.u.pNC = pNC; sqlite3WalkExpr(&w, pExpr); } SQLITE_PRIVATE void sqlite3ExprAnalyzeAggList(NameContext *pNC, ExprList *pList){ struct ExprList_item *pItem; int i; if( pList ){ for(pItem=pList->a, i=0; i<pList->nExpr; i++, pItem++){ sqlite3ExprAnalyzeAggregates(pNC, pItem->pExpr); } } } SQLITE_PRIVATE int sqlite3GetTempReg(Parse *pParse){ if( pParse->nTempReg==0 ){ return ++pParse->nMem; } return pParse->aTempReg[--pParse->nTempReg]; } SQLITE_PRIVATE void sqlite3ReleaseTempReg(Parse *pParse, int iReg){ if( iReg && pParse->nTempReg<ArraySize(pParse->aTempReg) ){ sqlite3ExprWritableRegister(pParse, iReg, iReg); pParse->aTempReg[pParse->nTempReg++] = iReg; } } SQLITE_PRIVATE int sqlite3GetTempRange(Parse *pParse, int nReg){ int i, n; i = pParse->iRangeReg; n = pParse->nRangeReg; if( nReg<=n && !usedAsColumnCache(pParse, i, i+n-1) ){ pParse->iRangeReg += nReg; pParse->nRangeReg -= nReg; }else{ i = pParse->nMem+1; pParse->nMem += nReg; } return i; } SQLITE_PRIVATE void sqlite3ReleaseTempRange(Parse *pParse, int iReg, int nReg){ if( nReg>pParse->nRangeReg ){ pParse->nRangeReg = nReg; pParse->iRangeReg = iReg; } } 
#ifndef SQLITE_OMIT_ALTERTABLE 
static void renameTableFunc( sqlite3_context *context, int NotUsed, sqlite3_value **argv ){ unsigned char const *zSql = sqlite3_value_text(argv[0]); unsigned char const *zTableName = sqlite3_value_text(argv[1]); int token; Token tname; unsigned char const *zCsr = zSql; int len = 0; char *zRet; sqlite3 *db = sqlite3_context_db_handle(context); UNUSED_PARAMETER(NotUsed); if( zSql ){ do { if( !*zCsr ){ return; } tname.z = zCsr; tname.n = len; do { zCsr += len; len = sqlite3GetToken(zCsr, &token); } while( token==TK_SPACE ); assert( len>0 ); } while( token!=TK_LP && token!=TK_USING ); zRet = sqlite3MPrintf(db, "%.*s\"%w\"%s", tname.z - zSql, zSql, zTableName, tname.z+tname.n); sqlite3_result_text(context, zRet, -1, SQLITE_DYNAMIC); } } 
#ifndef SQLITE_OMIT_TRIGGER 
static void renameTriggerFunc( sqlite3_context *context, int NotUsed, sqlite3_value **argv ){ unsigned char const *zSql = sqlite3_value_text(argv[0]); unsigned char const *zTableName = sqlite3_value_text(argv[1]); int token; Token tname; int dist = 3; unsigned char const *zCsr = zSql; int len = 0; char *zRet; sqlite3 *db = sqlite3_context_db_handle(context); UNUSED_PARAMETER(NotUsed); if( zSql ){ do { if( !*zCsr ){ return; } tname.z = zCsr; tname.n = len; do { zCsr += len; len = sqlite3GetToken(zCsr, &token); }while( token==TK_SPACE ); assert( len>0 ); dist++; if( token==TK_DOT || token==TK_ON ){ dist = 0; } } while( dist!=2 || (token!=TK_WHEN && token!=TK_FOR && token!=TK_BEGIN) ); zRet = sqlite3MPrintf(db, "%.*s\"%w\"%s", tname.z - zSql, zSql, zTableName, tname.z+tname.n); sqlite3_result_text(context, zRet, -1, SQLITE_DYNAMIC); } } 
#endif 
SQLITE_PRIVATE void sqlite3AlterFunctions(sqlite3 *db){ sqlite3CreateFunc(db, "sqlite_rename_table", 2, SQLITE_UTF8, 0, renameTableFunc, 0, 0); 
#ifndef SQLITE_OMIT_TRIGGER 
 sqlite3CreateFunc(db, "sqlite_rename_trigger", 2, SQLITE_UTF8, 0, renameTriggerFunc, 0, 0); 
#endif 
} static char *whereTempTriggers(Parse *pParse, Table *pTab){ Trigger *pTrig; char *zWhere = 0; char *tmp = 0; const Schema *pTempSchema = pParse->db->aDb[1].pSchema; if( pTab->pSchema!=pTempSchema ){ sqlite3 *db = pParse->db; for( pTrig=pTab->pTrigger; pTrig; pTrig=pTrig->pNext ){ if( pTrig->pSchema==pTempSchema ){ if( !zWhere ){ zWhere = sqlite3MPrintf(db, "name=%Q", pTrig->name); }else{ tmp = zWhere; zWhere = sqlite3MPrintf(db, "%s OR name=%Q", zWhere, pTrig->name); sqlite3DbFree(db, tmp); } } } } return zWhere; } static void reloadTableSchema(Parse *pParse, Table *pTab, const char *zName){ Vdbe *v; char *zWhere; int iDb; 
#ifndef SQLITE_OMIT_TRIGGER 
 Trigger *pTrig; 
#endif 
 v = sqlite3GetVdbe(pParse); if( !v ) return; assert( sqlite3BtreeHoldsAllMutexes(pParse->db) ); iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema); assert( iDb>=0 ); 
#ifndef SQLITE_OMIT_TRIGGER 
 for(pTrig=pTab->pTrigger; pTrig; pTrig=pTrig->pNext){ int iTrigDb = sqlite3SchemaToIndex(pParse->db, pTrig->pSchema); assert( iTrigDb==iDb || iTrigDb==1 ); sqlite3VdbeAddOp4(v, OP_DropTrigger, iTrigDb, 0, 0, pTrig->name, 0); } 
#endif 
 sqlite3VdbeAddOp4(v, OP_DropTable, iDb, 0, 0, pTab->zName, 0); zWhere = sqlite3MPrintf(pParse->db, "tbl_name=%Q", zName); if( !zWhere ) return; sqlite3VdbeAddOp4(v, OP_ParseSchema, iDb, 0, 0, zWhere, P4_DYNAMIC); 
#ifndef SQLITE_OMIT_TRIGGER 
 if( (zWhere=whereTempTriggers(pParse, pTab))!=0 ){ sqlite3VdbeAddOp4(v, OP_ParseSchema, 1, 0, 0, zWhere, P4_DYNAMIC); } 
#endif 
} SQLITE_PRIVATE void sqlite3AlterRenameTable( Parse *pParse, SrcList *pSrc, Token *pName ){ int iDb; char *zDb; Table *pTab; char *zName = 0; sqlite3 *db = pParse->db; int nTabName; const char *zTabName; Vdbe *v; 
#ifndef SQLITE_OMIT_TRIGGER 
 char *zWhere = 0; 
#endif 
 int isVirtualRename = 0; if( db->mallocFailed ) goto exit_rename_table; assert( pSrc->nSrc==1 ); assert( sqlite3BtreeHoldsAllMutexes(pParse->db) ); pTab = sqlite3LocateTable(pParse, 0, pSrc->a[0].zName, pSrc->a[0].zDatabase); if( !pTab ) goto exit_rename_table; iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema); zDb = db->aDb[iDb].zName; zName = sqlite3NameFromToken(db, pName); if( !zName ) goto exit_rename_table; if( sqlite3FindTable(db, zName, zDb) || sqlite3FindIndex(db, zName, zDb) ){ sqlite3ErrorMsg(pParse, "there is already another table or index with this name: %s", zName); goto exit_rename_table; } if( strlen(pTab->zName)>6 && 0==sqlite3StrNICmp(pTab->zName, "sqlite_", 7) ){ sqlite3ErrorMsg(pParse, "table %s may not be altered", pTab->zName); goto exit_rename_table; } if( SQLITE_OK!=sqlite3CheckObjectName(pParse, zName) ){ goto exit_rename_table; } 
#ifndef SQLITE_OMIT_VIEW 
 if( pTab->pSelect ){ sqlite3ErrorMsg(pParse, "view %s may not be altered", pTab->zName); goto exit_rename_table; } 
#endif 
#ifndef SQLITE_OMIT_AUTHORIZATION 
 if( sqlite3AuthCheck(pParse, SQLITE_ALTER_TABLE, zDb, pTab->zName, 0) ){ goto exit_rename_table; } 
#endif 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 if( sqlite3ViewGetColumnNames(pParse, pTab) ){ goto exit_rename_table; } if( IsVirtual(pTab) && pTab->pMod->pModule->xRename ){ isVirtualRename = 1; } 
#endif 
 v = sqlite3GetVdbe(pParse); if( v==0 ){ goto exit_rename_table; } sqlite3BeginWriteOperation(pParse, isVirtualRename, iDb); sqlite3ChangeCookie(pParse, iDb); 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 if( isVirtualRename ){ int i = ++pParse->nMem; sqlite3VdbeAddOp4(v, OP_String8, 0, i, 0, zName, 0); sqlite3VdbeAddOp4(v, OP_VRename, i, 0, 0,(const char*)pTab->pVtab, P4_VTAB); } 
#endif 
 zTabName = pTab->zName; nTabName = sqlite3Utf8CharLen(zTabName, -1); sqlite3NestedParse(pParse, "UPDATE %Q.%s SET " 
#ifdef SQLITE_OMIT_TRIGGER 
 "sql = sqlite_rename_table(sql, %Q), " 
#else 
 "sql = CASE " "WHEN type = 'trigger' THEN sqlite_rename_trigger(sql, %Q)" "ELSE sqlite_rename_table(sql, %Q) END, " 
#endif 
 "tbl_name = %Q, " "name = CASE " "WHEN type='table' THEN %Q " "WHEN name LIKE 'sqlite_autoindex%%' AND type='index' THEN " "'sqlite_autoindex_' || %Q || substr(name,%d+18) " "ELSE name END " "WHERE tbl_name=%Q AND " "(type='table' OR type='index' OR type='trigger');", zDb, SCHEMA_TABLE(iDb), zName, zName, zName, 
#ifndef SQLITE_OMIT_TRIGGER 
 zName, 
#endif 
 zName, nTabName, zTabName ); 
#ifndef SQLITE_OMIT_AUTOINCREMENT 
 if( sqlite3FindTable(db, "sqlite_sequence", zDb) ){ sqlite3NestedParse(pParse, "UPDATE \"%w\".sqlite_sequence set name = %Q WHERE name = %Q", zDb, zName, pTab->zName); } 
#endif 
#ifndef SQLITE_OMIT_TRIGGER 
 if( (zWhere=whereTempTriggers(pParse, pTab))!=0 ){ sqlite3NestedParse(pParse, "UPDATE sqlite_temp_master SET " "sql = sqlite_rename_trigger(sql, %Q), " "tbl_name = %Q " "WHERE %s;", zName, zName, zWhere); sqlite3DbFree(db, zWhere); } 
#endif 
 reloadTableSchema(pParse, pTab, zName); exit_rename_table: sqlite3SrcListDelete(db, pSrc); sqlite3DbFree(db, zName); } SQLITE_PRIVATE void sqlite3AlterFinishAddColumn(Parse *pParse, Token *pColDef){ Table *pNew; Table *pTab; int iDb; const char *zDb; const char *zTab; char *zCol; Column *pCol; Expr *pDflt; sqlite3 *db; db = pParse->db; if( pParse->nErr || db->mallocFailed ) return; pNew = pParse->pNewTable; assert( pNew ); assert( sqlite3BtreeHoldsAllMutexes(db) ); iDb = sqlite3SchemaToIndex(db, pNew->pSchema); zDb = db->aDb[iDb].zName; zTab = pNew->zName; pCol = &pNew->aCol[pNew->nCol-1]; pDflt = pCol->pDflt; pTab = sqlite3FindTable(db, zTab, zDb); assert( pTab ); 
#ifndef SQLITE_OMIT_AUTHORIZATION 
 if( sqlite3AuthCheck(pParse, SQLITE_ALTER_TABLE, zDb, pTab->zName, 0) ){ return; } 
#endif 
 if( pDflt && pDflt->op==TK_NULL ){ pDflt = 0; } if( pCol->isPrimKey ){ sqlite3ErrorMsg(pParse, "Cannot add a PRIMARY KEY column"); return; } if( pNew->pIndex ){ sqlite3ErrorMsg(pParse, "Cannot add a UNIQUE column"); return; } if( pCol->notNull && !pDflt ){ sqlite3ErrorMsg(pParse, "Cannot add a NOT NULL column with default value NULL"); return; } if( pDflt ){ sqlite3_value *pVal; if( sqlite3ValueFromExpr(db, pDflt, SQLITE_UTF8, SQLITE_AFF_NONE, &pVal) ){ db->mallocFailed = 1; return; } if( !pVal ){ sqlite3ErrorMsg(pParse, "Cannot add a column with non-constant default"); return; } sqlite3ValueFree(pVal); } zCol = sqlite3DbStrNDup(db, (char*)pColDef->z, pColDef->n); if( zCol ){ char *zEnd = &zCol[pColDef->n-1]; while( (zEnd>zCol && *zEnd==';') || isspace(*(unsigned char *)zEnd) ){ *zEnd-- = '\0'; } sqlite3NestedParse(pParse, "UPDATE \"%w\".%s SET " "sql = substr(sql,1,%d) || ', ' || %Q || substr(sql,%d) " "WHERE type = 'table' AND name = %Q", zDb, SCHEMA_TABLE(iDb), pNew->addColOffset, zCol, pNew->addColOffset+1, zTab ); sqlite3DbFree(db, zCol); } sqlite3MinimumFileFormat(pParse, iDb, pDflt ? 3 : 2); reloadTableSchema(pParse, pTab, pTab->zName); } SQLITE_PRIVATE void sqlite3AlterBeginAddColumn(Parse *pParse, SrcList *pSrc){ Table *pNew; Table *pTab; Vdbe *v; int iDb; int i; int nAlloc; sqlite3 *db = pParse->db; assert( pParse->pNewTable==0 ); assert( sqlite3BtreeHoldsAllMutexes(db) ); if( db->mallocFailed ) goto exit_begin_add_column; pTab = sqlite3LocateTable(pParse, 0, pSrc->a[0].zName, pSrc->a[0].zDatabase); if( !pTab ) goto exit_begin_add_column; 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 if( IsVirtual(pTab) ){ sqlite3ErrorMsg(pParse, "virtual tables may not be altered"); goto exit_begin_add_column; } 
#endif 
 if( pTab->pSelect ){ sqlite3ErrorMsg(pParse, "Cannot add a column to a view"); goto exit_begin_add_column; } assert( pTab->addColOffset>0 ); iDb = sqlite3SchemaToIndex(db, pTab->pSchema); pNew = (Table*)sqlite3DbMallocZero(db, sizeof(Table)); if( !pNew ) goto exit_begin_add_column; pParse->pNewTable = pNew; pNew->nRef = 1; pNew->db = db; pNew->nCol = pTab->nCol; assert( pNew->nCol>0 ); nAlloc = (((pNew->nCol-1)/8)*8)+8; assert( nAlloc>=pNew->nCol && nAlloc%8==0 && nAlloc-pNew->nCol<8 ); pNew->aCol = (Column*)sqlite3DbMallocZero(db, sizeof(Column)*nAlloc); pNew->zName = sqlite3DbStrDup(db, pTab->zName); if( !pNew->aCol || !pNew->zName ){ db->mallocFailed = 1; goto exit_begin_add_column; } memcpy(pNew->aCol, pTab->aCol, sizeof(Column)*pNew->nCol); for(i=0; i<pNew->nCol; i++){ Column *pCol = &pNew->aCol[i]; pCol->zName = sqlite3DbStrDup(db, pCol->zName); pCol->zColl = 0; pCol->zType = 0; pCol->pDflt = 0; } pNew->pSchema = db->aDb[iDb].pSchema; pNew->addColOffset = pTab->addColOffset; pNew->nRef = 1; sqlite3BeginWriteOperation(pParse, 0, iDb); v = sqlite3GetVdbe(pParse); if( !v ) goto exit_begin_add_column; sqlite3ChangeCookie(pParse, iDb); exit_begin_add_column: sqlite3SrcListDelete(db, pSrc); return; } 
#endif 
#ifndef SQLITE_OMIT_ANALYZE 
static void openStatTable( Parse *pParse, int iDb, int iStatCur, const char *zWhere ){ sqlite3 *db = pParse->db; Db *pDb; int iRootPage; int createStat1 = 0; Table *pStat; Vdbe *v = sqlite3GetVdbe(pParse); if( v==0 ) return; assert( sqlite3BtreeHoldsAllMutexes(db) ); assert( sqlite3VdbeDb(v)==db ); pDb = &db->aDb[iDb]; if( (pStat = sqlite3FindTable(db, "sqlite_stat1", pDb->zName))==0 ){ sqlite3NestedParse(pParse, "CREATE TABLE %Q.sqlite_stat1(tbl,idx,stat)", pDb->zName ); iRootPage = pParse->regRoot; createStat1 = 1; }else if( zWhere ){ sqlite3NestedParse(pParse, "DELETE FROM %Q.sqlite_stat1 WHERE tbl=%Q", pDb->zName, zWhere ); iRootPage = pStat->tnum; }else{ iRootPage = pStat->tnum; sqlite3VdbeAddOp2(v, OP_Clear, pStat->tnum, iDb); } if( !createStat1 ){ sqlite3TableLock(pParse, iDb, iRootPage, 1, "sqlite_stat1"); } sqlite3VdbeAddOp2(v, OP_SetNumColumns, 0, 3); sqlite3VdbeAddOp3(v, OP_OpenWrite, iStatCur, iRootPage, iDb); sqlite3VdbeChangeP5(v, createStat1); } static void analyzeOneTable( Parse *pParse, Table *pTab, int iStatCur, int iMem ){ Index *pIdx; int iIdxCur; int nCol; Vdbe *v; int i; int topOfLoop; int endOfLoop; int addr; int iDb; v = sqlite3GetVdbe(pParse); if( v==0 || pTab==0 || pTab->pIndex==0 ){ return; } assert( sqlite3BtreeHoldsAllMutexes(pParse->db) ); iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema); assert( iDb>=0 ); 
#ifndef SQLITE_OMIT_AUTHORIZATION 
 if( sqlite3AuthCheck(pParse, SQLITE_ANALYZE, pTab->zName, 0, pParse->db->aDb[iDb].zName ) ){ return; } 
#endif 
 sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName); iIdxCur = pParse->nTab; for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){ KeyInfo *pKey = sqlite3IndexKeyinfo(pParse, pIdx); int regFields; int regRec; int regTemp; int regCol; int regRowid; int regF2; assert( iDb==sqlite3SchemaToIndex(pParse->db, pIdx->pSchema) ); nCol = pIdx->nColumn; sqlite3VdbeAddOp2(v, OP_SetNumColumns, 0, nCol+1); sqlite3VdbeAddOp4(v, OP_OpenRead, iIdxCur, pIdx->tnum, iDb, (char *)pKey, P4_KEYINFO_HANDOFF); VdbeComment((v, "%s", pIdx->zName)); regFields = iMem+nCol*2; regTemp = regRowid = regCol = regFields+3; regRec = regCol+1; if( regRec>pParse->nMem ){ pParse->nMem = regRec; } for(i=0; i<=nCol; i++){ sqlite3VdbeAddOp2(v, OP_Integer, 0, iMem+i); } for(i=0; i<nCol; i++){ sqlite3VdbeAddOp2(v, OP_Null, 0, iMem+nCol+i+1); } endOfLoop = sqlite3VdbeMakeLabel(v); sqlite3VdbeAddOp2(v, OP_Rewind, iIdxCur, endOfLoop); topOfLoop = sqlite3VdbeCurrentAddr(v); sqlite3VdbeAddOp2(v, OP_AddImm, iMem, 1); for(i=0; i<nCol; i++){ sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, i, regCol); sqlite3VdbeAddOp3(v, OP_Ne, regCol, 0, iMem+nCol+i+1); sqlite3VdbeChangeP5(v, SQLITE_JUMPIFNULL); } sqlite3VdbeAddOp2(v, OP_Goto, 0, endOfLoop); for(i=0; i<nCol; i++){ sqlite3VdbeJumpHere(v, topOfLoop + 2*(i + 1)); sqlite3VdbeAddOp2(v, OP_AddImm, iMem+i+1, 1); sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, i, iMem+nCol+i+1); } sqlite3VdbeResolveLabel(v, endOfLoop); sqlite3VdbeAddOp2(v, OP_Next, iIdxCur, topOfLoop); sqlite3VdbeAddOp1(v, OP_Close, iIdxCur); addr = sqlite3VdbeAddOp1(v, OP_IfNot, iMem); sqlite3VdbeAddOp4(v, OP_String8, 0, regFields, 0, pTab->zName, 0); sqlite3VdbeAddOp4(v, OP_String8, 0, regFields+1, 0, pIdx->zName, 0); regF2 = regFields+2; sqlite3VdbeAddOp2(v, OP_SCopy, iMem, regF2); for(i=0; i<nCol; i++){ sqlite3VdbeAddOp4(v, OP_String8, 0, regTemp, 0, " ", 0); sqlite3VdbeAddOp3(v, OP_Concat, regTemp, regF2, regF2); sqlite3VdbeAddOp3(v, OP_Add, iMem, iMem+i+1, regTemp); sqlite3VdbeAddOp2(v, OP_AddImm, regTemp, -1); sqlite3VdbeAddOp3(v, OP_Divide, iMem+i+1, regTemp, regTemp); sqlite3VdbeAddOp1(v, OP_ToInt, regTemp); sqlite3VdbeAddOp3(v, OP_Concat, regTemp, regF2, regF2); } sqlite3VdbeAddOp4(v, OP_MakeRecord, regFields, 3, regRec, "aaa", 0); sqlite3VdbeAddOp2(v, OP_NewRowid, iStatCur, regRowid); sqlite3VdbeAddOp3(v, OP_Insert, iStatCur, regRec, regRowid); sqlite3VdbeChangeP5(v, OPFLAG_APPEND); sqlite3VdbeJumpHere(v, addr); } } static void loadAnalysis(Parse *pParse, int iDb){ Vdbe *v = sqlite3GetVdbe(pParse); if( v ){ sqlite3VdbeAddOp1(v, OP_LoadAnalysis, iDb); } } static void analyzeDatabase(Parse *pParse, int iDb){ sqlite3 *db = pParse->db; Schema *pSchema = db->aDb[iDb].pSchema; HashElem *k; int iStatCur; int iMem; sqlite3BeginWriteOperation(pParse, 0, iDb); iStatCur = pParse->nTab++; openStatTable(pParse, iDb, iStatCur, 0); iMem = pParse->nMem+1; for(k=sqliteHashFirst(&pSchema->tblHash); k; k=sqliteHashNext(k)){ Table *pTab = (Table*)sqliteHashData(k); analyzeOneTable(pParse, pTab, iStatCur, iMem); } loadAnalysis(pParse, iDb); } static void analyzeTable(Parse *pParse, Table *pTab){ int iDb; int iStatCur; assert( pTab!=0 ); assert( sqlite3BtreeHoldsAllMutexes(pParse->db) ); iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema); sqlite3BeginWriteOperation(pParse, 0, iDb); iStatCur = pParse->nTab++; openStatTable(pParse, iDb, iStatCur, pTab->zName); analyzeOneTable(pParse, pTab, iStatCur, pParse->nMem+1); loadAnalysis(pParse, iDb); } SQLITE_PRIVATE void sqlite3Analyze(Parse *pParse, Token *pName1, Token *pName2){ sqlite3 *db = pParse->db; int iDb; int i; char *z, *zDb; Table *pTab; Token *pTableName; assert( sqlite3BtreeHoldsAllMutexes(pParse->db) ); if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){ return; } if( pName1==0 ){ for(i=0; i<db->nDb; i++){ if( i==1 ) continue; analyzeDatabase(pParse, i); } }else if( pName2==0 || pName2->n==0 ){ iDb = sqlite3FindDb(db, pName1); if( iDb>=0 ){ analyzeDatabase(pParse, iDb); }else{ z = sqlite3NameFromToken(db, pName1); if( z ){ pTab = sqlite3LocateTable(pParse, 0, z, 0); sqlite3DbFree(db, z); if( pTab ){ analyzeTable(pParse, pTab); } } } }else{ iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pTableName); if( iDb>=0 ){ zDb = db->aDb[iDb].zName; z = sqlite3NameFromToken(db, pTableName); if( z ){ pTab = sqlite3LocateTable(pParse, 0, z, zDb); sqlite3DbFree(db, z); if( pTab ){ analyzeTable(pParse, pTab); } } } } } typedef struct analysisInfo analysisInfo; struct analysisInfo { sqlite3 *db; const char *zDatabase; }; static int analysisLoader(void *pData, int argc, char **argv, char **NotUsed){ analysisInfo *pInfo = (analysisInfo*)pData; Index *pIndex; int i, c; unsigned int v; const char *z; assert( argc==2 ); UNUSED_PARAMETER2(NotUsed, argc); if( argv==0 || argv[0]==0 || argv[1]==0 ){ return 0; } pIndex = sqlite3FindIndex(pInfo->db, argv[0], pInfo->zDatabase); if( pIndex==0 ){ return 0; } z = argv[1]; for(i=0; *z && i<=pIndex->nColumn; i++){ v = 0; while( (c=z[0])>='0' && c<='9' ){ v = v*10 + c - '0'; z++; } pIndex->aiRowEst[i] = v; if( *z==' ' ) z++; } return 0; } SQLITE_PRIVATE int sqlite3AnalysisLoad(sqlite3 *db, int iDb){ analysisInfo sInfo; HashElem *i; char *zSql; int rc; assert( iDb>=0 && iDb<db->nDb ); assert( db->aDb[iDb].pBt!=0 ); assert( sqlite3BtreeHoldsMutex(db->aDb[iDb].pBt) ); for(i=sqliteHashFirst(&db->aDb[iDb].pSchema->idxHash);i;i=sqliteHashNext(i)){ Index *pIdx = sqliteHashData(i); sqlite3DefaultRowEst(pIdx); } sInfo.db = db; sInfo.zDatabase = db->aDb[iDb].zName; if( sqlite3FindTable(db, "sqlite_stat1", sInfo.zDatabase)==0 ){ return SQLITE_ERROR; } zSql = sqlite3MPrintf(db, "SELECT idx, stat FROM %Q.sqlite_stat1", sInfo.zDatabase); (void)sqlite3SafetyOff(db); rc = sqlite3_exec(db, zSql, analysisLoader, &sInfo, 0); (void)sqlite3SafetyOn(db); sqlite3DbFree(db, zSql); return rc; } 
#endif 
#ifndef SQLITE_OMIT_ATTACH 
static int resolveAttachExpr(NameContext *pName, Expr *pExpr) { int rc = SQLITE_OK; if( pExpr ){ if( pExpr->op!=TK_ID ){ rc = sqlite3ResolveExprNames(pName, pExpr); if( rc==SQLITE_OK && !sqlite3ExprIsConstant(pExpr) ){ sqlite3ErrorMsg(pName->pParse, "invalid name: \"%T\"", &pExpr->span); return SQLITE_ERROR; } }else{ pExpr->op = TK_STRING; } } return rc; } static void attachFunc( sqlite3_context *context, int NotUsed, sqlite3_value **argv ){ int i; int rc = 0; sqlite3 *db = sqlite3_context_db_handle(context); const char *zName; const char *zFile; Db *aNew; char *zErrDyn = 0; char zErr[128]; UNUSED_PARAMETER(NotUsed); zFile = (const char *)sqlite3_value_text(argv[0]); zName = (const char *)sqlite3_value_text(argv[1]); if( zFile==0 ) zFile = ""; if( zName==0 ) zName = ""; if( db->nDb>=db->aLimit[SQLITE_LIMIT_ATTACHED]+2 ){ sqlite3_snprintf( sizeof(zErr), zErr, "too many attached databases - max %d", db->aLimit[SQLITE_LIMIT_ATTACHED] ); goto attach_error; } if( !db->autoCommit ){ sqlite3_snprintf(sizeof(zErr), zErr, "cannot ATTACH database within transaction"); goto attach_error; } for(i=0; i<db->nDb; i++){ char *z = db->aDb[i].zName; if( z && zName && sqlite3StrICmp(z, zName)==0 ){ sqlite3_snprintf(sizeof(zErr), zErr, "database %s is already in use", zName); goto attach_error; } } if( db->aDb==db->aDbStatic ){ aNew = sqlite3DbMallocRaw(db, sizeof(db->aDb[0])*3 ); if( aNew==0 ) return; memcpy(aNew, db->aDb, sizeof(db->aDb[0])*2); }else{ aNew = sqlite3DbRealloc(db, db->aDb, sizeof(db->aDb[0])*(db->nDb+1) ); if( aNew==0 ) return; } db->aDb = aNew; aNew = &db->aDb[db->nDb++]; memset(aNew, 0, sizeof(*aNew)); rc = sqlite3BtreeFactory(db, zFile, 0, SQLITE_DEFAULT_CACHE_SIZE, db->openFlags | SQLITE_OPEN_MAIN_DB, &aNew->pBt); if( rc==SQLITE_OK ){ Pager *pPager; aNew->pSchema = sqlite3SchemaGet(db, aNew->pBt); if( !aNew->pSchema ){ rc = SQLITE_NOMEM; }else if( aNew->pSchema->file_format && aNew->pSchema->enc!=ENC(db) ){ sqlite3_snprintf(sizeof(zErr), zErr, "attached databases must use the same text encoding as main database"); goto attach_error; } pPager = sqlite3BtreePager(aNew->pBt); sqlite3PagerLockingMode(pPager, db->dfltLockMode); sqlite3PagerJournalMode(pPager, db->dfltJournalMode); } aNew->zName = sqlite3DbStrDup(db, zName); aNew->safety_level = 3; 
#if SQLITE_HAS_CODEC 
 { extern int sqlite3CodecAttach(sqlite3*, int, const void*, int); extern void sqlite3CodecGetKey(sqlite3*, int, void**, int*); int nKey; char *zKey; int t = sqlite3_value_type(argv[2]); switch( t ){ case SQLITE_INTEGER: case SQLITE_FLOAT: zErrDyn = sqlite3DbStrDup(db, "Invalid key value"); rc = SQLITE_ERROR; break; case SQLITE_TEXT: case SQLITE_BLOB: nKey = sqlite3_value_bytes(argv[2]); zKey = (char *)sqlite3_value_blob(argv[2]); sqlite3CodecAttach(db, db->nDb-1, zKey, nKey); break; case SQLITE_NULL: sqlite3CodecGetKey(db, 0, (void**)&zKey, &nKey); sqlite3CodecAttach(db, db->nDb-1, zKey, nKey); break; } } 
#endif 
 if( rc==SQLITE_OK ){ (void)sqlite3SafetyOn(db); sqlite3BtreeEnterAll(db); rc = sqlite3Init(db, &zErrDyn); sqlite3BtreeLeaveAll(db); (void)sqlite3SafetyOff(db); } if( rc ){ int iDb = db->nDb - 1; assert( iDb>=2 ); if( db->aDb[iDb].pBt ){ sqlite3BtreeClose(db->aDb[iDb].pBt); db->aDb[iDb].pBt = 0; db->aDb[iDb].pSchema = 0; } sqlite3ResetInternalSchema(db, 0); db->nDb = iDb; if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ){ db->mallocFailed = 1; sqlite3_snprintf(sizeof(zErr),zErr, "out of memory"); }else{ sqlite3_snprintf(sizeof(zErr),zErr, "unable to open database: %s", zFile); } goto attach_error; } return; attach_error: if( zErrDyn ){ sqlite3_result_error(context, zErrDyn, -1); sqlite3DbFree(db, zErrDyn); }else{ zErr[sizeof(zErr)-1] = 0; sqlite3_result_error(context, zErr, -1); } if( rc ) sqlite3_result_error_code(context, rc); } static void detachFunc( sqlite3_context *context, int NotUsed, sqlite3_value **argv ){ const char *zName = (const char *)sqlite3_value_text(argv[0]); sqlite3 *db = sqlite3_context_db_handle(context); int i; Db *pDb = 0; char zErr[128]; UNUSED_PARAMETER(NotUsed); if( zName==0 ) zName = ""; for(i=0; i<db->nDb; i++){ pDb = &db->aDb[i]; if( pDb->pBt==0 ) continue; if( sqlite3StrICmp(pDb->zName, zName)==0 ) break; } if( i>=db->nDb ){ sqlite3_snprintf(sizeof(zErr),zErr, "no such database: %s", zName); goto detach_error; } if( i<2 ){ sqlite3_snprintf(sizeof(zErr),zErr, "cannot detach database %s", zName); goto detach_error; } if( !db->autoCommit ){ sqlite3_snprintf(sizeof(zErr), zErr, "cannot DETACH database within transaction"); goto detach_error; } if( sqlite3BtreeIsInReadTrans(pDb->pBt) ){ sqlite3_snprintf(sizeof(zErr),zErr, "database %s is locked", zName); goto detach_error; } sqlite3BtreeClose(pDb->pBt); pDb->pBt = 0; pDb->pSchema = 0; sqlite3ResetInternalSchema(db, 0); return; detach_error: sqlite3_result_error(context, zErr, -1); } static void codeAttach( Parse *pParse, int type, FuncDef *pFunc, Expr *pAuthArg, Expr *pFilename, Expr *pDbname, Expr *pKey ){ int rc; NameContext sName; Vdbe *v; sqlite3* db = pParse->db; int regArgs; 
#ifndef SQLITE_OMIT_AUTHORIZATION 
 assert( db->mallocFailed || pAuthArg ); if( pAuthArg ){ char *zAuthArg = sqlite3NameFromToken(db, &pAuthArg->span); if( !zAuthArg ){ goto attach_end; } rc = sqlite3AuthCheck(pParse, type, zAuthArg, 0, 0); sqlite3DbFree(db, zAuthArg); if(rc!=SQLITE_OK ){ goto attach_end; } } 
#endif 
 memset(&sName, 0, sizeof(NameContext)); sName.pParse = pParse; if( SQLITE_OK!=(rc = resolveAttachExpr(&sName, pFilename)) || SQLITE_OK!=(rc = resolveAttachExpr(&sName, pDbname)) || SQLITE_OK!=(rc = resolveAttachExpr(&sName, pKey)) ){ pParse->nErr++; goto attach_end; } v = sqlite3GetVdbe(pParse); regArgs = sqlite3GetTempRange(pParse, 4); sqlite3ExprCode(pParse, pFilename, regArgs); sqlite3ExprCode(pParse, pDbname, regArgs+1); sqlite3ExprCode(pParse, pKey, regArgs+2); assert( v || db->mallocFailed ); if( v ){ sqlite3VdbeAddOp3(v, OP_Function, 0, regArgs+3-pFunc->nArg, regArgs+3); sqlite3VdbeChangeP5(v, pFunc->nArg); sqlite3VdbeChangeP4(v, -1, (char *)pFunc, P4_FUNCDEF); sqlite3VdbeAddOp1(v, OP_Expire, (type==SQLITE_ATTACH)); } attach_end: sqlite3ExprDelete(db, pFilename); sqlite3ExprDelete(db, pDbname); sqlite3ExprDelete(db, pKey); } SQLITE_PRIVATE void sqlite3Detach(Parse *pParse, Expr *pDbname){ static FuncDef detach_func = { 1, SQLITE_UTF8, 0, 0, 0, detachFunc, 0, 0, "sqlite_detach", 0 }; codeAttach(pParse, SQLITE_DETACH, &detach_func, pDbname, 0, 0, pDbname); } SQLITE_PRIVATE void sqlite3Attach(Parse *pParse, Expr *p, Expr *pDbname, Expr *pKey){ static FuncDef attach_func = { 3, SQLITE_UTF8, 0, 0, 0, attachFunc, 0, 0, "sqlite_attach", 0 }; codeAttach(pParse, SQLITE_ATTACH, &attach_func, p, p, pDbname, pKey); } 
#endif 
SQLITE_PRIVATE int sqlite3FixInit( DbFixer *pFix, Parse *pParse, int iDb, const char *zType, const Token *pName ){ sqlite3 *db; if( iDb<0 || iDb==1 ) return 0; db = pParse->db; assert( db->nDb>iDb ); pFix->pParse = pParse; pFix->zDb = db->aDb[iDb].zName; pFix->zType = zType; pFix->pName = pName; return 1; } SQLITE_PRIVATE int sqlite3FixSrcList( DbFixer *pFix, SrcList *pList ){ int i; const char *zDb; struct SrcList_item *pItem; if( pList==0 ) return 0; zDb = pFix->zDb; for(i=0, pItem=pList->a; i<pList->nSrc; i++, pItem++){ if( pItem->zDatabase==0 ){ pItem->zDatabase = sqlite3DbStrDup(pFix->pParse->db, zDb); }else if( sqlite3StrICmp(pItem->zDatabase,zDb)!=0 ){ sqlite3ErrorMsg(pFix->pParse, "%s %T cannot reference objects in database %s", pFix->zType, pFix->pName, pItem->zDatabase); return 1; } 
#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_TRIGGER) 
 if( sqlite3FixSelect(pFix, pItem->pSelect) ) return 1; if( sqlite3FixExpr(pFix, pItem->pOn) ) return 1; 
#endif 
 } return 0; } 
#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_TRIGGER) 
SQLITE_PRIVATE int sqlite3FixSelect( DbFixer *pFix, Select *pSelect ){ while( pSelect ){ if( sqlite3FixExprList(pFix, pSelect->pEList) ){ return 1; } if( sqlite3FixSrcList(pFix, pSelect->pSrc) ){ return 1; } if( sqlite3FixExpr(pFix, pSelect->pWhere) ){ return 1; } if( sqlite3FixExpr(pFix, pSelect->pHaving) ){ return 1; } pSelect = pSelect->pPrior; } return 0; } SQLITE_PRIVATE int sqlite3FixExpr( DbFixer *pFix, Expr *pExpr ){ while( pExpr ){ if( sqlite3FixSelect(pFix, pExpr->pSelect) ){ return 1; } if( sqlite3FixExprList(pFix, pExpr->pList) ){ return 1; } if( sqlite3FixExpr(pFix, pExpr->pRight) ){ return 1; } pExpr = pExpr->pLeft; } return 0; } SQLITE_PRIVATE int sqlite3FixExprList( DbFixer *pFix, ExprList *pList ){ int i; struct ExprList_item *pItem; if( pList==0 ) return 0; for(i=0, pItem=pList->a; i<pList->nExpr; i++, pItem++){ if( sqlite3FixExpr(pFix, pItem->pExpr) ){ return 1; } } return 0; } 
#endif 
#ifndef SQLITE_OMIT_TRIGGER 
SQLITE_PRIVATE int sqlite3FixTriggerStep( DbFixer *pFix, TriggerStep *pStep ){ while( pStep ){ if( sqlite3FixSelect(pFix, pStep->pSelect) ){ return 1; } if( sqlite3FixExpr(pFix, pStep->pWhere) ){ return 1; } if( sqlite3FixExprList(pFix, pStep->pExprList) ){ return 1; } pStep = pStep->pNext; } return 0; } 
#endif 
#ifndef SQLITE_OMIT_AUTHORIZATION 
SQLITE_API int sqlite3_set_authorizer( sqlite3 *db, int (*xAuth)(void*,int,const char*,const char*,const char*,const char*), void *pArg ){ sqlite3_mutex_enter(db->mutex); db->xAuth = xAuth; db->pAuthArg = pArg; sqlite3ExpirePreparedStatements(db); sqlite3_mutex_leave(db->mutex); return SQLITE_OK; } static void sqliteAuthBadReturnCode(Parse *pParse, int rc){ sqlite3ErrorMsg(pParse, "illegal return value (%d) from the " "authorization function - should be SQLITE_OK, SQLITE_IGNORE, " "or SQLITE_DENY", rc); pParse->rc = SQLITE_ERROR; } SQLITE_PRIVATE void sqlite3AuthRead( Parse *pParse, Expr *pExpr, Schema *pSchema, SrcList *pTabList ){ sqlite3 *db = pParse->db; int rc; Table *pTab = 0; const char *zCol; int iSrc; const char *zDBase; TriggerStack *pStack; int iDb; if( db->xAuth==0 ) return; if( pExpr->op!=TK_COLUMN ) return; iDb = sqlite3SchemaToIndex(pParse->db, pSchema); if( iDb<0 ){ return; } for(iSrc=0; pTabList && iSrc<pTabList->nSrc; iSrc++){ if( pExpr->iTable==pTabList->a[iSrc].iCursor ) break; } if( iSrc>=0 && pTabList && iSrc<pTabList->nSrc ){ pTab = pTabList->a[iSrc].pTab; }else if( (pStack = pParse->trigStack)!=0 ){ assert( pExpr->iTable==pStack->newIdx || pExpr->iTable==pStack->oldIdx ); pTab = pStack->pTab; } if( pTab==0 ) return; if( pExpr->iColumn>=0 ){ assert( pExpr->iColumn<pTab->nCol ); zCol = pTab->aCol[pExpr->iColumn].zName; }else if( pTab->iPKey>=0 ){ assert( pTab->iPKey<pTab->nCol ); zCol = pTab->aCol[pTab->iPKey].zName; }else{ zCol = "ROWID"; } assert( iDb>=0 && iDb<db->nDb ); zDBase = db->aDb[iDb].zName; rc = db->xAuth(db->pAuthArg, SQLITE_READ, pTab->zName, zCol, zDBase, pParse->zAuthContext); if( rc==SQLITE_IGNORE ){ pExpr->op = TK_NULL; }else if( rc==SQLITE_DENY ){ if( db->nDb>2 || iDb!=0 ){ sqlite3ErrorMsg(pParse, "access to %s.%s.%s is prohibited", zDBase, pTab->zName, zCol); }else{ sqlite3ErrorMsg(pParse, "access to %s.%s is prohibited",pTab->zName,zCol); } pParse->rc = SQLITE_AUTH; }else if( rc!=SQLITE_OK ){ sqliteAuthBadReturnCode(pParse, rc); } } SQLITE_PRIVATE int sqlite3AuthCheck( Parse *pParse, int code, const char *zArg1, const char *zArg2, const char *zArg3 ){ sqlite3 *db = pParse->db; int rc; if( db->init.busy || IN_DECLARE_VTAB ){ return SQLITE_OK; } if( db->xAuth==0 ){ return SQLITE_OK; } rc = db->xAuth(db->pAuthArg, code, zArg1, zArg2, zArg3, pParse->zAuthContext); if( rc==SQLITE_DENY ){ sqlite3ErrorMsg(pParse, "not authorized"); pParse->rc = SQLITE_AUTH; }else if( rc!=SQLITE_OK && rc!=SQLITE_IGNORE ){ rc = SQLITE_DENY; sqliteAuthBadReturnCode(pParse, rc); } return rc; } SQLITE_PRIVATE void sqlite3AuthContextPush( Parse *pParse, AuthContext *pContext, const char *zContext ){ pContext->pParse = pParse; if( pParse ){ pContext->zAuthContext = pParse->zAuthContext; pParse->zAuthContext = zContext; } } SQLITE_PRIVATE void sqlite3AuthContextPop(AuthContext *pContext){ if( pContext->pParse ){ pContext->pParse->zAuthContext = pContext->zAuthContext; pContext->pParse = 0; } } 
#endif 
SQLITE_PRIVATE void sqlite3BeginParse(Parse *pParse, int explainFlag){ pParse->explain = explainFlag; pParse->nVar = 0; } 
#ifndef SQLITE_OMIT_SHARED_CACHE 
struct TableLock { int iDb; int iTab; u8 isWriteLock; const char *zName; }; SQLITE_PRIVATE void sqlite3TableLock( Parse *pParse, int iDb, int iTab, u8 isWriteLock, const char *zName ){ int i; int nBytes; TableLock *p; if( iDb<0 ){ return; } for(i=0; i<pParse->nTableLock; i++){ p = &pParse->aTableLock[i]; if( p->iDb==iDb && p->iTab==iTab ){ p->isWriteLock = (p->isWriteLock || isWriteLock); return; } } nBytes = sizeof(TableLock) * (pParse->nTableLock+1); pParse->aTableLock = sqlite3DbReallocOrFree(pParse->db, pParse->aTableLock, nBytes); if( pParse->aTableLock ){ p = &pParse->aTableLock[pParse->nTableLock++]; p->iDb = iDb; p->iTab = iTab; p->isWriteLock = isWriteLock; p->zName = zName; }else{ pParse->nTableLock = 0; pParse->db->mallocFailed = 1; } } static void codeTableLocks(Parse *pParse){ int i; Vdbe *pVdbe; if( 0==(pVdbe = sqlite3GetVdbe(pParse)) ){ return; } for(i=0; i<pParse->nTableLock; i++){ TableLock *p = &pParse->aTableLock[i]; int p1 = p->iDb; sqlite3VdbeAddOp4(pVdbe, OP_TableLock, p1, p->iTab, p->isWriteLock, p->zName, P4_STATIC); } } 
#else 
#define codeTableLocks(x) 
#endif 
SQLITE_PRIVATE void sqlite3FinishCoding(Parse *pParse){ sqlite3 *db; Vdbe *v; db = pParse->db; if( db->mallocFailed ) return; if( pParse->nested ) return; if( pParse->nErr ) return; v = sqlite3GetVdbe(pParse); if( v ){ sqlite3VdbeAddOp0(v, OP_Halt); if( pParse->cookieGoto>0 ){ u32 mask; int iDb; sqlite3VdbeJumpHere(v, pParse->cookieGoto-1); for(iDb=0, mask=1; iDb<db->nDb; mask<<=1, iDb++){ if( (mask & pParse->cookieMask)==0 ) continue; sqlite3VdbeUsesBtree(v, iDb); sqlite3VdbeAddOp2(v,OP_Transaction, iDb, (mask & pParse->writeMask)!=0); sqlite3VdbeAddOp2(v,OP_VerifyCookie, iDb, pParse->cookieValue[iDb]); } 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 { int i; for(i=0; i<pParse->nVtabLock; i++){ char *vtab = (char *)pParse->apVtabLock[i]->pVtab; sqlite3VdbeAddOp4(v, OP_VBegin, 0, 0, 0, vtab, P4_VTAB); } pParse->nVtabLock = 0; } 
#endif 
 codeTableLocks(pParse); sqlite3VdbeAddOp2(v, OP_Goto, 0, pParse->cookieGoto); } 
#ifndef SQLITE_OMIT_TRACE 
 if( !db->init.busy ){ VdbeOp *pOp = sqlite3VdbeGetOp(v, 0); if( pOp && pOp->opcode==OP_Trace ){ sqlite3VdbeChangeP4(v, 0, pParse->zSql, pParse->zTail-pParse->zSql); } } 
#endif 
 } if( v && pParse->nErr==0 && !db->mallocFailed ){ 
#ifdef SQLITE_DEBUG 
 FILE *trace = (db->flags & SQLITE_VdbeTrace)!=0 ? stdout : 0; sqlite3VdbeTrace(v, trace); 
#endif 
 assert( pParse->disableColCache==0 ); sqlite3VdbeMakeReady(v, pParse->nVar, pParse->nMem+3, pParse->nTab+3, pParse->explain); pParse->rc = SQLITE_DONE; pParse->colNamesSet = 0; }else if( pParse->rc==SQLITE_OK ){ pParse->rc = SQLITE_ERROR; } pParse->nTab = 0; pParse->nMem = 0; pParse->nSet = 0; pParse->nVar = 0; pParse->cookieMask = 0; pParse->cookieGoto = 0; } SQLITE_PRIVATE void sqlite3NestedParse(Parse *pParse, const char *zFormat, ...){ va_list ap; char *zSql; char *zErrMsg = 0; sqlite3 *db = pParse->db; 
#define SAVE_SZ (sizeof(Parse) - offsetof(Parse,nVar)) 
 char saveBuf[SAVE_SZ]; if( pParse->nErr ) return; assert( pParse->nested<10 ); va_start(ap, zFormat); zSql = sqlite3VMPrintf(db, zFormat, ap); va_end(ap); if( zSql==0 ){ return; } pParse->nested++; memcpy(saveBuf, &pParse->nVar, SAVE_SZ); memset(&pParse->nVar, 0, SAVE_SZ); sqlite3RunParser(pParse, zSql, &zErrMsg); sqlite3DbFree(db, zErrMsg); sqlite3DbFree(db, zSql); memcpy(&pParse->nVar, saveBuf, SAVE_SZ); pParse->nested--; } SQLITE_PRIVATE Table *sqlite3FindTable(sqlite3 *db, const char *zName, const char *zDatabase){ Table *p = 0; int i; int nName; assert( zName!=0 ); nName = sqlite3Strlen(db, zName) + 1; for(i=OMIT_TEMPDB; i<db->nDb; i++){ int j = (i<2) ? i^1 : i; if( zDatabase!=0 && sqlite3StrICmp(zDatabase, db->aDb[j].zName) ) continue; p = sqlite3HashFind(&db->aDb[j].pSchema->tblHash, zName, nName); if( p ) break; } return p; } SQLITE_PRIVATE Table *sqlite3LocateTable( Parse *pParse, int isView, const char *zName, const char *zDbase ){ Table *p; if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){ return 0; } p = sqlite3FindTable(pParse->db, zName, zDbase); if( p==0 ){ const char *zMsg = isView ? "no such view" : "no such table"; if( zDbase ){ sqlite3ErrorMsg(pParse, "%s: %s.%s", zMsg, zDbase, zName); }else{ sqlite3ErrorMsg(pParse, "%s: %s", zMsg, zName); } pParse->checkSchema = 1; } return p; } SQLITE_PRIVATE Index *sqlite3FindIndex(sqlite3 *db, const char *zName, const char *zDb){ Index *p = 0; int i; int nName = sqlite3Strlen(db, zName)+1; for(i=OMIT_TEMPDB; i<db->nDb; i++){ int j = (i<2) ? i^1 : i; Schema *pSchema = db->aDb[j].pSchema; if( zDb && sqlite3StrICmp(zDb, db->aDb[j].zName) ) continue; assert( pSchema || (j==1 && !db->aDb[1].pBt) ); if( pSchema ){ p = sqlite3HashFind(&pSchema->idxHash, zName, nName); } if( p ) break; } return p; } static void freeIndex(Index *p){ sqlite3 *db = p->pTable->db; sqlite3DbFree(db, p->zColAff); sqlite3DbFree(db, p); } static void sqliteDeleteIndex(Index *p){ Index *pOld; const char *zName = p->zName; pOld = sqlite3HashInsert(&p->pSchema->idxHash, zName, strlen(zName)+1, 0); assert( pOld==0 || pOld==p ); freeIndex(p); } SQLITE_PRIVATE void sqlite3UnlinkAndDeleteIndex(sqlite3 *db, int iDb, const char *zIdxName){ Index *pIndex; int len; Hash *pHash = &db->aDb[iDb].pSchema->idxHash; len = sqlite3Strlen(db, zIdxName); pIndex = sqlite3HashInsert(pHash, zIdxName, len+1, 0); if( pIndex ){ if( pIndex->pTable->pIndex==pIndex ){ pIndex->pTable->pIndex = pIndex->pNext; }else{ Index *p; for(p=pIndex->pTable->pIndex; p && p->pNext!=pIndex; p=p->pNext){} if( p && p->pNext==pIndex ){ p->pNext = pIndex->pNext; } } freeIndex(pIndex); } db->flags |= SQLITE_InternChanges; } SQLITE_PRIVATE void sqlite3ResetInternalSchema(sqlite3 *db, int iDb){ int i, j; assert( iDb>=0 && iDb<db->nDb ); if( iDb==0 ){ sqlite3BtreeEnterAll(db); } for(i=iDb; i<db->nDb; i++){ Db *pDb = &db->aDb[i]; if( pDb->pSchema ){ assert(i==1 || (pDb->pBt && sqlite3BtreeHoldsMutex(pDb->pBt))); sqlite3SchemaFree(pDb->pSchema); } if( iDb>0 ) return; } assert( iDb==0 ); db->flags &= ~SQLITE_InternChanges; sqlite3BtreeLeaveAll(db); for(i=0; i<db->nDb; i++){ struct Db *pDb = &db->aDb[i]; if( pDb->pBt==0 ){ if( pDb->pAux && pDb->xFreeAux ) pDb->xFreeAux(pDb->pAux); pDb->pAux = 0; } } for(i=j=2; i<db->nDb; i++){ struct Db *pDb = &db->aDb[i]; if( pDb->pBt==0 ){ sqlite3DbFree(db, pDb->zName); pDb->zName = 0; continue; } if( j<i ){ db->aDb[j] = db->aDb[i]; } j++; } memset(&db->aDb[j], 0, (db->nDb-j)*sizeof(db->aDb[j])); db->nDb = j; if( db->nDb<=2 && db->aDb!=db->aDbStatic ){ memcpy(db->aDbStatic, db->aDb, 2*sizeof(db->aDb[0])); sqlite3DbFree(db, db->aDb); db->aDb = db->aDbStatic; } } SQLITE_PRIVATE void sqlite3CommitInternalChanges(sqlite3 *db){ db->flags &= ~SQLITE_InternChanges; } static void sqliteResetColumnNames(Table *pTable){ int i; Column *pCol; sqlite3 *db = pTable->db; assert( pTable!=0 ); if( (pCol = pTable->aCol)!=0 ){ for(i=0; i<pTable->nCol; i++, pCol++){ sqlite3DbFree(db, pCol->zName); sqlite3ExprDelete(db, pCol->pDflt); sqlite3DbFree(db, pCol->zType); sqlite3DbFree(db, pCol->zColl); } sqlite3DbFree(db, pTable->aCol); } pTable->aCol = 0; pTable->nCol = 0; } SQLITE_PRIVATE void sqlite3DeleteTable(Table *pTable){ Index *pIndex, *pNext; FKey *pFKey, *pNextFKey; sqlite3 *db; if( pTable==0 ) return; db = pTable->db; pTable->nRef--; if( pTable->nRef>0 ){ return; } assert( pTable->nRef==0 ); for(pIndex = pTable->pIndex; pIndex; pIndex=pNext){ pNext = pIndex->pNext; assert( pIndex->pSchema==pTable->pSchema ); sqliteDeleteIndex(pIndex); } 
#ifndef SQLITE_OMIT_FOREIGN_KEY 
 for(pFKey=pTable->pFKey; pFKey; pFKey=pNextFKey){ pNextFKey = pFKey->pNextFrom; assert( sqlite3HashFind(&pTable->pSchema->aFKey, pFKey->zTo, strlen(pFKey->zTo)+1)!=pFKey ); sqlite3DbFree(db, pFKey); } 
#endif 
 sqliteResetColumnNames(pTable); sqlite3DbFree(db, pTable->zName); sqlite3DbFree(db, pTable->zColAff); sqlite3SelectDelete(db, pTable->pSelect); 
#ifndef SQLITE_OMIT_CHECK 
 sqlite3ExprDelete(db, pTable->pCheck); 
#endif 
 sqlite3VtabClear(pTable); sqlite3DbFree(db, pTable); } SQLITE_PRIVATE void sqlite3UnlinkAndDeleteTable(sqlite3 *db, int iDb, const char *zTabName){ Table *p; FKey *pF1, *pF2; Db *pDb; assert( db!=0 ); assert( iDb>=0 && iDb<db->nDb ); assert( zTabName && zTabName[0] ); pDb = &db->aDb[iDb]; p = sqlite3HashInsert(&pDb->pSchema->tblHash, zTabName, strlen(zTabName)+1,0); if( p ){ 
#ifndef SQLITE_OMIT_FOREIGN_KEY 
 for(pF1=p->pFKey; pF1; pF1=pF1->pNextFrom){ int nTo = strlen(pF1->zTo) + 1; pF2 = sqlite3HashFind(&pDb->pSchema->aFKey, pF1->zTo, nTo); if( pF2==pF1 ){ sqlite3HashInsert(&pDb->pSchema->aFKey, pF1->zTo, nTo, pF1->pNextTo); }else{ while( pF2 && pF2->pNextTo!=pF1 ){ pF2=pF2->pNextTo; } if( pF2 ){ pF2->pNextTo = pF1->pNextTo; } } } 
#endif 
 sqlite3DeleteTable(p); } db->flags |= SQLITE_InternChanges; } SQLITE_PRIVATE char *sqlite3NameFromToken(sqlite3 *db, Token *pName){ char *zName; if( pName ){ zName = sqlite3DbStrNDup(db, (char*)pName->z, pName->n); sqlite3Dequote(zName); }else{ zName = 0; } return zName; } SQLITE_PRIVATE void sqlite3OpenMasterTable(Parse *p, int iDb){ Vdbe *v = sqlite3GetVdbe(p); sqlite3TableLock(p, iDb, MASTER_ROOT, 1, SCHEMA_TABLE(iDb)); sqlite3VdbeAddOp2(v, OP_SetNumColumns, 0, 5); sqlite3VdbeAddOp3(v, OP_OpenWrite, 0, MASTER_ROOT, iDb); } SQLITE_PRIVATE int sqlite3FindDb(sqlite3 *db, Token *pName){ int i = -1; size_t n; Db *pDb; char *zName; zName = sqlite3NameFromToken(db, pName); if( zName ){ n = strlen(zName); for(i=(db->nDb-1), pDb=&db->aDb[i]; i>=0; i--, pDb--){ if( (!OMIT_TEMPDB || i!=1 ) && n==strlen(pDb->zName) && 0==sqlite3StrICmp(pDb->zName, zName) ){ break; } } sqlite3DbFree(db, zName); } return i; } SQLITE_PRIVATE int sqlite3TwoPartName( Parse *pParse, Token *pName1, Token *pName2, Token **pUnqual ){ int iDb; sqlite3 *db = pParse->db; if( pName2 && pName2->n>0 ){ if( db->init.busy ) { sqlite3ErrorMsg(pParse, "corrupt database"); pParse->nErr++; return -1; } *pUnqual = pName2; iDb = sqlite3FindDb(db, pName1); if( iDb<0 ){ sqlite3ErrorMsg(pParse, "unknown database %T", pName1); pParse->nErr++; return -1; } }else{ assert( db->init.iDb==0 || db->init.busy ); iDb = db->init.iDb; *pUnqual = pName1; } return iDb; } SQLITE_PRIVATE int sqlite3CheckObjectName(Parse *pParse, const char *zName){ if( !pParse->db->init.busy && pParse->nested==0 && (pParse->db->flags & SQLITE_WriteSchema)==0 && 0==sqlite3StrNICmp(zName, "sqlite_", 7) ){ sqlite3ErrorMsg(pParse, "object name reserved for internal use: %s", zName); return SQLITE_ERROR; } return SQLITE_OK; } SQLITE_PRIVATE void sqlite3StartTable( Parse *pParse, Token *pName1, Token *pName2, int isTemp, int isView, int isVirtual, int noErr ){ Table *pTable; char *zName = 0; sqlite3 *db = pParse->db; Vdbe *v; int iDb; Token *pName; iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName); if( iDb<0 ) return; if( !OMIT_TEMPDB && isTemp && iDb>1 ){ sqlite3ErrorMsg(pParse, "temporary table name must be unqualified"); return; } if( !OMIT_TEMPDB && isTemp ) iDb = 1; pParse->sNameToken = *pName; zName = sqlite3NameFromToken(db, pName); if( zName==0 ) return; if( SQLITE_OK!=sqlite3CheckObjectName(pParse, zName) ){ goto begin_table_error; } if( db->init.iDb==1 ) isTemp = 1; 
#ifndef SQLITE_OMIT_AUTHORIZATION 
 assert( (isTemp & 1)==isTemp ); { int code; char *zDb = db->aDb[iDb].zName; if( sqlite3AuthCheck(pParse, SQLITE_INSERT, SCHEMA_TABLE(isTemp), 0, zDb) ){ goto begin_table_error; } if( isView ){ if( !OMIT_TEMPDB && isTemp ){ code = SQLITE_CREATE_TEMP_VIEW; }else{ code = SQLITE_CREATE_VIEW; } }else{ if( !OMIT_TEMPDB && isTemp ){ code = SQLITE_CREATE_TEMP_TABLE; }else{ code = SQLITE_CREATE_TABLE; } } if( !isVirtual && sqlite3AuthCheck(pParse, code, zName, 0, zDb) ){ goto begin_table_error; } } 
#endif 
 if( !IN_DECLARE_VTAB ){ if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){ goto begin_table_error; } pTable = sqlite3FindTable(db, zName, db->aDb[iDb].zName); if( pTable ){ if( !noErr ){ sqlite3ErrorMsg(pParse, "table %T already exists", pName); } goto begin_table_error; } if( sqlite3FindIndex(db, zName, 0)!=0 && (iDb==0 || !db->init.busy) ){ sqlite3ErrorMsg(pParse, "there is already an index named %s", zName); goto begin_table_error; } } pTable = sqlite3DbMallocZero(db, sizeof(Table)); if( pTable==0 ){ db->mallocFailed = 1; pParse->rc = SQLITE_NOMEM; pParse->nErr++; goto begin_table_error; } pTable->zName = zName; pTable->iPKey = -1; pTable->pSchema = db->aDb[iDb].pSchema; pTable->nRef = 1; pTable->db = db; if( pParse->pNewTable ) sqlite3DeleteTable(pParse->pNewTable); pParse->pNewTable = pTable; 
#ifndef SQLITE_OMIT_AUTOINCREMENT 
 if( !pParse->nested && strcmp(zName, "sqlite_sequence")==0 ){ pTable->pSchema->pSeqTab = pTable; } 
#endif 
 if( !db->init.busy && (v = sqlite3GetVdbe(pParse))!=0 ){ int j1; int fileFormat; int reg1, reg2, reg3; sqlite3BeginWriteOperation(pParse, 0, iDb); 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 if( isVirtual ){ sqlite3VdbeAddOp0(v, OP_VBegin); } 
#endif 
 reg1 = pParse->regRowid = ++pParse->nMem; reg2 = pParse->regRoot = ++pParse->nMem; reg3 = ++pParse->nMem; sqlite3VdbeAddOp3(v, OP_ReadCookie, iDb, reg3, 1); sqlite3VdbeUsesBtree(v, iDb); j1 = sqlite3VdbeAddOp1(v, OP_If, reg3); fileFormat = (db->flags & SQLITE_LegacyFileFmt)!=0 ? 1 : SQLITE_MAX_FILE_FORMAT; sqlite3VdbeAddOp2(v, OP_Integer, fileFormat, reg3); sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, 1, reg3); sqlite3VdbeAddOp2(v, OP_Integer, ENC(db), reg3); sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, 4, reg3); sqlite3VdbeJumpHere(v, j1); 
#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE) 
 if( isView || isVirtual ){ sqlite3VdbeAddOp2(v, OP_Integer, 0, reg2); }else 
#endif 
 { sqlite3VdbeAddOp2(v, OP_CreateTable, iDb, reg2); } sqlite3OpenMasterTable(pParse, iDb); sqlite3VdbeAddOp2(v, OP_NewRowid, 0, reg1); sqlite3VdbeAddOp2(v, OP_Null, 0, reg3); sqlite3VdbeAddOp3(v, OP_Insert, 0, reg3, reg1); sqlite3VdbeChangeP5(v, OPFLAG_APPEND); sqlite3VdbeAddOp0(v, OP_Close); } return; begin_table_error: sqlite3DbFree(db, zName); return; } 
#define STRICMP(x, y) ( sqlite3UpperToLower[*(unsigned char *)(x)]== sqlite3UpperToLower[*(unsigned char *)(y)] && sqlite3StrICmp((x)+1,(y)+1)==0 ) 
SQLITE_PRIVATE void sqlite3AddColumn(Parse *pParse, Token *pName){ Table *p; int i; char *z; Column *pCol; sqlite3 *db = pParse->db; if( (p = pParse->pNewTable)==0 ) return; 
#if SQLITE_MAX_COLUMN 
 if( p->nCol+1>db->aLimit[SQLITE_LIMIT_COLUMN] ){ sqlite3ErrorMsg(pParse, "too many columns on %s", p->zName); return; } 
#endif 
 z = sqlite3NameFromToken(pParse->db, pName); if( z==0 ) return; for(i=0; i<p->nCol; i++){ if( STRICMP(z, p->aCol[i].zName) ){ sqlite3ErrorMsg(pParse, "duplicate column name: %s", z); sqlite3DbFree(db, z); return; } } if( (p->nCol & 0x7)==0 ){ Column *aNew; aNew = sqlite3DbRealloc(pParse->db,p->aCol,(p->nCol+8)*sizeof(p->aCol[0])); if( aNew==0 ){ sqlite3DbFree(db, z); return; } p->aCol = aNew; } pCol = &p->aCol[p->nCol]; memset(pCol, 0, sizeof(p->aCol[0])); pCol->zName = z; pCol->affinity = SQLITE_AFF_NONE; p->nCol++; } SQLITE_PRIVATE void sqlite3AddNotNull(Parse *pParse, int onError){ Table *p; int i; if( (p = pParse->pNewTable)==0 ) return; i = p->nCol-1; if( i>=0 ) p->aCol[i].notNull = onError; } SQLITE_PRIVATE char sqlite3AffinityType(const Token *pType){ u32 h = 0; char aff = SQLITE_AFF_NUMERIC; const unsigned char *zIn = pType->z; const unsigned char *zEnd = &pType->z[pType->n]; while( zIn!=zEnd ){ h = (h<<8) + sqlite3UpperToLower[*zIn]; zIn++; if( h==(('c'<<24)+('h'<<16)+('a'<<8)+'r') ){ aff = SQLITE_AFF_TEXT; }else if( h==(('c'<<24)+('l'<<16)+('o'<<8)+'b') ){ aff = SQLITE_AFF_TEXT; }else if( h==(('t'<<24)+('e'<<16)+('x'<<8)+'t') ){ aff = SQLITE_AFF_TEXT; }else if( h==(('b'<<24)+('l'<<16)+('o'<<8)+'b') && (aff==SQLITE_AFF_NUMERIC || aff==SQLITE_AFF_REAL) ){ aff = SQLITE_AFF_NONE; 
#ifndef SQLITE_OMIT_FLOATING_POINT 
 }else if( h==(('r'<<24)+('e'<<16)+('a'<<8)+'l') && aff==SQLITE_AFF_NUMERIC ){ aff = SQLITE_AFF_REAL; }else if( h==(('f'<<24)+('l'<<16)+('o'<<8)+'a') && aff==SQLITE_AFF_NUMERIC ){ aff = SQLITE_AFF_REAL; }else if( h==(('d'<<24)+('o'<<16)+('u'<<8)+'b') && aff==SQLITE_AFF_NUMERIC ){ aff = SQLITE_AFF_REAL; 
#endif 
 }else if( (h&0x00FFFFFF)==(('i'<<16)+('n'<<8)+'t') ){ aff = SQLITE_AFF_INTEGER; break; } } return aff; } SQLITE_PRIVATE void sqlite3AddColumnType(Parse *pParse, Token *pType){ Table *p; int i; Column *pCol; sqlite3 *db; if( (p = pParse->pNewTable)==0 ) return; i = p->nCol-1; if( i<0 ) return; pCol = &p->aCol[i]; db = pParse->db; sqlite3DbFree(db, pCol->zType); pCol->zType = sqlite3NameFromToken(db, pType); pCol->affinity = sqlite3AffinityType(pType); } SQLITE_PRIVATE void sqlite3AddDefaultValue(Parse *pParse, Expr *pExpr){ Table *p; Column *pCol; sqlite3 *db = pParse->db; if( (p = pParse->pNewTable)!=0 ){ pCol = &(p->aCol[p->nCol-1]); if( !sqlite3ExprIsConstantOrFunction(pExpr) ){ sqlite3ErrorMsg(pParse, "default value of column [%s] is not constant", pCol->zName); }else{ Expr *pCopy; sqlite3ExprDelete(db, pCol->pDflt); pCol->pDflt = pCopy = sqlite3ExprDup(db, pExpr); if( pCopy ){ sqlite3TokenCopy(db, &pCopy->span, &pExpr->span); } } } sqlite3ExprDelete(db, pExpr); } SQLITE_PRIVATE void sqlite3AddPrimaryKey( Parse *pParse, ExprList *pList, int onError, int autoInc, int sortOrder ){ Table *pTab = pParse->pNewTable; char *zType = 0; int iCol = -1, i; if( pTab==0 || IN_DECLARE_VTAB ) goto primary_key_exit; if( pTab->tabFlags & TF_HasPrimaryKey ){ sqlite3ErrorMsg(pParse, "table \"%s\" has more than one primary key", pTab->zName); goto primary_key_exit; } pTab->tabFlags |= TF_HasPrimaryKey; if( pList==0 ){ iCol = pTab->nCol - 1; pTab->aCol[iCol].isPrimKey = 1; }else{ for(i=0; i<pList->nExpr; i++){ for(iCol=0; iCol<pTab->nCol; iCol++){ if( sqlite3StrICmp(pList->a[i].zName, pTab->aCol[iCol].zName)==0 ){ break; } } if( iCol<pTab->nCol ){ pTab->aCol[iCol].isPrimKey = 1; } } if( pList->nExpr>1 ) iCol = -1; } if( iCol>=0 && iCol<pTab->nCol ){ zType = pTab->aCol[iCol].zType; } if( zType && sqlite3StrICmp(zType, "INTEGER")==0 && sortOrder==SQLITE_SO_ASC ){ pTab->iPKey = iCol; pTab->keyConf = onError; assert( autoInc==0 || autoInc==1 ); pTab->tabFlags |= autoInc*TF_Autoincrement; }else if( autoInc ){ 
#ifndef SQLITE_OMIT_AUTOINCREMENT 
 sqlite3ErrorMsg(pParse, "AUTOINCREMENT is only allowed on an " "INTEGER PRIMARY KEY"); 
#endif 
 }else{ sqlite3CreateIndex(pParse, 0, 0, 0, pList, onError, 0, 0, sortOrder, 0); pList = 0; } primary_key_exit: sqlite3ExprListDelete(pParse->db, pList); return; } SQLITE_PRIVATE void sqlite3AddCheckConstraint( Parse *pParse, Expr *pCheckExpr ){ sqlite3 *db = pParse->db; 
#ifndef SQLITE_OMIT_CHECK 
 Table *pTab = pParse->pNewTable; if( pTab && !IN_DECLARE_VTAB ){ pTab->pCheck = sqlite3ExprAnd(db, pTab->pCheck, sqlite3ExprDup(db, pCheckExpr)); } 
#endif 
 sqlite3ExprDelete(db, pCheckExpr); } SQLITE_PRIVATE void sqlite3AddCollateType(Parse *pParse, Token *pToken){ Table *p; int i; char *zColl; sqlite3 *db; if( (p = pParse->pNewTable)==0 ) return; i = p->nCol-1; db = pParse->db; zColl = sqlite3NameFromToken(db, pToken); if( !zColl ) return; if( sqlite3LocateCollSeq(pParse, zColl, -1) ){ Index *pIdx; p->aCol[i].zColl = zColl; for(pIdx=p->pIndex; pIdx; pIdx=pIdx->pNext){ assert( pIdx->nColumn==1 ); if( pIdx->aiColumn[0]==i ){ pIdx->azColl[0] = p->aCol[i].zColl; } } }else{ sqlite3DbFree(db, zColl); } } SQLITE_PRIVATE CollSeq *sqlite3LocateCollSeq(Parse *pParse, const char *zName, int nName){ sqlite3 *db = pParse->db; u8 enc = ENC(db); u8 initbusy = db->init.busy; CollSeq *pColl; pColl = sqlite3FindCollSeq(db, enc, zName, nName, initbusy); if( !initbusy && (!pColl || !pColl->xCmp) ){ pColl = sqlite3GetCollSeq(db, pColl, zName, nName); if( !pColl ){ if( nName<0 ){ nName = sqlite3Strlen(db, zName); } sqlite3ErrorMsg(pParse, "no such collation sequence: %.*s", nName, zName); pColl = 0; } } return pColl; } SQLITE_PRIVATE void sqlite3ChangeCookie(Parse *pParse, int iDb){ int r1 = sqlite3GetTempReg(pParse); sqlite3 *db = pParse->db; Vdbe *v = pParse->pVdbe; sqlite3VdbeAddOp2(v, OP_Integer, db->aDb[iDb].pSchema->schema_cookie+1, r1); sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, 0, r1); sqlite3ReleaseTempReg(pParse, r1); } static int identLength(const char *z){ int n; for(n=0; *z; n++, z++){ if( *z=='"' ){ n++; } } return n + 2; } static void identPut(char *z, int *pIdx, char *zSignedIdent){ unsigned char *zIdent = (unsigned char*)zSignedIdent; int i, j, needQuote; i = *pIdx; for(j=0; zIdent[j]; j++){ if( !isalnum(zIdent[j]) && zIdent[j]!='_' ) break; } needQuote = zIdent[j]!=0 || isdigit(zIdent[0]) || sqlite3KeywordCode(zIdent, j)!=TK_ID; if( needQuote ) z[i++] = '"'; for(j=0; zIdent[j]; j++){ z[i++] = zIdent[j]; if( zIdent[j]=='"' ) z[i++] = '"'; } if( needQuote ) z[i++] = '"'; z[i] = 0; *pIdx = i; } static char *createTableStmt(sqlite3 *db, Table *p, int isTemp){ int i, k, n; char *zStmt; char *zSep, *zSep2, *zEnd, *z; Column *pCol; n = 0; for(pCol = p->aCol, i=0; i<p->nCol; i++, pCol++){ n += identLength(pCol->zName); z = pCol->zType; if( z ){ n += (strlen(z) + 1); } } n += identLength(p->zName); if( n<50 ){ zSep = ""; zSep2 = ","; zEnd = ")"; }else{ zSep = "\n "; zSep2 = ",\n "; zEnd = "\n)"; } n += 35 + 6*p->nCol; zStmt = sqlite3Malloc( n ); if( zStmt==0 ){ db->mallocFailed = 1; return 0; } sqlite3_snprintf(n, zStmt, !OMIT_TEMPDB&&isTemp ? "CREATE TEMP TABLE ":"CREATE TABLE "); k = strlen(zStmt); identPut(zStmt, &k, p->zName); zStmt[k++] = '('; for(pCol=p->aCol, i=0; i<p->nCol; i++, pCol++){ sqlite3_snprintf(n-k, &zStmt[k], zSep); k += strlen(&zStmt[k]); zSep = zSep2; identPut(zStmt, &k, pCol->zName); if( (z = pCol->zType)!=0 ){ zStmt[k++] = ' '; assert( (int)(strlen(z)+k+1)<=n ); sqlite3_snprintf(n-k, &zStmt[k], "%s", z); k += strlen(z); } } sqlite3_snprintf(n-k, &zStmt[k], "%s", zEnd); return zStmt; } SQLITE_PRIVATE void sqlite3EndTable( Parse *pParse, Token *pCons, Token *pEnd, Select *pSelect ){ Table *p; sqlite3 *db = pParse->db; int iDb; if( (pEnd==0 && pSelect==0) || pParse->nErr || db->mallocFailed ) { return; } p = pParse->pNewTable; if( p==0 ) return; assert( !db->init.busy || !pSelect ); iDb = sqlite3SchemaToIndex(db, p->pSchema); 
#ifndef SQLITE_OMIT_CHECK 
 if( p->pCheck ){ SrcList sSrc; NameContext sNC; memset(&sNC, 0, sizeof(sNC)); memset(&sSrc, 0, sizeof(sSrc)); sSrc.nSrc = 1; sSrc.a[0].zName = p->zName; sSrc.a[0].pTab = p; sSrc.a[0].iCursor = -1; sNC.pParse = pParse; sNC.pSrcList = &sSrc; sNC.isCheck = 1; if( sqlite3ResolveExprNames(&sNC, p->pCheck) ){ return; } } 
#endif 
 if( db->init.busy ){ p->tnum = db->init.newTnum; } if( !db->init.busy ){ int n; Vdbe *v; char *zType; char *zType2; char *zStmt; v = sqlite3GetVdbe(pParse); if( v==0 ) return; sqlite3VdbeAddOp1(v, OP_Close, 0); if( p->pSelect==0 ){ zType = "table"; zType2 = "TABLE"; 
#ifndef SQLITE_OMIT_VIEW 
 }else{ zType = "view"; zType2 = "VIEW"; 
#endif 
 } if( pSelect ){ SelectDest dest; Table *pSelTab; assert(pParse->nTab==0); sqlite3VdbeAddOp3(v, OP_OpenWrite, 1, pParse->regRoot, iDb); sqlite3VdbeChangeP5(v, 1); pParse->nTab = 2; sqlite3SelectDestInit(&dest, SRT_Table, 1); sqlite3Select(pParse, pSelect, &dest); sqlite3VdbeAddOp1(v, OP_Close, 1); if( pParse->nErr==0 ){ pSelTab = sqlite3ResultSetOfSelect(pParse, pSelect); if( pSelTab==0 ) return; assert( p->aCol==0 ); p->nCol = pSelTab->nCol; p->aCol = pSelTab->aCol; pSelTab->nCol = 0; pSelTab->aCol = 0; sqlite3DeleteTable(pSelTab); } } if( pSelect ){ zStmt = createTableStmt(db, p, p->pSchema==db->aDb[1].pSchema); }else{ n = pEnd->z - pParse->sNameToken.z + 1; zStmt = sqlite3MPrintf(db, "CREATE %s %.*s", zType2, n, pParse->sNameToken.z ); } sqlite3NestedParse(pParse, "UPDATE %Q.%s " "SET type='%s', name=%Q, tbl_name=%Q, rootpage=#%d, sql=%Q " "WHERE rowid=#%d", db->aDb[iDb].zName, SCHEMA_TABLE(iDb), zType, p->zName, p->zName, pParse->regRoot, zStmt, pParse->regRowid ); sqlite3DbFree(db, zStmt); sqlite3ChangeCookie(pParse, iDb); 
#ifndef SQLITE_OMIT_AUTOINCREMENT 
 if( p->tabFlags & TF_Autoincrement ){ Db *pDb = &db->aDb[iDb]; if( pDb->pSchema->pSeqTab==0 ){ sqlite3NestedParse(pParse, "CREATE TABLE %Q.sqlite_sequence(name,seq)", pDb->zName ); } } 
#endif 
 sqlite3VdbeAddOp4(v, OP_ParseSchema, iDb, 0, 0, sqlite3MPrintf(db, "tbl_name='%q'",p->zName), P4_DYNAMIC); } if( db->init.busy && pParse->nErr==0 ){ Table *pOld; FKey *pFKey; Schema *pSchema = p->pSchema; pOld = sqlite3HashInsert(&pSchema->tblHash, p->zName, strlen(p->zName)+1,p); if( pOld ){ assert( p==pOld ); db->mallocFailed = 1; return; } 
#ifndef SQLITE_OMIT_FOREIGN_KEY 
 for(pFKey=p->pFKey; pFKey; pFKey=pFKey->pNextFrom){ void *data; int nTo = strlen(pFKey->zTo) + 1; pFKey->pNextTo = sqlite3HashFind(&pSchema->aFKey, pFKey->zTo, nTo); data = sqlite3HashInsert(&pSchema->aFKey, pFKey->zTo, nTo, pFKey); if( data==(void *)pFKey ){ db->mallocFailed = 1; } } 
#endif 
 pParse->pNewTable = 0; db->nTable++; db->flags |= SQLITE_InternChanges; 
#ifndef SQLITE_OMIT_ALTERTABLE 
 if( !p->pSelect ){ const char *zName = (const char *)pParse->sNameToken.z; int nName; assert( !pSelect && pCons && pEnd ); if( pCons->z==0 ){ pCons = pEnd; } nName = (const char *)pCons->z - zName; p->addColOffset = 13 + sqlite3Utf8CharLen(zName, nName); } 
#endif 
 } } 
#ifndef SQLITE_OMIT_VIEW 
SQLITE_PRIVATE void sqlite3CreateView( Parse *pParse, Token *pBegin, Token *pName1, Token *pName2, Select *pSelect, int isTemp, int noErr ){ Table *p; int n; const unsigned char *z; Token sEnd; DbFixer sFix; Token *pName; int iDb; sqlite3 *db = pParse->db; if( pParse->nVar>0 ){ sqlite3ErrorMsg(pParse, "parameters are not allowed in views"); sqlite3SelectDelete(db, pSelect); return; } sqlite3StartTable(pParse, pName1, pName2, isTemp, 1, 0, noErr); p = pParse->pNewTable; if( p==0 || pParse->nErr ){ sqlite3SelectDelete(db, pSelect); return; } sqlite3TwoPartName(pParse, pName1, pName2, &pName); iDb = sqlite3SchemaToIndex(db, p->pSchema); if( sqlite3FixInit(&sFix, pParse, iDb, "view", pName) && sqlite3FixSelect(&sFix, pSelect) ){ sqlite3SelectDelete(db, pSelect); return; } p->pSelect = sqlite3SelectDup(db, pSelect); sqlite3SelectDelete(db, pSelect); if( db->mallocFailed ){ return; } if( !db->init.busy ){ sqlite3ViewGetColumnNames(pParse, p); } sEnd = pParse->sLastToken; if( sEnd.z[0]!=0 && sEnd.z[0]!=';' ){ sEnd.z += sEnd.n; } sEnd.n = 0; n = sEnd.z - pBegin->z; z = (const unsigned char*)pBegin->z; while( n>0 && (z[n-1]==';' || isspace(z[n-1])) ){ n--; } sEnd.z = &z[n-1]; sEnd.n = 1; sqlite3EndTable(pParse, 0, &sEnd, 0); return; } 
#endif 
#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE) 
SQLITE_PRIVATE int sqlite3ViewGetColumnNames(Parse *pParse, Table *pTable){ Table *pSelTab; Select *pSel; int nErr = 0; int n; sqlite3 *db = pParse->db; int (*xAuth)(void*,int,const char*,const char*,const char*,const char*); assert( pTable ); 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 if( sqlite3VtabCallConnect(pParse, pTable) ){ return SQLITE_ERROR; } if( IsVirtual(pTable) ) return 0; 
#endif 
#ifndef SQLITE_OMIT_VIEW 
 if( pTable->nCol>0 ) return 0; if( pTable->nCol<0 ){ sqlite3ErrorMsg(pParse, "view %s is circularly defined", pTable->zName); return 1; } assert( pTable->nCol>=0 ); assert( pTable->pSelect ); pSel = sqlite3SelectDup(db, pTable->pSelect); if( pSel ){ n = pParse->nTab; sqlite3SrcListAssignCursors(pParse, pSel->pSrc); pTable->nCol = -1; 
#ifndef SQLITE_OMIT_AUTHORIZATION 
 xAuth = db->xAuth; db->xAuth = 0; pSelTab = sqlite3ResultSetOfSelect(pParse, pSel); db->xAuth = xAuth; 
#else 
 pSelTab = sqlite3ResultSetOfSelect(pParse, pSel); 
#endif 
 pParse->nTab = n; if( pSelTab ){ assert( pTable->aCol==0 ); pTable->nCol = pSelTab->nCol; pTable->aCol = pSelTab->aCol; pSelTab->nCol = 0; pSelTab->aCol = 0; sqlite3DeleteTable(pSelTab); pTable->pSchema->flags |= DB_UnresetViews; }else{ pTable->nCol = 0; nErr++; } sqlite3SelectDelete(db, pSel); } else { nErr++; } 
#endif 
 return nErr; } 
#endif 
#ifndef SQLITE_OMIT_VIEW 
static void sqliteViewResetAll(sqlite3 *db, int idx){ HashElem *i; if( !DbHasProperty(db, idx, DB_UnresetViews) ) return; for(i=sqliteHashFirst(&db->aDb[idx].pSchema->tblHash); i;i=sqliteHashNext(i)){ Table *pTab = sqliteHashData(i); if( pTab->pSelect ){ sqliteResetColumnNames(pTab); } } DbClearProperty(db, idx, DB_UnresetViews); } 
#else 
#define sqliteViewResetAll(A,B) 
#endif 
#ifndef SQLITE_OMIT_AUTOVACUUM 
SQLITE_PRIVATE void sqlite3RootPageMoved(Db *pDb, int iFrom, int iTo){ HashElem *pElem; Hash *pHash; pHash = &pDb->pSchema->tblHash; for(pElem=sqliteHashFirst(pHash); pElem; pElem=sqliteHashNext(pElem)){ Table *pTab = sqliteHashData(pElem); if( pTab->tnum==iFrom ){ pTab->tnum = iTo; } } pHash = &pDb->pSchema->idxHash; for(pElem=sqliteHashFirst(pHash); pElem; pElem=sqliteHashNext(pElem)){ Index *pIdx = sqliteHashData(pElem); if( pIdx->tnum==iFrom ){ pIdx->tnum = iTo; } } } 
#endif 
 static void destroyRootPage(Parse *pParse, int iTable, int iDb){ Vdbe *v = sqlite3GetVdbe(pParse); int r1 = sqlite3GetTempReg(pParse); sqlite3VdbeAddOp3(v, OP_Destroy, iTable, r1, iDb); 
#ifndef SQLITE_OMIT_AUTOVACUUM 
 sqlite3NestedParse(pParse, "UPDATE %Q.%s SET rootpage=%d WHERE #%d AND rootpage=#%d", pParse->db->aDb[iDb].zName, SCHEMA_TABLE(iDb), iTable, r1, r1); 
#endif 
 sqlite3ReleaseTempReg(pParse, r1); } static void destroyTable(Parse *pParse, Table *pTab){ 
#ifdef SQLITE_OMIT_AUTOVACUUM 
 Index *pIdx; int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema); destroyRootPage(pParse, pTab->tnum, iDb); for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){ destroyRootPage(pParse, pIdx->tnum, iDb); } 
#else 
 int iTab = pTab->tnum; int iDestroyed = 0; while( 1 ){ Index *pIdx; int iLargest = 0; if( iDestroyed==0 || iTab<iDestroyed ){ iLargest = iTab; } for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){ int iIdx = pIdx->tnum; assert( pIdx->pSchema==pTab->pSchema ); if( (iDestroyed==0 || (iIdx<iDestroyed)) && iIdx>iLargest ){ iLargest = iIdx; } } if( iLargest==0 ){ return; }else{ int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema); destroyRootPage(pParse, iLargest, iDb); iDestroyed = iLargest; } } 
#endif 
} SQLITE_PRIVATE void sqlite3DropTable(Parse *pParse, SrcList *pName, int isView, int noErr){ Table *pTab; Vdbe *v; sqlite3 *db = pParse->db; int iDb; if( pParse->nErr || db->mallocFailed ){ goto exit_drop_table; } assert( pName->nSrc==1 ); pTab = sqlite3LocateTable(pParse, isView, pName->a[0].zName, pName->a[0].zDatabase); if( pTab==0 ){ if( noErr ){ sqlite3ErrorClear(pParse); } goto exit_drop_table; } iDb = sqlite3SchemaToIndex(db, pTab->pSchema); assert( iDb>=0 && iDb<db->nDb ); if( IsVirtual(pTab) && sqlite3ViewGetColumnNames(pParse, pTab) ){ goto exit_drop_table; } 
#ifndef SQLITE_OMIT_AUTHORIZATION 
 { int code; const char *zTab = SCHEMA_TABLE(iDb); const char *zDb = db->aDb[iDb].zName; const char *zArg2 = 0; if( sqlite3AuthCheck(pParse, SQLITE_DELETE, zTab, 0, zDb)){ goto exit_drop_table; } if( isView ){ if( !OMIT_TEMPDB && iDb==1 ){ code = SQLITE_DROP_TEMP_VIEW; }else{ code = SQLITE_DROP_VIEW; } 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 }else if( IsVirtual(pTab) ){ code = SQLITE_DROP_VTABLE; zArg2 = pTab->pMod->zName; 
#endif 
 }else{ if( !OMIT_TEMPDB && iDb==1 ){ code = SQLITE_DROP_TEMP_TABLE; }else{ code = SQLITE_DROP_TABLE; } } if( sqlite3AuthCheck(pParse, code, pTab->zName, zArg2, zDb) ){ goto exit_drop_table; } if( sqlite3AuthCheck(pParse, SQLITE_DELETE, pTab->zName, 0, zDb) ){ goto exit_drop_table; } } 
#endif 
 if( sqlite3StrNICmp(pTab->zName, "sqlite_", 7)==0 ){ sqlite3ErrorMsg(pParse, "table %s may not be dropped", pTab->zName); goto exit_drop_table; } 
#ifndef SQLITE_OMIT_VIEW 
 if( isView && pTab->pSelect==0 ){ sqlite3ErrorMsg(pParse, "use DROP TABLE to delete table %s", pTab->zName); goto exit_drop_table; } if( !isView && pTab->pSelect ){ sqlite3ErrorMsg(pParse, "use DROP VIEW to delete view %s", pTab->zName); goto exit_drop_table; } 
#endif 
 v = sqlite3GetVdbe(pParse); if( v ){ Trigger *pTrigger; Db *pDb = &db->aDb[iDb]; sqlite3BeginWriteOperation(pParse, 1, iDb); 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 if( IsVirtual(pTab) ){ Vdbe *v = sqlite3GetVdbe(pParse); if( v ){ sqlite3VdbeAddOp0(v, OP_VBegin); } } 
#endif 
 pTrigger = pTab->pTrigger; while( pTrigger ){ assert( pTrigger->pSchema==pTab->pSchema || pTrigger->pSchema==db->aDb[1].pSchema ); sqlite3DropTriggerPtr(pParse, pTrigger); pTrigger = pTrigger->pNext; } 
#ifndef SQLITE_OMIT_AUTOINCREMENT 
 if( pTab->tabFlags & TF_Autoincrement ){ sqlite3NestedParse(pParse, "DELETE FROM %s.sqlite_sequence WHERE name=%Q", pDb->zName, pTab->zName ); } 
#endif 
 sqlite3NestedParse(pParse, "DELETE FROM %Q.%s WHERE tbl_name=%Q and type!='trigger'", pDb->zName, SCHEMA_TABLE(iDb), pTab->zName); if( sqlite3FindTable(db, "sqlite_stat1", db->aDb[iDb].zName) ){ sqlite3NestedParse(pParse, "DELETE FROM %Q.sqlite_stat1 WHERE tbl=%Q", pDb->zName, pTab->zName ); } if( !isView && !IsVirtual(pTab) ){ destroyTable(pParse, pTab); } if( IsVirtual(pTab) ){ sqlite3VdbeAddOp4(v, OP_VDestroy, iDb, 0, 0, pTab->zName, 0); } sqlite3VdbeAddOp4(v, OP_DropTable, iDb, 0, 0, pTab->zName, 0); sqlite3ChangeCookie(pParse, iDb); } sqliteViewResetAll(db, iDb); exit_drop_table: sqlite3SrcListDelete(db, pName); } SQLITE_PRIVATE void sqlite3CreateForeignKey( Parse *pParse, ExprList *pFromCol, Token *pTo, ExprList *pToCol, int flags ){ sqlite3 *db = pParse->db; 
#ifndef SQLITE_OMIT_FOREIGN_KEY 
 FKey *pFKey = 0; Table *p = pParse->pNewTable; int nByte; int i; int nCol; char *z; assert( pTo!=0 ); if( p==0 || pParse->nErr || IN_DECLARE_VTAB ) goto fk_end; if( pFromCol==0 ){ int iCol = p->nCol-1; if( iCol<0 ) goto fk_end; if( pToCol && pToCol->nExpr!=1 ){ sqlite3ErrorMsg(pParse, "foreign key on %s" " should reference only one column of table %T", p->aCol[iCol].zName, pTo); goto fk_end; } nCol = 1; }else if( pToCol && pToCol->nExpr!=pFromCol->nExpr ){ sqlite3ErrorMsg(pParse, "number of columns in foreign key does not match the number of " "columns in the referenced table"); goto fk_end; }else{ nCol = pFromCol->nExpr; } nByte = sizeof(*pFKey) + nCol*sizeof(pFKey->aCol[0]) + pTo->n + 1; if( pToCol ){ for(i=0; i<pToCol->nExpr; i++){ nByte += strlen(pToCol->a[i].zName) + 1; } } pFKey = sqlite3DbMallocZero(db, nByte ); if( pFKey==0 ){ goto fk_end; } pFKey->pFrom = p; pFKey->pNextFrom = p->pFKey; z = (char*)&pFKey[1]; pFKey->aCol = (struct sColMap*)z; z += sizeof(struct sColMap)*nCol; pFKey->zTo = z; memcpy(z, pTo->z, pTo->n); z[pTo->n] = 0; z += pTo->n+1; pFKey->pNextTo = 0; pFKey->nCol = nCol; if( pFromCol==0 ){ pFKey->aCol[0].iFrom = p->nCol-1; }else{ for(i=0; i<nCol; i++){ int j; for(j=0; j<p->nCol; j++){ if( sqlite3StrICmp(p->aCol[j].zName, pFromCol->a[i].zName)==0 ){ pFKey->aCol[i].iFrom = j; break; } } if( j>=p->nCol ){ sqlite3ErrorMsg(pParse, "unknown column \"%s\" in foreign key definition", pFromCol->a[i].zName); goto fk_end; } } } if( pToCol ){ for(i=0; i<nCol; i++){ int n = strlen(pToCol->a[i].zName); pFKey->aCol[i].zCol = z; memcpy(z, pToCol->a[i].zName, n); z[n] = 0; z += n+1; } } pFKey->isDeferred = 0; pFKey->deleteConf = flags & 0xff; pFKey->updateConf = (flags >> 8 ) & 0xff; pFKey->insertConf = (flags >> 16 ) & 0xff; p->pFKey = pFKey; pFKey = 0; fk_end: sqlite3DbFree(db, pFKey); 
#endif 
 sqlite3ExprListDelete(db, pFromCol); sqlite3ExprListDelete(db, pToCol); } SQLITE_PRIVATE void sqlite3DeferForeignKey(Parse *pParse, int isDeferred){ 
#ifndef SQLITE_OMIT_FOREIGN_KEY 
 Table *pTab; FKey *pFKey; if( (pTab = pParse->pNewTable)==0 || (pFKey = pTab->pFKey)==0 ) return; pFKey->isDeferred = isDeferred; 
#endif 
} static void sqlite3RefillIndex(Parse *pParse, Index *pIndex, int memRootPage){ Table *pTab = pIndex->pTable; int iTab = pParse->nTab; int iIdx = pParse->nTab+1; int addr1; int tnum; Vdbe *v; KeyInfo *pKey; int regIdxKey; int regRecord; sqlite3 *db = pParse->db; int iDb = sqlite3SchemaToIndex(db, pIndex->pSchema); 
#ifndef SQLITE_OMIT_AUTHORIZATION 
 if( sqlite3AuthCheck(pParse, SQLITE_REINDEX, pIndex->zName, 0, db->aDb[iDb].zName ) ){ return; } 
#endif 
 sqlite3TableLock(pParse, iDb, pTab->tnum, 1, pTab->zName); v = sqlite3GetVdbe(pParse); if( v==0 ) return; if( memRootPage>=0 ){ tnum = memRootPage; }else{ tnum = pIndex->tnum; sqlite3VdbeAddOp2(v, OP_Clear, tnum, iDb); } pKey = sqlite3IndexKeyinfo(pParse, pIndex); sqlite3VdbeAddOp4(v, OP_OpenWrite, iIdx, tnum, iDb, (char *)pKey, P4_KEYINFO_HANDOFF); if( memRootPage>=0 ){ sqlite3VdbeChangeP5(v, 1); } sqlite3OpenTable(pParse, iTab, iDb, pTab, OP_OpenRead); addr1 = sqlite3VdbeAddOp2(v, OP_Rewind, iTab, 0); regRecord = sqlite3GetTempReg(pParse); regIdxKey = sqlite3GenerateIndexKey(pParse, pIndex, iTab, regRecord, 1); if( pIndex->onError!=OE_None ){ int j1, j2; int regRowid; regRowid = regIdxKey + pIndex->nColumn; j1 = sqlite3VdbeAddOp3(v, OP_IsNull, regIdxKey, 0, pIndex->nColumn); j2 = sqlite3VdbeAddOp4(v, OP_IsUnique, iIdx, 0, regRowid, SQLITE_INT_TO_PTR(regRecord), P4_INT32); sqlite3VdbeAddOp4(v, OP_Halt, SQLITE_CONSTRAINT, OE_Abort, 0, "indexed columns are not unique", P4_STATIC); sqlite3VdbeJumpHere(v, j1); sqlite3VdbeJumpHere(v, j2); } sqlite3VdbeAddOp2(v, OP_IdxInsert, iIdx, regRecord); sqlite3ReleaseTempReg(pParse, regRecord); sqlite3VdbeAddOp2(v, OP_Next, iTab, addr1+1); sqlite3VdbeJumpHere(v, addr1); sqlite3VdbeAddOp1(v, OP_Close, iTab); sqlite3VdbeAddOp1(v, OP_Close, iIdx); } SQLITE_PRIVATE void sqlite3CreateIndex( Parse *pParse, Token *pName1, Token *pName2, SrcList *pTblName, ExprList *pList, int onError, Token *pStart, Token *pEnd, int sortOrder, int ifNotExist ){ Table *pTab = 0; Index *pIndex = 0; char *zName = 0; int nName; int i, j; Token nullId; DbFixer sFix; int sortOrderMask; sqlite3 *db = pParse->db; Db *pDb; int iDb; Token *pName = 0; struct ExprList_item *pListItem; int nCol; int nExtra = 0; char *zExtra; if( pParse->nErr || db->mallocFailed || IN_DECLARE_VTAB ){ goto exit_create_index; } if( pTblName!=0 ){ assert( pName1 && pName2 ); iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName); if( iDb<0 ) goto exit_create_index; 
#ifndef SQLITE_OMIT_TEMPDB 
 if( !db->init.busy ){ pTab = sqlite3SrcListLookup(pParse, pTblName); if( pName2 && pName2->n==0 && pTab && pTab->pSchema==db->aDb[1].pSchema ){ iDb = 1; } } 
#endif 
 if( sqlite3FixInit(&sFix, pParse, iDb, "index", pName) && sqlite3FixSrcList(&sFix, pTblName) ){ assert(0); } pTab = sqlite3LocateTable(pParse, 0, pTblName->a[0].zName, pTblName->a[0].zDatabase); if( !pTab || db->mallocFailed ) goto exit_create_index; assert( db->aDb[iDb].pSchema==pTab->pSchema ); }else{ assert( pName==0 ); pTab = pParse->pNewTable; if( !pTab ) goto exit_create_index; iDb = sqlite3SchemaToIndex(db, pTab->pSchema); } pDb = &db->aDb[iDb]; if( pTab==0 || pParse->nErr ) goto exit_create_index; if( sqlite3StrNICmp(pTab->zName, "sqlite_", 7)==0 ){ sqlite3ErrorMsg(pParse, "table %s may not be indexed", pTab->zName); goto exit_create_index; } 
#ifndef SQLITE_OMIT_VIEW 
 if( pTab->pSelect ){ sqlite3ErrorMsg(pParse, "views may not be indexed"); goto exit_create_index; } 
#endif 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 if( IsVirtual(pTab) ){ sqlite3ErrorMsg(pParse, "virtual tables may not be indexed"); goto exit_create_index; } 
#endif 
 if( pName ){ zName = sqlite3NameFromToken(db, pName); if( SQLITE_OK!=sqlite3ReadSchema(pParse) ) goto exit_create_index; if( zName==0 ) goto exit_create_index; if( SQLITE_OK!=sqlite3CheckObjectName(pParse, zName) ){ goto exit_create_index; } if( !db->init.busy ){ if( SQLITE_OK!=sqlite3ReadSchema(pParse) ) goto exit_create_index; if( sqlite3FindTable(db, zName, 0)!=0 ){ sqlite3ErrorMsg(pParse, "there is already a table named %s", zName); goto exit_create_index; } } if( sqlite3FindIndex(db, zName, pDb->zName)!=0 ){ if( !ifNotExist ){ sqlite3ErrorMsg(pParse, "index %s already exists", zName); } goto exit_create_index; } }else{ int n; Index *pLoop; for(pLoop=pTab->pIndex, n=1; pLoop; pLoop=pLoop->pNext, n++){} zName = sqlite3MPrintf(db, "sqlite_autoindex_%s_%d", pTab->zName, n); if( zName==0 ){ goto exit_create_index; } } 
#ifndef SQLITE_OMIT_AUTHORIZATION 
 { const char *zDb = pDb->zName; if( sqlite3AuthCheck(pParse, SQLITE_INSERT, SCHEMA_TABLE(iDb), 0, zDb) ){ goto exit_create_index; } i = SQLITE_CREATE_INDEX; if( !OMIT_TEMPDB && iDb==1 ) i = SQLITE_CREATE_TEMP_INDEX; if( sqlite3AuthCheck(pParse, i, zName, pTab->zName, zDb) ){ goto exit_create_index; } } 
#endif 
 if( pList==0 ){ nullId.z = (u8*)pTab->aCol[pTab->nCol-1].zName; nullId.n = strlen((char*)nullId.z); pList = sqlite3ExprListAppend(pParse, 0, 0, &nullId); if( pList==0 ) goto exit_create_index; pList->a[0].sortOrder = sortOrder; } for(i=0; i<pList->nExpr; i++){ Expr *pExpr; CollSeq *pColl; if( (pExpr = pList->a[i].pExpr)!=0 && (pColl = pExpr->pColl)!=0 ){ nExtra += (1 + strlen(pColl->zName)); } } nName = strlen(zName); nCol = pList->nExpr; pIndex = sqlite3DbMallocZero(db, sizeof(Index) + sizeof(int)*nCol + sizeof(int)*(nCol+1) + sizeof(char *)*nCol + sizeof(u8)*nCol + nName + 1 + nExtra ); if( db->mallocFailed ){ goto exit_create_index; } pIndex->azColl = (char**)(&pIndex[1]); pIndex->aiColumn = (int *)(&pIndex->azColl[nCol]); pIndex->aiRowEst = (unsigned *)(&pIndex->aiColumn[nCol]); pIndex->aSortOrder = (u8 *)(&pIndex->aiRowEst[nCol+1]); pIndex->zName = (char *)(&pIndex->aSortOrder[nCol]); zExtra = (char *)(&pIndex->zName[nName+1]); memcpy(pIndex->zName, zName, nName+1); pIndex->pTable = pTab; pIndex->nColumn = pList->nExpr; pIndex->onError = onError; pIndex->autoIndex = pName==0; pIndex->pSchema = db->aDb[iDb].pSchema; if( pDb->pSchema->file_format>=4 ){ sortOrderMask = -1; }else{ sortOrderMask = 0; } for(i=0, pListItem=pList->a; i<pList->nExpr; i++, pListItem++){ const char *zColName = pListItem->zName; Column *pTabCol; int requestedSortOrder; char *zColl; for(j=0, pTabCol=pTab->aCol; j<pTab->nCol; j++, pTabCol++){ if( sqlite3StrICmp(zColName, pTabCol->zName)==0 ) break; } if( j>=pTab->nCol ){ sqlite3ErrorMsg(pParse, "table %s has no column named %s", pTab->zName, zColName); goto exit_create_index; } pIndex->aiColumn[i] = j; if( pListItem->pExpr && pListItem->pExpr->pColl ){ assert( pListItem->pExpr->pColl ); zColl = zExtra; sqlite3_snprintf(nExtra, zExtra, "%s", pListItem->pExpr->pColl->zName); zExtra += (strlen(zColl) + 1); }else{ zColl = pTab->aCol[j].zColl; if( !zColl ){ zColl = db->pDfltColl->zName; } } if( !db->init.busy && !sqlite3LocateCollSeq(pParse, zColl, -1) ){ goto exit_create_index; } pIndex->azColl[i] = zColl; requestedSortOrder = pListItem->sortOrder & sortOrderMask; pIndex->aSortOrder[i] = requestedSortOrder; } sqlite3DefaultRowEst(pIndex); if( pTab==pParse->pNewTable ){ Index *pIdx; for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){ int k; assert( pIdx->onError!=OE_None ); assert( pIdx->autoIndex ); assert( pIndex->onError!=OE_None ); if( pIdx->nColumn!=pIndex->nColumn ) continue; for(k=0; k<pIdx->nColumn; k++){ const char *z1 = pIdx->azColl[k]; const char *z2 = pIndex->azColl[k]; if( pIdx->aiColumn[k]!=pIndex->aiColumn[k] ) break; if( pIdx->aSortOrder[k]!=pIndex->aSortOrder[k] ) break; if( z1!=z2 && sqlite3StrICmp(z1, z2) ) break; } if( k==pIdx->nColumn ){ if( pIdx->onError!=pIndex->onError ){ if( !(pIdx->onError==OE_Default || pIndex->onError==OE_Default) ){ sqlite3ErrorMsg(pParse, "conflicting ON CONFLICT clauses specified", 0); } if( pIdx->onError==OE_Default ){ pIdx->onError = pIndex->onError; } } goto exit_create_index; } } } if( db->init.busy ){ Index *p; p = sqlite3HashInsert(&pIndex->pSchema->idxHash, pIndex->zName, strlen(pIndex->zName)+1, pIndex); if( p ){ assert( p==pIndex ); db->mallocFailed = 1; goto exit_create_index; } db->flags |= SQLITE_InternChanges; if( pTblName!=0 ){ pIndex->tnum = db->init.newTnum; } } else if( db->init.busy==0 ){ Vdbe *v; char *zStmt; int iMem = ++pParse->nMem; v = sqlite3GetVdbe(pParse); if( v==0 ) goto exit_create_index; sqlite3BeginWriteOperation(pParse, 1, iDb); sqlite3VdbeAddOp2(v, OP_CreateIndex, iDb, iMem); if( pStart && pEnd ){ zStmt = sqlite3MPrintf(db, "CREATE%s INDEX %.*s", onError==OE_None ? "" : " UNIQUE", pEnd->z - pName->z + 1, pName->z); }else{ zStmt = 0; } sqlite3NestedParse(pParse, "INSERT INTO %Q.%s VALUES('index',%Q,%Q,#%d,%Q);", db->aDb[iDb].zName, SCHEMA_TABLE(iDb), pIndex->zName, pTab->zName, iMem, zStmt ); sqlite3DbFree(db, zStmt); if( pTblName ){ sqlite3RefillIndex(pParse, pIndex, iMem); sqlite3ChangeCookie(pParse, iDb); sqlite3VdbeAddOp4(v, OP_ParseSchema, iDb, 0, 0, sqlite3MPrintf(db, "name='%q'", pIndex->zName), P4_DYNAMIC); sqlite3VdbeAddOp1(v, OP_Expire, 0); } } if( db->init.busy || pTblName==0 ){ if( onError!=OE_Replace || pTab->pIndex==0 || pTab->pIndex->onError==OE_Replace){ pIndex->pNext = pTab->pIndex; pTab->pIndex = pIndex; }else{ Index *pOther = pTab->pIndex; while( pOther->pNext && pOther->pNext->onError!=OE_Replace ){ pOther = pOther->pNext; } pIndex->pNext = pOther->pNext; pOther->pNext = pIndex; } pIndex = 0; } exit_create_index: if( pIndex ){ freeIndex(pIndex); } sqlite3ExprListDelete(db, pList); sqlite3SrcListDelete(db, pTblName); sqlite3DbFree(db, zName); return; } SQLITE_PRIVATE void sqlite3MinimumFileFormat(Parse *pParse, int iDb, int minFormat){ Vdbe *v; v = sqlite3GetVdbe(pParse); if( v ){ int r1 = sqlite3GetTempReg(pParse); int r2 = sqlite3GetTempReg(pParse); int j1; sqlite3VdbeAddOp3(v, OP_ReadCookie, iDb, r1, 1); sqlite3VdbeUsesBtree(v, iDb); sqlite3VdbeAddOp2(v, OP_Integer, minFormat, r2); j1 = sqlite3VdbeAddOp3(v, OP_Ge, r2, 0, r1); sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, 1, r2); sqlite3VdbeJumpHere(v, j1); sqlite3ReleaseTempReg(pParse, r1); sqlite3ReleaseTempReg(pParse, r2); } } SQLITE_PRIVATE void sqlite3DefaultRowEst(Index *pIdx){ unsigned *a = pIdx->aiRowEst; int i; assert( a!=0 ); a[0] = 1000000; for(i=pIdx->nColumn; i>=5; i--){ a[i] = 5; } while( i>=1 ){ a[i] = 11 - i; i--; } if( pIdx->onError!=OE_None ){ a[pIdx->nColumn] = 1; } } SQLITE_PRIVATE void sqlite3DropIndex(Parse *pParse, SrcList *pName, int ifExists){ Index *pIndex; Vdbe *v; sqlite3 *db = pParse->db; int iDb; if( pParse->nErr || db->mallocFailed ){ goto exit_drop_index; } assert( pName->nSrc==1 ); if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){ goto exit_drop_index; } pIndex = sqlite3FindIndex(db, pName->a[0].zName, pName->a[0].zDatabase); if( pIndex==0 ){ if( !ifExists ){ sqlite3ErrorMsg(pParse, "no such index: %S", pName, 0); } pParse->checkSchema = 1; goto exit_drop_index; } if( pIndex->autoIndex ){ sqlite3ErrorMsg(pParse, "index associated with UNIQUE " "or PRIMARY KEY constraint cannot be dropped", 0); goto exit_drop_index; } iDb = sqlite3SchemaToIndex(db, pIndex->pSchema); 
#ifndef SQLITE_OMIT_AUTHORIZATION 
 { int code = SQLITE_DROP_INDEX; Table *pTab = pIndex->pTable; const char *zDb = db->aDb[iDb].zName; const char *zTab = SCHEMA_TABLE(iDb); if( sqlite3AuthCheck(pParse, SQLITE_DELETE, zTab, 0, zDb) ){ goto exit_drop_index; } if( !OMIT_TEMPDB && iDb ) code = SQLITE_DROP_TEMP_INDEX; if( sqlite3AuthCheck(pParse, code, pIndex->zName, pTab->zName, zDb) ){ goto exit_drop_index; } } 
#endif 
 v = sqlite3GetVdbe(pParse); if( v ){ sqlite3BeginWriteOperation(pParse, 1, iDb); sqlite3NestedParse(pParse, "DELETE FROM %Q.%s WHERE name=%Q", db->aDb[iDb].zName, SCHEMA_TABLE(iDb), pIndex->zName ); if( sqlite3FindTable(db, "sqlite_stat1", db->aDb[iDb].zName) ){ sqlite3NestedParse(pParse, "DELETE FROM %Q.sqlite_stat1 WHERE idx=%Q", db->aDb[iDb].zName, pIndex->zName ); } sqlite3ChangeCookie(pParse, iDb); destroyRootPage(pParse, pIndex->tnum, iDb); sqlite3VdbeAddOp4(v, OP_DropIndex, iDb, 0, 0, pIndex->zName, 0); } exit_drop_index: sqlite3SrcListDelete(db, pName); } SQLITE_PRIVATE void *sqlite3ArrayAllocate( sqlite3 *db, void *pArray, int szEntry, int initSize, int *pnEntry, int *pnAlloc, int *pIdx ){ char *z; if( *pnEntry >= *pnAlloc ){ void *pNew; int newSize; newSize = (*pnAlloc)*2 + initSize; pNew = sqlite3DbRealloc(db, pArray, newSize*szEntry); if( pNew==0 ){ *pIdx = -1; return pArray; } *pnAlloc = newSize; pArray = pNew; } z = (char*)pArray; memset(&z[*pnEntry * szEntry], 0, szEntry); *pIdx = *pnEntry; ++*pnEntry; return pArray; } SQLITE_PRIVATE IdList *sqlite3IdListAppend(sqlite3 *db, IdList *pList, Token *pToken){ int i; if( pList==0 ){ pList = sqlite3DbMallocZero(db, sizeof(IdList) ); if( pList==0 ) return 0; pList->nAlloc = 0; } pList->a = sqlite3ArrayAllocate( db, pList->a, sizeof(pList->a[0]), 5, &pList->nId, &pList->nAlloc, &i ); if( i<0 ){ sqlite3IdListDelete(db, pList); return 0; } pList->a[i].zName = sqlite3NameFromToken(db, pToken); return pList; } SQLITE_PRIVATE void sqlite3IdListDelete(sqlite3 *db, IdList *pList){ int i; if( pList==0 ) return; for(i=0; i<pList->nId; i++){ sqlite3DbFree(db, pList->a[i].zName); } sqlite3DbFree(db, pList->a); sqlite3DbFree(db, pList); } SQLITE_PRIVATE int sqlite3IdListIndex(IdList *pList, const char *zName){ int i; if( pList==0 ) return -1; for(i=0; i<pList->nId; i++){ if( sqlite3StrICmp(pList->a[i].zName, zName)==0 ) return i; } return -1; } SQLITE_PRIVATE SrcList *sqlite3SrcListEnlarge( sqlite3 *db, SrcList *pSrc, int nExtra, int iStart ){ int i; assert( iStart>=0 ); assert( nExtra>=1 ); if( pSrc==0 || iStart>pSrc->nSrc ){ assert( db->mallocFailed ); return pSrc; } if( pSrc->nSrc+nExtra>pSrc->nAlloc ){ SrcList *pNew; int nAlloc = pSrc->nSrc+nExtra; pNew = sqlite3DbRealloc(db, pSrc, sizeof(*pSrc) + (nAlloc-1)*sizeof(pSrc->a[0]) ); if( pNew==0 ){ assert( db->mallocFailed ); return pSrc; } pSrc = pNew; pSrc->nAlloc = nAlloc; } for(i=pSrc->nSrc-1; i>=iStart; i--){ pSrc->a[i+nExtra] = pSrc->a[i]; } pSrc->nSrc += nExtra; memset(&pSrc->a[iStart], 0, sizeof(pSrc->a[0])*nExtra); for(i=iStart; i<iStart+nExtra; i++){ pSrc->a[i].iCursor = -1; } return pSrc; } SQLITE_PRIVATE SrcList *sqlite3SrcListAppend( sqlite3 *db, SrcList *pList, Token *pTable, Token *pDatabase ){ struct SrcList_item *pItem; if( pList==0 ){ pList = sqlite3DbMallocZero(db, sizeof(SrcList) ); if( pList==0 ) return 0; pList->nAlloc = 1; } pList = sqlite3SrcListEnlarge(db, pList, 1, pList->nSrc); if( db->mallocFailed ){ sqlite3SrcListDelete(db, pList); return 0; } pItem = &pList->a[pList->nSrc-1]; if( pDatabase && pDatabase->z==0 ){ pDatabase = 0; } if( pDatabase && pTable ){ Token *pTemp = pDatabase; pDatabase = pTable; pTable = pTemp; } pItem->zName = sqlite3NameFromToken(db, pTable); pItem->zDatabase = sqlite3NameFromToken(db, pDatabase); return pList; } SQLITE_PRIVATE void sqlite3SrcListAssignCursors(Parse *pParse, SrcList *pList){ int i; struct SrcList_item *pItem; assert(pList || pParse->db->mallocFailed ); if( pList ){ for(i=0, pItem=pList->a; i<pList->nSrc; i++, pItem++){ if( pItem->iCursor>=0 ) break; pItem->iCursor = pParse->nTab++; if( pItem->pSelect ){ sqlite3SrcListAssignCursors(pParse, pItem->pSelect->pSrc); } } } } SQLITE_PRIVATE void sqlite3SrcListDelete(sqlite3 *db, SrcList *pList){ int i; struct SrcList_item *pItem; if( pList==0 ) return; for(pItem=pList->a, i=0; i<pList->nSrc; i++, pItem++){ sqlite3DbFree(db, pItem->zDatabase); sqlite3DbFree(db, pItem->zName); sqlite3DbFree(db, pItem->zAlias); sqlite3DbFree(db, pItem->zIndex); sqlite3DeleteTable(pItem->pTab); sqlite3SelectDelete(db, pItem->pSelect); sqlite3ExprDelete(db, pItem->pOn); sqlite3IdListDelete(db, pItem->pUsing); } sqlite3DbFree(db, pList); } SQLITE_PRIVATE SrcList *sqlite3SrcListAppendFromTerm( Parse *pParse, SrcList *p, Token *pTable, Token *pDatabase, Token *pAlias, Select *pSubquery, Expr *pOn, IdList *pUsing ){ struct SrcList_item *pItem; sqlite3 *db = pParse->db; p = sqlite3SrcListAppend(db, p, pTable, pDatabase); if( p==0 || p->nSrc==0 ){ sqlite3ExprDelete(db, pOn); sqlite3IdListDelete(db, pUsing); sqlite3SelectDelete(db, pSubquery); return p; } pItem = &p->a[p->nSrc-1]; if( pAlias && pAlias->n ){ pItem->zAlias = sqlite3NameFromToken(db, pAlias); } pItem->pSelect = pSubquery; pItem->pOn = pOn; pItem->pUsing = pUsing; return p; } SQLITE_PRIVATE void sqlite3SrcListIndexedBy(Parse *pParse, SrcList *p, Token *pIndexedBy){ if( pIndexedBy && p && p->nSrc>0 ){ struct SrcList_item *pItem = &p->a[p->nSrc-1]; assert( pItem->notIndexed==0 && pItem->zIndex==0 ); if( pIndexedBy->n==1 && !pIndexedBy->z ){ pItem->notIndexed = 1; }else{ pItem->zIndex = sqlite3NameFromToken(pParse->db, pIndexedBy); } } } SQLITE_PRIVATE void sqlite3SrcListShiftJoinType(SrcList *p){ if( p && p->a ){ int i; for(i=p->nSrc-1; i>0; i--){ p->a[i].jointype = p->a[i-1].jointype; } p->a[0].jointype = 0; } } SQLITE_PRIVATE void sqlite3BeginTransaction(Parse *pParse, int type){ sqlite3 *db; Vdbe *v; int i; if( pParse==0 || (db=pParse->db)==0 || db->aDb[0].pBt==0 ) return; if( pParse->nErr || db->mallocFailed ) return; if( sqlite3AuthCheck(pParse, SQLITE_TRANSACTION, "BEGIN", 0, 0) ) return; v = sqlite3GetVdbe(pParse); if( !v ) return; if( type!=TK_DEFERRED ){ for(i=0; i<db->nDb; i++){ sqlite3VdbeAddOp2(v, OP_Transaction, i, (type==TK_EXCLUSIVE)+1); sqlite3VdbeUsesBtree(v, i); } } sqlite3VdbeAddOp2(v, OP_AutoCommit, 0, 0); } SQLITE_PRIVATE void sqlite3CommitTransaction(Parse *pParse){ sqlite3 *db; Vdbe *v; if( pParse==0 || (db=pParse->db)==0 || db->aDb[0].pBt==0 ) return; if( pParse->nErr || db->mallocFailed ) return; if( sqlite3AuthCheck(pParse, SQLITE_TRANSACTION, "COMMIT", 0, 0) ) return; v = sqlite3GetVdbe(pParse); if( v ){ sqlite3VdbeAddOp2(v, OP_AutoCommit, 1, 0); } } SQLITE_PRIVATE void sqlite3RollbackTransaction(Parse *pParse){ sqlite3 *db; Vdbe *v; if( pParse==0 || (db=pParse->db)==0 || db->aDb[0].pBt==0 ) return; if( pParse->nErr || db->mallocFailed ) return; if( sqlite3AuthCheck(pParse, SQLITE_TRANSACTION, "ROLLBACK", 0, 0) ) return; v = sqlite3GetVdbe(pParse); if( v ){ sqlite3VdbeAddOp2(v, OP_AutoCommit, 1, 1); } } SQLITE_PRIVATE int sqlite3OpenTempDatabase(Parse *pParse){ sqlite3 *db = pParse->db; if( db->aDb[1].pBt==0 && !pParse->explain ){ int rc; static const int flags = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE | SQLITE_OPEN_EXCLUSIVE | SQLITE_OPEN_DELETEONCLOSE | SQLITE_OPEN_TEMP_DB; rc = sqlite3BtreeFactory(db, 0, 0, SQLITE_DEFAULT_CACHE_SIZE, flags, &db->aDb[1].pBt); if( rc!=SQLITE_OK ){ sqlite3ErrorMsg(pParse, "unable to open a temporary database " "file for storing temporary tables"); pParse->rc = rc; return 1; } assert( (db->flags & SQLITE_InTrans)==0 || db->autoCommit ); assert( db->aDb[1].pSchema ); sqlite3PagerJournalMode(sqlite3BtreePager(db->aDb[1].pBt), db->dfltJournalMode); } return 0; } SQLITE_PRIVATE void sqlite3CodeVerifySchema(Parse *pParse, int iDb){ sqlite3 *db; Vdbe *v; int mask; v = sqlite3GetVdbe(pParse); if( v==0 ) return; db = pParse->db; if( pParse->cookieGoto==0 ){ pParse->cookieGoto = sqlite3VdbeAddOp2(v, OP_Goto, 0, 0)+1; } if( iDb>=0 ){ assert( iDb<db->nDb ); assert( db->aDb[iDb].pBt!=0 || iDb==1 ); assert( iDb<SQLITE_MAX_ATTACHED+2 ); mask = 1<<iDb; if( (pParse->cookieMask & mask)==0 ){ pParse->cookieMask |= mask; pParse->cookieValue[iDb] = db->aDb[iDb].pSchema->schema_cookie; if( !OMIT_TEMPDB && iDb==1 ){ sqlite3OpenTempDatabase(pParse); } } } } SQLITE_PRIVATE void sqlite3BeginWriteOperation(Parse *pParse, int setStatement, int iDb){ Vdbe *v = sqlite3GetVdbe(pParse); if( v==0 ) return; sqlite3CodeVerifySchema(pParse, iDb); pParse->writeMask |= 1<<iDb; if( setStatement && pParse->nested==0 ){ sqlite3VdbeAddOp1(v, OP_Statement, iDb); } if( (OMIT_TEMPDB || iDb!=1) && pParse->db->aDb[1].pBt!=0 ){ sqlite3BeginWriteOperation(pParse, setStatement, 1); } } 
#ifndef SQLITE_OMIT_REINDEX 
static int collationMatch(const char *zColl, Index *pIndex){ int i; for(i=0; i<pIndex->nColumn; i++){ const char *z = pIndex->azColl[i]; if( z==zColl || (z && zColl && 0==sqlite3StrICmp(z, zColl)) ){ return 1; } } return 0; } 
#endif 
#ifndef SQLITE_OMIT_REINDEX 
static void reindexTable(Parse *pParse, Table *pTab, char const *zColl){ Index *pIndex; for(pIndex=pTab->pIndex; pIndex; pIndex=pIndex->pNext){ if( zColl==0 || collationMatch(zColl, pIndex) ){ int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema); sqlite3BeginWriteOperation(pParse, 0, iDb); sqlite3RefillIndex(pParse, pIndex, -1); } } } 
#endif 
#ifndef SQLITE_OMIT_REINDEX 
static void reindexDatabases(Parse *pParse, char const *zColl){ Db *pDb; int iDb; sqlite3 *db = pParse->db; HashElem *k; Table *pTab; for(iDb=0, pDb=db->aDb; iDb<db->nDb; iDb++, pDb++){ assert( pDb!=0 ); for(k=sqliteHashFirst(&pDb->pSchema->tblHash); k; k=sqliteHashNext(k)){ pTab = (Table*)sqliteHashData(k); reindexTable(pParse, pTab, zColl); } } } 
#endif 
#ifndef SQLITE_OMIT_REINDEX 
SQLITE_PRIVATE void sqlite3Reindex(Parse *pParse, Token *pName1, Token *pName2){ CollSeq *pColl; char *z; const char *zDb; Table *pTab; Index *pIndex; int iDb; sqlite3 *db = pParse->db; Token *pObjName; if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){ return; } if( pName1==0 || pName1->z==0 ){ reindexDatabases(pParse, 0); return; }else if( pName2==0 || pName2->z==0 ){ char *zColl; assert( pName1->z ); zColl = sqlite3NameFromToken(pParse->db, pName1); if( !zColl ) return; pColl = sqlite3FindCollSeq(db, ENC(db), zColl, -1, 0); if( pColl ){ if( zColl ){ reindexDatabases(pParse, zColl); sqlite3DbFree(db, zColl); } return; } sqlite3DbFree(db, zColl); } iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pObjName); if( iDb<0 ) return; z = sqlite3NameFromToken(db, pObjName); if( z==0 ) return; zDb = db->aDb[iDb].zName; pTab = sqlite3FindTable(db, z, zDb); if( pTab ){ reindexTable(pParse, pTab, 0); sqlite3DbFree(db, z); return; } pIndex = sqlite3FindIndex(db, z, zDb); sqlite3DbFree(db, z); if( pIndex ){ sqlite3BeginWriteOperation(pParse, 0, iDb); sqlite3RefillIndex(pParse, pIndex, -1); return; } sqlite3ErrorMsg(pParse, "unable to identify the object to be reindexed"); } 
#endif 
SQLITE_PRIVATE KeyInfo *sqlite3IndexKeyinfo(Parse *pParse, Index *pIdx){ int i; int nCol = pIdx->nColumn; int nBytes = sizeof(KeyInfo) + (nCol-1)*sizeof(CollSeq*) + nCol; sqlite3 *db = pParse->db; KeyInfo *pKey = (KeyInfo *)sqlite3DbMallocZero(db, nBytes); if( pKey ){ pKey->db = pParse->db; pKey->aSortOrder = (u8 *)&(pKey->aColl[nCol]); assert( &pKey->aSortOrder[nCol]==&(((u8 *)pKey)[nBytes]) ); for(i=0; i<nCol; i++){ char *zColl = pIdx->azColl[i]; assert( zColl ); pKey->aColl[i] = sqlite3LocateCollSeq(pParse, zColl, -1); pKey->aSortOrder[i] = pIdx->aSortOrder[i]; } pKey->nField = nCol; } if( pParse->nErr ){ sqlite3DbFree(db, pKey); pKey = 0; } return pKey; } static void callCollNeeded(sqlite3 *db, const char *zName, int nName){ assert( !db->xCollNeeded || !db->xCollNeeded16 ); if( nName<0 ) nName = sqlite3Strlen(db, zName); if( db->xCollNeeded ){ char *zExternal = sqlite3DbStrNDup(db, zName, nName); if( !zExternal ) return; db->xCollNeeded(db->pCollNeededArg, db, (int)ENC(db), zExternal); sqlite3DbFree(db, zExternal); } 
#ifndef SQLITE_OMIT_UTF16 
 if( db->xCollNeeded16 ){ char const *zExternal; sqlite3_value *pTmp = sqlite3ValueNew(db); sqlite3ValueSetStr(pTmp, nName, zName, SQLITE_UTF8, SQLITE_STATIC); zExternal = sqlite3ValueText(pTmp, SQLITE_UTF16NATIVE); if( zExternal ){ db->xCollNeeded16(db->pCollNeededArg, db, (int)ENC(db), zExternal); } sqlite3ValueFree(pTmp); } 
#endif 
} static int synthCollSeq(sqlite3 *db, CollSeq *pColl){ CollSeq *pColl2; char *z = pColl->zName; int n = strlen(z); int i; static const u8 aEnc[] = { SQLITE_UTF16BE, SQLITE_UTF16LE, SQLITE_UTF8 }; for(i=0; i<3; i++){ pColl2 = sqlite3FindCollSeq(db, aEnc[i], z, n, 0); if( pColl2->xCmp!=0 ){ memcpy(pColl, pColl2, sizeof(CollSeq)); pColl->xDel = 0; return SQLITE_OK; } } return SQLITE_ERROR; } SQLITE_PRIVATE CollSeq *sqlite3GetCollSeq( sqlite3* db, CollSeq *pColl, const char *zName, int nName ){ CollSeq *p; p = pColl; if( !p ){ p = sqlite3FindCollSeq(db, ENC(db), zName, nName, 0); } if( !p || !p->xCmp ){ callCollNeeded(db, zName, nName); p = sqlite3FindCollSeq(db, ENC(db), zName, nName, 0); } if( p && !p->xCmp && synthCollSeq(db, p) ){ p = 0; } assert( !p || p->xCmp ); return p; } SQLITE_PRIVATE int sqlite3CheckCollSeq(Parse *pParse, CollSeq *pColl){ if( pColl ){ const char *zName = pColl->zName; CollSeq *p = sqlite3GetCollSeq(pParse->db, pColl, zName, -1); if( !p ){ if( pParse->nErr==0 ){ sqlite3ErrorMsg(pParse, "no such collation sequence: %s", zName); } pParse->nErr++; return SQLITE_ERROR; } assert( p==pColl ); } return SQLITE_OK; } static CollSeq *findCollSeqEntry( sqlite3 *db, const char *zName, int nName, int create ){ CollSeq *pColl; if( nName<0 ) nName = sqlite3Strlen(db, zName); pColl = sqlite3HashFind(&db->aCollSeq, zName, nName); if( 0==pColl && create ){ pColl = sqlite3DbMallocZero(db, 3*sizeof(*pColl) + nName + 1 ); if( pColl ){ CollSeq *pDel = 0; pColl[0].zName = (char*)&pColl[3]; pColl[0].enc = SQLITE_UTF8; pColl[1].zName = (char*)&pColl[3]; pColl[1].enc = SQLITE_UTF16LE; pColl[2].zName = (char*)&pColl[3]; pColl[2].enc = SQLITE_UTF16BE; memcpy(pColl[0].zName, zName, nName); pColl[0].zName[nName] = 0; pDel = sqlite3HashInsert(&db->aCollSeq, pColl[0].zName, nName, pColl); assert( pDel==0 || pDel==pColl ); if( pDel!=0 ){ db->mallocFailed = 1; sqlite3DbFree(db, pDel); pColl = 0; } } } return pColl; } SQLITE_PRIVATE CollSeq *sqlite3FindCollSeq( sqlite3 *db, u8 enc, const char *zName, int nName, int create ){ CollSeq *pColl; if( zName ){ pColl = findCollSeqEntry(db, zName, nName, create); }else{ pColl = db->pDfltColl; } assert( SQLITE_UTF8==1 && SQLITE_UTF16LE==2 && SQLITE_UTF16BE==3 ); assert( enc>=SQLITE_UTF8 && enc<=SQLITE_UTF16BE ); if( pColl ) pColl += enc-1; return pColl; } static int matchQuality(FuncDef *p, int nArg, u8 enc){ int match = 0; if( p->nArg==-1 || p->nArg==nArg || nArg==-1 ){ match = 1; if( p->nArg==nArg || nArg==-1 ){ match = 4; } if( enc==p->iPrefEnc ){ match += 2; } else if( (enc==SQLITE_UTF16LE && p->iPrefEnc==SQLITE_UTF16BE) || (enc==SQLITE_UTF16BE && p->iPrefEnc==SQLITE_UTF16LE) ){ match += 1; } } return match; } static FuncDef *functionSearch( FuncDefHash *pHash, int h, const char *zFunc, int nFunc ){ FuncDef *p; for(p=pHash->a[h]; p; p=p->pHash){ if( sqlite3StrNICmp(p->zName, zFunc, nFunc)==0 && p->zName[nFunc]==0 ){ return p; } } return 0; } SQLITE_PRIVATE void sqlite3FuncDefInsert( FuncDefHash *pHash, FuncDef *pDef ){ FuncDef *pOther; int nName = strlen(pDef->zName); u8 c1 = (u8)pDef->zName[0]; int h = (sqlite3UpperToLower[c1] + nName) % ArraySize(pHash->a); pOther = functionSearch(pHash, h, pDef->zName, nName); if( pOther ){ pDef->pNext = pOther->pNext; pOther->pNext = pDef; }else{ pDef->pNext = 0; pDef->pHash = pHash->a[h]; pHash->a[h] = pDef; } } SQLITE_PRIVATE FuncDef *sqlite3FindFunction( sqlite3 *db, const char *zName, int nName, int nArg, u8 enc, int createFlag ){ FuncDef *p; FuncDef *pBest = 0; int bestScore = 0; int h; assert( enc==SQLITE_UTF8 || enc==SQLITE_UTF16LE || enc==SQLITE_UTF16BE ); if( nArg<-1 ) nArg = -1; h = (sqlite3UpperToLower[(u8)zName[0]] + nName) % ArraySize(db->aFunc.a); p = functionSearch(&db->aFunc, h, zName, nName); while( p ){ int score = matchQuality(p, nArg, enc); if( score>bestScore ){ pBest = p; bestScore = score; } p = p->pNext; } if( !createFlag && !pBest ){ FuncDefHash *pHash = &GLOBAL(FuncDefHash, sqlite3GlobalFunctions); p = functionSearch(pHash, h, zName, nName); while( p ){ int score = matchQuality(p, nArg, enc); if( score>bestScore ){ pBest = p; bestScore = score; } p = p->pNext; } } if( createFlag && (bestScore<6 || pBest->nArg!=nArg) && (pBest = sqlite3DbMallocZero(db, sizeof(*pBest)+nName+1))!=0 ){ pBest->zName = (char *)&pBest[1]; pBest->nArg = nArg; pBest->iPrefEnc = enc; memcpy(pBest->zName, zName, nName); pBest->zName[nName] = 0; sqlite3FuncDefInsert(&db->aFunc, pBest); } if( pBest && (pBest->xStep || pBest->xFunc || createFlag) ){ return pBest; } return 0; } SQLITE_PRIVATE void sqlite3SchemaFree(void *p){ Hash temp1; Hash temp2; HashElem *pElem; Schema *pSchema = (Schema *)p; temp1 = pSchema->tblHash; temp2 = pSchema->trigHash; sqlite3HashInit(&pSchema->trigHash, 0); sqlite3HashClear(&pSchema->aFKey); sqlite3HashClear(&pSchema->idxHash); for(pElem=sqliteHashFirst(&temp2); pElem; pElem=sqliteHashNext(pElem)){ sqlite3DeleteTrigger(0, (Trigger*)sqliteHashData(pElem)); } sqlite3HashClear(&temp2); sqlite3HashInit(&pSchema->tblHash, 0); for(pElem=sqliteHashFirst(&temp1); pElem; pElem=sqliteHashNext(pElem)){ Table *pTab = sqliteHashData(pElem); sqlite3DeleteTable(pTab); } sqlite3HashClear(&temp1); pSchema->pSeqTab = 0; pSchema->flags &= ~DB_SchemaLoaded; } SQLITE_PRIVATE Schema *sqlite3SchemaGet(sqlite3 *db, Btree *pBt){ Schema * p; if( pBt ){ p = (Schema *)sqlite3BtreeSchema(pBt, sizeof(Schema), sqlite3SchemaFree); }else{ p = (Schema *)sqlite3MallocZero(sizeof(Schema)); } if( !p ){ db->mallocFailed = 1; }else if ( 0==p->file_format ){ sqlite3HashInit(&p->tblHash, 0); sqlite3HashInit(&p->idxHash, 0); sqlite3HashInit(&p->trigHash, 0); sqlite3HashInit(&p->aFKey, 1); p->enc = SQLITE_UTF8; } return p; } SQLITE_PRIVATE Table *sqlite3SrcListLookup(Parse *pParse, SrcList *pSrc){ struct SrcList_item *pItem = pSrc->a; Table *pTab; assert( pItem && pSrc->nSrc==1 ); pTab = sqlite3LocateTable(pParse, 0, pItem->zName, pItem->zDatabase); sqlite3DeleteTable(pItem->pTab); pItem->pTab = pTab; if( pTab ){ pTab->nRef++; } if( sqlite3IndexedByLookup(pParse, pItem) ){ pTab = 0; } return pTab; } SQLITE_PRIVATE int sqlite3IsReadOnly(Parse *pParse, Table *pTab, int viewOk){ if( ((pTab->tabFlags & TF_Readonly)!=0 && (pParse->db->flags & SQLITE_WriteSchema)==0 && pParse->nested==0) 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 || (pTab->pMod && pTab->pMod->pModule->xUpdate==0) 
#endif 
 ){ sqlite3ErrorMsg(pParse, "table %s may not be modified", pTab->zName); return 1; } 
#ifndef SQLITE_OMIT_VIEW 
 if( !viewOk && pTab->pSelect ){ sqlite3ErrorMsg(pParse,"cannot modify %s because it is a view",pTab->zName); return 1; } 
#endif 
 return 0; } SQLITE_PRIVATE void sqlite3OpenTable( Parse *p, int iCur, int iDb, Table *pTab, int opcode ){ Vdbe *v; if( IsVirtual(pTab) ) return; v = sqlite3GetVdbe(p); assert( opcode==OP_OpenWrite || opcode==OP_OpenRead ); sqlite3TableLock(p, iDb, pTab->tnum, (opcode==OP_OpenWrite), pTab->zName); sqlite3VdbeAddOp2(v, OP_SetNumColumns, 0, pTab->nCol); sqlite3VdbeAddOp3(v, opcode, iCur, pTab->tnum, iDb); VdbeComment((v, "%s", pTab->zName)); } 
#if !defined(SQLITE_OMIT_VIEW) && !defined(SQLITE_OMIT_TRIGGER) 
SQLITE_PRIVATE void sqlite3MaterializeView( Parse *pParse, Table *pView, Expr *pWhere, int iCur ){ SelectDest dest; Select *pDup; sqlite3 *db = pParse->db; pDup = sqlite3SelectDup(db, pView->pSelect); if( pWhere ){ SrcList *pFrom; Token viewName; pWhere = sqlite3ExprDup(db, pWhere); viewName.z = (u8*)pView->zName; viewName.n = (unsigned int)strlen((const char*)viewName.z); pFrom = sqlite3SrcListAppendFromTerm(pParse, 0, 0, 0, &viewName, pDup, 0,0); pDup = sqlite3SelectNew(pParse, 0, pFrom, pWhere, 0, 0, 0, 0, 0, 0); } sqlite3SelectDestInit(&dest, SRT_EphemTab, iCur); sqlite3Select(pParse, pDup, &dest); sqlite3SelectDelete(db, pDup); } 
#endif 
#if defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) && !defined(SQLITE_OMIT_SUBQUERY) 
SQLITE_PRIVATE Expr *sqlite3LimitWhere( Parse *pParse, SrcList *pSrc, Expr *pWhere, ExprList *pOrderBy, Expr *pLimit, Expr *pOffset, char *zStmtType ){ Expr *pWhereRowid = NULL; Expr *pInClause = NULL; Expr *pSelectRowid = NULL; ExprList *pEList = NULL; SrcList *pSelectSrc = NULL; Select *pSelect = NULL; if( pOrderBy && (pLimit == 0) ) { sqlite3ErrorMsg(pParse, "ORDER BY without LIMIT on %s", zStmtType); pParse->parseError = 1; goto limit_where_cleanup_2; } if( pLimit == 0 ) { assert( pOffset == 0 ); return pWhere; } pSelectRowid = sqlite3Expr(pParse->db, TK_ROW, 0, 0, 0); if( pSelectRowid == 0 ) goto limit_where_cleanup_2; pEList = sqlite3ExprListAppend(pParse, 0, pSelectRowid, 0); if( pEList == 0 ) goto limit_where_cleanup_2; pSelectSrc = sqlite3SrcListDup(pParse->db, pSrc); if( pSelectSrc == 0 ) { sqlite3ExprListDelete(pParse->db, pEList); goto limit_where_cleanup_2; } pSelect = sqlite3SelectNew(pParse,pEList,pSelectSrc,pWhere,0,0,pOrderBy,0,pLimit,pOffset); if( pSelect == 0 ) return 0; pWhereRowid = sqlite3Expr(pParse->db, TK_ROW, 0, 0, 0); if( pWhereRowid == 0 ) goto limit_where_cleanup_1; pInClause = sqlite3PExpr(pParse, TK_IN, pWhereRowid, 0, 0); if( pInClause == 0 ) goto limit_where_cleanup_1; pInClause->pSelect = pSelect; sqlite3ExprSetHeight(pParse, pInClause); return pInClause; limit_where_cleanup_1: sqlite3SelectDelete(pParse->db, pSelect); return 0; limit_where_cleanup_2: sqlite3ExprDelete(pParse->db, pWhere); sqlite3ExprListDelete(pParse->db, pOrderBy); sqlite3ExprDelete(pParse->db, pLimit); sqlite3ExprDelete(pParse->db, pOffset); return 0; } 
#endif 
SQLITE_PRIVATE void sqlite3DeleteFrom( Parse *pParse, SrcList *pTabList, Expr *pWhere ){ Vdbe *v; Table *pTab; const char *zDb; int end, addr = 0; int i; WhereInfo *pWInfo; Index *pIdx; int iCur; sqlite3 *db; AuthContext sContext; int oldIdx = -1; NameContext sNC; int iDb; int memCnt = -1; int rcauth; 
#ifndef SQLITE_OMIT_TRIGGER 
 int isView; int triggers_exist = 0; 
#endif 
 int iBeginAfterTrigger; int iEndAfterTrigger; int iBeginBeforeTrigger; int iEndBeforeTrigger; u32 old_col_mask = 0; sContext.pParse = 0; db = pParse->db; if( pParse->nErr || db->mallocFailed ){ goto delete_from_cleanup; } assert( pTabList->nSrc==1 ); pTab = sqlite3SrcListLookup(pParse, pTabList); if( pTab==0 ) goto delete_from_cleanup; 
#ifndef SQLITE_OMIT_TRIGGER 
 triggers_exist = sqlite3TriggersExist(pTab, TK_DELETE, 0); isView = pTab->pSelect!=0; 
#else 
#define triggers_exist 0 
#define isView 0 
#endif 
#ifdef SQLITE_OMIT_VIEW 
#undef isView 
#define isView 0 
#endif 
 if( sqlite3IsReadOnly(pParse, pTab, triggers_exist) ){ goto delete_from_cleanup; } iDb = sqlite3SchemaToIndex(db, pTab->pSchema); assert( iDb<db->nDb ); zDb = db->aDb[iDb].zName; rcauth = sqlite3AuthCheck(pParse, SQLITE_DELETE, pTab->zName, 0, zDb); assert( rcauth==SQLITE_OK || rcauth==SQLITE_DENY || rcauth==SQLITE_IGNORE ); if( rcauth==SQLITE_DENY ){ goto delete_from_cleanup; } assert(!isView || triggers_exist); if( sqlite3ViewGetColumnNames(pParse, pTab) ){ goto delete_from_cleanup; } if( triggers_exist ){ oldIdx = pParse->nTab++; } assert( pTabList->nSrc==1 ); iCur = pTabList->a[0].iCursor = pParse->nTab++; for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){ pParse->nTab++; } if( isView ){ sqlite3AuthContextPush(pParse, &sContext, pTab->zName); } v = sqlite3GetVdbe(pParse); if( v==0 ){ goto delete_from_cleanup; } if( pParse->nested==0 ) sqlite3VdbeCountChanges(v); sqlite3BeginWriteOperation(pParse, triggers_exist, iDb); if( triggers_exist ){ int orconf = ((pParse->trigStack)?pParse->trigStack->orconf:OE_Default); int iGoto = sqlite3VdbeAddOp0(v, OP_Goto); addr = sqlite3VdbeMakeLabel(v); iBeginBeforeTrigger = sqlite3VdbeCurrentAddr(v); (void)sqlite3CodeRowTrigger(pParse, TK_DELETE, 0, TRIGGER_BEFORE, pTab, -1, oldIdx, orconf, addr, &old_col_mask, 0); iEndBeforeTrigger = sqlite3VdbeAddOp0(v, OP_Goto); iBeginAfterTrigger = sqlite3VdbeCurrentAddr(v); (void)sqlite3CodeRowTrigger(pParse, TK_DELETE, 0, TRIGGER_AFTER, pTab, -1, oldIdx, orconf, addr, &old_col_mask, 0); iEndAfterTrigger = sqlite3VdbeAddOp0(v, OP_Goto); sqlite3VdbeJumpHere(v, iGoto); } 
#if !defined(SQLITE_OMIT_VIEW) && !defined(SQLITE_OMIT_TRIGGER) 
 if( isView ){ sqlite3MaterializeView(pParse, pTab, pWhere, iCur); } 
#endif 
 memset(&sNC, 0, sizeof(sNC)); sNC.pParse = pParse; sNC.pSrcList = pTabList; if( sqlite3ResolveExprNames(&sNC, pWhere) ){ goto delete_from_cleanup; } if( db->flags & SQLITE_CountRows ){ memCnt = ++pParse->nMem; sqlite3VdbeAddOp2(v, OP_Integer, 0, memCnt); } 
#ifndef SQLITE_OMIT_TRUNCATE_OPTIMIZATION 
 if( rcauth==SQLITE_OK && pWhere==0 && !triggers_exist && !IsVirtual(pTab) ){ assert( !isView ); sqlite3VdbeAddOp3(v, OP_Clear, pTab->tnum, iDb, memCnt); if( !pParse->nested ){ sqlite3VdbeChangeP4(v, -1, pTab->zName, P4_STATIC); } for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){ assert( pIdx->pSchema==pTab->pSchema ); sqlite3VdbeAddOp2(v, OP_Clear, pIdx->tnum, iDb); } }else 
#endif 
 { int iRowid = ++pParse->nMem; pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, 0, 0); if( pWInfo==0 ) goto delete_from_cleanup; sqlite3VdbeAddOp2(v, IsVirtual(pTab) ? OP_VRowid : OP_Rowid, iCur, iRowid); sqlite3VdbeAddOp1(v, OP_FifoWrite, iRowid); if( db->flags & SQLITE_CountRows ){ sqlite3VdbeAddOp2(v, OP_AddImm, memCnt, 1); } sqlite3WhereEnd(pWInfo); if( triggers_exist ){ sqlite3VdbeAddOp2(v, OP_SetNumColumns, 0, pTab->nCol); sqlite3VdbeAddOp1(v, OP_OpenPseudo, oldIdx); } end = sqlite3VdbeMakeLabel(v); if( !isView ){ sqlite3OpenTableAndIndices(pParse, pTab, iCur, OP_OpenWrite); } if( triggers_exist ){ sqlite3VdbeResolveLabel(v, addr); } addr = sqlite3VdbeAddOp2(v, OP_FifoRead, iRowid, end); if( triggers_exist ){ int iData = ++pParse->nMem; sqlite3VdbeAddOp3(v, OP_NotExists, iCur, addr, iRowid); if( old_col_mask ){ sqlite3VdbeAddOp2(v, OP_RowData, iCur, iData); }else{ sqlite3VdbeAddOp2(v, OP_Null, 0, iData); } sqlite3VdbeAddOp3(v, OP_Insert, oldIdx, iData, iRowid); sqlite3VdbeAddOp2(v, OP_Goto, 0, iBeginBeforeTrigger); sqlite3VdbeJumpHere(v, iEndBeforeTrigger); } if( !isView ){ 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 if( IsVirtual(pTab) ){ const char *pVtab = (const char *)pTab->pVtab; sqlite3VtabMakeWritable(pParse, pTab); sqlite3VdbeAddOp4(v, OP_VUpdate, 0, 1, iRowid, pVtab, P4_VTAB); }else 
#endif 
 { sqlite3GenerateRowDelete(pParse, pTab, iCur, iRowid, pParse->nested==0); } } if( triggers_exist ){ sqlite3VdbeAddOp2(v, OP_Goto, 0, iBeginAfterTrigger); sqlite3VdbeJumpHere(v, iEndAfterTrigger); } sqlite3VdbeAddOp2(v, OP_Goto, 0, addr); sqlite3VdbeResolveLabel(v, end); if( !isView && !IsVirtual(pTab) ){ for(i=1, pIdx=pTab->pIndex; pIdx; i++, pIdx=pIdx->pNext){ sqlite3VdbeAddOp2(v, OP_Close, iCur + i, pIdx->tnum); } sqlite3VdbeAddOp1(v, OP_Close, iCur); } } if( db->flags & SQLITE_CountRows && pParse->nested==0 && !pParse->trigStack ){ sqlite3VdbeAddOp2(v, OP_ResultRow, memCnt, 1); sqlite3VdbeSetNumCols(v, 1); sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "rows deleted", SQLITE_STATIC); } delete_from_cleanup: sqlite3AuthContextPop(&sContext); sqlite3SrcListDelete(db, pTabList); sqlite3ExprDelete(db, pWhere); return; } SQLITE_PRIVATE void sqlite3GenerateRowDelete( Parse *pParse, Table *pTab, int iCur, int iRowid, int count ){ int addr; Vdbe *v; v = pParse->pVdbe; addr = sqlite3VdbeAddOp3(v, OP_NotExists, iCur, 0, iRowid); sqlite3GenerateRowIndexDelete(pParse, pTab, iCur, 0); sqlite3VdbeAddOp2(v, OP_Delete, iCur, (count?OPFLAG_NCHANGE:0)); if( count ){ sqlite3VdbeChangeP4(v, -1, pTab->zName, P4_STATIC); } sqlite3VdbeJumpHere(v, addr); } SQLITE_PRIVATE void sqlite3GenerateRowIndexDelete( Parse *pParse, Table *pTab, int iCur, int *aRegIdx ){ int i; Index *pIdx; int r1; for(i=1, pIdx=pTab->pIndex; pIdx; i++, pIdx=pIdx->pNext){ if( aRegIdx!=0 && aRegIdx[i-1]==0 ) continue; r1 = sqlite3GenerateIndexKey(pParse, pIdx, iCur, 0, 0); sqlite3VdbeAddOp3(pParse->pVdbe, OP_IdxDelete, iCur+i, r1,pIdx->nColumn+1); } } SQLITE_PRIVATE int sqlite3GenerateIndexKey( Parse *pParse, Index *pIdx, int iCur, int regOut, int doMakeRec ){ Vdbe *v = pParse->pVdbe; int j; Table *pTab = pIdx->pTable; int regBase; int nCol; nCol = pIdx->nColumn; regBase = sqlite3GetTempRange(pParse, nCol+1); sqlite3VdbeAddOp2(v, OP_Rowid, iCur, regBase+nCol); for(j=0; j<nCol; j++){ int idx = pIdx->aiColumn[j]; if( idx==pTab->iPKey ){ sqlite3VdbeAddOp2(v, OP_SCopy, regBase+nCol, regBase+j); }else{ sqlite3VdbeAddOp3(v, OP_Column, iCur, idx, regBase+j); sqlite3ColumnDefault(v, pTab, idx); } } if( doMakeRec ){ sqlite3VdbeAddOp3(v, OP_MakeRecord, regBase, nCol+1, regOut); sqlite3IndexAffinityStr(v, pIdx); sqlite3ExprCacheAffinityChange(pParse, regBase, nCol+1); } sqlite3ReleaseTempRange(pParse, regBase, nCol+1); return regBase; } 
#undef isView 
static CollSeq *sqlite3GetFuncCollSeq(sqlite3_context *context){ return context->pColl; } static void minmaxFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){ int i; int mask; int iBest; CollSeq *pColl; if( argc==0 ) return; mask = sqlite3_user_data(context)==0 ? 0 : -1; pColl = sqlite3GetFuncCollSeq(context); assert( pColl ); assert( mask==-1 || mask==0 ); iBest = 0; if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return; for(i=1; i<argc; i++){ if( sqlite3_value_type(argv[i])==SQLITE_NULL ) return; if( (sqlite3MemCompare(argv[iBest], argv[i], pColl)^mask)>=0 ){ iBest = i; } } sqlite3_result_value(context, argv[iBest]); } static void typeofFunc( sqlite3_context *context, int NotUsed, sqlite3_value **argv ){ const char *z = 0; UNUSED_PARAMETER(NotUsed); switch( sqlite3_value_type(argv[0]) ){ case SQLITE_NULL: z = "null"; break; case SQLITE_INTEGER: z = "integer"; break; case SQLITE_TEXT: z = "text"; break; case SQLITE_FLOAT: z = "real"; break; case SQLITE_BLOB: z = "blob"; break; } sqlite3_result_text(context, z, -1, SQLITE_STATIC); } static void lengthFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){ int len; assert( argc==1 ); UNUSED_PARAMETER(argc); switch( sqlite3_value_type(argv[0]) ){ case SQLITE_BLOB: case SQLITE_INTEGER: case SQLITE_FLOAT: { sqlite3_result_int(context, sqlite3_value_bytes(argv[0])); break; } case SQLITE_TEXT: { const unsigned char *z = sqlite3_value_text(argv[0]); if( z==0 ) return; len = 0; while( *z ){ len++; SQLITE_SKIP_UTF8(z); } sqlite3_result_int(context, len); break; } default: { sqlite3_result_null(context); break; } } } static void absFunc(sqlite3_context *context, int argc, sqlite3_value **argv){ assert( argc==1 ); UNUSED_PARAMETER(argc); switch( sqlite3_value_type(argv[0]) ){ case SQLITE_INTEGER: { i64 iVal = sqlite3_value_int64(argv[0]); if( iVal<0 ){ if( (iVal<<1)==0 ){ sqlite3_result_error(context, "integer overflow", -1); return; } iVal = -iVal; } sqlite3_result_int64(context, iVal); break; } case SQLITE_NULL: { sqlite3_result_null(context); break; } default: { double rVal = sqlite3_value_double(argv[0]); if( rVal<0 ) rVal = -rVal; sqlite3_result_double(context, rVal); break; } } } static void substrFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){ const unsigned char *z; const unsigned char *z2; int len; int p0type; i64 p1, p2; assert( argc==3 || argc==2 ); p0type = sqlite3_value_type(argv[0]); if( p0type==SQLITE_BLOB ){ len = sqlite3_value_bytes(argv[0]); z = sqlite3_value_blob(argv[0]); if( z==0 ) return; assert( len==sqlite3_value_bytes(argv[0]) ); }else{ z = sqlite3_value_text(argv[0]); if( z==0 ) return; len = 0; for(z2=z; *z2; len++){ SQLITE_SKIP_UTF8(z2); } } p1 = sqlite3_value_int(argv[1]); if( argc==3 ){ p2 = sqlite3_value_int(argv[2]); }else{ p2 = sqlite3_context_db_handle(context)->aLimit[SQLITE_LIMIT_LENGTH]; } if( p1<0 ){ p1 += len; if( p1<0 ){ p2 += p1; p1 = 0; } }else if( p1>0 ){ p1--; } if( p1+p2>len ){ p2 = len-p1; } if( p0type!=SQLITE_BLOB ){ while( *z && p1 ){ SQLITE_SKIP_UTF8(z); p1--; } for(z2=z; *z2 && p2; p2--){ SQLITE_SKIP_UTF8(z2); } sqlite3_result_text(context, (char*)z, z2-z, SQLITE_TRANSIENT); }else{ if( p2<0 ) p2 = 0; sqlite3_result_blob(context, (char*)&z[p1], p2, SQLITE_TRANSIENT); } } static void roundFunc(sqlite3_context *context, int argc, sqlite3_value **argv){ int n = 0; double r; char zBuf[500]; assert( argc==1 || argc==2 ); if( argc==2 ){ if( SQLITE_NULL==sqlite3_value_type(argv[1]) ) return; n = sqlite3_value_int(argv[1]); if( n>30 ) n = 30; if( n<0 ) n = 0; } if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return; r = sqlite3_value_double(argv[0]); sqlite3_snprintf(sizeof(zBuf),zBuf,"%.*f",n,r); sqlite3AtoF(zBuf, &r); sqlite3_result_double(context, r); } static void *contextMalloc(sqlite3_context *context, i64 nByte){ char *z; if( nByte>sqlite3_context_db_handle(context)->aLimit[SQLITE_LIMIT_LENGTH] ){ sqlite3_result_error_toobig(context); z = 0; }else{ z = sqlite3Malloc(nByte); if( !z && nByte>0 ){ sqlite3_result_error_nomem(context); } } return z; } static void upperFunc(sqlite3_context *context, int argc, sqlite3_value **argv){ char *z1; const char *z2; int i, n; if( argc<1 || SQLITE_NULL==sqlite3_value_type(argv[0]) ) return; z2 = (char*)sqlite3_value_text(argv[0]); n = sqlite3_value_bytes(argv[0]); assert( z2==(char*)sqlite3_value_text(argv[0]) ); if( z2 ){ z1 = contextMalloc(context, ((i64)n)+1); if( z1 ){ memcpy(z1, z2, n+1); for(i=0; z1[i]; i++){ z1[i] = toupper(z1[i]); } sqlite3_result_text(context, z1, -1, sqlite3_free); } } } static void lowerFunc(sqlite3_context *context, int argc, sqlite3_value **argv){ char *z1; const char *z2; int i, n; if( argc<1 || SQLITE_NULL==sqlite3_value_type(argv[0]) ) return; z2 = (char*)sqlite3_value_text(argv[0]); n = sqlite3_value_bytes(argv[0]); assert( z2==(char*)sqlite3_value_text(argv[0]) ); if( z2 ){ z1 = contextMalloc(context, ((i64)n)+1); if( z1 ){ memcpy(z1, z2, n+1); for(i=0; z1[i]; i++){ z1[i] = tolower(z1[i]); } sqlite3_result_text(context, z1, -1, sqlite3_free); } } } static void ifnullFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){ int i; for(i=0; i<argc; i++){ if( SQLITE_NULL!=sqlite3_value_type(argv[i]) ){ sqlite3_result_value(context, argv[i]); break; } } } static void randomFunc( sqlite3_context *context, int NotUsed, sqlite3_value **NotUsed2 ){ sqlite_int64 r; UNUSED_PARAMETER2(NotUsed, NotUsed2); sqlite3_randomness(sizeof(r), &r); if( (r<<1)==0 ) r = 0; sqlite3_result_int64(context, r); } static void randomBlob( sqlite3_context *context, int argc, sqlite3_value **argv ){ int n; unsigned char *p; assert( argc==1 ); UNUSED_PARAMETER(argc); n = sqlite3_value_int(argv[0]); if( n<1 ){ n = 1; } p = contextMalloc(context, n); if( p ){ sqlite3_randomness(n, p); sqlite3_result_blob(context, (char*)p, n, sqlite3_free); } } static void last_insert_rowid( sqlite3_context *context, int NotUsed, sqlite3_value **NotUsed2 ){ sqlite3 *db = sqlite3_context_db_handle(context); UNUSED_PARAMETER2(NotUsed, NotUsed2); sqlite3_result_int64(context, sqlite3_last_insert_rowid(db)); } static void changes( sqlite3_context *context, int NotUsed, sqlite3_value **NotUsed2 ){ sqlite3 *db = sqlite3_context_db_handle(context); UNUSED_PARAMETER2(NotUsed, NotUsed2); sqlite3_result_int(context, sqlite3_changes(db)); } static void total_changes( sqlite3_context *context, int NotUsed, sqlite3_value **NotUsed2 ){ sqlite3 *db = sqlite3_context_db_handle(context); UNUSED_PARAMETER2(NotUsed, NotUsed2); sqlite3_result_int(context, sqlite3_total_changes(db)); } struct compareInfo { u8 matchAll; u8 matchOne; u8 matchSet; u8 noCase; }; 
#if defined(SQLITE_EBCDIC) 
#define sqlite3Utf8Read(A,B,C) (*(A++)) 
#define GlogUpperToLower(A) A = sqlite3UpperToLower[A] 
#else 
#define GlogUpperToLower(A) if( A<0x80 ){ A = sqlite3UpperToLower[A]; } 
#endif 
static const struct compareInfo globInfo = { '*', '?', '[', 0 }; static const struct compareInfo likeInfoNorm = { '%', '_', 0, 1 }; static const struct compareInfo likeInfoAlt = { '%', '_', 0, 0 }; static int patternCompare( const u8 *zPattern, const u8 *zString, const struct compareInfo *pInfo, const int esc ){ int c, c2; int invert; int seen; u8 matchOne = pInfo->matchOne; u8 matchAll = pInfo->matchAll; u8 matchSet = pInfo->matchSet; u8 noCase = pInfo->noCase; int prevEscape = 0; while( (c = sqlite3Utf8Read(zPattern,0,&zPattern))!=0 ){ if( !prevEscape && c==matchAll ){ while( (c=sqlite3Utf8Read(zPattern,0,&zPattern)) == matchAll || c == matchOne ){ if( c==matchOne && sqlite3Utf8Read(zString, 0, &zString)==0 ){ return 0; } } if( c==0 ){ return 1; }else if( c==esc ){ c = sqlite3Utf8Read(zPattern, 0, &zPattern); if( c==0 ){ return 0; } }else if( c==matchSet ){ assert( esc==0 ); assert( matchSet<0x80 ); while( *zString && patternCompare(&zPattern[-1],zString,pInfo,esc)==0 ){ SQLITE_SKIP_UTF8(zString); } return *zString!=0; } while( (c2 = sqlite3Utf8Read(zString,0,&zString))!=0 ){ if( noCase ){ GlogUpperToLower(c2); GlogUpperToLower(c); while( c2 != 0 && c2 != c ){ c2 = sqlite3Utf8Read(zString, 0, &zString); GlogUpperToLower(c2); } }else{ while( c2 != 0 && c2 != c ){ c2 = sqlite3Utf8Read(zString, 0, &zString); } } if( c2==0 ) return 0; if( patternCompare(zPattern,zString,pInfo,esc) ) return 1; } return 0; }else if( !prevEscape && c==matchOne ){ if( sqlite3Utf8Read(zString, 0, &zString)==0 ){ return 0; } }else if( c==matchSet ){ int prior_c = 0; assert( esc==0 ); seen = 0; invert = 0; c = sqlite3Utf8Read(zString, 0, &zString); if( c==0 ) return 0; c2 = sqlite3Utf8Read(zPattern, 0, &zPattern); if( c2=='^' ){ invert = 1; c2 = sqlite3Utf8Read(zPattern, 0, &zPattern); } if( c2==']' ){ if( c==']' ) seen = 1; c2 = sqlite3Utf8Read(zPattern, 0, &zPattern); } while( c2 && c2!=']' ){ if( c2=='-' && zPattern[0]!=']' && zPattern[0]!=0 && prior_c>0 ){ c2 = sqlite3Utf8Read(zPattern, 0, &zPattern); if( c>=prior_c && c<=c2 ) seen = 1; prior_c = 0; }else{ if( c==c2 ){ seen = 1; } prior_c = c2; } c2 = sqlite3Utf8Read(zPattern, 0, &zPattern); } if( c2==0 || (seen ^ invert)==0 ){ return 0; } }else if( esc==c && !prevEscape ){ prevEscape = 1; }else{ c2 = sqlite3Utf8Read(zString, 0, &zString); if( noCase ){ GlogUpperToLower(c); GlogUpperToLower(c2); } if( c!=c2 ){ return 0; } prevEscape = 0; } } return *zString==0; } 
#ifdef SQLITE_TEST 
SQLITE_API int sqlite3_like_count = 0; 
#endif 
static void likeFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){ const unsigned char *zA, *zB; int escape = 0; sqlite3 *db = sqlite3_context_db_handle(context); zB = sqlite3_value_text(argv[0]); zA = sqlite3_value_text(argv[1]); if( sqlite3_value_bytes(argv[0]) > db->aLimit[SQLITE_LIMIT_LIKE_PATTERN_LENGTH] ){ sqlite3_result_error(context, "LIKE or GLOB pattern too complex", -1); return; } assert( zB==sqlite3_value_text(argv[0]) ); if( argc==3 ){ const unsigned char *zEsc = sqlite3_value_text(argv[2]); if( zEsc==0 ) return; if( sqlite3Utf8CharLen((char*)zEsc, -1)!=1 ){ sqlite3_result_error(context, "ESCAPE expression must be a single character", -1); return; } escape = sqlite3Utf8Read(zEsc, 0, &zEsc); } if( zA && zB ){ struct compareInfo *pInfo = sqlite3_user_data(context); 
#ifdef SQLITE_TEST 
 sqlite3_like_count++; 
#endif 
 sqlite3_result_int(context, patternCompare(zB, zA, pInfo, escape)); } } static void nullifFunc( sqlite3_context *context, int NotUsed, sqlite3_value **argv ){ CollSeq *pColl = sqlite3GetFuncCollSeq(context); UNUSED_PARAMETER(NotUsed); if( sqlite3MemCompare(argv[0], argv[1], pColl)!=0 ){ sqlite3_result_value(context, argv[0]); } } static void versionFunc( sqlite3_context *context, int NotUsed, sqlite3_value **NotUsed2 ){ UNUSED_PARAMETER2(NotUsed, NotUsed2); sqlite3_result_text(context, sqlite3_version, -1, SQLITE_STATIC); } static const char hexdigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' }; static void quoteFunc(sqlite3_context *context, int argc, sqlite3_value **argv){ if( argc<1 ) return; switch( sqlite3_value_type(argv[0]) ){ case SQLITE_NULL: { sqlite3_result_text(context, "NULL", 4, SQLITE_STATIC); break; } case SQLITE_INTEGER: case SQLITE_FLOAT: { sqlite3_result_value(context, argv[0]); break; } case SQLITE_BLOB: { char *zText = 0; char const *zBlob = sqlite3_value_blob(argv[0]); int nBlob = sqlite3_value_bytes(argv[0]); assert( zBlob==sqlite3_value_blob(argv[0]) ); zText = (char *)contextMalloc(context, (2*(i64)nBlob)+4); if( zText ){ int i; for(i=0; i<nBlob; i++){ zText[(i*2)+2] = hexdigits[(zBlob[i]>>4)&0x0F]; zText[(i*2)+3] = hexdigits[(zBlob[i])&0x0F]; } zText[(nBlob*2)+2] = '\''; zText[(nBlob*2)+3] = '\0'; zText[0] = 'X'; zText[1] = '\''; sqlite3_result_text(context, zText, -1, SQLITE_TRANSIENT); sqlite3_free(zText); } break; } case SQLITE_TEXT: { int i,j; u64 n; const unsigned char *zArg = sqlite3_value_text(argv[0]); char *z; if( zArg==0 ) return; for(i=0, n=0; zArg[i]; i++){ if( zArg[i]=='\'' ) n++; } z = contextMalloc(context, ((i64)i)+((i64)n)+3); if( z ){ z[0] = '\''; for(i=0, j=1; zArg[i]; i++){ z[j++] = zArg[i]; if( zArg[i]=='\'' ){ z[j++] = '\''; } } z[j++] = '\''; z[j] = 0; sqlite3_result_text(context, z, j, sqlite3_free); } } } } static void hexFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){ int i, n; const unsigned char *pBlob; char *zHex, *z; assert( argc==1 ); UNUSED_PARAMETER(argc); pBlob = sqlite3_value_blob(argv[0]); n = sqlite3_value_bytes(argv[0]); assert( pBlob==sqlite3_value_blob(argv[0]) ); z = zHex = contextMalloc(context, ((i64)n)*2 + 1); if( zHex ){ for(i=0; i<n; i++, pBlob++){ unsigned char c = *pBlob; *(z++) = hexdigits[(c>>4)&0xf]; *(z++) = hexdigits[c&0xf]; } *z = 0; sqlite3_result_text(context, zHex, n*2, sqlite3_free); } } static void zeroblobFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){ i64 n; assert( argc==1 ); UNUSED_PARAMETER(argc); n = sqlite3_value_int64(argv[0]); if( n>SQLITE_MAX_LENGTH ){ sqlite3_result_error_toobig(context); }else{ sqlite3_result_zeroblob(context, n); } } static void replaceFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){ const unsigned char *zStr; const unsigned char *zPattern; const unsigned char *zRep; unsigned char *zOut; int nStr; int nPattern; int nRep; i64 nOut; int loopLimit; int i, j; assert( argc==3 ); UNUSED_PARAMETER(argc); zStr = sqlite3_value_text(argv[0]); if( zStr==0 ) return; nStr = sqlite3_value_bytes(argv[0]); assert( zStr==sqlite3_value_text(argv[0]) ); zPattern = sqlite3_value_text(argv[1]); if( zPattern==0 || zPattern[0]==0 ) return; nPattern = sqlite3_value_bytes(argv[1]); assert( zPattern==sqlite3_value_text(argv[1]) ); zRep = sqlite3_value_text(argv[2]); if( zRep==0 ) return; nRep = sqlite3_value_bytes(argv[2]); assert( zRep==sqlite3_value_text(argv[2]) ); nOut = nStr + 1; assert( nOut<SQLITE_MAX_LENGTH ); zOut = contextMalloc(context, (i64)nOut); if( zOut==0 ){ return; } loopLimit = nStr - nPattern; for(i=j=0; i<=loopLimit; i++){ if( zStr[i]!=zPattern[0] || memcmp(&zStr[i], zPattern, nPattern) ){ zOut[j++] = zStr[i]; }else{ u8 *zOld; sqlite3 *db = sqlite3_context_db_handle(context); nOut += nRep - nPattern; if( nOut>=db->aLimit[SQLITE_LIMIT_LENGTH] ){ sqlite3_result_error_toobig(context); sqlite3DbFree(db, zOut); return; } zOld = zOut; zOut = sqlite3_realloc(zOut, (int)nOut); if( zOut==0 ){ sqlite3_result_error_nomem(context); sqlite3DbFree(db, zOld); return; } memcpy(&zOut[j], zRep, nRep); j += nRep; i += nPattern-1; } } assert( j+nStr-i+1==nOut ); memcpy(&zOut[j], &zStr[i], nStr-i); j += nStr - i; assert( j<=nOut ); zOut[j] = 0; sqlite3_result_text(context, (char*)zOut, j, sqlite3_free); } static void trimFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){ const unsigned char *zIn; const unsigned char *zCharSet; int nIn; int flags; int i; unsigned char *aLen; unsigned char **azChar; int nChar; if( sqlite3_value_type(argv[0])==SQLITE_NULL ){ return; } zIn = sqlite3_value_text(argv[0]); if( zIn==0 ) return; nIn = sqlite3_value_bytes(argv[0]); assert( zIn==sqlite3_value_text(argv[0]) ); if( argc==1 ){ static const unsigned char lenOne[] = { 1 }; static unsigned char * const azOne[] = { (u8*)" " }; nChar = 1; aLen = (u8*)lenOne; azChar = (unsigned char **)azOne; zCharSet = 0; }else if( (zCharSet = sqlite3_value_text(argv[1]))==0 ){ return; }else{ const unsigned char *z; for(z=zCharSet, nChar=0; *z; nChar++){ SQLITE_SKIP_UTF8(z); } if( nChar>0 ){ azChar = contextMalloc(context, ((i64)nChar)*(sizeof(char*)+1)); if( azChar==0 ){ return; } aLen = (unsigned char*)&azChar[nChar]; for(z=zCharSet, nChar=0; *z; nChar++){ azChar[nChar] = (unsigned char *)z; SQLITE_SKIP_UTF8(z); aLen[nChar] = z - azChar[nChar]; } } } if( nChar>0 ){ flags = SQLITE_PTR_TO_INT(sqlite3_user_data(context)); if( flags & 1 ){ while( nIn>0 ){ int len; for(i=0; i<nChar; i++){ len = aLen[i]; if( memcmp(zIn, azChar[i], len)==0 ) break; } if( i>=nChar ) break; zIn += len; nIn -= len; } } if( flags & 2 ){ while( nIn>0 ){ int len; for(i=0; i<nChar; i++){ len = aLen[i]; if( len<=nIn && memcmp(&zIn[nIn-len],azChar[i],len)==0 ) break; } if( i>=nChar ) break; nIn -= len; } } if( zCharSet ){ sqlite3_free(azChar); } } sqlite3_result_text(context, (char*)zIn, nIn, SQLITE_TRANSIENT); } 
#ifdef SQLITE_SOUNDEX 
static void soundexFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){ char zResult[8]; const u8 *zIn; int i, j; static const unsigned char iCode[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 0, 1, 2, 0, 0, 2, 2, 4, 5, 5, 0, 1, 2, 6, 2, 3, 0, 1, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 0, 1, 2, 0, 0, 2, 2, 4, 5, 5, 0, 1, 2, 6, 2, 3, 0, 1, 0, 2, 0, 2, 0, 0, 0, 0, 0, }; assert( argc==1 ); zIn = (u8*)sqlite3_value_text(argv[0]); if( zIn==0 ) zIn = (u8*)""; for(i=0; zIn[i] && !isalpha(zIn[i]); i++){} if( zIn[i] ){ u8 prevcode = iCode[zIn[i]&0x7f]; zResult[0] = toupper(zIn[i]); for(j=1; j<4 && zIn[i]; i++){ int code = iCode[zIn[i]&0x7f]; if( code>0 ){ if( code!=prevcode ){ prevcode = code; zResult[j++] = code + '0'; } }else{ prevcode = 0; } } while( j<4 ){ zResult[j++] = '0'; } zResult[j] = 0; sqlite3_result_text(context, zResult, 4, SQLITE_TRANSIENT); }else{ sqlite3_result_text(context, "?000", 4, SQLITE_STATIC); } } 
#endif 
#ifndef SQLITE_OMIT_LOAD_EXTENSION 
static void loadExt(sqlite3_context *context, int argc, sqlite3_value **argv){ const char *zFile = (const char *)sqlite3_value_text(argv[0]); const char *zProc; sqlite3 *db = sqlite3_context_db_handle(context); char *zErrMsg = 0; if( argc==2 ){ zProc = (const char *)sqlite3_value_text(argv[1]); }else{ zProc = 0; } if( zFile && sqlite3_load_extension(db, zFile, zProc, &zErrMsg) ){ sqlite3_result_error(context, zErrMsg, -1); sqlite3_free(zErrMsg); } } 
#endif 
typedef struct SumCtx SumCtx; struct SumCtx { double rSum; i64 iSum; i64 cnt; u8 overflow; u8 approx; }; static void sumStep(sqlite3_context *context, int argc, sqlite3_value **argv){ SumCtx *p; int type; assert( argc==1 ); UNUSED_PARAMETER(argc); p = sqlite3_aggregate_context(context, sizeof(*p)); type = sqlite3_value_numeric_type(argv[0]); if( p && type!=SQLITE_NULL ){ p->cnt++; if( type==SQLITE_INTEGER ){ i64 v = sqlite3_value_int64(argv[0]); p->rSum += v; if( (p->approx|p->overflow)==0 ){ i64 iNewSum = p->iSum + v; int s1 = p->iSum >> (sizeof(i64)*8-1); int s2 = v >> (sizeof(i64)*8-1); int s3 = iNewSum >> (sizeof(i64)*8-1); p->overflow = (s1&s2&~s3) | (~s1&~s2&s3); p->iSum = iNewSum; } }else{ p->rSum += sqlite3_value_double(argv[0]); p->approx = 1; } } } static void sumFinalize(sqlite3_context *context){ SumCtx *p; p = sqlite3_aggregate_context(context, 0); if( p && p->cnt>0 ){ if( p->overflow ){ sqlite3_result_error(context,"integer overflow",-1); }else if( p->approx ){ sqlite3_result_double(context, p->rSum); }else{ sqlite3_result_int64(context, p->iSum); } } } static void avgFinalize(sqlite3_context *context){ SumCtx *p; p = sqlite3_aggregate_context(context, 0); if( p && p->cnt>0 ){ sqlite3_result_double(context, p->rSum/(double)p->cnt); } } static void totalFinalize(sqlite3_context *context){ SumCtx *p; p = sqlite3_aggregate_context(context, 0); sqlite3_result_double(context, p ? p->rSum : 0.0); } typedef struct CountCtx CountCtx; struct CountCtx { i64 n; }; static void countStep(sqlite3_context *context, int argc, sqlite3_value **argv){ CountCtx *p; p = sqlite3_aggregate_context(context, sizeof(*p)); if( (argc==0 || SQLITE_NULL!=sqlite3_value_type(argv[0])) && p ){ p->n++; } } static void countFinalize(sqlite3_context *context){ CountCtx *p; p = sqlite3_aggregate_context(context, 0); sqlite3_result_int64(context, p ? p->n : 0); } static void minmaxStep( sqlite3_context *context, int NotUsed, sqlite3_value **argv ){ Mem *pArg = (Mem *)argv[0]; Mem *pBest; UNUSED_PARAMETER(NotUsed); if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return; pBest = (Mem *)sqlite3_aggregate_context(context, sizeof(*pBest)); if( !pBest ) return; if( pBest->flags ){ int max; int cmp; CollSeq *pColl = sqlite3GetFuncCollSeq(context); max = sqlite3_user_data(context)!=0; cmp = sqlite3MemCompare(pBest, pArg, pColl); if( (max && cmp<0) || (!max && cmp>0) ){ sqlite3VdbeMemCopy(pBest, pArg); } }else{ sqlite3VdbeMemCopy(pBest, pArg); } } static void minMaxFinalize(sqlite3_context *context){ sqlite3_value *pRes; pRes = (sqlite3_value *)sqlite3_aggregate_context(context, 0); if( pRes ){ if( pRes->flags ){ sqlite3_result_value(context, pRes); } sqlite3VdbeMemRelease(pRes); } } static void groupConcatStep( sqlite3_context *context, int argc, sqlite3_value **argv ){ const char *zVal; StrAccum *pAccum; const char *zSep; int nVal, nSep, i; if( argc==0 || sqlite3_value_type(argv[0])==SQLITE_NULL ) return; pAccum = (StrAccum*)sqlite3_aggregate_context(context, sizeof(*pAccum)); if( pAccum ){ sqlite3 *db = sqlite3_context_db_handle(context); pAccum->useMalloc = 1; pAccum->mxAlloc = db->aLimit[SQLITE_LIMIT_LENGTH]; if( pAccum->nChar ){ if( argc>1 ){ zSep = (char*)sqlite3_value_text(argv[argc-1]); nSep = sqlite3_value_bytes(argv[argc-1]); }else{ zSep = ","; nSep = 1; } sqlite3StrAccumAppend(pAccum, zSep, nSep); } i = 0; do{ zVal = (char*)sqlite3_value_text(argv[i]); nVal = sqlite3_value_bytes(argv[i]); sqlite3StrAccumAppend(pAccum, zVal, nVal); i++; }while( i<argc-1 ); } } static void groupConcatFinalize(sqlite3_context *context){ StrAccum *pAccum; pAccum = sqlite3_aggregate_context(context, 0); if( pAccum ){ if( pAccum->tooBig ){ sqlite3_result_error_toobig(context); }else if( pAccum->mallocFailed ){ sqlite3_result_error_nomem(context); }else{ sqlite3_result_text(context, sqlite3StrAccumFinish(pAccum), -1, sqlite3_free); } } } SQLITE_PRIVATE void sqlite3RegisterBuiltinFunctions(sqlite3 *db){ 
#ifndef SQLITE_OMIT_ALTERTABLE 
 sqlite3AlterFunctions(db); 
#endif 
 if( !db->mallocFailed ){ int rc = sqlite3_overload_function(db, "MATCH", 2); assert( rc==SQLITE_NOMEM || rc==SQLITE_OK ); if( rc==SQLITE_NOMEM ){ db->mallocFailed = 1; } } 
#ifdef SQLITE_SSE 
 (void)sqlite3SseFunctions(db); 
#endif 
} static void setLikeOptFlag(sqlite3 *db, const char *zName, int flagVal){ FuncDef *pDef; pDef = sqlite3FindFunction(db, zName, strlen(zName), 2, SQLITE_UTF8, 0); if( pDef ){ pDef->flags = flagVal; } } SQLITE_PRIVATE void sqlite3RegisterLikeFunctions(sqlite3 *db, int caseSensitive){ struct compareInfo *pInfo; if( caseSensitive ){ pInfo = (struct compareInfo*)&likeInfoAlt; }else{ pInfo = (struct compareInfo*)&likeInfoNorm; } sqlite3CreateFunc(db, "like", 2, SQLITE_UTF8, pInfo, likeFunc, 0, 0); sqlite3CreateFunc(db, "like", 3, SQLITE_UTF8, pInfo, likeFunc, 0, 0); sqlite3CreateFunc(db, "glob", 2, SQLITE_UTF8, (struct compareInfo*)&globInfo, likeFunc, 0,0); setLikeOptFlag(db, "glob", SQLITE_FUNC_LIKE | SQLITE_FUNC_CASE); setLikeOptFlag(db, "like", caseSensitive ? (SQLITE_FUNC_LIKE | SQLITE_FUNC_CASE) : SQLITE_FUNC_LIKE); } SQLITE_PRIVATE int sqlite3IsLikeFunction(sqlite3 *db, Expr *pExpr, int *pIsNocase, char *aWc){ FuncDef *pDef; if( pExpr->op!=TK_FUNCTION || !pExpr->pList ){ return 0; } if( pExpr->pList->nExpr!=2 ){ return 0; } pDef = sqlite3FindFunction(db, (char*)pExpr->token.z, pExpr->token.n, 2, SQLITE_UTF8, 0); if( pDef==0 || (pDef->flags & SQLITE_FUNC_LIKE)==0 ){ return 0; } memcpy(aWc, pDef->pUserData, 3); assert( (char*)&likeInfoAlt == (char*)&likeInfoAlt.matchAll ); assert( &((char*)&likeInfoAlt)[1] == (char*)&likeInfoAlt.matchOne ); assert( &((char*)&likeInfoAlt)[2] == (char*)&likeInfoAlt.matchSet ); *pIsNocase = (pDef->flags & SQLITE_FUNC_CASE)==0; return 1; } SQLITE_PRIVATE void sqlite3RegisterGlobalFunctions(void){ static SQLITE_WSD FuncDef aBuiltinFunc[] = { FUNCTION(ltrim, 1, 1, 0, trimFunc ), FUNCTION(ltrim, 2, 1, 0, trimFunc ), FUNCTION(rtrim, 1, 2, 0, trimFunc ), FUNCTION(rtrim, 2, 2, 0, trimFunc ), FUNCTION(trim, 1, 3, 0, trimFunc ), FUNCTION(trim, 2, 3, 0, trimFunc ), FUNCTION(min, -1, 0, 1, minmaxFunc ), FUNCTION(min, 0, 0, 1, 0 ), AGGREGATE(min, 1, 0, 1, minmaxStep, minMaxFinalize ), FUNCTION(max, -1, 1, 1, minmaxFunc ), FUNCTION(max, 0, 1, 1, 0 ), AGGREGATE(max, 1, 1, 1, minmaxStep, minMaxFinalize ), FUNCTION(typeof, 1, 0, 0, typeofFunc ), FUNCTION(length, 1, 0, 0, lengthFunc ), FUNCTION(substr, 2, 0, 0, substrFunc ), FUNCTION(substr, 3, 0, 0, substrFunc ), FUNCTION(abs, 1, 0, 0, absFunc ), FUNCTION(round, 1, 0, 0, roundFunc ), FUNCTION(round, 2, 0, 0, roundFunc ), FUNCTION(upper, 1, 0, 0, upperFunc ), FUNCTION(lower, 1, 0, 0, lowerFunc ), FUNCTION(coalesce, 1, 0, 0, 0 ), FUNCTION(coalesce, -1, 0, 0, ifnullFunc ), FUNCTION(coalesce, 0, 0, 0, 0 ), FUNCTION(hex, 1, 0, 0, hexFunc ), FUNCTION(ifnull, 2, 0, 1, ifnullFunc ), FUNCTION(random, -1, 0, 0, randomFunc ), FUNCTION(randomblob, 1, 0, 0, randomBlob ), FUNCTION(nullif, 2, 0, 1, nullifFunc ), FUNCTION(sqlite_version, 0, 0, 0, versionFunc ), FUNCTION(quote, 1, 0, 0, quoteFunc ), FUNCTION(last_insert_rowid, 0, 0, 0, last_insert_rowid), FUNCTION(changes, 0, 0, 0, changes ), FUNCTION(total_changes, 0, 0, 0, total_changes ), FUNCTION(replace, 3, 0, 0, replaceFunc ), FUNCTION(zeroblob, 1, 0, 0, zeroblobFunc ), 
#ifdef SQLITE_SOUNDEX 
 FUNCTION(soundex, 1, 0, 0, soundexFunc ), 
#endif 
#ifndef SQLITE_OMIT_LOAD_EXTENSION 
 FUNCTION(load_extension, 1, 0, 0, loadExt ), FUNCTION(load_extension, 2, 0, 0, loadExt ), 
#endif 
 AGGREGATE(sum, 1, 0, 0, sumStep, sumFinalize ), AGGREGATE(total, 1, 0, 0, sumStep, totalFinalize ), AGGREGATE(avg, 1, 0, 0, sumStep, avgFinalize ), AGGREGATE(count, 0, 0, 0, countStep, countFinalize ), AGGREGATE(count, 1, 0, 0, countStep, countFinalize ), AGGREGATE(group_concat, -1, 0, 0, groupConcatStep, groupConcatFinalize), LIKEFUNC(glob, 2, &globInfo, SQLITE_FUNC_LIKE|SQLITE_FUNC_CASE), 
#ifdef SQLITE_CASE_SENSITIVE_LIKE 
 LIKEFUNC(like, 2, &likeInfoAlt, SQLITE_FUNC_LIKE|SQLITE_FUNC_CASE), LIKEFUNC(like, 3, &likeInfoAlt, SQLITE_FUNC_LIKE|SQLITE_FUNC_CASE), 
#else 
 LIKEFUNC(like, 2, &likeInfoNorm, SQLITE_FUNC_LIKE), LIKEFUNC(like, 3, &likeInfoNorm, SQLITE_FUNC_LIKE), 
#endif 
 }; int i; FuncDefHash *pHash = &GLOBAL(FuncDefHash, sqlite3GlobalFunctions); FuncDef *aFunc = (FuncDef*)&GLOBAL(FuncDef, aBuiltinFunc); for(i=0; i<ArraySize(aBuiltinFunc); i++){ sqlite3FuncDefInsert(pHash, &aFunc[i]); } sqlite3RegisterDateTimeFunctions(); } SQLITE_PRIVATE void sqlite3IndexAffinityStr(Vdbe *v, Index *pIdx){ if( !pIdx->zColAff ){ int n; Table *pTab = pIdx->pTable; sqlite3 *db = sqlite3VdbeDb(v); pIdx->zColAff = (char *)sqlite3Malloc(pIdx->nColumn+2); if( !pIdx->zColAff ){ db->mallocFailed = 1; return; } for(n=0; n<pIdx->nColumn; n++){ pIdx->zColAff[n] = pTab->aCol[pIdx->aiColumn[n]].affinity; } pIdx->zColAff[n++] = SQLITE_AFF_NONE; pIdx->zColAff[n] = 0; } sqlite3VdbeChangeP4(v, -1, pIdx->zColAff, 0); } SQLITE_PRIVATE void sqlite3TableAffinityStr(Vdbe *v, Table *pTab){ if( !pTab->zColAff ){ char *zColAff; int i; sqlite3 *db = sqlite3VdbeDb(v); zColAff = (char *)sqlite3Malloc(pTab->nCol+1); if( !zColAff ){ db->mallocFailed = 1; return; } for(i=0; i<pTab->nCol; i++){ zColAff[i] = pTab->aCol[i].affinity; } zColAff[pTab->nCol] = '\0'; pTab->zColAff = zColAff; } sqlite3VdbeChangeP4(v, -1, pTab->zColAff, 0); } static int readsTable(Vdbe *v, int iStartAddr, int iDb, Table *pTab){ int i; int iEnd = sqlite3VdbeCurrentAddr(v); for(i=iStartAddr; i<iEnd; i++){ VdbeOp *pOp = sqlite3VdbeGetOp(v, i); assert( pOp!=0 ); if( pOp->opcode==OP_OpenRead && pOp->p3==iDb ){ Index *pIndex; int tnum = pOp->p2; if( tnum==pTab->tnum ){ return 1; } for(pIndex=pTab->pIndex; pIndex; pIndex=pIndex->pNext){ if( tnum==pIndex->tnum ){ return 1; } } } 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 if( pOp->opcode==OP_VOpen && pOp->p4.pVtab==pTab->pVtab ){ assert( pOp->p4.pVtab!=0 ); assert( pOp->p4type==P4_VTAB ); return 1; } 
#endif 
 } return 0; } 
#ifndef SQLITE_OMIT_AUTOINCREMENT 
static int autoIncBegin( Parse *pParse, int iDb, Table *pTab ){ int memId = 0; if( pTab->tabFlags & TF_Autoincrement ){ Vdbe *v = pParse->pVdbe; Db *pDb = &pParse->db->aDb[iDb]; int iCur = pParse->nTab; int addr; assert( v ); pParse->nMem++; memId = ++pParse->nMem; pParse->nMem++; sqlite3OpenTable(pParse, iCur, iDb, pDb->pSchema->pSeqTab, OP_OpenRead); addr = sqlite3VdbeCurrentAddr(v); sqlite3VdbeAddOp4(v, OP_String8, 0, memId-1, 0, pTab->zName, 0); sqlite3VdbeAddOp2(v, OP_Rewind, iCur, addr+9); sqlite3VdbeAddOp3(v, OP_Column, iCur, 0, memId); sqlite3VdbeAddOp3(v, OP_Ne, memId-1, addr+7, memId); sqlite3VdbeChangeP5(v, SQLITE_JUMPIFNULL); sqlite3VdbeAddOp2(v, OP_Rowid, iCur, memId+1); sqlite3VdbeAddOp3(v, OP_Column, iCur, 1, memId); sqlite3VdbeAddOp2(v, OP_Goto, 0, addr+9); sqlite3VdbeAddOp2(v, OP_Next, iCur, addr+2); sqlite3VdbeAddOp2(v, OP_Integer, 0, memId); sqlite3VdbeAddOp2(v, OP_Close, iCur, 0); } return memId; } static void autoIncStep(Parse *pParse, int memId, int regRowid){ if( memId>0 ){ sqlite3VdbeAddOp2(pParse->pVdbe, OP_MemMax, memId, regRowid); } } static void autoIncEnd( Parse *pParse, int iDb, Table *pTab, int memId ){ if( pTab->tabFlags & TF_Autoincrement ){ int iCur = pParse->nTab; Vdbe *v = pParse->pVdbe; Db *pDb = &pParse->db->aDb[iDb]; int j1; int iRec = ++pParse->nMem; assert( v ); sqlite3OpenTable(pParse, iCur, iDb, pDb->pSchema->pSeqTab, OP_OpenWrite); j1 = sqlite3VdbeAddOp1(v, OP_NotNull, memId+1); sqlite3VdbeAddOp2(v, OP_NewRowid, iCur, memId+1); sqlite3VdbeJumpHere(v, j1); sqlite3VdbeAddOp3(v, OP_MakeRecord, memId-1, 2, iRec); sqlite3VdbeAddOp3(v, OP_Insert, iCur, iRec, memId+1); sqlite3VdbeChangeP5(v, OPFLAG_APPEND); sqlite3VdbeAddOp1(v, OP_Close, iCur); } } 
#else 
#define autoIncBegin(A,B,C) (0) 
#define autoIncStep(A,B,C) 
#define autoIncEnd(A,B,C,D) 
#endif 
static int xferOptimization( Parse *pParse, Table *pDest, Select *pSelect, int onError, int iDbDest ); SQLITE_PRIVATE void sqlite3Insert( Parse *pParse, SrcList *pTabList, ExprList *pList, Select *pSelect, IdList *pColumn, int onError ){ sqlite3 *db; Table *pTab; char *zTab; const char *zDb; int i, j, idx; Vdbe *v; Index *pIdx; int nColumn; int nHidden = 0; int baseCur = 0; int keyColumn = -1; int endOfLoop; int useTempTable = 0; int srcTab = 0; int addrInsTop = 0; int addrCont = 0; int addrSelect = 0; SelectDest dest; int newIdx = -1; int iDb; Db *pDb; int appendFlag = 0; int regFromSelect; int regAutoinc = 0; int regRowCount = 0; int regIns; int regRowid; int regData; int regRecord; int regEof; int *aRegIdx = 0; 
#ifndef SQLITE_OMIT_TRIGGER 
 int isView; int triggers_exist = 0; 
#endif 
 db = pParse->db; if( pParse->nErr || db->mallocFailed ){ goto insert_cleanup; } assert( pTabList->nSrc==1 ); zTab = pTabList->a[0].zName; if( zTab==0 ) goto insert_cleanup; pTab = sqlite3SrcListLookup(pParse, pTabList); if( pTab==0 ){ goto insert_cleanup; } iDb = sqlite3SchemaToIndex(db, pTab->pSchema); assert( iDb<db->nDb ); pDb = &db->aDb[iDb]; zDb = pDb->zName; if( sqlite3AuthCheck(pParse, SQLITE_INSERT, pTab->zName, 0, zDb) ){ goto insert_cleanup; } 
#ifndef SQLITE_OMIT_TRIGGER 
 triggers_exist = sqlite3TriggersExist(pTab, TK_INSERT, 0); isView = pTab->pSelect!=0; 
#else 
#define triggers_exist 0 
#define isView 0 
#endif 
#ifdef SQLITE_OMIT_VIEW 
#undef isView 
#define isView 0 
#endif 
 if( sqlite3IsReadOnly(pParse, pTab, triggers_exist) ){ goto insert_cleanup; } assert( pTab!=0 ); if( sqlite3ViewGetColumnNames(pParse, pTab) ){ goto insert_cleanup; } v = sqlite3GetVdbe(pParse); if( v==0 ) goto insert_cleanup; if( pParse->nested==0 ) sqlite3VdbeCountChanges(v); sqlite3BeginWriteOperation(pParse, pSelect || triggers_exist, iDb); if( triggers_exist ){ newIdx = pParse->nTab++; } 
#ifndef SQLITE_OMIT_XFER_OPT 
 if( pColumn==0 && xferOptimization(pParse, pTab, pSelect, onError, iDb) ){ assert( !triggers_exist ); assert( pList==0 ); goto insert_cleanup; } 
#endif 
 regAutoinc = autoIncBegin(pParse, iDb, pTab); if( pSelect ){ int rc, j1; regEof = ++pParse->nMem; sqlite3VdbeAddOp2(v, OP_Integer, 0, regEof); VdbeComment((v, "SELECT eof flag")); sqlite3SelectDestInit(&dest, SRT_Coroutine, ++pParse->nMem); addrSelect = sqlite3VdbeCurrentAddr(v)+2; sqlite3VdbeAddOp2(v, OP_Integer, addrSelect-1, dest.iParm); j1 = sqlite3VdbeAddOp2(v, OP_Goto, 0, 0); VdbeComment((v, "Jump over SELECT coroutine")); rc = sqlite3Select(pParse, pSelect, &dest); if( rc || pParse->nErr || db->mallocFailed ){ goto insert_cleanup; } sqlite3VdbeAddOp2(v, OP_Integer, 1, regEof); sqlite3VdbeAddOp1(v, OP_Yield, dest.iParm); sqlite3VdbeAddOp2(v, OP_Halt, SQLITE_INTERNAL, OE_Abort); VdbeComment((v, "End of SELECT coroutine")); sqlite3VdbeJumpHere(v, j1); regFromSelect = dest.iMem; assert( pSelect->pEList ); nColumn = pSelect->pEList->nExpr; assert( dest.nMem==nColumn ); if( triggers_exist || readsTable(v, addrSelect, iDb, pTab) ){ useTempTable = 1; } if( useTempTable ){ int regRec; int regRowid; int addrTop; int addrIf; srcTab = pParse->nTab++; regRec = sqlite3GetTempReg(pParse); regRowid = sqlite3GetTempReg(pParse); sqlite3VdbeAddOp2(v, OP_OpenEphemeral, srcTab, nColumn); addrTop = sqlite3VdbeAddOp1(v, OP_Yield, dest.iParm); addrIf = sqlite3VdbeAddOp1(v, OP_If, regEof); sqlite3VdbeAddOp3(v, OP_MakeRecord, regFromSelect, nColumn, regRec); sqlite3VdbeAddOp2(v, OP_NewRowid, srcTab, regRowid); sqlite3VdbeAddOp3(v, OP_Insert, srcTab, regRec, regRowid); sqlite3VdbeAddOp2(v, OP_Goto, 0, addrTop); sqlite3VdbeJumpHere(v, addrIf); sqlite3ReleaseTempReg(pParse, regRec); sqlite3ReleaseTempReg(pParse, regRowid); } }else{ NameContext sNC; memset(&sNC, 0, sizeof(sNC)); sNC.pParse = pParse; srcTab = -1; assert( useTempTable==0 ); nColumn = pList ? pList->nExpr : 0; for(i=0; i<nColumn; i++){ if( sqlite3ResolveExprNames(&sNC, pList->a[i].pExpr) ){ goto insert_cleanup; } } } if( IsVirtual(pTab) ){ for(i=0; i<pTab->nCol; i++){ nHidden += (IsHiddenColumn(&pTab->aCol[i]) ? 1 : 0); } } if( pColumn==0 && nColumn && nColumn!=(pTab->nCol-nHidden) ){ sqlite3ErrorMsg(pParse, "table %S has %d columns but %d values were supplied", pTabList, 0, pTab->nCol, nColumn); goto insert_cleanup; } if( pColumn!=0 && nColumn!=pColumn->nId ){ sqlite3ErrorMsg(pParse, "%d values for %d columns", nColumn, pColumn->nId); goto insert_cleanup; } if( pColumn ){ for(i=0; i<pColumn->nId; i++){ pColumn->a[i].idx = -1; } for(i=0; i<pColumn->nId; i++){ for(j=0; j<pTab->nCol; j++){ if( sqlite3StrICmp(pColumn->a[i].zName, pTab->aCol[j].zName)==0 ){ pColumn->a[i].idx = j; if( j==pTab->iPKey ){ keyColumn = i; } break; } } if( j>=pTab->nCol ){ if( sqlite3IsRowid(pColumn->a[i].zName) ){ keyColumn = i; }else{ sqlite3ErrorMsg(pParse, "table %S has no column named %s", pTabList, 0, pColumn->a[i].zName); pParse->nErr++; goto insert_cleanup; } } } } if( pColumn==0 && nColumn>0 ){ keyColumn = pTab->iPKey; } if( triggers_exist ){ sqlite3VdbeAddOp2(v, OP_SetNumColumns, 0, pTab->nCol); sqlite3VdbeAddOp2(v, OP_OpenPseudo, newIdx, 0); } if( db->flags & SQLITE_CountRows ){ regRowCount = ++pParse->nMem; sqlite3VdbeAddOp2(v, OP_Integer, 0, regRowCount); } if( !isView ){ int nIdx; int i; baseCur = pParse->nTab; nIdx = sqlite3OpenTableAndIndices(pParse, pTab, baseCur, OP_OpenWrite); aRegIdx = sqlite3DbMallocRaw(db, sizeof(int)*(nIdx+1)); if( aRegIdx==0 ){ goto insert_cleanup; } for(i=0; i<nIdx; i++){ aRegIdx[i] = ++pParse->nMem; } } if( useTempTable ){ addrInsTop = sqlite3VdbeAddOp1(v, OP_Rewind, srcTab); addrCont = sqlite3VdbeCurrentAddr(v); }else if( pSelect ){ addrCont = sqlite3VdbeAddOp1(v, OP_Yield, dest.iParm); addrInsTop = sqlite3VdbeAddOp1(v, OP_If, regEof); } regRecord = ++pParse->nMem; regRowid = regIns = pParse->nMem+1; pParse->nMem += pTab->nCol + 1; if( IsVirtual(pTab) ){ regRowid++; pParse->nMem++; } regData = regRowid+1; endOfLoop = sqlite3VdbeMakeLabel(v); if( triggers_exist & TRIGGER_BEFORE ){ int regRowid; int regCols; int regRec; regRowid = sqlite3GetTempReg(pParse); if( keyColumn<0 ){ sqlite3VdbeAddOp2(v, OP_Integer, -1, regRowid); }else if( useTempTable ){ sqlite3VdbeAddOp3(v, OP_Column, srcTab, keyColumn, regRowid); }else{ int j1; assert( pSelect==0 ); sqlite3ExprCode(pParse, pList->a[keyColumn].pExpr, regRowid); j1 = sqlite3VdbeAddOp1(v, OP_NotNull, regRowid); sqlite3VdbeAddOp2(v, OP_Integer, -1, regRowid); sqlite3VdbeJumpHere(v, j1); sqlite3VdbeAddOp1(v, OP_MustBeInt, regRowid); } assert(!IsVirtual(pTab)); regCols = sqlite3GetTempRange(pParse, pTab->nCol); for(i=0; i<pTab->nCol; i++){ if( pColumn==0 ){ j = i; }else{ for(j=0; j<pColumn->nId; j++){ if( pColumn->a[j].idx==i ) break; } } if( pColumn && j>=pColumn->nId ){ sqlite3ExprCode(pParse, pTab->aCol[i].pDflt, regCols+i); }else if( useTempTable ){ sqlite3VdbeAddOp3(v, OP_Column, srcTab, j, regCols+i); }else{ assert( pSelect==0 ); sqlite3ExprCodeAndCache(pParse, pList->a[j].pExpr, regCols+i); } } regRec = sqlite3GetTempReg(pParse); sqlite3VdbeAddOp3(v, OP_MakeRecord, regCols, pTab->nCol, regRec); if( !isView ){ sqlite3TableAffinityStr(v, pTab); } sqlite3VdbeAddOp3(v, OP_Insert, newIdx, regRec, regRowid); sqlite3ReleaseTempReg(pParse, regRec); sqlite3ReleaseTempReg(pParse, regRowid); sqlite3ReleaseTempRange(pParse, regCols, pTab->nCol); if( sqlite3CodeRowTrigger(pParse, TK_INSERT, 0, TRIGGER_BEFORE, pTab, newIdx, -1, onError, endOfLoop, 0, 0) ){ goto insert_cleanup; } } if( !isView ){ if( IsVirtual(pTab) ){ sqlite3VdbeAddOp2(v, OP_Null, 0, regIns); } if( keyColumn>=0 ){ if( useTempTable ){ sqlite3VdbeAddOp3(v, OP_Column, srcTab, keyColumn, regRowid); }else if( pSelect ){ sqlite3VdbeAddOp2(v, OP_SCopy, regFromSelect+keyColumn, regRowid); }else{ VdbeOp *pOp; sqlite3ExprCode(pParse, pList->a[keyColumn].pExpr, regRowid); pOp = sqlite3VdbeGetOp(v, sqlite3VdbeCurrentAddr(v) - 1); if( pOp && pOp->opcode==OP_Null && !IsVirtual(pTab) ){ appendFlag = 1; pOp->opcode = OP_NewRowid; pOp->p1 = baseCur; pOp->p2 = regRowid; pOp->p3 = regAutoinc; } } if( !appendFlag ){ int j1; if( !IsVirtual(pTab) ){ j1 = sqlite3VdbeAddOp1(v, OP_NotNull, regRowid); sqlite3VdbeAddOp3(v, OP_NewRowid, baseCur, regRowid, regAutoinc); sqlite3VdbeJumpHere(v, j1); }else{ j1 = sqlite3VdbeCurrentAddr(v); sqlite3VdbeAddOp2(v, OP_IsNull, regRowid, j1+2); } sqlite3VdbeAddOp1(v, OP_MustBeInt, regRowid); } }else if( IsVirtual(pTab) ){ sqlite3VdbeAddOp2(v, OP_Null, 0, regRowid); }else{ sqlite3VdbeAddOp3(v, OP_NewRowid, baseCur, regRowid, regAutoinc); appendFlag = 1; } autoIncStep(pParse, regAutoinc, regRowid); nHidden = 0; for(i=0; i<pTab->nCol; i++){ int iRegStore = regRowid+1+i; if( i==pTab->iPKey ){ sqlite3VdbeAddOp2(v, OP_Null, 0, iRegStore); continue; } if( pColumn==0 ){ if( IsHiddenColumn(&pTab->aCol[i]) ){ assert( IsVirtual(pTab) ); j = -1; nHidden++; }else{ j = i - nHidden; } }else{ for(j=0; j<pColumn->nId; j++){ if( pColumn->a[j].idx==i ) break; } } if( j<0 || nColumn==0 || (pColumn && j>=pColumn->nId) ){ sqlite3ExprCode(pParse, pTab->aCol[i].pDflt, iRegStore); }else if( useTempTable ){ sqlite3VdbeAddOp3(v, OP_Column, srcTab, j, iRegStore); }else if( pSelect ){ sqlite3VdbeAddOp2(v, OP_SCopy, regFromSelect+j, iRegStore); }else{ sqlite3ExprCode(pParse, pList->a[j].pExpr, iRegStore); } } 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 if( IsVirtual(pTab) ){ sqlite3VtabMakeWritable(pParse, pTab); sqlite3VdbeAddOp4(v, OP_VUpdate, 1, pTab->nCol+2, regIns, (const char*)pTab->pVtab, P4_VTAB); }else 
#endif 
 { sqlite3GenerateConstraintChecks( pParse, pTab, baseCur, regIns, aRegIdx, keyColumn>=0, 0, onError, endOfLoop ); sqlite3CompleteInsertion( pParse, pTab, baseCur, regIns, aRegIdx, 0, (triggers_exist & TRIGGER_AFTER)!=0 ? newIdx : -1, appendFlag ); } } if( (db->flags & SQLITE_CountRows)!=0 ){ sqlite3VdbeAddOp2(v, OP_AddImm, regRowCount, 1); } if( triggers_exist ){ if( sqlite3CodeRowTrigger(pParse, TK_INSERT, 0, TRIGGER_AFTER, pTab, newIdx, -1, onError, endOfLoop, 0, 0) ){ goto insert_cleanup; } } sqlite3VdbeResolveLabel(v, endOfLoop); if( useTempTable ){ sqlite3VdbeAddOp2(v, OP_Next, srcTab, addrCont); sqlite3VdbeJumpHere(v, addrInsTop); sqlite3VdbeAddOp1(v, OP_Close, srcTab); }else if( pSelect ){ sqlite3VdbeAddOp2(v, OP_Goto, 0, addrCont); sqlite3VdbeJumpHere(v, addrInsTop); } if( !IsVirtual(pTab) && !isView ){ sqlite3VdbeAddOp1(v, OP_Close, baseCur); for(idx=1, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, idx++){ sqlite3VdbeAddOp1(v, OP_Close, idx+baseCur); } } autoIncEnd(pParse, iDb, pTab, regAutoinc); if( db->flags & SQLITE_CountRows && pParse->nested==0 && !pParse->trigStack ){ sqlite3VdbeAddOp2(v, OP_ResultRow, regRowCount, 1); sqlite3VdbeSetNumCols(v, 1); sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "rows inserted", SQLITE_STATIC); } insert_cleanup: sqlite3SrcListDelete(db, pTabList); sqlite3ExprListDelete(db, pList); sqlite3SelectDelete(db, pSelect); sqlite3IdListDelete(db, pColumn); sqlite3DbFree(db, aRegIdx); } SQLITE_PRIVATE void sqlite3GenerateConstraintChecks( Parse *pParse, Table *pTab, int baseCur, int regRowid, int *aRegIdx, int rowidChng, int isUpdate, int overrideError, int ignoreDest ){ int i; Vdbe *v; int nCol; int onError; int j1, j2, j3; int regData; int iCur; Index *pIdx; int seenReplace = 0; int hasTwoRowids = (isUpdate && rowidChng); v = sqlite3GetVdbe(pParse); assert( v!=0 ); assert( pTab->pSelect==0 ); nCol = pTab->nCol; regData = regRowid + 1; for(i=0; i<nCol; i++){ if( i==pTab->iPKey ){ continue; } onError = pTab->aCol[i].notNull; if( onError==OE_None ) continue; if( overrideError!=OE_Default ){ onError = overrideError; }else if( onError==OE_Default ){ onError = OE_Abort; } if( onError==OE_Replace && pTab->aCol[i].pDflt==0 ){ onError = OE_Abort; } j1 = sqlite3VdbeAddOp1(v, OP_NotNull, regData+i); assert( onError==OE_Rollback || onError==OE_Abort || onError==OE_Fail || onError==OE_Ignore || onError==OE_Replace ); switch( onError ){ case OE_Rollback: case OE_Abort: case OE_Fail: { char *zMsg; sqlite3VdbeAddOp2(v, OP_Halt, SQLITE_CONSTRAINT, onError); zMsg = sqlite3MPrintf(pParse->db, "%s.%s may not be NULL", pTab->zName, pTab->aCol[i].zName); sqlite3VdbeChangeP4(v, -1, zMsg, P4_DYNAMIC); break; } case OE_Ignore: { sqlite3VdbeAddOp2(v, OP_Goto, 0, ignoreDest); break; } case OE_Replace: { sqlite3ExprCode(pParse, pTab->aCol[i].pDflt, regData+i); break; } } sqlite3VdbeJumpHere(v, j1); } 
#ifndef SQLITE_OMIT_CHECK 
 if( pTab->pCheck && (pParse->db->flags & SQLITE_IgnoreChecks)==0 ){ int allOk = sqlite3VdbeMakeLabel(v); pParse->ckBase = regData; sqlite3ExprIfTrue(pParse, pTab->pCheck, allOk, SQLITE_JUMPIFNULL); onError = overrideError!=OE_Default ? overrideError : OE_Abort; if( onError==OE_Ignore ){ sqlite3VdbeAddOp2(v, OP_Goto, 0, ignoreDest); }else{ sqlite3VdbeAddOp2(v, OP_Halt, SQLITE_CONSTRAINT, onError); } sqlite3VdbeResolveLabel(v, allOk); } 
#endif 
 if( rowidChng ){ onError = pTab->keyConf; if( overrideError!=OE_Default ){ onError = overrideError; }else if( onError==OE_Default ){ onError = OE_Abort; } if( onError!=OE_Replace || pTab->pIndex ){ if( isUpdate ){ j2 = sqlite3VdbeAddOp3(v, OP_Eq, regRowid, 0, regRowid-1); } j3 = sqlite3VdbeAddOp3(v, OP_NotExists, baseCur, 0, regRowid); switch( onError ){ default: { onError = OE_Abort; } case OE_Rollback: case OE_Abort: case OE_Fail: { sqlite3VdbeAddOp4(v, OP_Halt, SQLITE_CONSTRAINT, onError, 0, "PRIMARY KEY must be unique", P4_STATIC); break; } case OE_Replace: { sqlite3GenerateRowIndexDelete(pParse, pTab, baseCur, 0); seenReplace = 1; break; } case OE_Ignore: { assert( seenReplace==0 ); sqlite3VdbeAddOp2(v, OP_Goto, 0, ignoreDest); break; } } sqlite3VdbeJumpHere(v, j3); if( isUpdate ){ sqlite3VdbeJumpHere(v, j2); } } } for(iCur=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, iCur++){ int regIdx; int regR; if( aRegIdx[iCur]==0 ) continue; regIdx = sqlite3GetTempRange(pParse, pIdx->nColumn+1); for(i=0; i<pIdx->nColumn; i++){ int idx = pIdx->aiColumn[i]; if( idx==pTab->iPKey ){ sqlite3VdbeAddOp2(v, OP_SCopy, regRowid, regIdx+i); }else{ sqlite3VdbeAddOp2(v, OP_SCopy, regData+idx, regIdx+i); } } sqlite3VdbeAddOp2(v, OP_SCopy, regRowid, regIdx+i); sqlite3VdbeAddOp3(v, OP_MakeRecord, regIdx, pIdx->nColumn+1, aRegIdx[iCur]); sqlite3IndexAffinityStr(v, pIdx); sqlite3ExprCacheAffinityChange(pParse, regIdx, pIdx->nColumn+1); sqlite3ReleaseTempRange(pParse, regIdx, pIdx->nColumn+1); onError = pIdx->onError; if( onError==OE_None ) continue; if( overrideError!=OE_Default ){ onError = overrideError; }else if( onError==OE_Default ){ onError = OE_Abort; } if( seenReplace ){ if( onError==OE_Ignore ) onError = OE_Replace; else if( onError==OE_Fail ) onError = OE_Abort; } j2 = sqlite3VdbeAddOp3(v, OP_IsNull, regIdx, 0, pIdx->nColumn); regR = sqlite3GetTempReg(pParse); sqlite3VdbeAddOp2(v, OP_SCopy, regRowid-hasTwoRowids, regR); j3 = sqlite3VdbeAddOp4(v, OP_IsUnique, baseCur+iCur+1, 0, regR, SQLITE_INT_TO_PTR(aRegIdx[iCur]), P4_INT32); assert( onError==OE_Rollback || onError==OE_Abort || onError==OE_Fail || onError==OE_Ignore || onError==OE_Replace ); switch( onError ){ case OE_Rollback: case OE_Abort: case OE_Fail: { int j, n1, n2; char zErrMsg[200]; sqlite3_snprintf(ArraySize(zErrMsg), zErrMsg, pIdx->nColumn>1 ? "columns " : "column "); n1 = strlen(zErrMsg); for(j=0; j<pIdx->nColumn && n1<ArraySize(zErrMsg)-30; j++){ char *zCol = pTab->aCol[pIdx->aiColumn[j]].zName; n2 = strlen(zCol); if( j>0 ){ sqlite3_snprintf(ArraySize(zErrMsg)-n1, &zErrMsg[n1], ", "); n1 += 2; } if( n1+n2>ArraySize(zErrMsg)-30 ){ sqlite3_snprintf(ArraySize(zErrMsg)-n1, &zErrMsg[n1], "..."); n1 += 3; break; }else{ sqlite3_snprintf(ArraySize(zErrMsg)-n1, &zErrMsg[n1], "%s", zCol); n1 += n2; } } sqlite3_snprintf(ArraySize(zErrMsg)-n1, &zErrMsg[n1], pIdx->nColumn>1 ? " are not unique" : " is not unique"); sqlite3VdbeAddOp4(v, OP_Halt, SQLITE_CONSTRAINT, onError, 0, zErrMsg,0); break; } case OE_Ignore: { assert( seenReplace==0 ); sqlite3VdbeAddOp2(v, OP_Goto, 0, ignoreDest); break; } case OE_Replace: { sqlite3GenerateRowDelete(pParse, pTab, baseCur, regR, 0); seenReplace = 1; break; } } sqlite3VdbeJumpHere(v, j2); sqlite3VdbeJumpHere(v, j3); sqlite3ReleaseTempReg(pParse, regR); } } SQLITE_PRIVATE void sqlite3CompleteInsertion( Parse *pParse, Table *pTab, int baseCur, int regRowid, int *aRegIdx, int isUpdate, int newIdx, int appendBias ){ int i; Vdbe *v; int nIdx; Index *pIdx; int pik_flags; int regData; int regRec; v = sqlite3GetVdbe(pParse); assert( v!=0 ); assert( pTab->pSelect==0 ); for(nIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nIdx++){} for(i=nIdx-1; i>=0; i--){ if( aRegIdx[i]==0 ) continue; sqlite3VdbeAddOp2(v, OP_IdxInsert, baseCur+i+1, aRegIdx[i]); } regData = regRowid + 1; regRec = sqlite3GetTempReg(pParse); sqlite3VdbeAddOp3(v, OP_MakeRecord, regData, pTab->nCol, regRec); sqlite3TableAffinityStr(v, pTab); sqlite3ExprCacheAffinityChange(pParse, regData, pTab->nCol); 
#ifndef SQLITE_OMIT_TRIGGER 
 if( newIdx>=0 ){ sqlite3VdbeAddOp3(v, OP_Insert, newIdx, regRec, regRowid); } 
#endif 
 if( pParse->nested ){ pik_flags = 0; }else{ pik_flags = OPFLAG_NCHANGE; pik_flags |= (isUpdate?OPFLAG_ISUPDATE:OPFLAG_LASTROWID); } if( appendBias ){ pik_flags |= OPFLAG_APPEND; } sqlite3VdbeAddOp3(v, OP_Insert, baseCur, regRec, regRowid); if( !pParse->nested ){ sqlite3VdbeChangeP4(v, -1, pTab->zName, P4_STATIC); } sqlite3VdbeChangeP5(v, pik_flags); } SQLITE_PRIVATE int sqlite3OpenTableAndIndices( Parse *pParse, Table *pTab, int baseCur, int op ){ int i; int iDb; Index *pIdx; Vdbe *v; if( IsVirtual(pTab) ) return 0; iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema); v = sqlite3GetVdbe(pParse); assert( v!=0 ); sqlite3OpenTable(pParse, baseCur, iDb, pTab, op); for(i=1, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, i++){ KeyInfo *pKey = sqlite3IndexKeyinfo(pParse, pIdx); assert( pIdx->pSchema==pTab->pSchema ); sqlite3VdbeAddOp4(v, op, i+baseCur, pIdx->tnum, iDb, (char*)pKey, P4_KEYINFO_HANDOFF); VdbeComment((v, "%s", pIdx->zName)); } if( pParse->nTab<=baseCur+i ){ pParse->nTab = baseCur+i; } return i-1; } 
#ifdef SQLITE_TEST 
SQLITE_API int sqlite3_xferopt_count; 
#endif 
#ifndef SQLITE_OMIT_XFER_OPT 
static int xferCompatibleCollation(const char *z1, const char *z2){ if( z1==0 ){ return z2==0; } if( z2==0 ){ return 0; } return sqlite3StrICmp(z1, z2)==0; } static int xferCompatibleIndex(Index *pDest, Index *pSrc){ int i; assert( pDest && pSrc ); assert( pDest->pTable!=pSrc->pTable ); if( pDest->nColumn!=pSrc->nColumn ){ return 0; } if( pDest->onError!=pSrc->onError ){ return 0; } for(i=0; i<pSrc->nColumn; i++){ if( pSrc->aiColumn[i]!=pDest->aiColumn[i] ){ return 0; } if( pSrc->aSortOrder[i]!=pDest->aSortOrder[i] ){ return 0; } if( pSrc->azColl[i]!=pDest->azColl[i] ){ return 0; } } return 1; } static int xferOptimization( Parse *pParse, Table *pDest, Select *pSelect, int onError, int iDbDest ){ ExprList *pEList; Table *pSrc; Index *pSrcIdx, *pDestIdx; struct SrcList_item *pItem; int i; int iDbSrc; int iSrc, iDest; int addr1, addr2; int emptyDestTest; int emptySrcTest; Vdbe *v; KeyInfo *pKey; int regAutoinc; int destHasUniqueIdx = 0; int regData, regRowid; if( pSelect==0 ){ return 0; } if( pDest->pTrigger ){ return 0; } 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 if( pDest->tabFlags & TF_Virtual ){ return 0; } 
#endif 
 if( onError==OE_Default ){ onError = OE_Abort; } if( onError!=OE_Abort && onError!=OE_Rollback ){ return 0; } assert(pSelect->pSrc); if( pSelect->pSrc->nSrc!=1 ){ return 0; } if( pSelect->pSrc->a[0].pSelect ){ return 0; } if( pSelect->pWhere ){ return 0; } if( pSelect->pOrderBy ){ return 0; } if( pSelect->pGroupBy ){ return 0; } if( pSelect->pLimit ){ return 0; } assert( pSelect->pOffset==0 ); if( pSelect->pPrior ){ return 0; } if( pSelect->selFlags & SF_Distinct ){ return 0; } pEList = pSelect->pEList; assert( pEList!=0 ); if( pEList->nExpr!=1 ){ return 0; } assert( pEList->a[0].pExpr ); if( pEList->a[0].pExpr->op!=TK_ALL ){ return 0; } pItem = pSelect->pSrc->a; pSrc = sqlite3LocateTable(pParse, 0, pItem->zName, pItem->zDatabase); if( pSrc==0 ){ return 0; } if( pSrc==pDest ){ return 0; } 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 if( pSrc->tabFlags & TF_Virtual ){ return 0; } 
#endif 
 if( pSrc->pSelect ){ return 0; } if( pDest->nCol!=pSrc->nCol ){ return 0; } if( pDest->iPKey!=pSrc->iPKey ){ return 0; } for(i=0; i<pDest->nCol; i++){ if( pDest->aCol[i].affinity!=pSrc->aCol[i].affinity ){ return 0; } if( !xferCompatibleCollation(pDest->aCol[i].zColl, pSrc->aCol[i].zColl) ){ return 0; } if( pDest->aCol[i].notNull && !pSrc->aCol[i].notNull ){ return 0; } } for(pDestIdx=pDest->pIndex; pDestIdx; pDestIdx=pDestIdx->pNext){ if( pDestIdx->onError!=OE_None ){ destHasUniqueIdx = 1; } for(pSrcIdx=pSrc->pIndex; pSrcIdx; pSrcIdx=pSrcIdx->pNext){ if( xferCompatibleIndex(pDestIdx, pSrcIdx) ) break; } if( pSrcIdx==0 ){ return 0; } } 
#ifndef SQLITE_OMIT_CHECK 
 if( pDest->pCheck && !sqlite3ExprCompare(pSrc->pCheck, pDest->pCheck) ){ return 0; } 
#endif 
 
#ifdef SQLITE_TEST 
 sqlite3_xferopt_count++; 
#endif 
 iDbSrc = sqlite3SchemaToIndex(pParse->db, pSrc->pSchema); v = sqlite3GetVdbe(pParse); sqlite3CodeVerifySchema(pParse, iDbSrc); iSrc = pParse->nTab++; iDest = pParse->nTab++; regAutoinc = autoIncBegin(pParse, iDbDest, pDest); sqlite3OpenTable(pParse, iDest, iDbDest, pDest, OP_OpenWrite); if( (pDest->iPKey<0 && pDest->pIndex!=0) || destHasUniqueIdx ){ addr1 = sqlite3VdbeAddOp2(v, OP_Rewind, iDest, 0); emptyDestTest = sqlite3VdbeAddOp2(v, OP_Goto, 0, 0); sqlite3VdbeJumpHere(v, addr1); }else{ emptyDestTest = 0; } sqlite3OpenTable(pParse, iSrc, iDbSrc, pSrc, OP_OpenRead); emptySrcTest = sqlite3VdbeAddOp2(v, OP_Rewind, iSrc, 0); regData = sqlite3GetTempReg(pParse); regRowid = sqlite3GetTempReg(pParse); if( pDest->iPKey>=0 ){ addr1 = sqlite3VdbeAddOp2(v, OP_Rowid, iSrc, regRowid); addr2 = sqlite3VdbeAddOp3(v, OP_NotExists, iDest, 0, regRowid); sqlite3VdbeAddOp4(v, OP_Halt, SQLITE_CONSTRAINT, onError, 0, "PRIMARY KEY must be unique", P4_STATIC); sqlite3VdbeJumpHere(v, addr2); autoIncStep(pParse, regAutoinc, regRowid); }else if( pDest->pIndex==0 ){ addr1 = sqlite3VdbeAddOp2(v, OP_NewRowid, iDest, regRowid); }else{ addr1 = sqlite3VdbeAddOp2(v, OP_Rowid, iSrc, regRowid); assert( (pDest->tabFlags & TF_Autoincrement)==0 ); } sqlite3VdbeAddOp2(v, OP_RowData, iSrc, regData); sqlite3VdbeAddOp3(v, OP_Insert, iDest, regData, regRowid); sqlite3VdbeChangeP5(v, OPFLAG_NCHANGE|OPFLAG_LASTROWID|OPFLAG_APPEND); sqlite3VdbeChangeP4(v, -1, pDest->zName, 0); sqlite3VdbeAddOp2(v, OP_Next, iSrc, addr1); autoIncEnd(pParse, iDbDest, pDest, regAutoinc); for(pDestIdx=pDest->pIndex; pDestIdx; pDestIdx=pDestIdx->pNext){ for(pSrcIdx=pSrc->pIndex; pSrcIdx; pSrcIdx=pSrcIdx->pNext){ if( xferCompatibleIndex(pDestIdx, pSrcIdx) ) break; } assert( pSrcIdx ); sqlite3VdbeAddOp2(v, OP_Close, iSrc, 0); sqlite3VdbeAddOp2(v, OP_Close, iDest, 0); pKey = sqlite3IndexKeyinfo(pParse, pSrcIdx); sqlite3VdbeAddOp4(v, OP_OpenRead, iSrc, pSrcIdx->tnum, iDbSrc, (char*)pKey, P4_KEYINFO_HANDOFF); VdbeComment((v, "%s", pSrcIdx->zName)); pKey = sqlite3IndexKeyinfo(pParse, pDestIdx); sqlite3VdbeAddOp4(v, OP_OpenWrite, iDest, pDestIdx->tnum, iDbDest, (char*)pKey, P4_KEYINFO_HANDOFF); VdbeComment((v, "%s", pDestIdx->zName)); addr1 = sqlite3VdbeAddOp2(v, OP_Rewind, iSrc, 0); sqlite3VdbeAddOp2(v, OP_RowKey, iSrc, regData); sqlite3VdbeAddOp3(v, OP_IdxInsert, iDest, regData, 1); sqlite3VdbeAddOp2(v, OP_Next, iSrc, addr1+1); sqlite3VdbeJumpHere(v, addr1); } sqlite3VdbeJumpHere(v, emptySrcTest); sqlite3ReleaseTempReg(pParse, regRowid); sqlite3ReleaseTempReg(pParse, regData); sqlite3VdbeAddOp2(v, OP_Close, iSrc, 0); sqlite3VdbeAddOp2(v, OP_Close, iDest, 0); if( emptyDestTest ){ sqlite3VdbeAddOp2(v, OP_Halt, SQLITE_OK, 0); sqlite3VdbeJumpHere(v, emptyDestTest); sqlite3VdbeAddOp2(v, OP_Close, iDest, 0); return 0; }else{ return 1; } } 
#endif 
#undef isView 
SQLITE_API int sqlite3_exec( sqlite3 *db, const char *zSql, sqlite3_callback xCallback, void *pArg, char **pzErrMsg ){ int rc = SQLITE_OK; const char *zLeftover; sqlite3_stmt *pStmt = 0; char **azCols = 0; int nRetry = 0; int nCallback; if( zSql==0 ) zSql = ""; sqlite3_mutex_enter(db->mutex); sqlite3Error(db, SQLITE_OK, 0); while( (rc==SQLITE_OK || (rc==SQLITE_SCHEMA && (++nRetry)<2)) && zSql[0] ){ int nCol; char **azVals = 0; pStmt = 0; rc = sqlite3_prepare(db, zSql, -1, &pStmt, &zLeftover); assert( rc==SQLITE_OK || pStmt==0 ); if( rc!=SQLITE_OK ){ continue; } if( !pStmt ){ zSql = zLeftover; continue; } nCallback = 0; nCol = sqlite3_column_count(pStmt); while( 1 ){ int i; rc = sqlite3_step(pStmt); if( xCallback && (SQLITE_ROW==rc || (SQLITE_DONE==rc && !nCallback && db->flags&SQLITE_NullCallback)) ){ if( 0==nCallback ){ if( azCols==0 ){ azCols = sqlite3DbMallocZero(db, 2*nCol*sizeof(const char*) + 1); if( azCols==0 ){ goto exec_out; } } for(i=0; i<nCol; i++){ azCols[i] = (char *)sqlite3_column_name(pStmt, i); assert( azCols[i]!=0 ); } nCallback++; } if( rc==SQLITE_ROW ){ azVals = &azCols[nCol]; for(i=0; i<nCol; i++){ azVals[i] = (char *)sqlite3_column_text(pStmt, i); if( !azVals[i] && sqlite3_column_type(pStmt, i)!=SQLITE_NULL ){ db->mallocFailed = 1; goto exec_out; } } } if( xCallback(pArg, nCol, azVals, azCols) ){ rc = SQLITE_ABORT; sqlite3_finalize(pStmt); pStmt = 0; sqlite3Error(db, SQLITE_ABORT, 0); goto exec_out; } } if( rc!=SQLITE_ROW ){ rc = sqlite3_finalize(pStmt); pStmt = 0; if( rc!=SQLITE_SCHEMA ){ nRetry = 0; zSql = zLeftover; while( isspace((unsigned char)zSql[0]) ) zSql++; } break; } } sqlite3DbFree(db, azCols); azCols = 0; } exec_out: if( pStmt ) sqlite3_finalize(pStmt); sqlite3DbFree(db, azCols); rc = sqlite3ApiExit(db, rc); if( rc!=SQLITE_OK && rc==sqlite3_errcode(db) && pzErrMsg ){ int nErrMsg = 1 + strlen(sqlite3_errmsg(db)); *pzErrMsg = sqlite3Malloc(nErrMsg); if( *pzErrMsg ){ memcpy(*pzErrMsg, sqlite3_errmsg(db), nErrMsg); } }else if( pzErrMsg ){ *pzErrMsg = 0; } assert( (rc&db->errMask)==rc ); sqlite3_mutex_leave(db->mutex); return rc; } 
#ifndef SQLITE_CORE 
#define SQLITE_CORE 1 
#endif 
#ifndef _SQLITE3EXT_H_ 
#define _SQLITE3EXT_H_ 
typedef struct sqlite3_api_routines sqlite3_api_routines; struct sqlite3_api_routines { void * (*aggregate_context)(sqlite3_context*,int nBytes); int (*aggregate_count)(sqlite3_context*); int (*bind_blob)(sqlite3_stmt*,int,const void*,int n,void(*)(void*)); int (*bind_double)(sqlite3_stmt*,int,double); int (*bind_int)(sqlite3_stmt*,int,int); int (*bind_int64)(sqlite3_stmt*,int,sqlite_int64); int (*bind_null)(sqlite3_stmt*,int); int (*bind_parameter_count)(sqlite3_stmt*); int (*bind_parameter_index)(sqlite3_stmt*,const char*zName); const char * (*bind_parameter_name)(sqlite3_stmt*,int); int (*bind_text)(sqlite3_stmt*,int,const char*,int n,void(*)(void*)); int (*bind_text16)(sqlite3_stmt*,int,const void*,int,void(*)(void*)); int (*bind_value)(sqlite3_stmt*,int,const sqlite3_value*); int (*busy_handler)(sqlite3*,int(*)(void*,int),void*); int (*busy_timeout)(sqlite3*,int ms); int (*changes)(sqlite3*); int (*close)(sqlite3*); int (*collation_needed)(sqlite3*,void*,void(*)(void*,sqlite3*,int eTextRep,const char*)); int (*collation_needed16)(sqlite3*,void*,void(*)(void*,sqlite3*,int eTextRep,const void*)); const void * (*column_blob)(sqlite3_stmt*,int iCol); int (*column_bytes)(sqlite3_stmt*,int iCol); int (*column_bytes16)(sqlite3_stmt*,int iCol); int (*column_count)(sqlite3_stmt*pStmt); const char * (*column_database_name)(sqlite3_stmt*,int); const void * (*column_database_name16)(sqlite3_stmt*,int); const char * (*column_decltype)(sqlite3_stmt*,int i); const void * (*column_decltype16)(sqlite3_stmt*,int); double (*column_double)(sqlite3_stmt*,int iCol); int (*column_int)(sqlite3_stmt*,int iCol); sqlite_int64 (*column_int64)(sqlite3_stmt*,int iCol); const char * (*column_name)(sqlite3_stmt*,int); const void * (*column_name16)(sqlite3_stmt*,int); const char * (*column_origin_name)(sqlite3_stmt*,int); const void * (*column_origin_name16)(sqlite3_stmt*,int); const char * (*column_table_name)(sqlite3_stmt*,int); const void * (*column_table_name16)(sqlite3_stmt*,int); const unsigned char * (*column_text)(sqlite3_stmt*,int iCol); const void * (*column_text16)(sqlite3_stmt*,int iCol); int (*column_type)(sqlite3_stmt*,int iCol); sqlite3_value* (*column_value)(sqlite3_stmt*,int iCol); void * (*commit_hook)(sqlite3*,int(*)(void*),void*); int (*complete)(const char*sql); int (*complete16)(const void*sql); int (*create_collation)(sqlite3*,const char*,int,void*,int(*)(void*,int,const void*,int,const void*)); int (*create_collation16)(sqlite3*,const void*,int,void*,int(*)(void*,int,const void*,int,const void*)); int (*create_function)(sqlite3*,const char*,int,int,void*,void (*xFunc)(sqlite3_context*,int,sqlite3_value**),void (*xStep)(sqlite3_context*,int,sqlite3_value**),void (*xFinal)(sqlite3_context*)); int (*create_function16)(sqlite3*,const void*,int,int,void*,void (*xFunc)(sqlite3_context*,int,sqlite3_value**),void (*xStep)(sqlite3_context*,int,sqlite3_value**),void (*xFinal)(sqlite3_context*)); int (*create_module)(sqlite3*,const char*,const sqlite3_module*,void*); int (*data_count)(sqlite3_stmt*pStmt); sqlite3 * (*db_handle)(sqlite3_stmt*); int (*declare_vtab)(sqlite3*,const char*); int (*enable_shared_cache)(int); int (*errcode)(sqlite3*db); const char * (*errmsg)(sqlite3*); const void * (*errmsg16)(sqlite3*); int (*exec)(sqlite3*,const char*,sqlite3_callback,void*,char**); int (*expired)(sqlite3_stmt*); int (*finalize)(sqlite3_stmt*pStmt); void (*free)(void*); void (*free_table)(char**result); int (*get_autocommit)(sqlite3*); void * (*get_auxdata)(sqlite3_context*,int); int (*get_table)(sqlite3*,const char*,char***,int*,int*,char**); int (*global_recover)(void); void (*interruptx)(sqlite3*); sqlite_int64 (*last_insert_rowid)(sqlite3*); const char * (*libversion)(void); int (*libversion_number)(void); void *(*malloc)(int); char * (*mprintf)(const char*,...); int (*open)(const char*,sqlite3**); int (*open16)(const void*,sqlite3**); int (*prepare)(sqlite3*,const char*,int,sqlite3_stmt**,const char**); int (*prepare16)(sqlite3*,const void*,int,sqlite3_stmt**,const void**); void * (*profile)(sqlite3*,void(*)(void*,const char*,sqlite_uint64),void*); void (*progress_handler)(sqlite3*,int,int(*)(void*),void*); void *(*realloc)(void*,int); int (*reset)(sqlite3_stmt*pStmt); void (*result_blob)(sqlite3_context*,const void*,int,void(*)(void*)); void (*result_double)(sqlite3_context*,double); void (*result_error)(sqlite3_context*,const char*,int); void (*result_error16)(sqlite3_context*,const void*,int); void (*result_int)(sqlite3_context*,int); void (*result_int64)(sqlite3_context*,sqlite_int64); void (*result_null)(sqlite3_context*); void (*result_text)(sqlite3_context*,const char*,int,void(*)(void*)); void (*result_text16)(sqlite3_context*,const void*,int,void(*)(void*)); void (*result_text16be)(sqlite3_context*,const void*,int,void(*)(void*)); void (*result_text16le)(sqlite3_context*,const void*,int,void(*)(void*)); void (*result_value)(sqlite3_context*,sqlite3_value*); void * (*rollback_hook)(sqlite3*,void(*)(void*),void*); int (*set_authorizer)(sqlite3*,int(*)(void*,int,const char*,const char*,const char*,const char*),void*); void (*set_auxdata)(sqlite3_context*,int,void*,void (*)(void*)); char * (*snprintf)(int,char*,const char*,...); int (*step)(sqlite3_stmt*); int (*table_column_metadata)(sqlite3*,const char*,const char*,const char*,char const**,char const**,int*,int*,int*); void (*thread_cleanup)(void); int (*total_changes)(sqlite3*); void * (*trace)(sqlite3*,void(*xTrace)(void*,const char*),void*); int (*transfer_bindings)(sqlite3_stmt*,sqlite3_stmt*); void * (*update_hook)(sqlite3*,void(*)(void*,int ,char const*,char const*,sqlite_int64),void*); void * (*user_data)(sqlite3_context*); const void * (*value_blob)(sqlite3_value*); int (*value_bytes)(sqlite3_value*); int (*value_bytes16)(sqlite3_value*); double (*value_double)(sqlite3_value*); int (*value_int)(sqlite3_value*); sqlite_int64 (*value_int64)(sqlite3_value*); int (*value_numeric_type)(sqlite3_value*); const unsigned char * (*value_text)(sqlite3_value*); const void * (*value_text16)(sqlite3_value*); const void * (*value_text16be)(sqlite3_value*); const void * (*value_text16le)(sqlite3_value*); int (*value_type)(sqlite3_value*); char *(*vmprintf)(const char*,va_list); int (*overload_function)(sqlite3*, const char *zFuncName, int nArg); int (*prepare_v2)(sqlite3*,const char*,int,sqlite3_stmt**,const char**); int (*prepare16_v2)(sqlite3*,const void*,int,sqlite3_stmt**,const void**); int (*clear_bindings)(sqlite3_stmt*); int (*create_module_v2)(sqlite3*,const char*,const sqlite3_module*,void*,void (*xDestroy)(void *)); int (*bind_zeroblob)(sqlite3_stmt*,int,int); int (*blob_bytes)(sqlite3_blob*); int (*blob_close)(sqlite3_blob*); int (*blob_open)(sqlite3*,const char*,const char*,const char*,sqlite3_int64,int,sqlite3_blob**); int (*blob_read)(sqlite3_blob*,void*,int,int); int (*blob_write)(sqlite3_blob*,const void*,int,int); int (*create_collation_v2)(sqlite3*,const char*,int,void*,int(*)(void*,int,const void*,int,const void*),void(*)(void*)); int (*file_control)(sqlite3*,const char*,int,void*); sqlite3_int64 (*memory_highwater)(int); sqlite3_int64 (*memory_used)(void); sqlite3_mutex *(*mutex_alloc)(int); void (*mutex_enter)(sqlite3_mutex*); void (*mutex_free)(sqlite3_mutex*); void (*mutex_leave)(sqlite3_mutex*); int (*mutex_try)(sqlite3_mutex*); int (*open_v2)(const char*,sqlite3**,int,const char*); int (*release_memory)(int); void (*result_error_nomem)(sqlite3_context*); void (*result_error_toobig)(sqlite3_context*); int (*sleep)(int); void (*soft_heap_limit)(int); sqlite3_vfs *(*vfs_find)(const char*); int (*vfs_register)(sqlite3_vfs*,int); int (*vfs_unregister)(sqlite3_vfs*); int (*xthreadsafe)(void); void (*result_zeroblob)(sqlite3_context*,int); void (*result_error_code)(sqlite3_context*,int); int (*test_control)(int, ...); void (*randomness)(int,void*); sqlite3 *(*context_db_handle)(sqlite3_context*); int (*extended_result_codes)(sqlite3*,int); int (*limit)(sqlite3*,int,int); sqlite3_stmt *(*next_stmt)(sqlite3*,sqlite3_stmt*); const char *(*sql)(sqlite3_stmt*); int (*status)(int,int*,int*,int); }; 
#ifndef SQLITE_CORE 
#define sqlite3_aggregate_context sqlite3_api->aggregate_context 
#ifndef SQLITE_OMIT_DEPRECATED 
#define sqlite3_aggregate_count sqlite3_api->aggregate_count 
#endif 
#define sqlite3_bind_blob sqlite3_api->bind_blob 
#define sqlite3_bind_double sqlite3_api->bind_double 
#define sqlite3_bind_int sqlite3_api->bind_int 
#define sqlite3_bind_int64 sqlite3_api->bind_int64 
#define sqlite3_bind_null sqlite3_api->bind_null 
#define sqlite3_bind_parameter_count sqlite3_api->bind_parameter_count 
#define sqlite3_bind_parameter_index sqlite3_api->bind_parameter_index 
#define sqlite3_bind_parameter_name sqlite3_api->bind_parameter_name 
#define sqlite3_bind_text sqlite3_api->bind_text 
#define sqlite3_bind_text16 sqlite3_api->bind_text16 
#define sqlite3_bind_value sqlite3_api->bind_value 
#define sqlite3_busy_handler sqlite3_api->busy_handler 
#define sqlite3_busy_timeout sqlite3_api->busy_timeout 
#define sqlite3_changes sqlite3_api->changes 
#define sqlite3_close sqlite3_api->close 
#define sqlite3_collation_needed sqlite3_api->collation_needed 
#define sqlite3_collation_needed16 sqlite3_api->collation_needed16 
#define sqlite3_column_blob sqlite3_api->column_blob 
#define sqlite3_column_bytes sqlite3_api->column_bytes 
#define sqlite3_column_bytes16 sqlite3_api->column_bytes16 
#define sqlite3_column_count sqlite3_api->column_count 
#define sqlite3_column_database_name sqlite3_api->column_database_name 
#define sqlite3_column_database_name16 sqlite3_api->column_database_name16 
#define sqlite3_column_decltype sqlite3_api->column_decltype 
#define sqlite3_column_decltype16 sqlite3_api->column_decltype16 
#define sqlite3_column_double sqlite3_api->column_double 
#define sqlite3_column_int sqlite3_api->column_int 
#define sqlite3_column_int64 sqlite3_api->column_int64 
#define sqlite3_column_name sqlite3_api->column_name 
#define sqlite3_column_name16 sqlite3_api->column_name16 
#define sqlite3_column_origin_name sqlite3_api->column_origin_name 
#define sqlite3_column_origin_name16 sqlite3_api->column_origin_name16 
#define sqlite3_column_table_name sqlite3_api->column_table_name 
#define sqlite3_column_table_name16 sqlite3_api->column_table_name16 
#define sqlite3_column_text sqlite3_api->column_text 
#define sqlite3_column_text16 sqlite3_api->column_text16 
#define sqlite3_column_type sqlite3_api->column_type 
#define sqlite3_column_value sqlite3_api->column_value 
#define sqlite3_commit_hook sqlite3_api->commit_hook 
#define sqlite3_complete sqlite3_api->complete 
#define sqlite3_complete16 sqlite3_api->complete16 
#define sqlite3_create_collation sqlite3_api->create_collation 
#define sqlite3_create_collation16 sqlite3_api->create_collation16 
#define sqlite3_create_function sqlite3_api->create_function 
#define sqlite3_create_function16 sqlite3_api->create_function16 
#define sqlite3_create_module sqlite3_api->create_module 
#define sqlite3_create_module_v2 sqlite3_api->create_module_v2 
#define sqlite3_data_count sqlite3_api->data_count 
#define sqlite3_db_handle sqlite3_api->db_handle 
#define sqlite3_declare_vtab sqlite3_api->declare_vtab 
#define sqlite3_enable_shared_cache sqlite3_api->enable_shared_cache 
#define sqlite3_errcode sqlite3_api->errcode 
#define sqlite3_errmsg sqlite3_api->errmsg 
#define sqlite3_errmsg16 sqlite3_api->errmsg16 
#define sqlite3_exec sqlite3_api->exec 
#ifndef SQLITE_OMIT_DEPRECATED 
#define sqlite3_expired sqlite3_api->expired 
#endif 
#define sqlite3_finalize sqlite3_api->finalize 
#define sqlite3_free sqlite3_api->free 
#define sqlite3_free_table sqlite3_api->free_table 
#define sqlite3_get_autocommit sqlite3_api->get_autocommit 
#define sqlite3_get_auxdata sqlite3_api->get_auxdata 
#define sqlite3_get_table sqlite3_api->get_table 
#ifndef SQLITE_OMIT_DEPRECATED 
#define sqlite3_global_recover sqlite3_api->global_recover 
#endif 
#define sqlite3_interrupt sqlite3_api->interruptx 
#define sqlite3_last_insert_rowid sqlite3_api->last_insert_rowid 
#define sqlite3_libversion sqlite3_api->libversion 
#define sqlite3_libversion_number sqlite3_api->libversion_number 
#define sqlite3_malloc sqlite3_api->malloc 
#define sqlite3_mprintf sqlite3_api->mprintf 
#define sqlite3_open sqlite3_api->open 
#define sqlite3_open16 sqlite3_api->open16 
#define sqlite3_prepare sqlite3_api->prepare 
#define sqlite3_prepare16 sqlite3_api->prepare16 
#define sqlite3_prepare_v2 sqlite3_api->prepare_v2 
#define sqlite3_prepare16_v2 sqlite3_api->prepare16_v2 
#define sqlite3_profile sqlite3_api->profile 
#define sqlite3_progress_handler sqlite3_api->progress_handler 
#define sqlite3_realloc sqlite3_api->realloc 
#define sqlite3_reset sqlite3_api->reset 
#define sqlite3_result_blob sqlite3_api->result_blob 
#define sqlite3_result_double sqlite3_api->result_double 
#define sqlite3_result_error sqlite3_api->result_error 
#define sqlite3_result_error16 sqlite3_api->result_error16 
#define sqlite3_result_int sqlite3_api->result_int 
#define sqlite3_result_int64 sqlite3_api->result_int64 
#define sqlite3_result_null sqlite3_api->result_null 
#define sqlite3_result_text sqlite3_api->result_text 
#define sqlite3_result_text16 sqlite3_api->result_text16 
#define sqlite3_result_text16be sqlite3_api->result_text16be 
#define sqlite3_result_text16le sqlite3_api->result_text16le 
#define sqlite3_result_value sqlite3_api->result_value 
#define sqlite3_rollback_hook sqlite3_api->rollback_hook 
#define sqlite3_set_authorizer sqlite3_api->set_authorizer 
#define sqlite3_set_auxdata sqlite3_api->set_auxdata 
#define sqlite3_snprintf sqlite3_api->snprintf 
#define sqlite3_step sqlite3_api->step 
#define sqlite3_table_column_metadata sqlite3_api->table_column_metadata 
#define sqlite3_thread_cleanup sqlite3_api->thread_cleanup 
#define sqlite3_total_changes sqlite3_api->total_changes 
#define sqlite3_trace sqlite3_api->trace 
#ifndef SQLITE_OMIT_DEPRECATED 
#define sqlite3_transfer_bindings sqlite3_api->transfer_bindings 
#endif 
#define sqlite3_update_hook sqlite3_api->update_hook 
#define sqlite3_user_data sqlite3_api->user_data 
#define sqlite3_value_blob sqlite3_api->value_blob 
#define sqlite3_value_bytes sqlite3_api->value_bytes 
#define sqlite3_value_bytes16 sqlite3_api->value_bytes16 
#define sqlite3_value_double sqlite3_api->value_double 
#define sqlite3_value_int sqlite3_api->value_int 
#define sqlite3_value_int64 sqlite3_api->value_int64 
#define sqlite3_value_numeric_type sqlite3_api->value_numeric_type 
#define sqlite3_value_text sqlite3_api->value_text 
#define sqlite3_value_text16 sqlite3_api->value_text16 
#define sqlite3_value_text16be sqlite3_api->value_text16be 
#define sqlite3_value_text16le sqlite3_api->value_text16le 
#define sqlite3_value_type sqlite3_api->value_type 
#define sqlite3_vmprintf sqlite3_api->vmprintf 
#define sqlite3_overload_function sqlite3_api->overload_function 
#define sqlite3_prepare_v2 sqlite3_api->prepare_v2 
#define sqlite3_prepare16_v2 sqlite3_api->prepare16_v2 
#define sqlite3_clear_bindings sqlite3_api->clear_bindings 
#define sqlite3_bind_zeroblob sqlite3_api->bind_zeroblob 
#define sqlite3_blob_bytes sqlite3_api->blob_bytes 
#define sqlite3_blob_close sqlite3_api->blob_close 
#define sqlite3_blob_open sqlite3_api->blob_open 
#define sqlite3_blob_read sqlite3_api->blob_read 
#define sqlite3_blob_write sqlite3_api->blob_write 
#define sqlite3_create_collation_v2 sqlite3_api->create_collation_v2 
#define sqlite3_file_control sqlite3_api->file_control 
#define sqlite3_memory_highwater sqlite3_api->memory_highwater 
#define sqlite3_memory_used sqlite3_api->memory_used 
#define sqlite3_mutex_alloc sqlite3_api->mutex_alloc 
#define sqlite3_mutex_enter sqlite3_api->mutex_enter 
#define sqlite3_mutex_free sqlite3_api->mutex_free 
#define sqlite3_mutex_leave sqlite3_api->mutex_leave 
#define sqlite3_mutex_try sqlite3_api->mutex_try 
#define sqlite3_open_v2 sqlite3_api->open_v2 
#define sqlite3_release_memory sqlite3_api->release_memory 
#define sqlite3_result_error_nomem sqlite3_api->result_error_nomem 
#define sqlite3_result_error_toobig sqlite3_api->result_error_toobig 
#define sqlite3_sleep sqlite3_api->sleep 
#define sqlite3_soft_heap_limit sqlite3_api->soft_heap_limit 
#define sqlite3_vfs_find sqlite3_api->vfs_find 
#define sqlite3_vfs_register sqlite3_api->vfs_register 
#define sqlite3_vfs_unregister sqlite3_api->vfs_unregister 
#define sqlite3_threadsafe sqlite3_api->xthreadsafe 
#define sqlite3_result_zeroblob sqlite3_api->result_zeroblob 
#define sqlite3_result_error_code sqlite3_api->result_error_code 
#define sqlite3_test_control sqlite3_api->test_control 
#define sqlite3_randomness sqlite3_api->randomness 
#define sqlite3_context_db_handle sqlite3_api->context_db_handle 
#define sqlite3_extended_result_codes sqlite3_api->extended_result_codes 
#define sqlite3_limit sqlite3_api->limit 
#define sqlite3_next_stmt sqlite3_api->next_stmt 
#define sqlite3_sql sqlite3_api->sql 
#define sqlite3_status sqlite3_api->status 
#endif 
#define SQLITE_EXTENSION_INIT1 const sqlite3_api_routines *sqlite3_api = 0; 
#define SQLITE_EXTENSION_INIT2(v) sqlite3_api = v; 
#endif 
#ifndef SQLITE_OMIT_LOAD_EXTENSION 
#ifndef SQLITE_ENABLE_COLUMN_METADATA 
#define sqlite3_column_database_name 0 
#define sqlite3_column_database_name16 0 
#define sqlite3_column_table_name 0 
#define sqlite3_column_table_name16 0 
#define sqlite3_column_origin_name 0 
#define sqlite3_column_origin_name16 0 
#define sqlite3_table_column_metadata 0 
#endif 
#ifdef SQLITE_OMIT_AUTHORIZATION 
#define sqlite3_set_authorizer 0 
#endif 
#ifdef SQLITE_OMIT_UTF16 
#define sqlite3_bind_text16 0 
#define sqlite3_collation_needed16 0 
#define sqlite3_column_decltype16 0 
#define sqlite3_column_name16 0 
#define sqlite3_column_text16 0 
#define sqlite3_complete16 0 
#define sqlite3_create_collation16 0 
#define sqlite3_create_function16 0 
#define sqlite3_errmsg16 0 
#define sqlite3_open16 0 
#define sqlite3_prepare16 0 
#define sqlite3_prepare16_v2 0 
#define sqlite3_result_error16 0 
#define sqlite3_result_text16 0 
#define sqlite3_result_text16be 0 
#define sqlite3_result_text16le 0 
#define sqlite3_value_text16 0 
#define sqlite3_value_text16be 0 
#define sqlite3_value_text16le 0 
#define sqlite3_column_database_name16 0 
#define sqlite3_column_table_name16 0 
#define sqlite3_column_origin_name16 0 
#endif 
#ifdef SQLITE_OMIT_COMPLETE 
#define sqlite3_complete 0 
#define sqlite3_complete16 0 
#endif 
#ifdef SQLITE_OMIT_PROGRESS_CALLBACK 
#define sqlite3_progress_handler 0 
#endif 
#ifdef SQLITE_OMIT_VIRTUALTABLE 
#define sqlite3_create_module 0 
#define sqlite3_create_module_v2 0 
#define sqlite3_declare_vtab 0 
#endif 
#ifdef SQLITE_OMIT_SHARED_CACHE 
#define sqlite3_enable_shared_cache 0 
#endif 
#ifdef SQLITE_OMIT_TRACE 
#define sqlite3_profile 0 
#define sqlite3_trace 0 
#endif 
#ifdef SQLITE_OMIT_GET_TABLE 
#define sqlite3_free_table 0 
#define sqlite3_get_table 0 
#endif 
#ifdef SQLITE_OMIT_INCRBLOB 
#define sqlite3_bind_zeroblob 0 
#define sqlite3_blob_bytes 0 
#define sqlite3_blob_close 0 
#define sqlite3_blob_open 0 
#define sqlite3_blob_read 0 
#define sqlite3_blob_write 0 
#endif 
static const sqlite3_api_routines sqlite3Apis = { sqlite3_aggregate_context, 
#ifndef SQLITE_OMIT_DEPRECATED 
 sqlite3_aggregate_count, 
#else 
 0, 
#endif 
 sqlite3_bind_blob, sqlite3_bind_double, sqlite3_bind_int, sqlite3_bind_int64, sqlite3_bind_null, sqlite3_bind_parameter_count, sqlite3_bind_parameter_index, sqlite3_bind_parameter_name, sqlite3_bind_text, sqlite3_bind_text16, sqlite3_bind_value, sqlite3_busy_handler, sqlite3_busy_timeout, sqlite3_changes, sqlite3_close, sqlite3_collation_needed, sqlite3_collation_needed16, sqlite3_column_blob, sqlite3_column_bytes, sqlite3_column_bytes16, sqlite3_column_count, sqlite3_column_database_name, sqlite3_column_database_name16, sqlite3_column_decltype, sqlite3_column_decltype16, sqlite3_column_double, sqlite3_column_int, sqlite3_column_int64, sqlite3_column_name, sqlite3_column_name16, sqlite3_column_origin_name, sqlite3_column_origin_name16, sqlite3_column_table_name, sqlite3_column_table_name16, sqlite3_column_text, sqlite3_column_text16, sqlite3_column_type, sqlite3_column_value, sqlite3_commit_hook, sqlite3_complete, sqlite3_complete16, sqlite3_create_collation, sqlite3_create_collation16, sqlite3_create_function, sqlite3_create_function16, sqlite3_create_module, sqlite3_data_count, sqlite3_db_handle, sqlite3_declare_vtab, sqlite3_enable_shared_cache, sqlite3_errcode, sqlite3_errmsg, sqlite3_errmsg16, sqlite3_exec, 
#ifndef SQLITE_OMIT_DEPRECATED 
 sqlite3_expired, 
#else 
 0, 
#endif 
 sqlite3_finalize, sqlite3_free, sqlite3_free_table, sqlite3_get_autocommit, sqlite3_get_auxdata, sqlite3_get_table, 0, sqlite3_interrupt, sqlite3_last_insert_rowid, sqlite3_libversion, sqlite3_libversion_number, sqlite3_malloc, sqlite3_mprintf, sqlite3_open, sqlite3_open16, sqlite3_prepare, sqlite3_prepare16, sqlite3_profile, sqlite3_progress_handler, sqlite3_realloc, sqlite3_reset, sqlite3_result_blob, sqlite3_result_double, sqlite3_result_error, sqlite3_result_error16, sqlite3_result_int, sqlite3_result_int64, sqlite3_result_null, sqlite3_result_text, sqlite3_result_text16, sqlite3_result_text16be, sqlite3_result_text16le, sqlite3_result_value, sqlite3_rollback_hook, sqlite3_set_authorizer, sqlite3_set_auxdata, sqlite3_snprintf, sqlite3_step, sqlite3_table_column_metadata, 
#ifndef SQLITE_OMIT_DEPRECATED 
 sqlite3_thread_cleanup, 
#else 
 0, 
#endif 
 sqlite3_total_changes, sqlite3_trace, 
#ifndef SQLITE_OMIT_DEPRECATED 
 sqlite3_transfer_bindings, 
#else 
 0, 
#endif 
 sqlite3_update_hook, sqlite3_user_data, sqlite3_value_blob, sqlite3_value_bytes, sqlite3_value_bytes16, sqlite3_value_double, sqlite3_value_int, sqlite3_value_int64, sqlite3_value_numeric_type, sqlite3_value_text, sqlite3_value_text16, sqlite3_value_text16be, sqlite3_value_text16le, sqlite3_value_type, sqlite3_vmprintf, sqlite3_overload_function, sqlite3_prepare_v2, sqlite3_prepare16_v2, sqlite3_clear_bindings, sqlite3_create_module_v2, sqlite3_bind_zeroblob, sqlite3_blob_bytes, sqlite3_blob_close, sqlite3_blob_open, sqlite3_blob_read, sqlite3_blob_write, sqlite3_create_collation_v2, sqlite3_file_control, sqlite3_memory_highwater, sqlite3_memory_used, 
#ifdef SQLITE_MUTEX_OMIT 
 0, 0, 0, 0, 0, 
#else 
 sqlite3_mutex_alloc, sqlite3_mutex_enter, sqlite3_mutex_free, sqlite3_mutex_leave, sqlite3_mutex_try, 
#endif 
 sqlite3_open_v2, sqlite3_release_memory, sqlite3_result_error_nomem, sqlite3_result_error_toobig, sqlite3_sleep, sqlite3_soft_heap_limit, sqlite3_vfs_find, sqlite3_vfs_register, sqlite3_vfs_unregister, sqlite3_threadsafe, sqlite3_result_zeroblob, sqlite3_result_error_code, sqlite3_test_control, sqlite3_randomness, sqlite3_context_db_handle, sqlite3_extended_result_codes, sqlite3_limit, sqlite3_next_stmt, sqlite3_sql, sqlite3_status, }; static int sqlite3LoadExtension( sqlite3 *db, const char *zFile, const char *zProc, char **pzErrMsg ){ sqlite3_vfs *pVfs = db->pVfs; void *handle; int (*xInit)(sqlite3*,char**,const sqlite3_api_routines*); char *zErrmsg = 0; void **aHandle; if( (db->flags & SQLITE_LoadExtension)==0 ){ if( pzErrMsg ){ *pzErrMsg = sqlite3_mprintf("not authorized"); } return SQLITE_ERROR; } if( zProc==0 ){ zProc = "sqlite3_extension_init"; } handle = sqlite3OsDlOpen(pVfs, zFile); if( handle==0 ){ if( pzErrMsg ){ char zErr[256]; zErr[sizeof(zErr)-1] = '\0'; sqlite3_snprintf(sizeof(zErr)-1, zErr, "unable to open shared library [%s]", zFile); sqlite3OsDlError(pVfs, sizeof(zErr)-1, zErr); *pzErrMsg = sqlite3DbStrDup(0, zErr); } return SQLITE_ERROR; } xInit = (int(*)(sqlite3*,char**,const sqlite3_api_routines*)) sqlite3OsDlSym(pVfs, handle, zProc); if( xInit==0 ){ if( pzErrMsg ){ char zErr[256]; zErr[sizeof(zErr)-1] = '\0'; sqlite3_snprintf(sizeof(zErr)-1, zErr, "no entry point [%s] in shared library [%s]", zProc,zFile); sqlite3OsDlError(pVfs, sizeof(zErr)-1, zErr); *pzErrMsg = sqlite3DbStrDup(0, zErr); sqlite3OsDlClose(pVfs, handle); } return SQLITE_ERROR; }else if( xInit(db, &zErrmsg, &sqlite3Apis) ){ if( pzErrMsg ){ *pzErrMsg = sqlite3_mprintf("error during initialization: %s", zErrmsg); } sqlite3_free(zErrmsg); sqlite3OsDlClose(pVfs, handle); return SQLITE_ERROR; } aHandle = sqlite3DbMallocZero(db, sizeof(handle)*(db->nExtension+1)); if( aHandle==0 ){ return SQLITE_NOMEM; } if( db->nExtension>0 ){ memcpy(aHandle, db->aExtension, sizeof(handle)*db->nExtension); } sqlite3DbFree(db, db->aExtension); db->aExtension = aHandle; db->aExtension[db->nExtension++] = handle; return SQLITE_OK; } SQLITE_API int sqlite3_load_extension( sqlite3 *db, const char *zFile, const char *zProc, char **pzErrMsg ){ int rc; sqlite3_mutex_enter(db->mutex); rc = sqlite3LoadExtension(db, zFile, zProc, pzErrMsg); sqlite3_mutex_leave(db->mutex); return rc; } SQLITE_PRIVATE void sqlite3CloseExtensions(sqlite3 *db){ int i; assert( sqlite3_mutex_held(db->mutex) ); for(i=0; i<db->nExtension; i++){ sqlite3OsDlClose(db->pVfs, db->aExtension[i]); } sqlite3DbFree(db, db->aExtension); } SQLITE_API int sqlite3_enable_load_extension(sqlite3 *db, int onoff){ sqlite3_mutex_enter(db->mutex); if( onoff ){ db->flags |= SQLITE_LoadExtension; }else{ db->flags &= ~SQLITE_LoadExtension; } sqlite3_mutex_leave(db->mutex); return SQLITE_OK; } 
#endif 
#ifdef SQLITE_OMIT_LOAD_EXTENSION 
static const sqlite3_api_routines sqlite3Apis = { 0 }; 
#endif 
typedef struct sqlite3ExtType sqlite3ExtType; static SQLITE_WSD struct sqlite3ExtType { int nExt; void **aExt; } sqlite3Autoext = { 0, 0 }; 
#ifdef SQLITE_OMIT_WSD 
#define wsdAutoextInit sqlite3ExtType *x = &GLOBAL(sqlite3ExtType,sqlite3Autoext) 
#define wsdAutoext x[0] 
#else 
#define wsdAutoextInit 
#define wsdAutoext sqlite3Autoext 
#endif 
SQLITE_API int sqlite3_auto_extension(void *xInit){ int rc = SQLITE_OK; 
#ifndef SQLITE_OMIT_AUTOINIT 
 rc = sqlite3_initialize(); if( rc ){ return rc; }else 
#endif 
 { int i; 
#if SQLITE_THREADSAFE 
 sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER); 
#endif 
 wsdAutoextInit; sqlite3_mutex_enter(mutex); for(i=0; i<wsdAutoext.nExt; i++){ if( wsdAutoext.aExt[i]==xInit ) break; } if( i==wsdAutoext.nExt ){ int nByte = (wsdAutoext.nExt+1)*sizeof(wsdAutoext.aExt[0]); void **aNew; aNew = sqlite3_realloc(wsdAutoext.aExt, nByte); if( aNew==0 ){ rc = SQLITE_NOMEM; }else{ wsdAutoext.aExt = aNew; wsdAutoext.aExt[wsdAutoext.nExt] = xInit; wsdAutoext.nExt++; } } sqlite3_mutex_leave(mutex); assert( (rc&0xff)==rc ); return rc; } } SQLITE_API void sqlite3_reset_auto_extension(void){ 
#ifndef SQLITE_OMIT_AUTOINIT 
 if( sqlite3_initialize()==SQLITE_OK ) 
#endif 
 { 
#if SQLITE_THREADSAFE 
 sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER); 
#endif 
 wsdAutoextInit; sqlite3_mutex_enter(mutex); sqlite3_free(wsdAutoext.aExt); wsdAutoext.aExt = 0; wsdAutoext.nExt = 0; sqlite3_mutex_leave(mutex); } } SQLITE_PRIVATE int sqlite3AutoLoadExtensions(sqlite3 *db){ int i; int go = 1; int rc = SQLITE_OK; int (*xInit)(sqlite3*,char**,const sqlite3_api_routines*); wsdAutoextInit; if( wsdAutoext.nExt==0 ){ return SQLITE_OK; } for(i=0; go; i++){ char *zErrmsg = 0; 
#if SQLITE_THREADSAFE 
 sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER); 
#endif 
 sqlite3_mutex_enter(mutex); if( i>=wsdAutoext.nExt ){ xInit = 0; go = 0; }else{ xInit = (int(*)(sqlite3*,char**,const sqlite3_api_routines*)) wsdAutoext.aExt[i]; } sqlite3_mutex_leave(mutex); if( xInit && xInit(db, &zErrmsg, &sqlite3Apis) ){ sqlite3Error(db, SQLITE_ERROR, "automatic extension loading failed: %s", zErrmsg); go = 0; rc = SQLITE_ERROR; sqlite3_free(zErrmsg); } } return rc; } 
#if !defined(SQLITE_OMIT_PRAGMA) && !defined(SQLITE_OMIT_PARSER) 
static int getSafetyLevel(const char *z){ static const char zText[] = "onoffalseyestruefull"; static const u8 iOffset[] = {0, 1, 2, 4, 9, 12, 16}; static const u8 iLength[] = {2, 2, 3, 5, 3, 4, 4}; static const u8 iValue[] = {1, 0, 0, 0, 1, 1, 2}; int i, n; if( isdigit(*z) ){ return atoi(z); } n = strlen(z); for(i=0; i<ArraySize(iLength); i++){ if( iLength[i]==n && sqlite3StrNICmp(&zText[iOffset[i]],z,n)==0 ){ return iValue[i]; } } return 1; } static int getBoolean(const char *z){ return getSafetyLevel(z)&1; } static int getLockingMode(const char *z){ if( z ){ if( 0==sqlite3StrICmp(z, "exclusive") ) return PAGER_LOCKINGMODE_EXCLUSIVE; if( 0==sqlite3StrICmp(z, "normal") ) return PAGER_LOCKINGMODE_NORMAL; } return PAGER_LOCKINGMODE_QUERY; } 
#ifndef SQLITE_OMIT_AUTOVACUUM 
static int getAutoVacuum(const char *z){ int i; if( 0==sqlite3StrICmp(z, "none") ) return BTREE_AUTOVACUUM_NONE; if( 0==sqlite3StrICmp(z, "full") ) return BTREE_AUTOVACUUM_FULL; if( 0==sqlite3StrICmp(z, "incremental") ) return BTREE_AUTOVACUUM_INCR; i = atoi(z); return ((i>=0&&i<=2)?i:0); } 
#endif 
#ifndef SQLITE_OMIT_PAGER_PRAGMAS 
static int getTempStore(const char *z){ if( z[0]>='0' && z[0]<='2' ){ return z[0] - '0'; }else if( sqlite3StrICmp(z, "file")==0 ){ return 1; }else if( sqlite3StrICmp(z, "memory")==0 ){ return 2; }else{ return 0; } } 
#endif 
#ifndef SQLITE_OMIT_PAGER_PRAGMAS 
static int invalidateTempStorage(Parse *pParse){ sqlite3 *db = pParse->db; if( db->aDb[1].pBt!=0 ){ if( !db->autoCommit || sqlite3BtreeIsInReadTrans(db->aDb[1].pBt) ){ sqlite3ErrorMsg(pParse, "temporary storage cannot be changed " "from within a transaction"); return SQLITE_ERROR; } sqlite3BtreeClose(db->aDb[1].pBt); db->aDb[1].pBt = 0; sqlite3ResetInternalSchema(db, 0); } return SQLITE_OK; } 
#endif 
#ifndef SQLITE_OMIT_PAGER_PRAGMAS 
static int changeTempStorage(Parse *pParse, const char *zStorageType){ int ts = getTempStore(zStorageType); sqlite3 *db = pParse->db; if( db->temp_store==ts ) return SQLITE_OK; if( invalidateTempStorage( pParse ) != SQLITE_OK ){ return SQLITE_ERROR; } db->temp_store = ts; return SQLITE_OK; } 
#endif 
static void returnSingleInt(Parse *pParse, const char *zLabel, int value){ Vdbe *v = sqlite3GetVdbe(pParse); int mem = ++pParse->nMem; sqlite3VdbeAddOp2(v, OP_Integer, value, mem); if( pParse->explain==0 ){ sqlite3VdbeSetNumCols(v, 1); sqlite3VdbeSetColName(v, 0, COLNAME_NAME, zLabel, SQLITE_STATIC); } sqlite3VdbeAddOp2(v, OP_ResultRow, mem, 1); } 
#ifndef SQLITE_OMIT_FLAG_PRAGMAS 
static int flagPragma(Parse *pParse, const char *zLeft, const char *zRight){ static const struct sPragmaType { const char *zName; int mask; } aPragma[] = { { "full_column_names", SQLITE_FullColNames }, { "short_column_names", SQLITE_ShortColNames }, { "count_changes", SQLITE_CountRows }, { "empty_result_callbacks", SQLITE_NullCallback }, { "legacy_file_format", SQLITE_LegacyFileFmt }, { "fullfsync", SQLITE_FullFSync }, 
#ifdef SQLITE_DEBUG 
 { "sql_trace", SQLITE_SqlTrace }, { "vdbe_listing", SQLITE_VdbeListing }, { "vdbe_trace", SQLITE_VdbeTrace }, 
#endif 
#ifndef SQLITE_OMIT_CHECK 
 { "ignore_check_constraints", SQLITE_IgnoreChecks }, 
#endif 
 { "writable_schema", SQLITE_WriteSchema|SQLITE_RecoveryMode }, { "omit_readlock", SQLITE_NoReadlock }, { "read_uncommitted", SQLITE_ReadUncommitted }, }; int i; const struct sPragmaType *p; for(i=0, p=aPragma; i<ArraySize(aPragma); i++, p++){ if( sqlite3StrICmp(zLeft, p->zName)==0 ){ sqlite3 *db = pParse->db; Vdbe *v; v = sqlite3GetVdbe(pParse); if( v ){ if( zRight==0 ){ returnSingleInt(pParse, p->zName, (db->flags & p->mask)!=0 ); }else{ if( getBoolean(zRight) ){ db->flags |= p->mask; }else{ db->flags &= ~p->mask; } sqlite3VdbeAddOp2(v, OP_Expire, 0, 0); } } return 1; } } return 0; } 
#endif 
static const char *actionName(u8 action){ switch( action ){ case OE_SetNull: return "SET NULL"; case OE_SetDflt: return "SET DEFAULT"; case OE_Restrict: return "RESTRICT"; case OE_Cascade: return "CASCADE"; } return ""; } SQLITE_PRIVATE void sqlite3Pragma( Parse *pParse, Token *pId1, Token *pId2, Token *pValue, int minusFlag ){ char *zLeft = 0; char *zRight = 0; const char *zDb = 0; Token *pId; int iDb; sqlite3 *db = pParse->db; Db *pDb; Vdbe *v = pParse->pVdbe = sqlite3VdbeCreate(db); if( v==0 ) return; pParse->nMem = 2; iDb = sqlite3TwoPartName(pParse, pId1, pId2, &pId); if( iDb<0 ) return; pDb = &db->aDb[iDb]; if( iDb==1 && sqlite3OpenTempDatabase(pParse) ){ return; } zLeft = sqlite3NameFromToken(db, pId); if( !zLeft ) return; if( minusFlag ){ zRight = sqlite3MPrintf(db, "-%T", pValue); }else{ zRight = sqlite3NameFromToken(db, pValue); } zDb = ((pId2 && pId2->n>0)?pDb->zName:0); if( sqlite3AuthCheck(pParse, SQLITE_PRAGMA, zLeft, zRight, zDb) ){ goto pragma_out; } 
#ifndef SQLITE_OMIT_PAGER_PRAGMAS 
 if( sqlite3StrICmp(zLeft,"default_cache_size")==0 ){ static const VdbeOpList getCacheSize[] = { { OP_ReadCookie, 0, 1, 2}, { OP_IfPos, 1, 6, 0}, { OP_Integer, 0, 2, 0}, { OP_Subtract, 1, 2, 1}, { OP_IfPos, 1, 6, 0}, { OP_Integer, 0, 1, 0}, { OP_ResultRow, 1, 1, 0}, }; int addr; if( sqlite3ReadSchema(pParse) ) goto pragma_out; sqlite3VdbeUsesBtree(v, iDb); if( !zRight ){ sqlite3VdbeSetNumCols(v, 1); sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "cache_size", SQLITE_STATIC); pParse->nMem += 2; addr = sqlite3VdbeAddOpList(v, ArraySize(getCacheSize), getCacheSize); sqlite3VdbeChangeP1(v, addr, iDb); sqlite3VdbeChangeP1(v, addr+5, SQLITE_DEFAULT_CACHE_SIZE); }else{ int size = atoi(zRight); if( size<0 ) size = -size; sqlite3BeginWriteOperation(pParse, 0, iDb); sqlite3VdbeAddOp2(v, OP_Integer, size, 1); sqlite3VdbeAddOp3(v, OP_ReadCookie, iDb, 2, 2); addr = sqlite3VdbeAddOp2(v, OP_IfPos, 2, 0); sqlite3VdbeAddOp2(v, OP_Integer, -size, 1); sqlite3VdbeJumpHere(v, addr); sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, 2, 1); pDb->pSchema->cache_size = size; sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size); } }else if( sqlite3StrICmp(zLeft,"page_size")==0 ){ Btree *pBt = pDb->pBt; if( !zRight ){ int size = pBt ? sqlite3BtreeGetPageSize(pBt) : 0; returnSingleInt(pParse, "page_size", size); }else{ db->nextPagesize = atoi(zRight); if( SQLITE_NOMEM==sqlite3BtreeSetPageSize(pBt, db->nextPagesize, -1) ){ db->mallocFailed = 1; } } }else if( sqlite3StrICmp(zLeft,"max_page_count")==0 ){ Btree *pBt = pDb->pBt; int newMax = 0; if( zRight ){ newMax = atoi(zRight); } if( pBt ){ newMax = sqlite3BtreeMaxPageCount(pBt, newMax); } returnSingleInt(pParse, "max_page_count", newMax); }else if( sqlite3StrICmp(zLeft,"page_count")==0 ){ Vdbe *v; int iReg; v = sqlite3GetVdbe(pParse); if( !v || sqlite3ReadSchema(pParse) ) goto pragma_out; sqlite3CodeVerifySchema(pParse, iDb); iReg = ++pParse->nMem; sqlite3VdbeAddOp2(v, OP_Pagecount, iDb, iReg); sqlite3VdbeAddOp2(v, OP_ResultRow, iReg, 1); sqlite3VdbeSetNumCols(v, 1); sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "page_count", SQLITE_STATIC); }else if( sqlite3StrICmp(zLeft,"locking_mode")==0 ){ const char *zRet = "normal"; int eMode = getLockingMode(zRight); if( pId2->n==0 && eMode==PAGER_LOCKINGMODE_QUERY ){ eMode = db->dfltLockMode; }else{ Pager *pPager; if( pId2->n==0 ){ int ii; assert(pDb==&db->aDb[0]); for(ii=2; ii<db->nDb; ii++){ pPager = sqlite3BtreePager(db->aDb[ii].pBt); sqlite3PagerLockingMode(pPager, eMode); } db->dfltLockMode = eMode; } pPager = sqlite3BtreePager(pDb->pBt); eMode = sqlite3PagerLockingMode(pPager, eMode); } assert(eMode==PAGER_LOCKINGMODE_NORMAL||eMode==PAGER_LOCKINGMODE_EXCLUSIVE); if( eMode==PAGER_LOCKINGMODE_EXCLUSIVE ){ zRet = "exclusive"; } sqlite3VdbeSetNumCols(v, 1); sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "locking_mode", SQLITE_STATIC); sqlite3VdbeAddOp4(v, OP_String8, 0, 1, 0, zRet, 0); sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1); }else if( sqlite3StrICmp(zLeft,"journal_mode")==0 ){ int eMode; static char * const azModeName[] = { "delete", "persist", "off", "truncate", "memory" }; if( zRight==0 ){ eMode = PAGER_JOURNALMODE_QUERY; }else{ int n = strlen(zRight); eMode = sizeof(azModeName)/sizeof(azModeName[0]) - 1; while( eMode>=0 && sqlite3StrNICmp(zRight, azModeName[eMode], n)!=0 ){ eMode--; } } if( pId2->n==0 && eMode==PAGER_JOURNALMODE_QUERY ){ eMode = db->dfltJournalMode; }else{ Pager *pPager; if( pId2->n==0 ){ int ii; assert(pDb==&db->aDb[0]); for(ii=1; ii<db->nDb; ii++){ if( db->aDb[ii].pBt ){ pPager = sqlite3BtreePager(db->aDb[ii].pBt); sqlite3PagerJournalMode(pPager, eMode); } } db->dfltJournalMode = eMode; } pPager = sqlite3BtreePager(pDb->pBt); eMode = sqlite3PagerJournalMode(pPager, eMode); } assert( eMode==PAGER_JOURNALMODE_DELETE || eMode==PAGER_JOURNALMODE_TRUNCATE || eMode==PAGER_JOURNALMODE_PERSIST || eMode==PAGER_JOURNALMODE_OFF || eMode==PAGER_JOURNALMODE_MEMORY ); sqlite3VdbeSetNumCols(v, 1); sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "journal_mode", SQLITE_STATIC); sqlite3VdbeAddOp4(v, OP_String8, 0, 1, 0, azModeName[eMode], P4_STATIC); sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1); }else if( sqlite3StrICmp(zLeft,"journal_size_limit")==0 ){ Pager *pPager = sqlite3BtreePager(pDb->pBt); i64 iLimit = -2; if( zRight ){ int iLimit32 = atoi(zRight); if( iLimit32<-1 ){ iLimit32 = -1; } iLimit = iLimit32; } iLimit = sqlite3PagerJournalSizeLimit(pPager, iLimit); returnSingleInt(pParse, "journal_size_limit", (int)iLimit); }else 
#endif 
 
#ifndef SQLITE_OMIT_AUTOVACUUM 
 if( sqlite3StrICmp(zLeft,"auto_vacuum")==0 ){ Btree *pBt = pDb->pBt; if( sqlite3ReadSchema(pParse) ){ goto pragma_out; } if( !zRight ){ int auto_vacuum = pBt ? sqlite3BtreeGetAutoVacuum(pBt) : SQLITE_DEFAULT_AUTOVACUUM; returnSingleInt(pParse, "auto_vacuum", auto_vacuum); }else{ int eAuto = getAutoVacuum(zRight); db->nextAutovac = eAuto; if( eAuto>=0 ){ int rc = sqlite3BtreeSetAutoVacuum(pBt, eAuto); if( rc==SQLITE_OK && (eAuto==1 || eAuto==2) ){ static const VdbeOpList setMeta6[] = { { OP_Transaction, 0, 1, 0}, { OP_ReadCookie, 0, 1, 3}, { OP_If, 1, 0, 0}, { OP_Halt, SQLITE_OK, OE_Abort, 0}, { OP_Integer, 0, 1, 0}, { OP_SetCookie, 0, 6, 1}, }; int iAddr; iAddr = sqlite3VdbeAddOpList(v, ArraySize(setMeta6), setMeta6); sqlite3VdbeChangeP1(v, iAddr, iDb); sqlite3VdbeChangeP1(v, iAddr+1, iDb); sqlite3VdbeChangeP2(v, iAddr+2, iAddr+4); sqlite3VdbeChangeP1(v, iAddr+4, eAuto-1); sqlite3VdbeChangeP1(v, iAddr+5, iDb); sqlite3VdbeUsesBtree(v, iDb); } } } }else 
#endif 
 
#ifndef SQLITE_OMIT_AUTOVACUUM 
 if( sqlite3StrICmp(zLeft,"incremental_vacuum")==0 ){ int iLimit, addr; if( sqlite3ReadSchema(pParse) ){ goto pragma_out; } if( zRight==0 || !sqlite3GetInt32(zRight, &iLimit) || iLimit<=0 ){ iLimit = 0x7fffffff; } sqlite3BeginWriteOperation(pParse, 0, iDb); sqlite3VdbeAddOp2(v, OP_Integer, iLimit, 1); addr = sqlite3VdbeAddOp1(v, OP_IncrVacuum, iDb); sqlite3VdbeAddOp1(v, OP_ResultRow, 1); sqlite3VdbeAddOp2(v, OP_AddImm, 1, -1); sqlite3VdbeAddOp2(v, OP_IfPos, 1, addr); sqlite3VdbeJumpHere(v, addr); }else 
#endif 
#ifndef SQLITE_OMIT_PAGER_PRAGMAS 
 if( sqlite3StrICmp(zLeft,"cache_size")==0 ){ if( sqlite3ReadSchema(pParse) ) goto pragma_out; if( !zRight ){ returnSingleInt(pParse, "cache_size", pDb->pSchema->cache_size); }else{ int size = atoi(zRight); if( size<0 ) size = -size; pDb->pSchema->cache_size = size; sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size); } }else if( sqlite3StrICmp(zLeft, "temp_store")==0 ){ if( !zRight ){ returnSingleInt(pParse, "temp_store", db->temp_store); }else{ changeTempStorage(pParse, zRight); } }else if( sqlite3StrICmp(zLeft, "temp_store_directory")==0 ){ if( !zRight ){ if( sqlite3_temp_directory ){ sqlite3VdbeSetNumCols(v, 1); sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "temp_store_directory", SQLITE_STATIC); sqlite3VdbeAddOp4(v, OP_String8, 0, 1, 0, sqlite3_temp_directory, 0); sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1); } }else{ 
#ifndef SQLITE_OMIT_WSD 
 if( zRight[0] ){ int rc; int res; rc = sqlite3OsAccess(db->pVfs, zRight, SQLITE_ACCESS_READWRITE, &res); if( rc!=SQLITE_OK || res==0 ){ sqlite3ErrorMsg(pParse, "not a writable directory"); goto pragma_out; } } if( SQLITE_TEMP_STORE==0 || (SQLITE_TEMP_STORE==1 && db->temp_store<=1) || (SQLITE_TEMP_STORE==2 && db->temp_store==1) ){ invalidateTempStorage(pParse); } sqlite3_free(sqlite3_temp_directory); if( zRight[0] ){ sqlite3_temp_directory = sqlite3DbStrDup(0, zRight); }else{ sqlite3_temp_directory = 0; } 
#endif 
 } }else if( sqlite3StrICmp(zLeft,"synchronous")==0 ){ if( sqlite3ReadSchema(pParse) ) goto pragma_out; if( !zRight ){ returnSingleInt(pParse, "synchronous", pDb->safety_level-1); }else{ if( !db->autoCommit ){ sqlite3ErrorMsg(pParse, "Safety level may not be changed inside a transaction"); }else{ pDb->safety_level = getSafetyLevel(zRight)+1; } } }else 
#endif 
#ifndef SQLITE_OMIT_FLAG_PRAGMAS 
 if( flagPragma(pParse, zLeft, zRight) ){ }else 
#endif 
#ifndef SQLITE_OMIT_SCHEMA_PRAGMAS 
 if( sqlite3StrICmp(zLeft, "table_info")==0 && zRight ){ Table *pTab; if( sqlite3ReadSchema(pParse) ) goto pragma_out; pTab = sqlite3FindTable(db, zRight, zDb); if( pTab ){ int i; int nHidden = 0; Column *pCol; sqlite3VdbeSetNumCols(v, 6); pParse->nMem = 6; sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "cid", SQLITE_STATIC); sqlite3VdbeSetColName(v, 1, COLNAME_NAME, "name", SQLITE_STATIC); sqlite3VdbeSetColName(v, 2, COLNAME_NAME, "type", SQLITE_STATIC); sqlite3VdbeSetColName(v, 3, COLNAME_NAME, "notnull", SQLITE_STATIC); sqlite3VdbeSetColName(v, 4, COLNAME_NAME, "dflt_value", SQLITE_STATIC); sqlite3VdbeSetColName(v, 5, COLNAME_NAME, "pk", SQLITE_STATIC); sqlite3ViewGetColumnNames(pParse, pTab); for(i=0, pCol=pTab->aCol; i<pTab->nCol; i++, pCol++){ const Token *pDflt; if( IsHiddenColumn(pCol) ){ nHidden++; continue; } sqlite3VdbeAddOp2(v, OP_Integer, i-nHidden, 1); sqlite3VdbeAddOp4(v, OP_String8, 0, 2, 0, pCol->zName, 0); sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, pCol->zType ? pCol->zType : "", 0); sqlite3VdbeAddOp2(v, OP_Integer, (pCol->notNull ? 1 : 0), 4); if( pCol->pDflt && (pDflt = &pCol->pDflt->span)->z ){ sqlite3VdbeAddOp4(v, OP_String8, 0, 5, 0, (char*)pDflt->z, pDflt->n); }else{ sqlite3VdbeAddOp2(v, OP_Null, 0, 5); } sqlite3VdbeAddOp2(v, OP_Integer, pCol->isPrimKey, 6); sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 6); } } }else if( sqlite3StrICmp(zLeft, "index_info")==0 && zRight ){ Index *pIdx; Table *pTab; if( sqlite3ReadSchema(pParse) ) goto pragma_out; pIdx = sqlite3FindIndex(db, zRight, zDb); if( pIdx ){ int i; pTab = pIdx->pTable; sqlite3VdbeSetNumCols(v, 3); pParse->nMem = 3; sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "seqno", SQLITE_STATIC); sqlite3VdbeSetColName(v, 1, COLNAME_NAME, "cid", SQLITE_STATIC); sqlite3VdbeSetColName(v, 2, COLNAME_NAME, "name", SQLITE_STATIC); for(i=0; i<pIdx->nColumn; i++){ int cnum = pIdx->aiColumn[i]; sqlite3VdbeAddOp2(v, OP_Integer, i, 1); sqlite3VdbeAddOp2(v, OP_Integer, cnum, 2); assert( pTab->nCol>cnum ); sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, pTab->aCol[cnum].zName, 0); sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 3); } } }else if( sqlite3StrICmp(zLeft, "index_list")==0 && zRight ){ Index *pIdx; Table *pTab; if( sqlite3ReadSchema(pParse) ) goto pragma_out; pTab = sqlite3FindTable(db, zRight, zDb); if( pTab ){ v = sqlite3GetVdbe(pParse); pIdx = pTab->pIndex; if( pIdx ){ int i = 0; sqlite3VdbeSetNumCols(v, 3); pParse->nMem = 3; sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "seq", SQLITE_STATIC); sqlite3VdbeSetColName(v, 1, COLNAME_NAME, "name", SQLITE_STATIC); sqlite3VdbeSetColName(v, 2, COLNAME_NAME, "unique", SQLITE_STATIC); while(pIdx){ sqlite3VdbeAddOp2(v, OP_Integer, i, 1); sqlite3VdbeAddOp4(v, OP_String8, 0, 2, 0, pIdx->zName, 0); sqlite3VdbeAddOp2(v, OP_Integer, pIdx->onError!=OE_None, 3); sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 3); ++i; pIdx = pIdx->pNext; } } } }else if( sqlite3StrICmp(zLeft, "database_list")==0 ){ int i; if( sqlite3ReadSchema(pParse) ) goto pragma_out; sqlite3VdbeSetNumCols(v, 3); pParse->nMem = 3; sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "seq", SQLITE_STATIC); sqlite3VdbeSetColName(v, 1, COLNAME_NAME, "name", SQLITE_STATIC); sqlite3VdbeSetColName(v, 2, COLNAME_NAME, "file", SQLITE_STATIC); for(i=0; i<db->nDb; i++){ if( db->aDb[i].pBt==0 ) continue; assert( db->aDb[i].zName!=0 ); sqlite3VdbeAddOp2(v, OP_Integer, i, 1); sqlite3VdbeAddOp4(v, OP_String8, 0, 2, 0, db->aDb[i].zName, 0); sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, sqlite3BtreeGetFilename(db->aDb[i].pBt), 0); sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 3); } }else if( sqlite3StrICmp(zLeft, "collation_list")==0 ){ int i = 0; HashElem *p; sqlite3VdbeSetNumCols(v, 2); pParse->nMem = 2; sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "seq", SQLITE_STATIC); sqlite3VdbeSetColName(v, 1, COLNAME_NAME, "name", SQLITE_STATIC); for(p=sqliteHashFirst(&db->aCollSeq); p; p=sqliteHashNext(p)){ CollSeq *pColl = (CollSeq *)sqliteHashData(p); sqlite3VdbeAddOp2(v, OP_Integer, i++, 1); sqlite3VdbeAddOp4(v, OP_String8, 0, 2, 0, pColl->zName, 0); sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 2); } }else 
#endif 
#ifndef SQLITE_OMIT_FOREIGN_KEY 
 if( sqlite3StrICmp(zLeft, "foreign_key_list")==0 && zRight ){ FKey *pFK; Table *pTab; if( sqlite3ReadSchema(pParse) ) goto pragma_out; pTab = sqlite3FindTable(db, zRight, zDb); if( pTab ){ v = sqlite3GetVdbe(pParse); pFK = pTab->pFKey; if( pFK ){ int i = 0; sqlite3VdbeSetNumCols(v, 8); pParse->nMem = 8; sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "id", SQLITE_STATIC); sqlite3VdbeSetColName(v, 1, COLNAME_NAME, "seq", SQLITE_STATIC); sqlite3VdbeSetColName(v, 2, COLNAME_NAME, "table", SQLITE_STATIC); sqlite3VdbeSetColName(v, 3, COLNAME_NAME, "from", SQLITE_STATIC); sqlite3VdbeSetColName(v, 4, COLNAME_NAME, "to", SQLITE_STATIC); sqlite3VdbeSetColName(v, 5, COLNAME_NAME, "on_update", SQLITE_STATIC); sqlite3VdbeSetColName(v, 6, COLNAME_NAME, "on_delete", SQLITE_STATIC); sqlite3VdbeSetColName(v, 7, COLNAME_NAME, "match", SQLITE_STATIC); while(pFK){ int j; for(j=0; j<pFK->nCol; j++){ char *zCol = pFK->aCol[j].zCol; char *zOnUpdate = (char *)actionName(pFK->updateConf); char *zOnDelete = (char *)actionName(pFK->deleteConf); sqlite3VdbeAddOp2(v, OP_Integer, i, 1); sqlite3VdbeAddOp2(v, OP_Integer, j, 2); sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, pFK->zTo, 0); sqlite3VdbeAddOp4(v, OP_String8, 0, 4, 0, pTab->aCol[pFK->aCol[j].iFrom].zName, 0); sqlite3VdbeAddOp4(v, zCol ? OP_String8 : OP_Null, 0, 5, 0, zCol, 0); sqlite3VdbeAddOp4(v, OP_String8, 0, 6, 0, zOnUpdate, 0); sqlite3VdbeAddOp4(v, OP_String8, 0, 7, 0, zOnDelete, 0); sqlite3VdbeAddOp4(v, OP_String8, 0, 8, 0, "NONE", 0); sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 8); } ++i; pFK = pFK->pNextFrom; } } } }else 
#endif 
#ifndef NDEBUG 
 if( sqlite3StrICmp(zLeft, "parser_trace")==0 ){ if( zRight ){ if( getBoolean(zRight) ){ sqlite3ParserTrace(stderr, "parser: "); }else{ sqlite3ParserTrace(0, 0); } } }else 
#endif 
 if( sqlite3StrICmp(zLeft, "case_sensitive_like")==0 ){ if( zRight ){ sqlite3RegisterLikeFunctions(db, getBoolean(zRight)); } }else 
#ifndef SQLITE_INTEGRITY_CHECK_ERROR_MAX 
#define SQLITE_INTEGRITY_CHECK_ERROR_MAX 100 
#endif 
#ifndef SQLITE_OMIT_INTEGRITY_CHECK 
 if( sqlite3StrICmp(zLeft, "integrity_check")==0 || sqlite3StrICmp(zLeft, "quick_check")==0 ){ int i, j, addr, mxErr; static const VdbeOpList endCode[] = { { OP_AddImm, 1, 0, 0}, { OP_IfNeg, 1, 0, 0}, { OP_String8, 0, 3, 0}, { OP_ResultRow, 3, 1, 0}, }; int isQuick = (zLeft[0]=='q'); if( sqlite3ReadSchema(pParse) ) goto pragma_out; pParse->nMem = 6; sqlite3VdbeSetNumCols(v, 1); sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "integrity_check", SQLITE_STATIC); mxErr = SQLITE_INTEGRITY_CHECK_ERROR_MAX; if( zRight ){ mxErr = atoi(zRight); if( mxErr<=0 ){ mxErr = SQLITE_INTEGRITY_CHECK_ERROR_MAX; } } sqlite3VdbeAddOp2(v, OP_Integer, mxErr, 1); for(i=0; i<db->nDb; i++){ HashElem *x; Hash *pTbls; int cnt = 0; if( OMIT_TEMPDB && i==1 ) continue; sqlite3CodeVerifySchema(pParse, i); addr = sqlite3VdbeAddOp1(v, OP_IfPos, 1); sqlite3VdbeAddOp2(v, OP_Halt, 0, 0); sqlite3VdbeJumpHere(v, addr); pTbls = &db->aDb[i].pSchema->tblHash; for(x=sqliteHashFirst(pTbls); x; x=sqliteHashNext(x)){ Table *pTab = sqliteHashData(x); Index *pIdx; sqlite3VdbeAddOp2(v, OP_Integer, pTab->tnum, 2+cnt); cnt++; for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){ sqlite3VdbeAddOp2(v, OP_Integer, pIdx->tnum, 2+cnt); cnt++; } } if( cnt==0 ) continue; if( pParse->nMem < cnt+4 ){ pParse->nMem = cnt+4; } sqlite3VdbeAddOp3(v, OP_IntegrityCk, 2, cnt, 1); sqlite3VdbeChangeP5(v, i); addr = sqlite3VdbeAddOp1(v, OP_IsNull, 2); sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, sqlite3MPrintf(db, "*** in database %s ***\n", db->aDb[i].zName), P4_DYNAMIC); sqlite3VdbeAddOp3(v, OP_Move, 2, 4, 1); sqlite3VdbeAddOp3(v, OP_Concat, 4, 3, 2); sqlite3VdbeAddOp2(v, OP_ResultRow, 2, 1); sqlite3VdbeJumpHere(v, addr); for(x=sqliteHashFirst(pTbls); x && !isQuick; x=sqliteHashNext(x)){ Table *pTab = sqliteHashData(x); Index *pIdx; int loopTop; if( pTab->pIndex==0 ) continue; addr = sqlite3VdbeAddOp1(v, OP_IfPos, 1); sqlite3VdbeAddOp2(v, OP_Halt, 0, 0); sqlite3VdbeJumpHere(v, addr); sqlite3OpenTableAndIndices(pParse, pTab, 1, OP_OpenRead); sqlite3VdbeAddOp2(v, OP_Integer, 0, 2); loopTop = sqlite3VdbeAddOp2(v, OP_Rewind, 1, 0); sqlite3VdbeAddOp2(v, OP_AddImm, 2, 1); for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){ int jmp2; static const VdbeOpList idxErr[] = { { OP_AddImm, 1, -1, 0}, { OP_String8, 0, 3, 0}, { OP_Rowid, 1, 4, 0}, { OP_String8, 0, 5, 0}, { OP_String8, 0, 6, 0}, { OP_Concat, 4, 3, 3}, { OP_Concat, 5, 3, 3}, { OP_Concat, 6, 3, 3}, { OP_ResultRow, 3, 1, 0}, { OP_IfPos, 1, 0, 0}, { OP_Halt, 0, 0, 0}, }; sqlite3GenerateIndexKey(pParse, pIdx, 1, 3, 1); jmp2 = sqlite3VdbeAddOp3(v, OP_Found, j+2, 0, 3); addr = sqlite3VdbeAddOpList(v, ArraySize(idxErr), idxErr); sqlite3VdbeChangeP4(v, addr+1, "rowid ", P4_STATIC); sqlite3VdbeChangeP4(v, addr+3, " missing from index ", P4_STATIC); sqlite3VdbeChangeP4(v, addr+4, pIdx->zName, P4_STATIC); sqlite3VdbeJumpHere(v, addr+9); sqlite3VdbeJumpHere(v, jmp2); } sqlite3VdbeAddOp2(v, OP_Next, 1, loopTop+1); sqlite3VdbeJumpHere(v, loopTop); for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){ static const VdbeOpList cntIdx[] = { { OP_Integer, 0, 3, 0}, { OP_Rewind, 0, 0, 0}, { OP_AddImm, 3, 1, 0}, { OP_Next, 0, 0, 0}, { OP_Eq, 2, 0, 3}, { OP_AddImm, 1, -1, 0}, { OP_String8, 0, 2, 0}, { OP_String8, 0, 3, 0}, { OP_Concat, 3, 2, 2}, { OP_ResultRow, 2, 1, 0}, }; if( pIdx->tnum==0 ) continue; addr = sqlite3VdbeAddOp1(v, OP_IfPos, 1); sqlite3VdbeAddOp2(v, OP_Halt, 0, 0); sqlite3VdbeJumpHere(v, addr); addr = sqlite3VdbeAddOpList(v, ArraySize(cntIdx), cntIdx); sqlite3VdbeChangeP1(v, addr+1, j+2); sqlite3VdbeChangeP2(v, addr+1, addr+4); sqlite3VdbeChangeP1(v, addr+3, j+2); sqlite3VdbeChangeP2(v, addr+3, addr+2); sqlite3VdbeJumpHere(v, addr+4); sqlite3VdbeChangeP4(v, addr+6, "wrong # of entries in index ", P4_STATIC); sqlite3VdbeChangeP4(v, addr+7, pIdx->zName, P4_STATIC); } } } addr = sqlite3VdbeAddOpList(v, ArraySize(endCode), endCode); sqlite3VdbeChangeP2(v, addr, -mxErr); sqlite3VdbeJumpHere(v, addr+1); sqlite3VdbeChangeP4(v, addr+2, "ok", P4_STATIC); }else 
#endif 
#ifndef SQLITE_OMIT_UTF16 
 if( sqlite3StrICmp(zLeft, "encoding")==0 ){ static const struct EncName { char *zName; u8 enc; } encnames[] = { { "UTF-8", SQLITE_UTF8 }, { "UTF8", SQLITE_UTF8 }, { "UTF-16le", SQLITE_UTF16LE }, { "UTF16le", SQLITE_UTF16LE }, { "UTF-16be", SQLITE_UTF16BE }, { "UTF16be", SQLITE_UTF16BE }, { "UTF-16", 0 }, { "UTF16", 0 }, { 0, 0 } }; const struct EncName *pEnc; if( !zRight ){ if( sqlite3ReadSchema(pParse) ) goto pragma_out; sqlite3VdbeSetNumCols(v, 1); sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "encoding", SQLITE_STATIC); sqlite3VdbeAddOp2(v, OP_String8, 0, 1); for(pEnc=&encnames[0]; pEnc->zName; pEnc++){ if( pEnc->enc==ENC(pParse->db) ){ sqlite3VdbeChangeP4(v, -1, pEnc->zName, P4_STATIC); break; } } sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1); }else{ if( !(DbHasProperty(db, 0, DB_SchemaLoaded)) || DbHasProperty(db, 0, DB_Empty) ){ for(pEnc=&encnames[0]; pEnc->zName; pEnc++){ if( 0==sqlite3StrICmp(zRight, pEnc->zName) ){ ENC(pParse->db) = pEnc->enc ? pEnc->enc : SQLITE_UTF16NATIVE; break; } } if( !pEnc->zName ){ sqlite3ErrorMsg(pParse, "unsupported encoding: %s", zRight); } } } }else 
#endif 
#ifndef SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS 
 if( sqlite3StrICmp(zLeft, "schema_version")==0 || sqlite3StrICmp(zLeft, "user_version")==0 || sqlite3StrICmp(zLeft, "freelist_count")==0 ){ int iCookie; sqlite3VdbeUsesBtree(v, iDb); switch( zLeft[0] ){ case 's': case 'S': iCookie = 0; break; case 'f': case 'F': iCookie = 1; iDb = (-1*(iDb+1)); assert(iDb<=0); break; default: iCookie = 5; break; } if( zRight && iDb>=0 ){ static const VdbeOpList setCookie[] = { { OP_Transaction, 0, 1, 0}, { OP_Integer, 0, 1, 0}, { OP_SetCookie, 0, 0, 1}, }; int addr = sqlite3VdbeAddOpList(v, ArraySize(setCookie), setCookie); sqlite3VdbeChangeP1(v, addr, iDb); sqlite3VdbeChangeP1(v, addr+1, atoi(zRight)); sqlite3VdbeChangeP1(v, addr+2, iDb); sqlite3VdbeChangeP2(v, addr+2, iCookie); }else{ static const VdbeOpList readCookie[] = { { OP_ReadCookie, 0, 1, 0}, { OP_ResultRow, 1, 1, 0} }; int addr = sqlite3VdbeAddOpList(v, ArraySize(readCookie), readCookie); sqlite3VdbeChangeP1(v, addr, iDb); sqlite3VdbeChangeP3(v, addr, iCookie); sqlite3VdbeSetNumCols(v, 1); sqlite3VdbeSetColName(v, 0, COLNAME_NAME, zLeft, SQLITE_TRANSIENT); } }else 
#endif 
#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST) 
 if( sqlite3StrICmp(zLeft, "lock_status")==0 ){ static const char *const azLockName[] = { "unlocked", "shared", "reserved", "pending", "exclusive" }; int i; Vdbe *v = sqlite3GetVdbe(pParse); sqlite3VdbeSetNumCols(v, 2); pParse->nMem = 2; sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "database", SQLITE_STATIC); sqlite3VdbeSetColName(v, 1, COLNAME_NAME, "status", SQLITE_STATIC); for(i=0; i<db->nDb; i++){ Btree *pBt; Pager *pPager; const char *zState = "unknown"; int j; if( db->aDb[i].zName==0 ) continue; sqlite3VdbeAddOp4(v, OP_String8, 0, 1, 0, db->aDb[i].zName, P4_STATIC); pBt = db->aDb[i].pBt; if( pBt==0 || (pPager = sqlite3BtreePager(pBt))==0 ){ zState = "closed"; }else if( sqlite3_file_control(db, i ? db->aDb[i].zName : 0, SQLITE_FCNTL_LOCKSTATE, &j)==SQLITE_OK ){ zState = azLockName[j]; } sqlite3VdbeAddOp4(v, OP_String8, 0, 2, 0, zState, P4_STATIC); sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 2); } }else 
#endif 
#ifdef SQLITE_SSE 
 if( sqlite3StrICmp(zLeft, "create_sqlite_statement_table")==0 ){ extern int sqlite3CreateStatementsTable(Parse*); sqlite3CreateStatementsTable(pParse); }else 
#endif 
#if SQLITE_HAS_CODEC 
 if( sqlite3StrICmp(zLeft, "key")==0 ){ sqlite3_key(db, zRight, strlen(zRight)); }else 
#endif 
#if SQLITE_HAS_CODEC || defined(SQLITE_ENABLE_CEROD) 
 if( sqlite3StrICmp(zLeft, "activate_extensions")==0 ){ 
#if SQLITE_HAS_CODEC 
 if( sqlite3StrNICmp(zRight, "see-", 4)==0 ){ extern void sqlite3_activate_see(const char*); sqlite3_activate_see(&zRight[4]); } 
#endif 
#ifdef SQLITE_ENABLE_CEROD 
 if( sqlite3StrNICmp(zRight, "cerod-", 6)==0 ){ extern void sqlite3_activate_cerod(const char*); sqlite3_activate_cerod(&zRight[6]); } 
#endif 
 } 
#endif 
 {} if( v ){ sqlite3VdbeAddOp2(v, OP_Expire, 1, 0); 
#ifndef SQLITE_OMIT_PAGER_PRAGMAS 
 if( db->autoCommit ){ sqlite3BtreeSetSafetyLevel(pDb->pBt, pDb->safety_level, (db->flags&SQLITE_FullFSync)!=0); } 
#endif 
 } pragma_out: sqlite3DbFree(db, zLeft); sqlite3DbFree(db, zRight); } 
#endif 
static void corruptSchema( InitData *pData, const char *zObj, const char *zExtra ){ sqlite3 *db = pData->db; if( !db->mallocFailed && (db->flags & SQLITE_RecoveryMode)==0 ){ if( zObj==0 ) zObj = "?"; sqlite3SetString(pData->pzErrMsg, pData->db, "malformed database schema (%s)", zObj); if( zExtra && zExtra[0] ){ *pData->pzErrMsg = sqlite3MAppendf(pData->db, *pData->pzErrMsg, "%s - %s", *pData->pzErrMsg, zExtra); } } pData->rc = SQLITE_CORRUPT; } SQLITE_PRIVATE int sqlite3InitCallback(void *pInit, int argc, char **argv, char **NotUsed){ InitData *pData = (InitData*)pInit; sqlite3 *db = pData->db; int iDb = pData->iDb; assert( argc==3 ); UNUSED_PARAMETER2(NotUsed, argc); assert( sqlite3_mutex_held(db->mutex) ); DbClearProperty(db, iDb, DB_Empty); if( db->mallocFailed ){ corruptSchema(pData, argv[0], 0); return SQLITE_NOMEM; } assert( iDb>=0 && iDb<db->nDb ); if( argv==0 ) return 0; if( argv[1]==0 ){ corruptSchema(pData, argv[0], 0); }else if( argv[2] && argv[2][0] ){ char *zErr; int rc; u8 lookasideEnabled; assert( db->init.busy ); db->init.iDb = iDb; db->init.newTnum = atoi(argv[1]); lookasideEnabled = db->lookaside.bEnabled; db->lookaside.bEnabled = 0; rc = sqlite3_exec(db, argv[2], 0, 0, &zErr); db->init.iDb = 0; db->lookaside.bEnabled = lookasideEnabled; assert( rc!=SQLITE_OK || zErr==0 ); if( SQLITE_OK!=rc ){ pData->rc = rc; if( rc==SQLITE_NOMEM ){ db->mallocFailed = 1; }else if( rc!=SQLITE_INTERRUPT ){ corruptSchema(pData, argv[0], zErr); } sqlite3DbFree(db, zErr); } }else if( argv[0]==0 ){ corruptSchema(pData, 0, 0); }else{ Index *pIndex; pIndex = sqlite3FindIndex(db, argv[0], db->aDb[iDb].zName); if( pIndex==0 || pIndex->tnum!=0 ){ ; }else{ pIndex->tnum = atoi(argv[1]); } } return 0; } static int sqlite3InitOne(sqlite3 *db, int iDb, char **pzErrMsg){ int rc; BtCursor *curMain; int size; Table *pTab; Db *pDb; char const *azArg[4]; int meta[10]; InitData initData; char const *zMasterSchema; char const *zMasterName = SCHEMA_TABLE(iDb); static const char master_schema[] = "CREATE TABLE sqlite_master(\n" " type text,\n" " name text,\n" " tbl_name text,\n" " rootpage integer,\n" " sql text\n" ")" ; 
#ifndef SQLITE_OMIT_TEMPDB 
 static const char temp_master_schema[] = "CREATE TEMP TABLE sqlite_temp_master(\n" " type text,\n" " name text,\n" " tbl_name text,\n" " rootpage integer,\n" " sql text\n" ")" ; 
#else 
#define temp_master_schema 0 
#endif 
 assert( iDb>=0 && iDb<db->nDb ); assert( db->aDb[iDb].pSchema ); assert( sqlite3_mutex_held(db->mutex) ); assert( iDb==1 || sqlite3BtreeHoldsMutex(db->aDb[iDb].pBt) ); if( !OMIT_TEMPDB && iDb==1 ){ zMasterSchema = temp_master_schema; }else{ zMasterSchema = master_schema; } zMasterName = SCHEMA_TABLE(iDb); azArg[0] = zMasterName; azArg[1] = "1"; azArg[2] = zMasterSchema; azArg[3] = 0; initData.db = db; initData.iDb = iDb; initData.rc = SQLITE_OK; initData.pzErrMsg = pzErrMsg; (void)sqlite3SafetyOff(db); sqlite3InitCallback(&initData, 3, (char **)azArg, 0); (void)sqlite3SafetyOn(db); if( initData.rc ){ rc = initData.rc; goto error_out; } pTab = sqlite3FindTable(db, zMasterName, db->aDb[iDb].zName); if( pTab ){ pTab->tabFlags |= TF_Readonly; } pDb = &db->aDb[iDb]; if( pDb->pBt==0 ){ if( !OMIT_TEMPDB && iDb==1 ){ DbSetProperty(db, 1, DB_SchemaLoaded); } return SQLITE_OK; } curMain = sqlite3MallocZero(sqlite3BtreeCursorSize()); if( !curMain ){ rc = SQLITE_NOMEM; goto error_out; } sqlite3BtreeEnter(pDb->pBt); rc = sqlite3BtreeCursor(pDb->pBt, MASTER_ROOT, 0, 0, curMain); if( rc!=SQLITE_OK && rc!=SQLITE_EMPTY ){ sqlite3SetString(pzErrMsg, db, "%s", sqlite3ErrStr(rc)); goto initone_error_out; } if( rc==SQLITE_OK ){ int i; for(i=0; i<ArraySize(meta); i++){ rc = sqlite3BtreeGetMeta(pDb->pBt, i+1, (u32 *)&meta[i]); if( rc ){ sqlite3SetString(pzErrMsg, db, "%s", sqlite3ErrStr(rc)); goto initone_error_out; } } }else{ memset(meta, 0, sizeof(meta)); } pDb->pSchema->schema_cookie = meta[0]; if( meta[4] ){ if( iDb==0 ){ ENC(db) = (u8)meta[4]; db->pDfltColl = sqlite3FindCollSeq(db, SQLITE_UTF8, "BINARY", 6, 0); }else{ if( meta[4]!=ENC(db) ){ sqlite3SetString(pzErrMsg, db, "attached databases must use the same" " text encoding as main database"); rc = SQLITE_ERROR; goto initone_error_out; } } }else{ DbSetProperty(db, iDb, DB_Empty); } pDb->pSchema->enc = ENC(db); if( pDb->pSchema->cache_size==0 ){ size = meta[2]; if( size==0 ){ size = SQLITE_DEFAULT_CACHE_SIZE; } if( size<0 ) size = -size; pDb->pSchema->cache_size = size; sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size); } pDb->pSchema->file_format = meta[1]; if( pDb->pSchema->file_format==0 ){ pDb->pSchema->file_format = 1; } if( pDb->pSchema->file_format>SQLITE_MAX_FILE_FORMAT ){ sqlite3SetString(pzErrMsg, db, "unsupported file format"); rc = SQLITE_ERROR; goto initone_error_out; } if( iDb==0 && meta[1]>=4 ){ db->flags &= ~SQLITE_LegacyFileFmt; } assert( db->init.busy ); if( rc==SQLITE_EMPTY ){ rc = SQLITE_OK; }else{ char *zSql; zSql = sqlite3MPrintf(db, "SELECT name, rootpage, sql FROM '%q'.%s", db->aDb[iDb].zName, zMasterName); (void)sqlite3SafetyOff(db); 
#ifndef SQLITE_OMIT_AUTHORIZATION 
 { int (*xAuth)(void*,int,const char*,const char*,const char*,const char*); xAuth = db->xAuth; db->xAuth = 0; 
#endif 
 rc = sqlite3_exec(db, zSql, sqlite3InitCallback, &initData, 0); 
#ifndef SQLITE_OMIT_AUTHORIZATION 
 db->xAuth = xAuth; } 
#endif 
 if( rc==SQLITE_OK ) rc = initData.rc; (void)sqlite3SafetyOn(db); sqlite3DbFree(db, zSql); 
#ifndef SQLITE_OMIT_ANALYZE 
 if( rc==SQLITE_OK ){ sqlite3AnalysisLoad(db, iDb); } 
#endif 
 } if( db->mallocFailed ){ rc = SQLITE_NOMEM; sqlite3ResetInternalSchema(db, 0); } if( rc==SQLITE_OK || (db->flags&SQLITE_RecoveryMode)){ DbSetProperty(db, iDb, DB_SchemaLoaded); rc = SQLITE_OK; } initone_error_out: sqlite3BtreeCloseCursor(curMain); sqlite3_free(curMain); sqlite3BtreeLeave(pDb->pBt); error_out: if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ){ db->mallocFailed = 1; } return rc; } SQLITE_PRIVATE int sqlite3Init(sqlite3 *db, char **pzErrMsg){ int i, rc; int commit_internal = !(db->flags&SQLITE_InternChanges); assert( sqlite3_mutex_held(db->mutex) ); if( db->init.busy ) return SQLITE_OK; rc = SQLITE_OK; db->init.busy = 1; for(i=0; rc==SQLITE_OK && i<db->nDb; i++){ if( DbHasProperty(db, i, DB_SchemaLoaded) || i==1 ) continue; rc = sqlite3InitOne(db, i, pzErrMsg); if( rc ){ sqlite3ResetInternalSchema(db, i); } } 
#ifndef SQLITE_OMIT_TEMPDB 
 if( rc==SQLITE_OK && db->nDb>1 && !DbHasProperty(db, 1, DB_SchemaLoaded) ){ rc = sqlite3InitOne(db, 1, pzErrMsg); if( rc ){ sqlite3ResetInternalSchema(db, 1); } } 
#endif 
 db->init.busy = 0; if( rc==SQLITE_OK && commit_internal ){ sqlite3CommitInternalChanges(db); } return rc; } SQLITE_PRIVATE int sqlite3ReadSchema(Parse *pParse){ int rc = SQLITE_OK; sqlite3 *db = pParse->db; assert( sqlite3_mutex_held(db->mutex) ); if( !db->init.busy ){ rc = sqlite3Init(db, &pParse->zErrMsg); } if( rc!=SQLITE_OK ){ pParse->rc = rc; pParse->nErr++; } return rc; } static int schemaIsValid(sqlite3 *db){ int iDb; int rc; BtCursor *curTemp; int cookie; int allOk = 1; curTemp = (BtCursor *)sqlite3Malloc(sqlite3BtreeCursorSize()); if( curTemp ){ assert( sqlite3_mutex_held(db->mutex) ); for(iDb=0; allOk && iDb<db->nDb; iDb++){ Btree *pBt; pBt = db->aDb[iDb].pBt; if( pBt==0 ) continue; memset(curTemp, 0, sqlite3BtreeCursorSize()); rc = sqlite3BtreeCursor(pBt, MASTER_ROOT, 0, 0, curTemp); if( rc==SQLITE_OK ){ rc = sqlite3BtreeGetMeta(pBt, 1, (u32 *)&cookie); if( rc==SQLITE_OK && cookie!=db->aDb[iDb].pSchema->schema_cookie ){ allOk = 0; } sqlite3BtreeCloseCursor(curTemp); } if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ){ db->mallocFailed = 1; } } sqlite3_free(curTemp); }else{ allOk = 0; db->mallocFailed = 1; } return allOk; } SQLITE_PRIVATE int sqlite3SchemaToIndex(sqlite3 *db, Schema *pSchema){ int i = -1000000; assert( sqlite3_mutex_held(db->mutex) ); if( pSchema ){ for(i=0; i<db->nDb; i++){ if( db->aDb[i].pSchema==pSchema ){ break; } } assert( i>=0 &&i>=0 && i<db->nDb ); } return i; } static int sqlite3Prepare( sqlite3 *db, const char *zSql, int nBytes, int saveSqlFlag, sqlite3_stmt **ppStmt, const char **pzTail ){ Parse sParse; char *zErrMsg = 0; int rc = SQLITE_OK; int i; assert( ppStmt ); *ppStmt = 0; if( sqlite3SafetyOn(db) ){ return SQLITE_MISUSE; } assert( !db->mallocFailed ); assert( sqlite3_mutex_held(db->mutex) ); for(i=0; i<db->nDb; i++) { Btree *pBt = db->aDb[i].pBt; if( pBt ){ int rc; rc = sqlite3BtreeSchemaLocked(pBt); if( rc ){ const char *zDb = db->aDb[i].zName; sqlite3Error(db, SQLITE_LOCKED, "database schema is locked: %s", zDb); (void)sqlite3SafetyOff(db); return sqlite3ApiExit(db, SQLITE_LOCKED); } } } memset(&sParse, 0, sizeof(sParse)); sParse.db = db; if( nBytes>=0 && (nBytes==0 || zSql[nBytes-1]!=0) ){ char *zSqlCopy; int mxLen = db->aLimit[SQLITE_LIMIT_SQL_LENGTH]; if( nBytes>mxLen ){ sqlite3Error(db, SQLITE_TOOBIG, "statement too long"); (void)sqlite3SafetyOff(db); return sqlite3ApiExit(db, SQLITE_TOOBIG); } zSqlCopy = sqlite3DbStrNDup(db, zSql, nBytes); if( zSqlCopy ){ sqlite3RunParser(&sParse, zSqlCopy, &zErrMsg); sqlite3DbFree(db, zSqlCopy); sParse.zTail = &zSql[sParse.zTail-zSqlCopy]; }else{ sParse.zTail = &zSql[nBytes]; } }else{ sqlite3RunParser(&sParse, zSql, &zErrMsg); } if( db->mallocFailed ){ sParse.rc = SQLITE_NOMEM; } if( sParse.rc==SQLITE_DONE ) sParse.rc = SQLITE_OK; if( sParse.checkSchema && !schemaIsValid(db) ){ sParse.rc = SQLITE_SCHEMA; } if( sParse.rc==SQLITE_SCHEMA ){ sqlite3ResetInternalSchema(db, 0); } if( db->mallocFailed ){ sParse.rc = SQLITE_NOMEM; } if( pzTail ){ *pzTail = sParse.zTail; } rc = sParse.rc; 
#ifndef SQLITE_OMIT_EXPLAIN 
 if( rc==SQLITE_OK && sParse.pVdbe && sParse.explain ){ if( sParse.explain==2 ){ sqlite3VdbeSetNumCols(sParse.pVdbe, 3); sqlite3VdbeSetColName(sParse.pVdbe, 0, COLNAME_NAME, "order", SQLITE_STATIC); sqlite3VdbeSetColName(sParse.pVdbe, 1, COLNAME_NAME, "from", SQLITE_STATIC); sqlite3VdbeSetColName(sParse.pVdbe, 2, COLNAME_NAME, "detail", SQLITE_STATIC); }else{ sqlite3VdbeSetNumCols(sParse.pVdbe, 8); sqlite3VdbeSetColName(sParse.pVdbe, 0, COLNAME_NAME, "addr", SQLITE_STATIC); sqlite3VdbeSetColName(sParse.pVdbe, 1, COLNAME_NAME, "opcode", SQLITE_STATIC); sqlite3VdbeSetColName(sParse.pVdbe, 2, COLNAME_NAME, "p1", SQLITE_STATIC); sqlite3VdbeSetColName(sParse.pVdbe, 3, COLNAME_NAME, "p2", SQLITE_STATIC); sqlite3VdbeSetColName(sParse.pVdbe, 4, COLNAME_NAME, "p3", SQLITE_STATIC); sqlite3VdbeSetColName(sParse.pVdbe, 5, COLNAME_NAME, "p4", SQLITE_STATIC); sqlite3VdbeSetColName(sParse.pVdbe, 6, COLNAME_NAME, "p5", SQLITE_STATIC); sqlite3VdbeSetColName(sParse.pVdbe, 7, COLNAME_NAME, "comment", SQLITE_STATIC); } } 
#endif 
 if( sqlite3SafetyOff(db) ){ rc = SQLITE_MISUSE; } if( saveSqlFlag ){ sqlite3VdbeSetSql(sParse.pVdbe, zSql, sParse.zTail - zSql); } if( rc!=SQLITE_OK || db->mallocFailed ){ sqlite3_finalize((sqlite3_stmt*)sParse.pVdbe); assert(!(*ppStmt)); }else{ *ppStmt = (sqlite3_stmt*)sParse.pVdbe; } if( zErrMsg ){ sqlite3Error(db, rc, "%s", zErrMsg); sqlite3DbFree(db, zErrMsg); }else{ sqlite3Error(db, rc, 0); } rc = sqlite3ApiExit(db, rc); assert( (rc&db->errMask)==rc ); return rc; } static int sqlite3LockAndPrepare( sqlite3 *db, const char *zSql, int nBytes, int saveSqlFlag, sqlite3_stmt **ppStmt, const char **pzTail ){ int rc; if( !sqlite3SafetyCheckOk(db) ){ return SQLITE_MISUSE; } sqlite3_mutex_enter(db->mutex); sqlite3BtreeEnterAll(db); rc = sqlite3Prepare(db, zSql, nBytes, saveSqlFlag, ppStmt, pzTail); sqlite3BtreeLeaveAll(db); sqlite3_mutex_leave(db->mutex); return rc; } SQLITE_PRIVATE int sqlite3Reprepare(Vdbe *p){ int rc; sqlite3_stmt *pNew; const char *zSql; sqlite3 *db; assert( sqlite3_mutex_held(sqlite3VdbeDb(p)->mutex) ); zSql = sqlite3_sql((sqlite3_stmt *)p); assert( zSql!=0 ); db = sqlite3VdbeDb(p); assert( sqlite3_mutex_held(db->mutex) ); rc = sqlite3LockAndPrepare(db, zSql, -1, 0, &pNew, 0); if( rc ){ if( rc==SQLITE_NOMEM ){ db->mallocFailed = 1; } assert( pNew==0 ); return 0; }else{ assert( pNew!=0 ); } sqlite3VdbeSwap((Vdbe*)pNew, p); sqlite3TransferBindings(pNew, (sqlite3_stmt*)p); sqlite3VdbeResetStepResult((Vdbe*)pNew); sqlite3VdbeFinalize((Vdbe*)pNew); return 1; } SQLITE_API int sqlite3_prepare( sqlite3 *db, const char *zSql, int nBytes, sqlite3_stmt **ppStmt, const char **pzTail ){ int rc; rc = sqlite3LockAndPrepare(db,zSql,nBytes,0,ppStmt,pzTail); assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 ); return rc; } SQLITE_API int sqlite3_prepare_v2( sqlite3 *db, const char *zSql, int nBytes, sqlite3_stmt **ppStmt, const char **pzTail ){ int rc; rc = sqlite3LockAndPrepare(db,zSql,nBytes,1,ppStmt,pzTail); assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 ); return rc; } 
#ifndef SQLITE_OMIT_UTF16 
static int sqlite3Prepare16( sqlite3 *db, const void *zSql, int nBytes, int saveSqlFlag, sqlite3_stmt **ppStmt, const void **pzTail ){ char *zSql8; const char *zTail8 = 0; int rc = SQLITE_OK; if( !sqlite3SafetyCheckOk(db) ){ return SQLITE_MISUSE; } sqlite3_mutex_enter(db->mutex); zSql8 = sqlite3Utf16to8(db, zSql, nBytes); if( zSql8 ){ rc = sqlite3LockAndPrepare(db, zSql8, -1, saveSqlFlag, ppStmt, &zTail8); } if( zTail8 && pzTail ){ int chars_parsed = sqlite3Utf8CharLen(zSql8, zTail8-zSql8); *pzTail = (u8 *)zSql + sqlite3Utf16ByteLen(zSql, chars_parsed); } sqlite3DbFree(db, zSql8); rc = sqlite3ApiExit(db, rc); sqlite3_mutex_leave(db->mutex); return rc; } SQLITE_API int sqlite3_prepare16( sqlite3 *db, const void *zSql, int nBytes, sqlite3_stmt **ppStmt, const void **pzTail ){ int rc; rc = sqlite3Prepare16(db,zSql,nBytes,0,ppStmt,pzTail); assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 ); return rc; } SQLITE_API int sqlite3_prepare16_v2( sqlite3 *db, const void *zSql, int nBytes, sqlite3_stmt **ppStmt, const void **pzTail ){ int rc; rc = sqlite3Prepare16(db,zSql,nBytes,1,ppStmt,pzTail); assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 ); return rc; } 
#endif 
static void clearSelect(sqlite3 *db, Select *p){ sqlite3ExprListDelete(db, p->pEList); sqlite3SrcListDelete(db, p->pSrc); sqlite3ExprDelete(db, p->pWhere); sqlite3ExprListDelete(db, p->pGroupBy); sqlite3ExprDelete(db, p->pHaving); sqlite3ExprListDelete(db, p->pOrderBy); sqlite3SelectDelete(db, p->pPrior); sqlite3ExprDelete(db, p->pLimit); sqlite3ExprDelete(db, p->pOffset); } SQLITE_PRIVATE void sqlite3SelectDestInit(SelectDest *pDest, int eDest, int iParm){ pDest->eDest = eDest; pDest->iParm = iParm; pDest->affinity = 0; pDest->iMem = 0; pDest->nMem = 0; } SQLITE_PRIVATE Select *sqlite3SelectNew( Parse *pParse, ExprList *pEList, SrcList *pSrc, Expr *pWhere, ExprList *pGroupBy, Expr *pHaving, ExprList *pOrderBy, int isDistinct, Expr *pLimit, Expr *pOffset ){ Select *pNew; Select standin; sqlite3 *db = pParse->db; pNew = sqlite3DbMallocZero(db, sizeof(*pNew) ); assert( db->mallocFailed || !pOffset || pLimit ); if( pNew==0 ){ pNew = &standin; memset(pNew, 0, sizeof(*pNew)); } if( pEList==0 ){ pEList = sqlite3ExprListAppend(pParse, 0, sqlite3Expr(db,TK_ALL,0,0,0), 0); } pNew->pEList = pEList; pNew->pSrc = pSrc; pNew->pWhere = pWhere; pNew->pGroupBy = pGroupBy; pNew->pHaving = pHaving; pNew->pOrderBy = pOrderBy; pNew->selFlags = isDistinct ? SF_Distinct : 0; pNew->op = TK_SELECT; pNew->pLimit = pLimit; pNew->pOffset = pOffset; pNew->addrOpenEphm[0] = -1; pNew->addrOpenEphm[1] = -1; pNew->addrOpenEphm[2] = -1; if( db->mallocFailed ) { clearSelect(db, pNew); if( pNew!=&standin ) sqlite3DbFree(db, pNew); pNew = 0; } return pNew; } SQLITE_PRIVATE void sqlite3SelectDelete(sqlite3 *db, Select *p){ if( p ){ clearSelect(db, p); sqlite3DbFree(db, p); } } SQLITE_PRIVATE int sqlite3JoinType(Parse *pParse, Token *pA, Token *pB, Token *pC){ int jointype = 0; Token *apAll[3]; Token *p; static const struct { const char zKeyword[8]; u8 nChar; u8 code; } keywords[] = { { "natural", 7, JT_NATURAL }, { "left", 4, JT_LEFT|JT_OUTER }, { "right", 5, JT_RIGHT|JT_OUTER }, { "full", 4, JT_LEFT|JT_RIGHT|JT_OUTER }, { "outer", 5, JT_OUTER }, { "inner", 5, JT_INNER }, { "cross", 5, JT_INNER|JT_CROSS }, }; int i, j; apAll[0] = pA; apAll[1] = pB; apAll[2] = pC; for(i=0; i<3 && apAll[i]; i++){ p = apAll[i]; for(j=0; j<ArraySize(keywords); j++){ if( p->n==keywords[j].nChar && sqlite3StrNICmp((char*)p->z, keywords[j].zKeyword, p->n)==0 ){ jointype |= keywords[j].code; break; } } if( j>=ArraySize(keywords) ){ jointype |= JT_ERROR; break; } } if( (jointype & (JT_INNER|JT_OUTER))==(JT_INNER|JT_OUTER) || (jointype & JT_ERROR)!=0 ){ const char *zSp = " "; assert( pB!=0 ); if( pC==0 ){ zSp++; } sqlite3ErrorMsg(pParse, "unknown or unsupported join type: " "%T %T%s%T", pA, pB, zSp, pC); jointype = JT_INNER; }else if( jointype & JT_RIGHT ){ sqlite3ErrorMsg(pParse, "RIGHT and FULL OUTER JOINs are not currently supported"); jointype = JT_INNER; } return jointype; } static int columnIndex(Table *pTab, const char *zCol){ int i; for(i=0; i<pTab->nCol; i++){ if( sqlite3StrICmp(pTab->aCol[i].zName, zCol)==0 ) return i; } return -1; } static void setToken(Token *p, const char *z){ p->z = (u8*)z; p->n = z ? strlen(z) : 0; p->dyn = 0; } static void setQuotedToken(Parse *pParse, Token *p, const char *z){ const char *z2 = z; if( *z2!='[' && *z2!='`' && *z2!='\'' ){ while( *z2 ){ if( *z2=='"' ) break; z2++; } } if( *z2 ){ p->z = (u8 *)sqlite3MPrintf(pParse->db, "\"%w\"", z); if( p->z ){ p->n = strlen((char *)p->z); p->dyn = 1; } }else{ p->z = (u8*)z; p->n = (z2 - z); p->dyn = 0; } } SQLITE_PRIVATE Expr *sqlite3CreateIdExpr(Parse *pParse, const char *zName){ Token dummy; setToken(&dummy, zName); return sqlite3PExpr(pParse, TK_ID, 0, 0, &dummy); } static void addWhereTerm( Parse *pParse, const char *zCol, const Table *pTab1, const char *zAlias1, const Table *pTab2, const char *zAlias2, int iRightJoinTable, Expr **ppExpr, int isOuterJoin ){ Expr *pE1a, *pE1b, *pE1c; Expr *pE2a, *pE2b, *pE2c; Expr *pE; pE1a = sqlite3CreateIdExpr(pParse, zCol); pE2a = sqlite3CreateIdExpr(pParse, zCol); if( zAlias1==0 ){ zAlias1 = pTab1->zName; } pE1b = sqlite3CreateIdExpr(pParse, zAlias1); if( zAlias2==0 ){ zAlias2 = pTab2->zName; } pE2b = sqlite3CreateIdExpr(pParse, zAlias2); pE1c = sqlite3PExpr(pParse, TK_DOT, pE1b, pE1a, 0); pE2c = sqlite3PExpr(pParse, TK_DOT, pE2b, pE2a, 0); pE = sqlite3PExpr(pParse, TK_EQ, pE1c, pE2c, 0); if( pE && isOuterJoin ){ ExprSetProperty(pE, EP_FromJoin); pE->iRightJoinTable = iRightJoinTable; } *ppExpr = sqlite3ExprAnd(pParse->db,*ppExpr, pE); } static void setJoinExpr(Expr *p, int iTable){ while( p ){ ExprSetProperty(p, EP_FromJoin); p->iRightJoinTable = iTable; setJoinExpr(p->pLeft, iTable); p = p->pRight; } } static int sqliteProcessJoin(Parse *pParse, Select *p){ SrcList *pSrc; int i, j; struct SrcList_item *pLeft; struct SrcList_item *pRight; pSrc = p->pSrc; pLeft = &pSrc->a[0]; pRight = &pLeft[1]; for(i=0; i<pSrc->nSrc-1; i++, pRight++, pLeft++){ Table *pLeftTab = pLeft->pTab; Table *pRightTab = pRight->pTab; int isOuter; if( pLeftTab==0 || pRightTab==0 ) continue; isOuter = (pRight->jointype & JT_OUTER)!=0; if( pRight->jointype & JT_NATURAL ){ if( pRight->pOn || pRight->pUsing ){ sqlite3ErrorMsg(pParse, "a NATURAL join may not have " "an ON or USING clause", 0); return 1; } for(j=0; j<pLeftTab->nCol; j++){ char *zName = pLeftTab->aCol[j].zName; if( columnIndex(pRightTab, zName)>=0 ){ addWhereTerm(pParse, zName, pLeftTab, pLeft->zAlias, pRightTab, pRight->zAlias, pRight->iCursor, &p->pWhere, isOuter); } } } if( pRight->pOn && pRight->pUsing ){ sqlite3ErrorMsg(pParse, "cannot have both ON and USING " "clauses in the same join"); return 1; } if( pRight->pOn ){ if( isOuter ) setJoinExpr(pRight->pOn, pRight->iCursor); p->pWhere = sqlite3ExprAnd(pParse->db, p->pWhere, pRight->pOn); pRight->pOn = 0; } if( pRight->pUsing ){ IdList *pList = pRight->pUsing; for(j=0; j<pList->nId; j++){ char *zName = pList->a[j].zName; if( columnIndex(pLeftTab, zName)<0 || columnIndex(pRightTab, zName)<0 ){ sqlite3ErrorMsg(pParse, "cannot join using column %s - column " "not present in both tables", zName); return 1; } addWhereTerm(pParse, zName, pLeftTab, pLeft->zAlias, pRightTab, pRight->zAlias, pRight->iCursor, &p->pWhere, isOuter); } } } return 0; } static void pushOntoSorter( Parse *pParse, ExprList *pOrderBy, Select *pSelect, int regData ){ Vdbe *v = pParse->pVdbe; int nExpr = pOrderBy->nExpr; int regBase = sqlite3GetTempRange(pParse, nExpr+2); int regRecord = sqlite3GetTempReg(pParse); sqlite3ExprCodeExprList(pParse, pOrderBy, regBase, 0); sqlite3VdbeAddOp2(v, OP_Sequence, pOrderBy->iECursor, regBase+nExpr); sqlite3ExprCodeMove(pParse, regData, regBase+nExpr+1, 1); sqlite3VdbeAddOp3(v, OP_MakeRecord, regBase, nExpr + 2, regRecord); sqlite3VdbeAddOp2(v, OP_IdxInsert, pOrderBy->iECursor, regRecord); sqlite3ReleaseTempReg(pParse, regRecord); sqlite3ReleaseTempRange(pParse, regBase, nExpr+2); if( pSelect->iLimit ){ int addr1, addr2; int iLimit; if( pSelect->iOffset ){ iLimit = pSelect->iOffset+1; }else{ iLimit = pSelect->iLimit; } addr1 = sqlite3VdbeAddOp1(v, OP_IfZero, iLimit); sqlite3VdbeAddOp2(v, OP_AddImm, iLimit, -1); addr2 = sqlite3VdbeAddOp0(v, OP_Goto); sqlite3VdbeJumpHere(v, addr1); sqlite3VdbeAddOp1(v, OP_Last, pOrderBy->iECursor); sqlite3VdbeAddOp1(v, OP_Delete, pOrderBy->iECursor); sqlite3VdbeJumpHere(v, addr2); pSelect->iLimit = 0; } } static void codeOffset( Vdbe *v, Select *p, int iContinue ){ if( p->iOffset && iContinue!=0 ){ int addr; sqlite3VdbeAddOp2(v, OP_AddImm, p->iOffset, -1); addr = sqlite3VdbeAddOp1(v, OP_IfNeg, p->iOffset); sqlite3VdbeAddOp2(v, OP_Goto, 0, iContinue); VdbeComment((v, "skip OFFSET records")); sqlite3VdbeJumpHere(v, addr); } } static void codeDistinct( Parse *pParse, int iTab, int addrRepeat, int N, int iMem ){ Vdbe *v; int r1; v = pParse->pVdbe; r1 = sqlite3GetTempReg(pParse); sqlite3VdbeAddOp3(v, OP_MakeRecord, iMem, N, r1); sqlite3VdbeAddOp3(v, OP_Found, iTab, addrRepeat, r1); sqlite3VdbeAddOp2(v, OP_IdxInsert, iTab, r1); sqlite3ReleaseTempReg(pParse, r1); } static int checkForMultiColumnSelectError( Parse *pParse, SelectDest *pDest, int nExpr ){ int eDest = pDest->eDest; if( nExpr>1 && (eDest==SRT_Mem || eDest==SRT_Set) ){ sqlite3ErrorMsg(pParse, "only a single result allowed for " "a SELECT that is part of an expression"); return 1; }else{ return 0; } } static void selectInnerLoop( Parse *pParse, Select *p, ExprList *pEList, int srcTab, int nColumn, ExprList *pOrderBy, int distinct, SelectDest *pDest, int iContinue, int iBreak ){ Vdbe *v = pParse->pVdbe; int i; int hasDistinct; int regResult; int eDest = pDest->eDest; int iParm = pDest->iParm; int nResultCol; if( v==0 ) return; assert( pEList!=0 ); hasDistinct = distinct>=0; if( pOrderBy==0 && !hasDistinct ){ codeOffset(v, p, iContinue); } if( nColumn>0 ){ nResultCol = nColumn; }else{ nResultCol = pEList->nExpr; } if( pDest->iMem==0 ){ pDest->iMem = pParse->nMem+1; pDest->nMem = nResultCol; pParse->nMem += nResultCol; }else if( pDest->nMem!=nResultCol ){ return; } regResult = pDest->iMem; if( nColumn>0 ){ for(i=0; i<nColumn; i++){ sqlite3VdbeAddOp3(v, OP_Column, srcTab, i, regResult+i); } }else if( eDest!=SRT_Exists ){ sqlite3ExprCodeExprList(pParse, pEList, regResult, eDest==SRT_Output); } nColumn = nResultCol; if( hasDistinct ){ assert( pEList!=0 ); assert( pEList->nExpr==nColumn ); codeDistinct(pParse, distinct, iContinue, nColumn, regResult); if( pOrderBy==0 ){ codeOffset(v, p, iContinue); } } if( checkForMultiColumnSelectError(pParse, pDest, pEList->nExpr) ){ return; } switch( eDest ){ 
#ifndef SQLITE_OMIT_COMPOUND_SELECT 
 case SRT_Union: { int r1; r1 = sqlite3GetTempReg(pParse); sqlite3VdbeAddOp3(v, OP_MakeRecord, regResult, nColumn, r1); sqlite3VdbeAddOp2(v, OP_IdxInsert, iParm, r1); sqlite3ReleaseTempReg(pParse, r1); break; } case SRT_Except: { sqlite3VdbeAddOp3(v, OP_IdxDelete, iParm, regResult, nColumn); break; } 
#endif 
 case SRT_Table: case SRT_EphemTab: { int r1 = sqlite3GetTempReg(pParse); sqlite3VdbeAddOp3(v, OP_MakeRecord, regResult, nColumn, r1); if( pOrderBy ){ pushOntoSorter(pParse, pOrderBy, p, r1); }else{ int r2 = sqlite3GetTempReg(pParse); sqlite3VdbeAddOp2(v, OP_NewRowid, iParm, r2); sqlite3VdbeAddOp3(v, OP_Insert, iParm, r1, r2); sqlite3VdbeChangeP5(v, OPFLAG_APPEND); sqlite3ReleaseTempReg(pParse, r2); } sqlite3ReleaseTempReg(pParse, r1); break; } 
#ifndef SQLITE_OMIT_SUBQUERY 
 case SRT_Set: { assert( nColumn==1 ); p->affinity = sqlite3CompareAffinity(pEList->a[0].pExpr, pDest->affinity); if( pOrderBy ){ pushOntoSorter(pParse, pOrderBy, p, regResult); }else{ int r1 = sqlite3GetTempReg(pParse); sqlite3VdbeAddOp4(v, OP_MakeRecord, regResult, 1, r1, &p->affinity, 1); sqlite3ExprCacheAffinityChange(pParse, regResult, 1); sqlite3VdbeAddOp2(v, OP_IdxInsert, iParm, r1); sqlite3ReleaseTempReg(pParse, r1); } break; } case SRT_Exists: { sqlite3VdbeAddOp2(v, OP_Integer, 1, iParm); break; } case SRT_Mem: { assert( nColumn==1 ); if( pOrderBy ){ pushOntoSorter(pParse, pOrderBy, p, regResult); }else{ sqlite3ExprCodeMove(pParse, regResult, iParm, 1); } break; } 
#endif 
 case SRT_Coroutine: case SRT_Output: { if( pOrderBy ){ int r1 = sqlite3GetTempReg(pParse); sqlite3VdbeAddOp3(v, OP_MakeRecord, regResult, nColumn, r1); pushOntoSorter(pParse, pOrderBy, p, r1); sqlite3ReleaseTempReg(pParse, r1); }else if( eDest==SRT_Coroutine ){ sqlite3VdbeAddOp1(v, OP_Yield, pDest->iParm); }else{ sqlite3VdbeAddOp2(v, OP_ResultRow, regResult, nColumn); sqlite3ExprCacheAffinityChange(pParse, regResult, nColumn); } break; } 
#if !defined(SQLITE_OMIT_TRIGGER) 
 default: { assert( eDest==SRT_Discard ); break; } 
#endif 
 } if( p->iLimit ){ assert( pOrderBy==0 ); sqlite3VdbeAddOp2(v, OP_AddImm, p->iLimit, -1); sqlite3VdbeAddOp2(v, OP_IfZero, p->iLimit, iBreak); } } static KeyInfo *keyInfoFromExprList(Parse *pParse, ExprList *pList){ sqlite3 *db = pParse->db; int nExpr; KeyInfo *pInfo; struct ExprList_item *pItem; int i; nExpr = pList->nExpr; pInfo = sqlite3DbMallocZero(db, sizeof(*pInfo) + nExpr*(sizeof(CollSeq*)+1) ); if( pInfo ){ pInfo->aSortOrder = (u8*)&pInfo->aColl[nExpr]; pInfo->nField = nExpr; pInfo->enc = ENC(db); for(i=0, pItem=pList->a; i<nExpr; i++, pItem++){ CollSeq *pColl; pColl = sqlite3ExprCollSeq(pParse, pItem->pExpr); if( !pColl ){ pColl = db->pDfltColl; } pInfo->aColl[i] = pColl; pInfo->aSortOrder[i] = pItem->sortOrder; } } return pInfo; } static void generateSortTail( Parse *pParse, Select *p, Vdbe *v, int nColumn, SelectDest *pDest ){ int brk = sqlite3VdbeMakeLabel(v); int cont = sqlite3VdbeMakeLabel(v); int addr; int iTab; int pseudoTab = 0; ExprList *pOrderBy = p->pOrderBy; int eDest = pDest->eDest; int iParm = pDest->iParm; int regRow; int regRowid; iTab = pOrderBy->iECursor; if( eDest==SRT_Output || eDest==SRT_Coroutine ){ pseudoTab = pParse->nTab++; sqlite3VdbeAddOp2(v, OP_SetNumColumns, 0, nColumn); sqlite3VdbeAddOp2(v, OP_OpenPseudo, pseudoTab, eDest==SRT_Output); } addr = 1 + sqlite3VdbeAddOp2(v, OP_Sort, iTab, brk); codeOffset(v, p, cont); regRow = sqlite3GetTempReg(pParse); regRowid = sqlite3GetTempReg(pParse); sqlite3VdbeAddOp3(v, OP_Column, iTab, pOrderBy->nExpr + 1, regRow); switch( eDest ){ case SRT_Table: case SRT_EphemTab: { sqlite3VdbeAddOp2(v, OP_NewRowid, iParm, regRowid); sqlite3VdbeAddOp3(v, OP_Insert, iParm, regRow, regRowid); sqlite3VdbeChangeP5(v, OPFLAG_APPEND); break; } 
#ifndef SQLITE_OMIT_SUBQUERY 
 case SRT_Set: { assert( nColumn==1 ); sqlite3VdbeAddOp4(v, OP_MakeRecord, regRow, 1, regRowid, &p->affinity, 1); sqlite3ExprCacheAffinityChange(pParse, regRow, 1); sqlite3VdbeAddOp2(v, OP_IdxInsert, iParm, regRowid); break; } case SRT_Mem: { assert( nColumn==1 ); sqlite3ExprCodeMove(pParse, regRow, iParm, 1); break; } 
#endif 
 case SRT_Output: case SRT_Coroutine: { int i; sqlite3VdbeAddOp2(v, OP_Integer, 1, regRowid); sqlite3VdbeAddOp3(v, OP_Insert, pseudoTab, regRow, regRowid); for(i=0; i<nColumn; i++){ assert( regRow!=pDest->iMem+i ); sqlite3VdbeAddOp3(v, OP_Column, pseudoTab, i, pDest->iMem+i); } if( eDest==SRT_Output ){ sqlite3VdbeAddOp2(v, OP_ResultRow, pDest->iMem, nColumn); sqlite3ExprCacheAffinityChange(pParse, pDest->iMem, nColumn); }else{ sqlite3VdbeAddOp1(v, OP_Yield, pDest->iParm); } break; } default: { break; } } sqlite3ReleaseTempReg(pParse, regRow); sqlite3ReleaseTempReg(pParse, regRowid); assert( p->iLimit==0 ); sqlite3VdbeResolveLabel(v, cont); sqlite3VdbeAddOp2(v, OP_Next, iTab, addr); sqlite3VdbeResolveLabel(v, brk); if( eDest==SRT_Output || eDest==SRT_Coroutine ){ sqlite3VdbeAddOp2(v, OP_Close, pseudoTab, 0); } } static const char *columnType( NameContext *pNC, Expr *pExpr, const char **pzOriginDb, const char **pzOriginTab, const char **pzOriginCol ){ char const *zType = 0; char const *zOriginDb = 0; char const *zOriginTab = 0; char const *zOriginCol = 0; int j; if( pExpr==0 || pNC->pSrcList==0 ) return 0; switch( pExpr->op ){ case TK_AGG_COLUMN: case TK_COLUMN: { Table *pTab = 0; Select *pS = 0; int iCol = pExpr->iColumn; while( pNC && !pTab ){ SrcList *pTabList = pNC->pSrcList; for(j=0;j<pTabList->nSrc && pTabList->a[j].iCursor!=pExpr->iTable;j++); if( j<pTabList->nSrc ){ pTab = pTabList->a[j].pTab; pS = pTabList->a[j].pSelect; }else{ pNC = pNC->pNext; } } if( pTab==0 ){ zType = "TEXT"; break; } assert( pTab ); if( pS ){ if( iCol>=0 && iCol<pS->pEList->nExpr ){ NameContext sNC; Expr *p = pS->pEList->a[iCol].pExpr; sNC.pSrcList = pS->pSrc; sNC.pNext = 0; sNC.pParse = pNC->pParse; zType = columnType(&sNC, p, &zOriginDb, &zOriginTab, &zOriginCol); } }else if( pTab->pSchema ){ assert( !pS ); if( iCol<0 ) iCol = pTab->iPKey; assert( iCol==-1 || (iCol>=0 && iCol<pTab->nCol) ); if( iCol<0 ){ zType = "INTEGER"; zOriginCol = "rowid"; }else{ zType = pTab->aCol[iCol].zType; zOriginCol = pTab->aCol[iCol].zName; } zOriginTab = pTab->zName; if( pNC->pParse ){ int iDb = sqlite3SchemaToIndex(pNC->pParse->db, pTab->pSchema); zOriginDb = pNC->pParse->db->aDb[iDb].zName; } } break; } 
#ifndef SQLITE_OMIT_SUBQUERY 
 case TK_SELECT: { NameContext sNC; Select *pS = pExpr->pSelect; Expr *p = pS->pEList->a[0].pExpr; sNC.pSrcList = pS->pSrc; sNC.pNext = pNC; sNC.pParse = pNC->pParse; zType = columnType(&sNC, p, &zOriginDb, &zOriginTab, &zOriginCol); break; } 
#endif 
 } if( pzOriginDb ){ assert( pzOriginTab && pzOriginCol ); *pzOriginDb = zOriginDb; *pzOriginTab = zOriginTab; *pzOriginCol = zOriginCol; } return zType; } static void generateColumnTypes( Parse *pParse, SrcList *pTabList, ExprList *pEList ){ 
#ifndef SQLITE_OMIT_DECLTYPE 
 Vdbe *v = pParse->pVdbe; int i; NameContext sNC; sNC.pSrcList = pTabList; sNC.pParse = pParse; for(i=0; i<pEList->nExpr; i++){ Expr *p = pEList->a[i].pExpr; const char *zType; 
#ifdef SQLITE_ENABLE_COLUMN_METADATA 
 const char *zOrigDb = 0; const char *zOrigTab = 0; const char *zOrigCol = 0; zType = columnType(&sNC, p, &zOrigDb, &zOrigTab, &zOrigCol); sqlite3VdbeSetColName(v, i, COLNAME_DATABASE, zOrigDb, SQLITE_TRANSIENT); sqlite3VdbeSetColName(v, i, COLNAME_TABLE, zOrigTab, SQLITE_TRANSIENT); sqlite3VdbeSetColName(v, i, COLNAME_COLUMN, zOrigCol, SQLITE_TRANSIENT); 
#else 
 zType = columnType(&sNC, p, 0, 0, 0); 
#endif 
 sqlite3VdbeSetColName(v, i, COLNAME_DECLTYPE, zType, SQLITE_TRANSIENT); } 
#endif 
} static void generateColumnNames( Parse *pParse, SrcList *pTabList, ExprList *pEList ){ Vdbe *v = pParse->pVdbe; int i, j; sqlite3 *db = pParse->db; int fullNames, shortNames; 
#ifndef SQLITE_OMIT_EXPLAIN 
 if( pParse->explain ){ return; } 
#endif 
 assert( v!=0 ); if( pParse->colNamesSet || v==0 || db->mallocFailed ) return; pParse->colNamesSet = 1; fullNames = (db->flags & SQLITE_FullColNames)!=0; shortNames = (db->flags & SQLITE_ShortColNames)!=0; sqlite3VdbeSetNumCols(v, pEList->nExpr); for(i=0; i<pEList->nExpr; i++){ Expr *p; p = pEList->a[i].pExpr; if( p==0 ) continue; if( pEList->a[i].zName ){ char *zName = pEList->a[i].zName; sqlite3VdbeSetColName(v, i, COLNAME_NAME, zName, SQLITE_TRANSIENT); }else if( (p->op==TK_COLUMN || p->op==TK_AGG_COLUMN) && pTabList ){ Table *pTab; char *zCol; int iCol = p->iColumn; for(j=0; j<pTabList->nSrc && pTabList->a[j].iCursor!=p->iTable; j++){} assert( j<pTabList->nSrc ); pTab = pTabList->a[j].pTab; if( iCol<0 ) iCol = pTab->iPKey; assert( iCol==-1 || (iCol>=0 && iCol<pTab->nCol) ); if( iCol<0 ){ zCol = "rowid"; }else{ zCol = pTab->aCol[iCol].zName; } if( !shortNames && !fullNames ){ sqlite3VdbeSetColName(v, i, COLNAME_NAME, sqlite3DbStrNDup(db, (char*)p->span.z, p->span.n), SQLITE_DYNAMIC); }else if( fullNames || (!shortNames && pTabList->nSrc>1) ){ char *zName = 0; char *zTab; zTab = pTabList->a[j].zAlias; if( fullNames || zTab==0 ) zTab = pTab->zName; zName = sqlite3MPrintf(db, "%s.%s", zTab, zCol); sqlite3VdbeSetColName(v, i, COLNAME_NAME, zName, SQLITE_DYNAMIC); }else{ sqlite3VdbeSetColName(v, i, COLNAME_NAME, zCol, SQLITE_TRANSIENT); } }else{ sqlite3VdbeSetColName(v, i, COLNAME_NAME, sqlite3DbStrNDup(db, (char*)p->span.z, p->span.n), SQLITE_DYNAMIC); } } generateColumnTypes(pParse, pTabList, pEList); } 
#ifndef SQLITE_OMIT_COMPOUND_SELECT 
static const char *selectOpName(int id){ char *z; switch( id ){ case TK_ALL: z = "UNION ALL"; break; case TK_INTERSECT: z = "INTERSECT"; break; case TK_EXCEPT: z = "EXCEPT"; break; default: z = "UNION"; break; } return z; } 
#endif 
static int selectColumnsFromExprList( Parse *pParse, ExprList *pEList, int *pnCol, Column **paCol ){ sqlite3 *db = pParse->db; int i, j, cnt; Column *aCol, *pCol; int nCol; Expr *p; char *zName; int nName; *pnCol = nCol = pEList->nExpr; aCol = *paCol = sqlite3DbMallocZero(db, sizeof(aCol[0])*nCol); if( aCol==0 ) return SQLITE_NOMEM; for(i=0, pCol=aCol; i<nCol; i++, pCol++){ p = pEList->a[i].pExpr; assert( p->pRight==0 || p->pRight->token.z==0 || p->pRight->token.z[0]!=0 ); if( (zName = pEList->a[i].zName)!=0 ){ zName = sqlite3DbStrDup(db, zName); }else{ Expr *pCol = p; Table *pTab; while( pCol->op==TK_DOT ) pCol = pCol->pRight; if( pCol->op==TK_COLUMN && (pTab = pCol->pTab)!=0 ){ int iCol = pCol->iColumn; if( iCol<0 ) iCol = pTab->iPKey; zName = sqlite3MPrintf(db, "%s", iCol>=0 ? pTab->aCol[iCol].zName : "rowid"); }else{ zName = sqlite3MPrintf(db, "%T", &pCol->span); } } if( db->mallocFailed ){ sqlite3DbFree(db, zName); break; } sqlite3Dequote(zName); nName = strlen(zName); for(j=cnt=0; j<i; j++){ if( sqlite3StrICmp(aCol[j].zName, zName)==0 ){ char *zNewName; zName[nName] = 0; zNewName = sqlite3MPrintf(db, "%s:%d", zName, ++cnt); sqlite3DbFree(db, zName); zName = zNewName; j = -1; if( zName==0 ) break; } } pCol->zName = zName; } if( db->mallocFailed ){ int j; for(j=0; j<i; j++){ sqlite3DbFree(db, aCol[j].zName); } sqlite3DbFree(db, aCol); *paCol = 0; *pnCol = 0; return SQLITE_NOMEM; } return SQLITE_OK; } static void selectAddColumnTypeAndCollation( Parse *pParse, int nCol, Column *aCol, Select *pSelect ){ sqlite3 *db = pParse->db; NameContext sNC; Column *pCol; CollSeq *pColl; int i; Expr *p; struct ExprList_item *a; assert( pSelect!=0 ); assert( (pSelect->selFlags & SF_Resolved)!=0 ); assert( nCol==pSelect->pEList->nExpr || db->mallocFailed ); if( db->mallocFailed ) return; memset(&sNC, 0, sizeof(sNC)); sNC.pSrcList = pSelect->pSrc; a = pSelect->pEList->a; for(i=0, pCol=aCol; i<nCol; i++, pCol++){ p = a[i].pExpr; pCol->zType = sqlite3DbStrDup(db, columnType(&sNC, p, 0, 0, 0)); pCol->affinity = sqlite3ExprAffinity(p); pColl = sqlite3ExprCollSeq(pParse, p); if( pColl ){ pCol->zColl = sqlite3DbStrDup(db, pColl->zName); } } } SQLITE_PRIVATE Table *sqlite3ResultSetOfSelect(Parse *pParse, Select *pSelect){ Table *pTab; sqlite3 *db = pParse->db; int savedFlags; savedFlags = db->flags; db->flags &= ~SQLITE_FullColNames; db->flags |= SQLITE_ShortColNames; sqlite3SelectPrep(pParse, pSelect, 0); if( pParse->nErr ) return 0; while( pSelect->pPrior ) pSelect = pSelect->pPrior; db->flags = savedFlags; pTab = sqlite3DbMallocZero(db, sizeof(Table) ); if( pTab==0 ){ return 0; } pTab->db = db; pTab->nRef = 1; pTab->zName = 0; selectColumnsFromExprList(pParse, pSelect->pEList, &pTab->nCol, &pTab->aCol); selectAddColumnTypeAndCollation(pParse, pTab->nCol, pTab->aCol, pSelect); pTab->iPKey = -1; if( db->mallocFailed ){ sqlite3DeleteTable(pTab); return 0; } return pTab; } SQLITE_PRIVATE Vdbe *sqlite3GetVdbe(Parse *pParse){ Vdbe *v = pParse->pVdbe; if( v==0 ){ v = pParse->pVdbe = sqlite3VdbeCreate(pParse->db); 
#ifndef SQLITE_OMIT_TRACE 
 if( v ){ sqlite3VdbeAddOp0(v, OP_Trace); } 
#endif 
 } return v; } static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak){ Vdbe *v = 0; int iLimit = 0; int iOffset; int addr1; if( p->iLimit ) return; if( p->pLimit ){ p->iLimit = iLimit = ++pParse->nMem; v = sqlite3GetVdbe(pParse); if( v==0 ) return; sqlite3ExprCode(pParse, p->pLimit, iLimit); sqlite3VdbeAddOp1(v, OP_MustBeInt, iLimit); VdbeComment((v, "LIMIT counter")); sqlite3VdbeAddOp2(v, OP_IfZero, iLimit, iBreak); } if( p->pOffset ){ p->iOffset = iOffset = ++pParse->nMem; if( p->pLimit ){ pParse->nMem++; } v = sqlite3GetVdbe(pParse); if( v==0 ) return; sqlite3ExprCode(pParse, p->pOffset, iOffset); sqlite3VdbeAddOp1(v, OP_MustBeInt, iOffset); VdbeComment((v, "OFFSET counter")); addr1 = sqlite3VdbeAddOp1(v, OP_IfPos, iOffset); sqlite3VdbeAddOp2(v, OP_Integer, 0, iOffset); sqlite3VdbeJumpHere(v, addr1); if( p->pLimit ){ sqlite3VdbeAddOp3(v, OP_Add, iLimit, iOffset, iOffset+1); VdbeComment((v, "LIMIT+OFFSET")); addr1 = sqlite3VdbeAddOp1(v, OP_IfPos, iLimit); sqlite3VdbeAddOp2(v, OP_Integer, -1, iOffset+1); sqlite3VdbeJumpHere(v, addr1); } } } 
#ifndef SQLITE_OMIT_COMPOUND_SELECT 
static CollSeq *multiSelectCollSeq(Parse *pParse, Select *p, int iCol){ CollSeq *pRet; if( p->pPrior ){ pRet = multiSelectCollSeq(pParse, p->pPrior, iCol); }else{ pRet = 0; } if( pRet==0 ){ pRet = sqlite3ExprCollSeq(pParse, p->pEList->a[iCol].pExpr); } return pRet; } 
#endif 
static int multiSelectOrderBy( Parse *pParse, Select *p, SelectDest *pDest ); 
#ifndef SQLITE_OMIT_COMPOUND_SELECT 
static int multiSelect( Parse *pParse, Select *p, SelectDest *pDest ){ int rc = SQLITE_OK; Select *pPrior; Vdbe *v; SelectDest dest; Select *pDelete = 0; sqlite3 *db; assert( p && p->pPrior ); db = pParse->db; pPrior = p->pPrior; assert( pPrior->pRightmost!=pPrior ); assert( pPrior->pRightmost==p->pRightmost ); dest = *pDest; if( pPrior->pOrderBy ){ sqlite3ErrorMsg(pParse,"ORDER BY clause should come after %s not before", selectOpName(p->op)); rc = 1; goto multi_select_end; } if( pPrior->pLimit ){ sqlite3ErrorMsg(pParse,"LIMIT clause should come after %s not before", selectOpName(p->op)); rc = 1; goto multi_select_end; } v = sqlite3GetVdbe(pParse); assert( v!=0 ); if( dest.eDest==SRT_EphemTab ){ assert( p->pEList ); sqlite3VdbeAddOp2(v, OP_OpenEphemeral, dest.iParm, p->pEList->nExpr); dest.eDest = SRT_Table; } assert( p->pEList && pPrior->pEList ); if( p->pEList->nExpr!=pPrior->pEList->nExpr ){ sqlite3ErrorMsg(pParse, "SELECTs to the left and right of %s" " do not have the same number of result columns", selectOpName(p->op)); rc = 1; goto multi_select_end; } if( p->pOrderBy ){ return multiSelectOrderBy(pParse, p, pDest); } switch( p->op ){ case TK_ALL: { int addr = 0; assert( !pPrior->pLimit ); pPrior->pLimit = p->pLimit; pPrior->pOffset = p->pOffset; rc = sqlite3Select(pParse, pPrior, &dest); p->pLimit = 0; p->pOffset = 0; if( rc ){ goto multi_select_end; } p->pPrior = 0; p->iLimit = pPrior->iLimit; p->iOffset = pPrior->iOffset; if( p->iLimit ){ addr = sqlite3VdbeAddOp1(v, OP_IfZero, p->iLimit); VdbeComment((v, "Jump ahead if LIMIT reached")); } rc = sqlite3Select(pParse, p, &dest); pDelete = p->pPrior; p->pPrior = pPrior; if( rc ){ goto multi_select_end; } if( addr ){ sqlite3VdbeJumpHere(v, addr); } break; } case TK_EXCEPT: case TK_UNION: { int unionTab; int op = 0; int priorOp; Expr *pLimit, *pOffset; int addr; SelectDest uniondest; priorOp = SRT_Union; if( dest.eDest==priorOp && !p->pLimit && !p->pOffset ){ unionTab = dest.iParm; }else{ unionTab = pParse->nTab++; assert( p->pOrderBy==0 ); addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, unionTab, 0); assert( p->addrOpenEphm[0] == -1 ); p->addrOpenEphm[0] = addr; p->pRightmost->selFlags |= SF_UsesEphemeral; assert( p->pEList ); } assert( !pPrior->pOrderBy ); sqlite3SelectDestInit(&uniondest, priorOp, unionTab); rc = sqlite3Select(pParse, pPrior, &uniondest); if( rc ){ goto multi_select_end; } if( p->op==TK_EXCEPT ){ op = SRT_Except; }else{ assert( p->op==TK_UNION ); op = SRT_Union; } p->pPrior = 0; pLimit = p->pLimit; p->pLimit = 0; pOffset = p->pOffset; p->pOffset = 0; uniondest.eDest = op; rc = sqlite3Select(pParse, p, &uniondest); sqlite3ExprListDelete(db, p->pOrderBy); pDelete = p->pPrior; p->pPrior = pPrior; p->pOrderBy = 0; sqlite3ExprDelete(db, p->pLimit); p->pLimit = pLimit; p->pOffset = pOffset; p->iLimit = 0; p->iOffset = 0; if( rc ){ goto multi_select_end; } if( dest.eDest!=priorOp || unionTab!=dest.iParm ){ int iCont, iBreak, iStart; assert( p->pEList ); if( dest.eDest==SRT_Output ){ Select *pFirst = p; while( pFirst->pPrior ) pFirst = pFirst->pPrior; generateColumnNames(pParse, 0, pFirst->pEList); } iBreak = sqlite3VdbeMakeLabel(v); iCont = sqlite3VdbeMakeLabel(v); computeLimitRegisters(pParse, p, iBreak); sqlite3VdbeAddOp2(v, OP_Rewind, unionTab, iBreak); iStart = sqlite3VdbeCurrentAddr(v); selectInnerLoop(pParse, p, p->pEList, unionTab, p->pEList->nExpr, 0, -1, &dest, iCont, iBreak); sqlite3VdbeResolveLabel(v, iCont); sqlite3VdbeAddOp2(v, OP_Next, unionTab, iStart); sqlite3VdbeResolveLabel(v, iBreak); sqlite3VdbeAddOp2(v, OP_Close, unionTab, 0); } break; } case TK_INTERSECT: { int tab1, tab2; int iCont, iBreak, iStart; Expr *pLimit, *pOffset; int addr; SelectDest intersectdest; int r1; tab1 = pParse->nTab++; tab2 = pParse->nTab++; assert( p->pOrderBy==0 ); addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, tab1, 0); assert( p->addrOpenEphm[0] == -1 ); p->addrOpenEphm[0] = addr; p->pRightmost->selFlags |= SF_UsesEphemeral; assert( p->pEList ); sqlite3SelectDestInit(&intersectdest, SRT_Union, tab1); rc = sqlite3Select(pParse, pPrior, &intersectdest); if( rc ){ goto multi_select_end; } addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, tab2, 0); assert( p->addrOpenEphm[1] == -1 ); p->addrOpenEphm[1] = addr; p->pPrior = 0; pLimit = p->pLimit; p->pLimit = 0; pOffset = p->pOffset; p->pOffset = 0; intersectdest.iParm = tab2; rc = sqlite3Select(pParse, p, &intersectdest); pDelete = p->pPrior; p->pPrior = pPrior; sqlite3ExprDelete(db, p->pLimit); p->pLimit = pLimit; p->pOffset = pOffset; if( rc ){ goto multi_select_end; } assert( p->pEList ); if( dest.eDest==SRT_Output ){ Select *pFirst = p; while( pFirst->pPrior ) pFirst = pFirst->pPrior; generateColumnNames(pParse, 0, pFirst->pEList); } iBreak = sqlite3VdbeMakeLabel(v); iCont = sqlite3VdbeMakeLabel(v); computeLimitRegisters(pParse, p, iBreak); sqlite3VdbeAddOp2(v, OP_Rewind, tab1, iBreak); r1 = sqlite3GetTempReg(pParse); iStart = sqlite3VdbeAddOp2(v, OP_RowKey, tab1, r1); sqlite3VdbeAddOp3(v, OP_NotFound, tab2, iCont, r1); sqlite3ReleaseTempReg(pParse, r1); selectInnerLoop(pParse, p, p->pEList, tab1, p->pEList->nExpr, 0, -1, &dest, iCont, iBreak); sqlite3VdbeResolveLabel(v, iCont); sqlite3VdbeAddOp2(v, OP_Next, tab1, iStart); sqlite3VdbeResolveLabel(v, iBreak); sqlite3VdbeAddOp2(v, OP_Close, tab2, 0); sqlite3VdbeAddOp2(v, OP_Close, tab1, 0); break; } } if( p->selFlags & SF_UsesEphemeral ){ int i; KeyInfo *pKeyInfo; Select *pLoop; CollSeq **apColl; int nCol; assert( p->pRightmost==p ); nCol = p->pEList->nExpr; pKeyInfo = sqlite3DbMallocZero(db, sizeof(*pKeyInfo)+nCol*(sizeof(CollSeq*) + 1)); if( !pKeyInfo ){ rc = SQLITE_NOMEM; goto multi_select_end; } pKeyInfo->enc = ENC(db); pKeyInfo->nField = nCol; for(i=0, apColl=pKeyInfo->aColl; i<nCol; i++, apColl++){ *apColl = multiSelectCollSeq(pParse, p, i); if( 0==*apColl ){ *apColl = db->pDfltColl; } } for(pLoop=p; pLoop; pLoop=pLoop->pPrior){ for(i=0; i<2; i++){ int addr = pLoop->addrOpenEphm[i]; if( addr<0 ){ assert( pLoop->addrOpenEphm[1]<0 ); break; } sqlite3VdbeChangeP2(v, addr, nCol); sqlite3VdbeChangeP4(v, addr, (char*)pKeyInfo, P4_KEYINFO); pLoop->addrOpenEphm[i] = -1; } } sqlite3DbFree(db, pKeyInfo); } multi_select_end: pDest->iMem = dest.iMem; pDest->nMem = dest.nMem; sqlite3SelectDelete(db, pDelete); return rc; } 
#endif 
static int generateOutputSubroutine( Parse *pParse, Select *p, SelectDest *pIn, SelectDest *pDest, int regReturn, int regPrev, KeyInfo *pKeyInfo, int p4type, int iBreak ){ Vdbe *v = pParse->pVdbe; int iContinue; int addr; addr = sqlite3VdbeCurrentAddr(v); iContinue = sqlite3VdbeMakeLabel(v); if( regPrev ){ int j1, j2; j1 = sqlite3VdbeAddOp1(v, OP_IfNot, regPrev); j2 = sqlite3VdbeAddOp4(v, OP_Compare, pIn->iMem, regPrev+1, pIn->nMem, (char*)pKeyInfo, p4type); sqlite3VdbeAddOp3(v, OP_Jump, j2+2, iContinue, j2+2); sqlite3VdbeJumpHere(v, j1); sqlite3ExprCodeCopy(pParse, pIn->iMem, regPrev+1, pIn->nMem); sqlite3VdbeAddOp2(v, OP_Integer, 1, regPrev); } if( pParse->db->mallocFailed ) return 0; codeOffset(v, p, iContinue); switch( pDest->eDest ){ case SRT_Table: case SRT_EphemTab: { int r1 = sqlite3GetTempReg(pParse); int r2 = sqlite3GetTempReg(pParse); sqlite3VdbeAddOp3(v, OP_MakeRecord, pIn->iMem, pIn->nMem, r1); sqlite3VdbeAddOp2(v, OP_NewRowid, pDest->iParm, r2); sqlite3VdbeAddOp3(v, OP_Insert, pDest->iParm, r1, r2); sqlite3VdbeChangeP5(v, OPFLAG_APPEND); sqlite3ReleaseTempReg(pParse, r2); sqlite3ReleaseTempReg(pParse, r1); break; } 
#ifndef SQLITE_OMIT_SUBQUERY 
 case SRT_Set: { int r1; assert( pIn->nMem==1 ); p->affinity = sqlite3CompareAffinity(p->pEList->a[0].pExpr, pDest->affinity); r1 = sqlite3GetTempReg(pParse); sqlite3VdbeAddOp4(v, OP_MakeRecord, pIn->iMem, 1, r1, &p->affinity, 1); sqlite3ExprCacheAffinityChange(pParse, pIn->iMem, 1); sqlite3VdbeAddOp2(v, OP_IdxInsert, pDest->iParm, r1); sqlite3ReleaseTempReg(pParse, r1); break; } 
#if 0 
 case SRT_Exists: { sqlite3VdbeAddOp2(v, OP_Integer, 1, pDest->iParm); break; } 
#endif 
 case SRT_Mem: { assert( pIn->nMem==1 ); sqlite3ExprCodeMove(pParse, pIn->iMem, pDest->iParm, 1); break; } 
#endif 
 case SRT_Coroutine: { if( pDest->iMem==0 ){ pDest->iMem = sqlite3GetTempRange(pParse, pIn->nMem); pDest->nMem = pIn->nMem; } sqlite3ExprCodeMove(pParse, pIn->iMem, pDest->iMem, pDest->nMem); sqlite3VdbeAddOp1(v, OP_Yield, pDest->iParm); break; } case SRT_Output: { sqlite3VdbeAddOp2(v, OP_ResultRow, pIn->iMem, pIn->nMem); sqlite3ExprCacheAffinityChange(pParse, pIn->iMem, pIn->nMem); break; } 
#if !defined(SQLITE_OMIT_TRIGGER) 
 default: { break; } 
#endif 
 } if( p->iLimit ){ sqlite3VdbeAddOp2(v, OP_AddImm, p->iLimit, -1); sqlite3VdbeAddOp2(v, OP_IfZero, p->iLimit, iBreak); } sqlite3VdbeResolveLabel(v, iContinue); sqlite3VdbeAddOp1(v, OP_Return, regReturn); return addr; } 
#ifndef SQLITE_OMIT_COMPOUND_SELECT 
static int multiSelectOrderBy( Parse *pParse, Select *p, SelectDest *pDest ){ int i, j; Select *pPrior; Vdbe *v; SelectDest destA; SelectDest destB; int regAddrA; int regEofA; int regAddrB; int regEofB; int addrSelectA; int addrSelectB; int regOutA; int regOutB; int addrOutA; int addrOutB; int addrEofA; int addrEofB; int addrAltB; int addrAeqB; int addrAgtB; int regLimitA; int regLimitB; int regPrev; int savedLimit; int savedOffset; int labelCmpr; int labelEnd; int j1; int op; KeyInfo *pKeyDup = 0; KeyInfo *pKeyMerge; sqlite3 *db; ExprList *pOrderBy; int nOrderBy; int *aPermute; assert( p->pOrderBy!=0 ); assert( pKeyDup==0 ); db = pParse->db; v = pParse->pVdbe; if( v==0 ) return SQLITE_NOMEM; labelEnd = sqlite3VdbeMakeLabel(v); labelCmpr = sqlite3VdbeMakeLabel(v); op = p->op; pPrior = p->pPrior; assert( pPrior->pOrderBy==0 ); pOrderBy = p->pOrderBy; assert( pOrderBy ); nOrderBy = pOrderBy->nExpr; if( op!=TK_ALL ){ for(i=1; db->mallocFailed==0 && i<=p->pEList->nExpr; i++){ struct ExprList_item *pItem; for(j=0, pItem=pOrderBy->a; j<nOrderBy; j++, pItem++){ assert( pItem->iCol>0 ); if( pItem->iCol==i ) break; } if( j==nOrderBy ){ Expr *pNew = sqlite3PExpr(pParse, TK_INTEGER, 0, 0, 0); if( pNew==0 ) return SQLITE_NOMEM; pNew->flags |= EP_IntValue; pNew->iTable = i; pOrderBy = sqlite3ExprListAppend(pParse, pOrderBy, pNew, 0); pOrderBy->a[nOrderBy++].iCol = i; } } } aPermute = sqlite3DbMallocRaw(db, sizeof(int)*nOrderBy); if( aPermute ){ struct ExprList_item *pItem; for(i=0, pItem=pOrderBy->a; i<nOrderBy; i++, pItem++){ assert( pItem->iCol>0 && pItem->iCol<=p->pEList->nExpr ); aPermute[i] = pItem->iCol - 1; } pKeyMerge = sqlite3DbMallocRaw(db, sizeof(*pKeyMerge)+nOrderBy*(sizeof(CollSeq*)+1)); if( pKeyMerge ){ pKeyMerge->aSortOrder = (u8*)&pKeyMerge->aColl[nOrderBy]; pKeyMerge->nField = nOrderBy; pKeyMerge->enc = ENC(db); for(i=0; i<nOrderBy; i++){ CollSeq *pColl; Expr *pTerm = pOrderBy->a[i].pExpr; if( pTerm->flags & EP_ExpCollate ){ pColl = pTerm->pColl; }else{ pColl = multiSelectCollSeq(pParse, p, aPermute[i]); pTerm->flags |= EP_ExpCollate; pTerm->pColl = pColl; } pKeyMerge->aColl[i] = pColl; pKeyMerge->aSortOrder[i] = pOrderBy->a[i].sortOrder; } } }else{ pKeyMerge = 0; } p->pOrderBy = pOrderBy; pPrior->pOrderBy = sqlite3ExprListDup(pParse->db, pOrderBy); if( op==TK_ALL ){ regPrev = 0; }else{ int nExpr = p->pEList->nExpr; assert( nOrderBy>=nExpr || db->mallocFailed ); regPrev = sqlite3GetTempRange(pParse, nExpr+1); sqlite3VdbeAddOp2(v, OP_Integer, 0, regPrev); pKeyDup = sqlite3DbMallocZero(db, sizeof(*pKeyDup) + nExpr*(sizeof(CollSeq*)+1) ); if( pKeyDup ){ pKeyDup->aSortOrder = (u8*)&pKeyDup->aColl[nExpr]; pKeyDup->nField = nExpr; pKeyDup->enc = ENC(db); for(i=0; i<nExpr; i++){ pKeyDup->aColl[i] = multiSelectCollSeq(pParse, p, i); pKeyDup->aSortOrder[i] = 0; } } } p->pPrior = 0; pPrior->pRightmost = 0; sqlite3ResolveOrderGroupBy(pParse, p, p->pOrderBy, "ORDER"); if( pPrior->pPrior==0 ){ sqlite3ResolveOrderGroupBy(pParse, pPrior, pPrior->pOrderBy, "ORDER"); } computeLimitRegisters(pParse, p, labelEnd); if( p->iLimit && op==TK_ALL ){ regLimitA = ++pParse->nMem; regLimitB = ++pParse->nMem; sqlite3VdbeAddOp2(v, OP_Copy, p->iOffset ? p->iOffset+1 : p->iLimit, regLimitA); sqlite3VdbeAddOp2(v, OP_Copy, regLimitA, regLimitB); }else{ regLimitA = regLimitB = 0; } sqlite3ExprDelete(db, p->pLimit); p->pLimit = 0; sqlite3ExprDelete(db, p->pOffset); p->pOffset = 0; regAddrA = ++pParse->nMem; regEofA = ++pParse->nMem; regAddrB = ++pParse->nMem; regEofB = ++pParse->nMem; regOutA = ++pParse->nMem; regOutB = ++pParse->nMem; sqlite3SelectDestInit(&destA, SRT_Coroutine, regAddrA); sqlite3SelectDestInit(&destB, SRT_Coroutine, regAddrB); j1 = sqlite3VdbeAddOp0(v, OP_Goto); addrSelectA = sqlite3VdbeCurrentAddr(v); VdbeNoopComment((v, "Begin coroutine for left SELECT")); pPrior->iLimit = regLimitA; sqlite3Select(pParse, pPrior, &destA); sqlite3VdbeAddOp2(v, OP_Integer, 1, regEofA); sqlite3VdbeAddOp1(v, OP_Yield, regAddrA); VdbeNoopComment((v, "End coroutine for left SELECT")); addrSelectB = sqlite3VdbeCurrentAddr(v); VdbeNoopComment((v, "Begin coroutine for right SELECT")); savedLimit = p->iLimit; savedOffset = p->iOffset; p->iLimit = regLimitB; p->iOffset = 0; sqlite3Select(pParse, p, &destB); p->iLimit = savedLimit; p->iOffset = savedOffset; sqlite3VdbeAddOp2(v, OP_Integer, 1, regEofB); sqlite3VdbeAddOp1(v, OP_Yield, regAddrB); VdbeNoopComment((v, "End coroutine for right SELECT")); VdbeNoopComment((v, "Output routine for A")); addrOutA = generateOutputSubroutine(pParse, p, &destA, pDest, regOutA, regPrev, pKeyDup, P4_KEYINFO_HANDOFF, labelEnd); if( op==TK_ALL || op==TK_UNION ){ VdbeNoopComment((v, "Output routine for B")); addrOutB = generateOutputSubroutine(pParse, p, &destB, pDest, regOutB, regPrev, pKeyDup, P4_KEYINFO_STATIC, labelEnd); } VdbeNoopComment((v, "eof-A subroutine")); if( op==TK_EXCEPT || op==TK_INTERSECT ){ addrEofA = sqlite3VdbeAddOp2(v, OP_Goto, 0, labelEnd); }else{ addrEofA = sqlite3VdbeAddOp2(v, OP_If, regEofB, labelEnd); sqlite3VdbeAddOp2(v, OP_Gosub, regOutB, addrOutB); sqlite3VdbeAddOp1(v, OP_Yield, regAddrB); sqlite3VdbeAddOp2(v, OP_Goto, 0, addrEofA); } if( op==TK_INTERSECT ){ addrEofB = addrEofA; }else{ VdbeNoopComment((v, "eof-B subroutine")); addrEofB = sqlite3VdbeAddOp2(v, OP_If, regEofA, labelEnd); sqlite3VdbeAddOp2(v, OP_Gosub, regOutA, addrOutA); sqlite3VdbeAddOp1(v, OP_Yield, regAddrA); sqlite3VdbeAddOp2(v, OP_Goto, 0, addrEofB); } VdbeNoopComment((v, "A-lt-B subroutine")); addrAltB = sqlite3VdbeAddOp2(v, OP_Gosub, regOutA, addrOutA); sqlite3VdbeAddOp1(v, OP_Yield, regAddrA); sqlite3VdbeAddOp2(v, OP_If, regEofA, addrEofA); sqlite3VdbeAddOp2(v, OP_Goto, 0, labelCmpr); if( op==TK_ALL ){ addrAeqB = addrAltB; }else if( op==TK_INTERSECT ){ addrAeqB = addrAltB; addrAltB++; }else{ VdbeNoopComment((v, "A-eq-B subroutine")); addrAeqB = sqlite3VdbeAddOp1(v, OP_Yield, regAddrA); sqlite3VdbeAddOp2(v, OP_If, regEofA, addrEofA); sqlite3VdbeAddOp2(v, OP_Goto, 0, labelCmpr); } VdbeNoopComment((v, "A-gt-B subroutine")); addrAgtB = sqlite3VdbeCurrentAddr(v); if( op==TK_ALL || op==TK_UNION ){ sqlite3VdbeAddOp2(v, OP_Gosub, regOutB, addrOutB); } sqlite3VdbeAddOp1(v, OP_Yield, regAddrB); sqlite3VdbeAddOp2(v, OP_If, regEofB, addrEofB); sqlite3VdbeAddOp2(v, OP_Goto, 0, labelCmpr); sqlite3VdbeJumpHere(v, j1); sqlite3VdbeAddOp2(v, OP_Integer, 0, regEofA); sqlite3VdbeAddOp2(v, OP_Integer, 0, regEofB); sqlite3VdbeAddOp2(v, OP_Gosub, regAddrA, addrSelectA); sqlite3VdbeAddOp2(v, OP_Gosub, regAddrB, addrSelectB); sqlite3VdbeAddOp2(v, OP_If, regEofA, addrEofA); sqlite3VdbeAddOp2(v, OP_If, regEofB, addrEofB); sqlite3VdbeResolveLabel(v, labelCmpr); sqlite3VdbeAddOp4(v, OP_Permutation, 0, 0, 0, (char*)aPermute, P4_INTARRAY); sqlite3VdbeAddOp4(v, OP_Compare, destA.iMem, destB.iMem, nOrderBy, (char*)pKeyMerge, P4_KEYINFO_HANDOFF); sqlite3VdbeAddOp3(v, OP_Jump, addrAltB, addrAeqB, addrAgtB); if( regPrev ){ sqlite3ReleaseTempRange(pParse, regPrev, nOrderBy+1); } sqlite3VdbeResolveLabel(v, labelEnd); if( pDest->eDest==SRT_Output ){ Select *pFirst = pPrior; while( pFirst->pPrior ) pFirst = pFirst->pPrior; generateColumnNames(pParse, 0, pFirst->pEList); } if( p->pPrior ){ sqlite3SelectDelete(db, p->pPrior); } p->pPrior = pPrior; return SQLITE_OK; } 
#endif 
#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW) 
static void substExprList(sqlite3*, ExprList*, int, ExprList*); static void substSelect(sqlite3*, Select *, int, ExprList *); static void substExpr( sqlite3 *db, Expr *pExpr, int iTable, ExprList *pEList ){ if( pExpr==0 ) return; if( pExpr->op==TK_COLUMN && pExpr->iTable==iTable ){ if( pExpr->iColumn<0 ){ pExpr->op = TK_NULL; }else{ Expr *pNew; assert( pEList!=0 && pExpr->iColumn<pEList->nExpr ); assert( pExpr->pLeft==0 && pExpr->pRight==0 && pExpr->pList==0 ); pNew = pEList->a[pExpr->iColumn].pExpr; assert( pNew!=0 ); pExpr->op = pNew->op; assert( pExpr->pLeft==0 ); pExpr->pLeft = sqlite3ExprDup(db, pNew->pLeft); assert( pExpr->pRight==0 ); pExpr->pRight = sqlite3ExprDup(db, pNew->pRight); assert( pExpr->pList==0 ); pExpr->pList = sqlite3ExprListDup(db, pNew->pList); pExpr->iTable = pNew->iTable; pExpr->pTab = pNew->pTab; pExpr->iColumn = pNew->iColumn; pExpr->iAgg = pNew->iAgg; sqlite3TokenCopy(db, &pExpr->token, &pNew->token); sqlite3TokenCopy(db, &pExpr->span, &pNew->span); pExpr->pSelect = sqlite3SelectDup(db, pNew->pSelect); pExpr->flags = pNew->flags; } }else{ substExpr(db, pExpr->pLeft, iTable, pEList); substExpr(db, pExpr->pRight, iTable, pEList); substSelect(db, pExpr->pSelect, iTable, pEList); substExprList(db, pExpr->pList, iTable, pEList); } } static void substExprList( sqlite3 *db, ExprList *pList, int iTable, ExprList *pEList ){ int i; if( pList==0 ) return; for(i=0; i<pList->nExpr; i++){ substExpr(db, pList->a[i].pExpr, iTable, pEList); } } static void substSelect( sqlite3 *db, Select *p, int iTable, ExprList *pEList ){ SrcList *pSrc; struct SrcList_item *pItem; int i; if( !p ) return; substExprList(db, p->pEList, iTable, pEList); substExprList(db, p->pGroupBy, iTable, pEList); substExprList(db, p->pOrderBy, iTable, pEList); substExpr(db, p->pHaving, iTable, pEList); substExpr(db, p->pWhere, iTable, pEList); substSelect(db, p->pPrior, iTable, pEList); pSrc = p->pSrc; if( pSrc ){ for(i=pSrc->nSrc, pItem=pSrc->a; i>0; i--, pItem++){ substSelect(db, pItem->pSelect, iTable, pEList); } } } 
#endif 
#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW) 
static int flattenSubquery( Parse *pParse, Select *p, int iFrom, int isAgg, int subqueryIsAgg ){ const char *zSavedAuthContext = pParse->zAuthContext; Select *pParent; Select *pSub; Select *pSub1; SrcList *pSrc; SrcList *pSubSrc; ExprList *pList; int iParent; int i; Expr *pWhere; struct SrcList_item *pSubitem; sqlite3 *db = pParse->db; assert( p!=0 ); if( p==0 ) return 0; assert( p->pPrior==0 ); pSrc = p->pSrc; assert( pSrc && iFrom>=0 && iFrom<pSrc->nSrc ); pSubitem = &pSrc->a[iFrom]; iParent = pSubitem->iCursor; pSub = pSubitem->pSelect; assert( pSub!=0 ); if( isAgg && subqueryIsAgg ) return 0; if( subqueryIsAgg && pSrc->nSrc>1 ) return 0; pSubSrc = pSub->pSrc; assert( pSubSrc ); if( pSub->pLimit && p->pLimit ) return 0; if( pSub->pOffset ) return 0; if( p->pRightmost && pSub->pLimit && pSub->pOrderBy ){ return 0; } if( pSubSrc->nSrc==0 ) return 0; if( ((pSub->selFlags & SF_Distinct)!=0 || pSub->pLimit) && (pSrc->nSrc>1 || isAgg) ){ return 0; } if( (p->selFlags & SF_Distinct)!=0 && subqueryIsAgg ){ return 0; } if( p->pOrderBy && pSub->pOrderBy ){ return 0; } if( isAgg && pSub->pOrderBy ) return 0; if( pSub->pLimit && p->pWhere ) return 0; if( (pSubitem->jointype & JT_OUTER)!=0 ){ return 0; } if( pSub->pPrior ){ if( p->pPrior || isAgg || (p->selFlags & SF_Distinct)!=0 || pSrc->nSrc!=1 ){ return 0; } for(pSub1=pSub; pSub1; pSub1=pSub1->pPrior){ if( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))!=0 || (pSub1->pPrior && pSub1->op!=TK_ALL) || !pSub1->pSrc || pSub1->pSrc->nSrc!=1 ){ return 0; } } if( p->pOrderBy ){ int ii; for(ii=0; ii<p->pOrderBy->nExpr; ii++){ if( p->pOrderBy->a[ii].iCol==0 ) return 0; } } } pParse->zAuthContext = pSubitem->zName; sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0); pParse->zAuthContext = zSavedAuthContext; for(pSub=pSub->pPrior; pSub; pSub=pSub->pPrior){ Select *pNew; ExprList *pOrderBy = p->pOrderBy; Expr *pLimit = p->pLimit; Select *pPrior = p->pPrior; p->pOrderBy = 0; p->pSrc = 0; p->pPrior = 0; p->pLimit = 0; pNew = sqlite3SelectDup(db, p); p->pLimit = pLimit; p->pOrderBy = pOrderBy; p->pSrc = pSrc; p->op = TK_ALL; p->pRightmost = 0; if( pNew==0 ){ pNew = pPrior; }else{ pNew->pPrior = pPrior; pNew->pRightmost = 0; } p->pPrior = pNew; if( db->mallocFailed ) return 1; } pSub = pSub1 = pSubitem->pSelect; sqlite3DbFree(db, pSubitem->zDatabase); sqlite3DbFree(db, pSubitem->zName); sqlite3DbFree(db, pSubitem->zAlias); pSubitem->zDatabase = 0; pSubitem->zName = 0; pSubitem->zAlias = 0; pSubitem->pSelect = 0; if( pSubitem->pTab!=0 ){ Table *pTabToDel = pSubitem->pTab; if( pTabToDel->nRef==1 ){ pTabToDel->pNextZombie = pParse->pZombieTab; pParse->pZombieTab = pTabToDel; }else{ pTabToDel->nRef--; } pSubitem->pTab = 0; } for(pParent=p; pParent; pParent=pParent->pPrior, pSub=pSub->pPrior){ int nSubSrc; int jointype = 0; pSubSrc = pSub->pSrc; nSubSrc = pSubSrc->nSrc; pSrc = pParent->pSrc; if( pSrc ){ assert( pParent==p ); jointype = pSubitem->jointype; }else{ assert( pParent!=p ); pSrc = pParent->pSrc = sqlite3SrcListAppend(db, 0, 0, 0); if( pSrc==0 ){ assert( db->mallocFailed ); break; } } if( nSubSrc>1 ){ pParent->pSrc = pSrc = sqlite3SrcListEnlarge(db, pSrc, nSubSrc-1,iFrom+1); if( db->mallocFailed ){ break; } } for(i=0; i<nSubSrc; i++){ pSrc->a[i+iFrom] = pSubSrc->a[i]; memset(&pSubSrc->a[i], 0, sizeof(pSubSrc->a[i])); } pSrc->a[iFrom].jointype = jointype; pList = pParent->pEList; for(i=0; i<pList->nExpr; i++){ Expr *pExpr; if( pList->a[i].zName==0 && (pExpr = pList->a[i].pExpr)->span.z!=0 ){ pList->a[i].zName = sqlite3DbStrNDup(db, (char*)pExpr->span.z, pExpr->span.n); } } substExprList(db, pParent->pEList, iParent, pSub->pEList); if( isAgg ){ substExprList(db, pParent->pGroupBy, iParent, pSub->pEList); substExpr(db, pParent->pHaving, iParent, pSub->pEList); } if( pSub->pOrderBy ){ assert( pParent->pOrderBy==0 ); pParent->pOrderBy = pSub->pOrderBy; pSub->pOrderBy = 0; }else if( pParent->pOrderBy ){ substExprList(db, pParent->pOrderBy, iParent, pSub->pEList); } if( pSub->pWhere ){ pWhere = sqlite3ExprDup(db, pSub->pWhere); }else{ pWhere = 0; } if( subqueryIsAgg ){ assert( pParent->pHaving==0 ); pParent->pHaving = pParent->pWhere; pParent->pWhere = pWhere; substExpr(db, pParent->pHaving, iParent, pSub->pEList); pParent->pHaving = sqlite3ExprAnd(db, pParent->pHaving, sqlite3ExprDup(db, pSub->pHaving)); assert( pParent->pGroupBy==0 ); pParent->pGroupBy = sqlite3ExprListDup(db, pSub->pGroupBy); }else{ substExpr(db, pParent->pWhere, iParent, pSub->pEList); pParent->pWhere = sqlite3ExprAnd(db, pParent->pWhere, pWhere); } pParent->selFlags |= pSub->selFlags & SF_Distinct; if( pSub->pLimit ){ pParent->pLimit = pSub->pLimit; pSub->pLimit = 0; } } sqlite3SelectDelete(db, pSub1); return 1; } 
#endif 
static int minMaxQuery(Select *p){ Expr *pExpr; ExprList *pEList = p->pEList; if( pEList->nExpr!=1 ) return WHERE_ORDERBY_NORMAL; pExpr = pEList->a[0].pExpr; pEList = pExpr->pList; if( pExpr->op!=TK_AGG_FUNCTION || pEList==0 || pEList->nExpr!=1 ) return 0; if( pEList->a[0].pExpr->op!=TK_AGG_COLUMN ) return WHERE_ORDERBY_NORMAL; if( pExpr->token.n!=3 ) return WHERE_ORDERBY_NORMAL; if( sqlite3StrNICmp((char*)pExpr->token.z,"min",3)==0 ){ return WHERE_ORDERBY_MIN; }else if( sqlite3StrNICmp((char*)pExpr->token.z,"max",3)==0 ){ return WHERE_ORDERBY_MAX; } return WHERE_ORDERBY_NORMAL; } SQLITE_PRIVATE int sqlite3IndexedByLookup(Parse *pParse, struct SrcList_item *pFrom){ if( pFrom->pTab && pFrom->zIndex ){ Table *pTab = pFrom->pTab; char *zIndex = pFrom->zIndex; Index *pIdx; for(pIdx=pTab->pIndex; pIdx && sqlite3StrICmp(pIdx->zName, zIndex); pIdx=pIdx->pNext ); if( !pIdx ){ sqlite3ErrorMsg(pParse, "no such index: %s", zIndex, 0); return SQLITE_ERROR; } pFrom->pIndex = pIdx; } return SQLITE_OK; } static int selectExpander(Walker *pWalker, Select *p){ Parse *pParse = pWalker->pParse; int i, j, k; SrcList *pTabList; ExprList *pEList; struct SrcList_item *pFrom; sqlite3 *db = pParse->db; if( db->mallocFailed ){ return WRC_Abort; } if( p->pSrc==0 || (p->selFlags & SF_Expanded)!=0 ){ return WRC_Prune; } p->selFlags |= SF_Expanded; pTabList = p->pSrc; pEList = p->pEList; sqlite3SrcListAssignCursors(pParse, pTabList); for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){ Table *pTab; if( pFrom->pTab!=0 ){ assert( i==0 ); return WRC_Prune; } if( pFrom->zName==0 ){ 
#ifndef SQLITE_OMIT_SUBQUERY 
 Select *pSel = pFrom->pSelect; assert( pSel!=0 ); assert( pFrom->pTab==0 ); sqlite3WalkSelect(pWalker, pSel); pFrom->pTab = pTab = sqlite3DbMallocZero(db, sizeof(Table)); if( pTab==0 ) return WRC_Abort; pTab->db = db; pTab->nRef = 1; pTab->zName = sqlite3MPrintf(db, "sqlite_subquery_%p_", (void*)pTab); while( pSel->pPrior ){ pSel = pSel->pPrior; } selectColumnsFromExprList(pParse, pSel->pEList, &pTab->nCol, &pTab->aCol); pTab->iPKey = -1; pTab->tabFlags |= TF_Ephemeral; 
#endif 
 }else{ assert( pFrom->pTab==0 ); pFrom->pTab = pTab = sqlite3LocateTable(pParse,0,pFrom->zName,pFrom->zDatabase); if( pTab==0 ) return WRC_Abort; pTab->nRef++; 
#if !defined(SQLITE_OMIT_VIEW) || !defined (SQLITE_OMIT_VIRTUALTABLE) 
 if( pTab->pSelect || IsVirtual(pTab) ){ if( sqlite3ViewGetColumnNames(pParse, pTab) ) return WRC_Abort; if( pFrom->pSelect==0 ){ pFrom->pSelect = sqlite3SelectDup(db, pTab->pSelect); sqlite3WalkSelect(pWalker, pFrom->pSelect); } } 
#endif 
 } if( sqlite3IndexedByLookup(pParse, pFrom) ){ return WRC_Abort; } } if( db->mallocFailed || sqliteProcessJoin(pParse, p) ){ return WRC_Abort; } for(k=0; k<pEList->nExpr; k++){ Expr *pE = pEList->a[k].pExpr; if( pE->op==TK_ALL ) break; if( pE->op==TK_DOT && pE->pRight && pE->pRight->op==TK_ALL && pE->pLeft && pE->pLeft->op==TK_ID ) break; } if( k<pEList->nExpr ){ struct ExprList_item *a = pEList->a; ExprList *pNew = 0; int flags = pParse->db->flags; int longNames = (flags & SQLITE_FullColNames)!=0 && (flags & SQLITE_ShortColNames)==0; for(k=0; k<pEList->nExpr; k++){ Expr *pE = a[k].pExpr; if( pE->op!=TK_ALL && (pE->op!=TK_DOT || pE->pRight==0 || pE->pRight->op!=TK_ALL) ){ pNew = sqlite3ExprListAppend(pParse, pNew, a[k].pExpr, 0); if( pNew ){ pNew->a[pNew->nExpr-1].zName = a[k].zName; } a[k].pExpr = 0; a[k].zName = 0; }else{ int tableSeen = 0; char *zTName; if( pE->op==TK_DOT && pE->pLeft ){ zTName = sqlite3NameFromToken(db, &pE->pLeft->token); }else{ zTName = 0; } for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){ Table *pTab = pFrom->pTab; char *zTabName = pFrom->zAlias; if( zTabName==0 || zTabName[0]==0 ){ zTabName = pTab->zName; } if( db->mallocFailed ) break; if( zTName && sqlite3StrICmp(zTName, zTabName)!=0 ){ continue; } tableSeen = 1; for(j=0; j<pTab->nCol; j++){ Expr *pExpr, *pRight; char *zName = pTab->aCol[j].zName; if( IsHiddenColumn(&pTab->aCol[j]) ){ assert(IsVirtual(pTab)); continue; } if( i>0 ){ struct SrcList_item *pLeft = &pTabList->a[i-1]; if( (pLeft[1].jointype & JT_NATURAL)!=0 && columnIndex(pLeft->pTab, zName)>=0 ){ continue; } if( sqlite3IdListIndex(pLeft[1].pUsing, zName)>=0 ){ continue; } } pRight = sqlite3PExpr(pParse, TK_ID, 0, 0, 0); if( pRight==0 ) break; setQuotedToken(pParse, &pRight->token, zName); if( longNames || pTabList->nSrc>1 ){ Expr *pLeft = sqlite3PExpr(pParse, TK_ID, 0, 0, 0); pExpr = sqlite3PExpr(pParse, TK_DOT, pLeft, pRight, 0); if( pExpr==0 ) break; setQuotedToken(pParse, &pLeft->token, zTabName); setToken(&pExpr->span, sqlite3MPrintf(db, "%s.%s", zTabName, zName)); pExpr->span.dyn = 1; pExpr->token.z = 0; pExpr->token.n = 0; pExpr->token.dyn = 0; }else{ pExpr = pRight; pExpr->span = pExpr->token; pExpr->span.dyn = 0; } if( longNames ){ pNew = sqlite3ExprListAppend(pParse, pNew, pExpr, &pExpr->span); }else{ pNew = sqlite3ExprListAppend(pParse, pNew, pExpr, &pRight->token); } } } if( !tableSeen ){ if( zTName ){ sqlite3ErrorMsg(pParse, "no such table: %s", zTName); }else{ sqlite3ErrorMsg(pParse, "no tables specified"); } } sqlite3DbFree(db, zTName); } } sqlite3ExprListDelete(db, pEList); p->pEList = pNew; } 
#if SQLITE_MAX_COLUMN 
 if( p->pEList && p->pEList->nExpr>db->aLimit[SQLITE_LIMIT_COLUMN] ){ sqlite3ErrorMsg(pParse, "too many columns in result set"); } 
#endif 
 return WRC_Continue; } static int exprWalkNoop(Walker *NotUsed, Expr *NotUsed2){ UNUSED_PARAMETER2(NotUsed, NotUsed2); return WRC_Continue; } static void sqlite3SelectExpand(Parse *pParse, Select *pSelect){ Walker w; w.xSelectCallback = selectExpander; w.xExprCallback = exprWalkNoop; w.pParse = pParse; sqlite3WalkSelect(&w, pSelect); } 
#ifndef SQLITE_OMIT_SUBQUERY 
static int selectAddSubqueryTypeInfo(Walker *pWalker, Select *p){ Parse *pParse; int i; SrcList *pTabList; struct SrcList_item *pFrom; assert( p->selFlags & SF_Resolved ); if( (p->selFlags & SF_HasTypeInfo)==0 ){ p->selFlags |= SF_HasTypeInfo; pParse = pWalker->pParse; pTabList = p->pSrc; for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){ Table *pTab = pFrom->pTab; if( pTab && (pTab->tabFlags & TF_Ephemeral)!=0 ){ Select *pSel = pFrom->pSelect; assert( pSel ); while( pSel->pPrior ) pSel = pSel->pPrior; selectAddColumnTypeAndCollation(pParse, pTab->nCol, pTab->aCol, pSel); } } } return WRC_Continue; } 
#endif 
static void sqlite3SelectAddTypeInfo(Parse *pParse, Select *pSelect){ 
#ifndef SQLITE_OMIT_SUBQUERY 
 Walker w; w.xSelectCallback = selectAddSubqueryTypeInfo; w.xExprCallback = exprWalkNoop; w.pParse = pParse; sqlite3WalkSelect(&w, pSelect); 
#endif 
} SQLITE_PRIVATE void sqlite3SelectPrep( Parse *pParse, Select *p, NameContext *pOuterNC ){ sqlite3 *db; if( p==0 ) return; db = pParse->db; if( p->selFlags & SF_HasTypeInfo ) return; if( pParse->nErr || db->mallocFailed ) return; sqlite3SelectExpand(pParse, p); if( pParse->nErr || db->mallocFailed ) return; sqlite3ResolveSelectNames(pParse, p, pOuterNC); if( pParse->nErr || db->mallocFailed ) return; sqlite3SelectAddTypeInfo(pParse, p); } static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo){ Vdbe *v = pParse->pVdbe; int i; struct AggInfo_func *pFunc; if( pAggInfo->nFunc+pAggInfo->nColumn==0 ){ return; } for(i=0; i<pAggInfo->nColumn; i++){ sqlite3VdbeAddOp2(v, OP_Null, 0, pAggInfo->aCol[i].iMem); } for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++){ sqlite3VdbeAddOp2(v, OP_Null, 0, pFunc->iMem); if( pFunc->iDistinct>=0 ){ Expr *pE = pFunc->pExpr; if( pE->pList==0 || pE->pList->nExpr!=1 ){ sqlite3ErrorMsg(pParse, "DISTINCT in aggregate must be followed " "by an expression"); pFunc->iDistinct = -1; }else{ KeyInfo *pKeyInfo = keyInfoFromExprList(pParse, pE->pList); sqlite3VdbeAddOp4(v, OP_OpenEphemeral, pFunc->iDistinct, 0, 0, (char*)pKeyInfo, P4_KEYINFO_HANDOFF); } } } } static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo){ Vdbe *v = pParse->pVdbe; int i; struct AggInfo_func *pF; for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++){ ExprList *pList = pF->pExpr->pList; sqlite3VdbeAddOp4(v, OP_AggFinal, pF->iMem, pList ? pList->nExpr : 0, 0, (void*)pF->pFunc, P4_FUNCDEF); } } static void updateAccumulator(Parse *pParse, AggInfo *pAggInfo){ Vdbe *v = pParse->pVdbe; int i; struct AggInfo_func *pF; struct AggInfo_col *pC; pAggInfo->directMode = 1; for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++){ int nArg; int addrNext = 0; int regAgg; ExprList *pList = pF->pExpr->pList; if( pList ){ nArg = pList->nExpr; regAgg = sqlite3GetTempRange(pParse, nArg); sqlite3ExprCodeExprList(pParse, pList, regAgg, 0); }else{ nArg = 0; regAgg = 0; } if( pF->iDistinct>=0 ){ addrNext = sqlite3VdbeMakeLabel(v); assert( nArg==1 ); codeDistinct(pParse, pF->iDistinct, addrNext, 1, regAgg); } if( pF->pFunc->flags & SQLITE_FUNC_NEEDCOLL ){ CollSeq *pColl = 0; struct ExprList_item *pItem; int j; assert( pList!=0 ); for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++){ pColl = sqlite3ExprCollSeq(pParse, pItem->pExpr); } if( !pColl ){ pColl = pParse->db->pDfltColl; } sqlite3VdbeAddOp4(v, OP_CollSeq, 0, 0, 0, (char *)pColl, P4_COLLSEQ); } sqlite3VdbeAddOp4(v, OP_AggStep, 0, regAgg, pF->iMem, (void*)pF->pFunc, P4_FUNCDEF); sqlite3VdbeChangeP5(v, nArg); sqlite3ReleaseTempRange(pParse, regAgg, nArg); sqlite3ExprCacheAffinityChange(pParse, regAgg, nArg); if( addrNext ){ sqlite3VdbeResolveLabel(v, addrNext); } } for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++){ sqlite3ExprCode(pParse, pC->pExpr, pC->iMem); } pAggInfo->directMode = 0; } SQLITE_PRIVATE int sqlite3Select( Parse *pParse, Select *p, SelectDest *pDest ){ int i, j; WhereInfo *pWInfo; Vdbe *v; int isAgg; ExprList *pEList; SrcList *pTabList; Expr *pWhere; ExprList *pOrderBy; ExprList *pGroupBy; Expr *pHaving; int isDistinct; int distinct; int rc = 1; int addrSortIndex; AggInfo sAggInfo; int iEnd; sqlite3 *db; db = pParse->db; if( p==0 || db->mallocFailed || pParse->nErr ){ return 1; } if( sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0) ) return 1; memset(&sAggInfo, 0, sizeof(sAggInfo)); pOrderBy = p->pOrderBy; if( IgnorableOrderby(pDest) ){ p->pOrderBy = 0; assert(pDest->eDest==SRT_Exists || pDest->eDest==SRT_Union || pDest->eDest==SRT_Except || pDest->eDest==SRT_Discard); p->selFlags &= ~SF_Distinct; } sqlite3SelectPrep(pParse, p, 0); if( pParse->nErr ){ goto select_end; } p->pOrderBy = pOrderBy; pTabList = p->pSrc; isAgg = (p->selFlags & SF_Aggregate)!=0; pEList = p->pEList; if( pEList==0 ) goto select_end; if( pParse->nErr>0 ) goto select_end; if( IgnorableOrderby(pDest) ){ pOrderBy = 0; } v = sqlite3GetVdbe(pParse); if( v==0 ) goto select_end; 
#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW) 
 for(i=0; !p->pPrior && i<pTabList->nSrc; i++){ struct SrcList_item *pItem = &pTabList->a[i]; SelectDest dest; Select *pSub = pItem->pSelect; int isAggSub; if( pSub==0 || pItem->isPopulated ) continue; pParse->nHeight += sqlite3SelectExprHeight(p); isAggSub = (pSub->selFlags & SF_Aggregate)!=0; if( flattenSubquery(pParse, p, i, isAgg, isAggSub) ){ if( isAggSub ){ isAgg = 1; p->selFlags |= SF_Aggregate; } i = -1; }else{ sqlite3SelectDestInit(&dest, SRT_EphemTab, pItem->iCursor); assert( pItem->isPopulated==0 ); sqlite3Select(pParse, pSub, &dest); pItem->isPopulated = 1; } if( pParse->nErr || db->mallocFailed ){ goto select_end; } pParse->nHeight -= sqlite3SelectExprHeight(p); pTabList = p->pSrc; if( !IgnorableOrderby(pDest) ){ pOrderBy = p->pOrderBy; } } pEList = p->pEList; 
#endif 
 pWhere = p->pWhere; pGroupBy = p->pGroupBy; pHaving = p->pHaving; isDistinct = (p->selFlags & SF_Distinct)!=0; 
#ifndef SQLITE_OMIT_COMPOUND_SELECT 
 if( p->pPrior ){ if( p->pRightmost==0 ){ Select *pLoop, *pRight = 0; int cnt = 0; int mxSelect; for(pLoop=p; pLoop; pLoop=pLoop->pPrior, cnt++){ pLoop->pRightmost = p; pLoop->pNext = pRight; pRight = pLoop; } mxSelect = db->aLimit[SQLITE_LIMIT_COMPOUND_SELECT]; if( mxSelect && cnt>mxSelect ){ sqlite3ErrorMsg(pParse, "too many terms in compound SELECT"); return 1; } } return multiSelect(pParse, p, pDest); } 
#endif 
 
#ifndef SQLITE_OMIT_SUBQUERY 
 if( checkForMultiColumnSelectError(pParse, pDest, pEList->nExpr) ){ goto select_end; } 
#endif 
 if( (p->selFlags & (SF_Distinct|SF_Aggregate))==SF_Distinct && !p->pGroupBy ){ p->pGroupBy = sqlite3ExprListDup(db, p->pEList); pGroupBy = p->pGroupBy; p->selFlags &= ~SF_Distinct; isDistinct = 0; } if( pOrderBy ){ KeyInfo *pKeyInfo; pKeyInfo = keyInfoFromExprList(pParse, pOrderBy); pOrderBy->iECursor = pParse->nTab++; p->addrOpenEphm[2] = addrSortIndex = sqlite3VdbeAddOp4(v, OP_OpenEphemeral, pOrderBy->iECursor, pOrderBy->nExpr+2, 0, (char*)pKeyInfo, P4_KEYINFO_HANDOFF); }else{ addrSortIndex = -1; } if( pDest->eDest==SRT_EphemTab ){ sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pDest->iParm, pEList->nExpr); } iEnd = sqlite3VdbeMakeLabel(v); computeLimitRegisters(pParse, p, iEnd); if( isDistinct ){ KeyInfo *pKeyInfo; assert( isAgg || pGroupBy ); distinct = pParse->nTab++; pKeyInfo = keyInfoFromExprList(pParse, p->pEList); sqlite3VdbeAddOp4(v, OP_OpenEphemeral, distinct, 0, 0, (char*)pKeyInfo, P4_KEYINFO_HANDOFF); }else{ distinct = -1; } if( !isAgg && pGroupBy==0 ){ pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, &pOrderBy, 0); if( pWInfo==0 ) goto select_end; if( addrSortIndex>=0 && pOrderBy==0 ){ sqlite3VdbeChangeToNoop(v, addrSortIndex, 1); p->addrOpenEphm[2] = -1; } assert(!isDistinct); selectInnerLoop(pParse, p, pEList, 0, 0, pOrderBy, -1, pDest, pWInfo->iContinue, pWInfo->iBreak); sqlite3WhereEnd(pWInfo); }else{ NameContext sNC; int iAMem; int iBMem; int iUseFlag; int iAbortFlag; int groupBySort; int addrEnd; if( pGroupBy ){ int i; struct ExprList_item *pItem; for(i=p->pEList->nExpr, pItem=p->pEList->a; i>0; i--, pItem++){ pItem->iAlias = 0; } for(i=pGroupBy->nExpr, pItem=pGroupBy->a; i>0; i--, pItem++){ pItem->iAlias = 0; } } addrEnd = sqlite3VdbeMakeLabel(v); memset(&sNC, 0, sizeof(sNC)); sNC.pParse = pParse; sNC.pSrcList = pTabList; sNC.pAggInfo = &sAggInfo; sAggInfo.nSortingColumn = pGroupBy ? pGroupBy->nExpr+1 : 0; sAggInfo.pGroupBy = pGroupBy; sqlite3ExprAnalyzeAggList(&sNC, pEList); sqlite3ExprAnalyzeAggList(&sNC, pOrderBy); if( pHaving ){ sqlite3ExprAnalyzeAggregates(&sNC, pHaving); } sAggInfo.nAccumulator = sAggInfo.nColumn; for(i=0; i<sAggInfo.nFunc; i++){ sqlite3ExprAnalyzeAggList(&sNC, sAggInfo.aFunc[i].pExpr->pList); } if( db->mallocFailed ) goto select_end; if( pGroupBy ){ KeyInfo *pKeyInfo; int j1; int addrOutputRow; int regOutputRow; int addrSetAbort; int addrTopOfLoop; int addrSortingIdx; int addrReset; int regReset; sAggInfo.sortingIdx = pParse->nTab++; pKeyInfo = keyInfoFromExprList(pParse, pGroupBy); addrSortingIdx = sqlite3VdbeAddOp4(v, OP_OpenEphemeral, sAggInfo.sortingIdx, sAggInfo.nSortingColumn, 0, (char*)pKeyInfo, P4_KEYINFO_HANDOFF); iUseFlag = ++pParse->nMem; iAbortFlag = ++pParse->nMem; regOutputRow = ++pParse->nMem; addrOutputRow = sqlite3VdbeMakeLabel(v); regReset = ++pParse->nMem; addrReset = sqlite3VdbeMakeLabel(v); iAMem = pParse->nMem + 1; pParse->nMem += pGroupBy->nExpr; iBMem = pParse->nMem + 1; pParse->nMem += pGroupBy->nExpr; sqlite3VdbeAddOp2(v, OP_Integer, 0, iAbortFlag); VdbeComment((v, "clear abort flag")); sqlite3VdbeAddOp2(v, OP_Integer, 0, iUseFlag); VdbeComment((v, "indicate accumulator empty")); sqlite3VdbeAddOp2(v, OP_Gosub, regReset, addrReset); pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, &pGroupBy, 0); if( pWInfo==0 ) goto select_end; if( pGroupBy==0 ){ pGroupBy = p->pGroupBy; groupBySort = 0; }else{ int regBase; int regRecord; int nCol; int nGroupBy; groupBySort = 1; nGroupBy = pGroupBy->nExpr; nCol = nGroupBy + 1; j = nGroupBy+1; for(i=0; i<sAggInfo.nColumn; i++){ if( sAggInfo.aCol[i].iSorterColumn>=j ){ nCol++; j++; } } regBase = sqlite3GetTempRange(pParse, nCol); sqlite3ExprCodeExprList(pParse, pGroupBy, regBase, 0); sqlite3VdbeAddOp2(v, OP_Sequence, sAggInfo.sortingIdx,regBase+nGroupBy); j = nGroupBy+1; for(i=0; i<sAggInfo.nColumn; i++){ struct AggInfo_col *pCol = &sAggInfo.aCol[i]; if( pCol->iSorterColumn>=j ){ int r1 = j + regBase; int r2; r2 = sqlite3ExprCodeGetColumn(pParse, pCol->pTab, pCol->iColumn, pCol->iTable, r1, 0); if( r1!=r2 ){ sqlite3VdbeAddOp2(v, OP_SCopy, r2, r1); } j++; } } regRecord = sqlite3GetTempReg(pParse); sqlite3VdbeAddOp3(v, OP_MakeRecord, regBase, nCol, regRecord); sqlite3VdbeAddOp2(v, OP_IdxInsert, sAggInfo.sortingIdx, regRecord); sqlite3ReleaseTempReg(pParse, regRecord); sqlite3ReleaseTempRange(pParse, regBase, nCol); sqlite3WhereEnd(pWInfo); sqlite3VdbeAddOp2(v, OP_Sort, sAggInfo.sortingIdx, addrEnd); VdbeComment((v, "GROUP BY sort")); sAggInfo.useSortingIdx = 1; } addrTopOfLoop = sqlite3VdbeCurrentAddr(v); for(j=0; j<pGroupBy->nExpr; j++){ if( groupBySort ){ sqlite3VdbeAddOp3(v, OP_Column, sAggInfo.sortingIdx, j, iBMem+j); }else{ sAggInfo.directMode = 1; sqlite3ExprCode(pParse, pGroupBy->a[j].pExpr, iBMem+j); } } sqlite3VdbeAddOp4(v, OP_Compare, iAMem, iBMem, pGroupBy->nExpr, (char*)pKeyInfo, P4_KEYINFO); j1 = sqlite3VdbeCurrentAddr(v); sqlite3VdbeAddOp3(v, OP_Jump, j1+1, 0, j1+1); sqlite3ExprCodeMove(pParse, iBMem, iAMem, pGroupBy->nExpr); sqlite3VdbeAddOp2(v, OP_Gosub, regOutputRow, addrOutputRow); VdbeComment((v, "output one row")); sqlite3VdbeAddOp2(v, OP_IfPos, iAbortFlag, addrEnd); VdbeComment((v, "check abort flag")); sqlite3VdbeAddOp2(v, OP_Gosub, regReset, addrReset); VdbeComment((v, "reset accumulator")); sqlite3VdbeJumpHere(v, j1); updateAccumulator(pParse, &sAggInfo); sqlite3VdbeAddOp2(v, OP_Integer, 1, iUseFlag); VdbeComment((v, "indicate data in accumulator")); if( groupBySort ){ sqlite3VdbeAddOp2(v, OP_Next, sAggInfo.sortingIdx, addrTopOfLoop); }else{ sqlite3WhereEnd(pWInfo); sqlite3VdbeChangeToNoop(v, addrSortingIdx, 1); } sqlite3VdbeAddOp2(v, OP_Gosub, regOutputRow, addrOutputRow); VdbeComment((v, "output final row")); sqlite3VdbeAddOp2(v, OP_Goto, 0, addrEnd); addrSetAbort = sqlite3VdbeCurrentAddr(v); sqlite3VdbeAddOp2(v, OP_Integer, 1, iAbortFlag); VdbeComment((v, "set abort flag")); sqlite3VdbeAddOp1(v, OP_Return, regOutputRow); sqlite3VdbeResolveLabel(v, addrOutputRow); addrOutputRow = sqlite3VdbeCurrentAddr(v); sqlite3VdbeAddOp2(v, OP_IfPos, iUseFlag, addrOutputRow+2); VdbeComment((v, "Groupby result generator entry point")); sqlite3VdbeAddOp1(v, OP_Return, regOutputRow); finalizeAggFunctions(pParse, &sAggInfo); if( pHaving ){ sqlite3ExprIfFalse(pParse, pHaving, addrOutputRow+1, SQLITE_JUMPIFNULL); } selectInnerLoop(pParse, p, p->pEList, 0, 0, pOrderBy, distinct, pDest, addrOutputRow+1, addrSetAbort); sqlite3VdbeAddOp1(v, OP_Return, regOutputRow); VdbeComment((v, "end groupby result generator")); sqlite3VdbeResolveLabel(v, addrReset); resetAccumulator(pParse, &sAggInfo); sqlite3VdbeAddOp1(v, OP_Return, regReset); } else { ExprList *pMinMax = 0; ExprList *pDel = 0; u8 flag; flag = minMaxQuery(p); if( flag ){ pDel = pMinMax = sqlite3ExprListDup(db, p->pEList->a[0].pExpr->pList); if( pMinMax && !db->mallocFailed ){ pMinMax->a[0].sortOrder = flag!=WHERE_ORDERBY_MIN; pMinMax->a[0].pExpr->op = TK_COLUMN; } } resetAccumulator(pParse, &sAggInfo); pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, &pMinMax, flag); if( pWInfo==0 ){ sqlite3ExprListDelete(db, pDel); goto select_end; } updateAccumulator(pParse, &sAggInfo); if( !pMinMax && flag ){ sqlite3VdbeAddOp2(v, OP_Goto, 0, pWInfo->iBreak); VdbeComment((v, "%s() by index",(flag==WHERE_ORDERBY_MIN?"min":"max"))); } sqlite3WhereEnd(pWInfo); finalizeAggFunctions(pParse, &sAggInfo); pOrderBy = 0; if( pHaving ){ sqlite3ExprIfFalse(pParse, pHaving, addrEnd, SQLITE_JUMPIFNULL); } selectInnerLoop(pParse, p, p->pEList, 0, 0, 0, -1, pDest, addrEnd, addrEnd); sqlite3ExprListDelete(db, pDel); } sqlite3VdbeResolveLabel(v, addrEnd); } if( pOrderBy ){ generateSortTail(pParse, p, v, pEList->nExpr, pDest); } sqlite3VdbeResolveLabel(v, iEnd); rc = 0; select_end: if( rc==SQLITE_OK && pDest->eDest==SRT_Output ){ generateColumnNames(pParse, pTabList, pEList); } sqlite3DbFree(db, sAggInfo.aCol); sqlite3DbFree(db, sAggInfo.aFunc); return rc; } 
#if defined(SQLITE_DEBUG) 
SQLITE_PRIVATE void sqlite3PrintExpr(Expr *p){ if( p->token.z && p->token.n>0 ){ sqlite3DebugPrintf("(%.*s", p->token.n, p->token.z); }else{ sqlite3DebugPrintf("(%d", p->op); } if( p->pLeft ){ sqlite3DebugPrintf(" "); sqlite3PrintExpr(p->pLeft); } if( p->pRight ){ sqlite3DebugPrintf(" "); sqlite3PrintExpr(p->pRight); } sqlite3DebugPrintf(")"); } SQLITE_PRIVATE void sqlite3PrintExprList(ExprList *pList){ int i; for(i=0; i<pList->nExpr; i++){ sqlite3PrintExpr(pList->a[i].pExpr); if( i<pList->nExpr-1 ){ sqlite3DebugPrintf(", "); } } } SQLITE_PRIVATE void sqlite3PrintSelect(Select *p, int indent){ sqlite3DebugPrintf("%*sSELECT(%p) ", indent, "", p); sqlite3PrintExprList(p->pEList); sqlite3DebugPrintf("\n"); if( p->pSrc ){ char *zPrefix; int i; zPrefix = "FROM"; for(i=0; i<p->pSrc->nSrc; i++){ struct SrcList_item *pItem = &p->pSrc->a[i]; sqlite3DebugPrintf("%*s ", indent+6, zPrefix); zPrefix = ""; if( pItem->pSelect ){ sqlite3DebugPrintf("(\n"); sqlite3PrintSelect(pItem->pSelect, indent+10); sqlite3DebugPrintf("%*s)", indent+8, ""); }else if( pItem->zName ){ sqlite3DebugPrintf("%s", pItem->zName); } if( pItem->pTab ){ sqlite3DebugPrintf("(table: %s)", pItem->pTab->zName); } if( pItem->zAlias ){ sqlite3DebugPrintf(" AS %s", pItem->zAlias); } if( i<p->pSrc->nSrc-1 ){ sqlite3DebugPrintf(","); } sqlite3DebugPrintf("\n"); } } if( p->pWhere ){ sqlite3DebugPrintf("%*s WHERE ", indent, ""); sqlite3PrintExpr(p->pWhere); sqlite3DebugPrintf("\n"); } if( p->pGroupBy ){ sqlite3DebugPrintf("%*s GROUP BY ", indent, ""); sqlite3PrintExprList(p->pGroupBy); sqlite3DebugPrintf("\n"); } if( p->pHaving ){ sqlite3DebugPrintf("%*s HAVING ", indent, ""); sqlite3PrintExpr(p->pHaving); sqlite3DebugPrintf("\n"); } if( p->pOrderBy ){ sqlite3DebugPrintf("%*s ORDER BY ", indent, ""); sqlite3PrintExprList(p->pOrderBy); sqlite3DebugPrintf("\n"); } } 
#endif 
#ifndef SQLITE_OMIT_GET_TABLE 
typedef struct TabResult { char **azResult; char *zErrMsg; int nResult; int nAlloc; int nRow; int nColumn; int nData; int rc; } TabResult; static int sqlite3_get_table_cb(void *pArg, int nCol, char **argv, char **colv){ TabResult *p = (TabResult*)pArg; int need; int i; char *z; if( p->nRow==0 && argv!=0 ){ need = nCol*2; }else{ need = nCol; } if( p->nData + need >= p->nAlloc ){ char **azNew; p->nAlloc = p->nAlloc*2 + need + 1; azNew = sqlite3_realloc( p->azResult, sizeof(char*)*p->nAlloc ); if( azNew==0 ) goto malloc_failed; p->azResult = azNew; } if( p->nRow==0 ){ p->nColumn = nCol; for(i=0; i<nCol; i++){ z = sqlite3_mprintf("%s", colv[i]); if( z==0 ) goto malloc_failed; p->azResult[p->nData++] = z; } }else if( p->nColumn!=nCol ){ sqlite3_free(p->zErrMsg); p->zErrMsg = sqlite3_mprintf( "sqlite3_get_table() called with two or more incompatible queries" ); p->rc = SQLITE_ERROR; return 1; } if( argv!=0 ){ for(i=0; i<nCol; i++){ if( argv[i]==0 ){ z = 0; }else{ int n = strlen(argv[i])+1; z = sqlite3_malloc( n ); if( z==0 ) goto malloc_failed; memcpy(z, argv[i], n); } p->azResult[p->nData++] = z; } p->nRow++; } return 0; malloc_failed: p->rc = SQLITE_NOMEM; return 1; } SQLITE_API int sqlite3_get_table( sqlite3 *db, const char *zSql, char ***pazResult, int *pnRow, int *pnColumn, char **pzErrMsg ){ int rc; TabResult res; *pazResult = 0; if( pnColumn ) *pnColumn = 0; if( pnRow ) *pnRow = 0; res.zErrMsg = 0; res.nResult = 0; res.nRow = 0; res.nColumn = 0; res.nData = 1; res.nAlloc = 20; res.rc = SQLITE_OK; res.azResult = sqlite3_malloc(sizeof(char*)*res.nAlloc ); if( res.azResult==0 ){ db->errCode = SQLITE_NOMEM; return SQLITE_NOMEM; } res.azResult[0] = 0; rc = sqlite3_exec(db, zSql, sqlite3_get_table_cb, &res, pzErrMsg); assert( sizeof(res.azResult[0])>= sizeof(res.nData) ); res.azResult[0] = SQLITE_INT_TO_PTR(res.nData); if( (rc&0xff)==SQLITE_ABORT ){ sqlite3_free_table(&res.azResult[1]); if( res.zErrMsg ){ if( pzErrMsg ){ sqlite3_free(*pzErrMsg); *pzErrMsg = sqlite3_mprintf("%s",res.zErrMsg); } sqlite3_free(res.zErrMsg); } db->errCode = res.rc; return res.rc; } sqlite3_free(res.zErrMsg); if( rc!=SQLITE_OK ){ sqlite3_free_table(&res.azResult[1]); return rc; } if( res.nAlloc>res.nData ){ char **azNew; azNew = sqlite3_realloc( res.azResult, sizeof(char*)*(res.nData+1) ); if( azNew==0 ){ sqlite3_free_table(&res.azResult[1]); db->errCode = SQLITE_NOMEM; return SQLITE_NOMEM; } res.nAlloc = res.nData+1; res.azResult = azNew; } *pazResult = &res.azResult[1]; if( pnColumn ) *pnColumn = res.nColumn; if( pnRow ) *pnRow = res.nRow; return rc; } SQLITE_API void sqlite3_free_table( char **azResult ){ if( azResult ){ int i, n; azResult--; assert( azResult!=0 ); n = SQLITE_PTR_TO_INT(azResult[0]); for(i=1; i<n; i++){ if( azResult[i] ) sqlite3_free(azResult[i]); } sqlite3_free(azResult); } } 
#endif 
#ifndef SQLITE_OMIT_TRIGGER 
SQLITE_PRIVATE void sqlite3DeleteTriggerStep(sqlite3 *db, TriggerStep *pTriggerStep){ while( pTriggerStep ){ TriggerStep * pTmp = pTriggerStep; pTriggerStep = pTriggerStep->pNext; if( pTmp->target.dyn ) sqlite3DbFree(db, (char*)pTmp->target.z); sqlite3ExprDelete(db, pTmp->pWhere); sqlite3ExprListDelete(db, pTmp->pExprList); sqlite3SelectDelete(db, pTmp->pSelect); sqlite3IdListDelete(db, pTmp->pIdList); sqlite3DbFree(db, pTmp); } } SQLITE_PRIVATE void sqlite3BeginTrigger( Parse *pParse, Token *pName1, Token *pName2, int tr_tm, int op, IdList *pColumns, SrcList *pTableName, Expr *pWhen, int isTemp, int noErr ){ Trigger *pTrigger = 0; Table *pTab; char *zName = 0; sqlite3 *db = pParse->db; int iDb; Token *pName; DbFixer sFix; int iTabDb; assert( pName1!=0 ); assert( pName2!=0 ); if( isTemp ){ if( pName2->n>0 ){ sqlite3ErrorMsg(pParse, "temporary trigger may not have qualified name"); goto trigger_cleanup; } iDb = 1; pName = pName1; }else{ iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName); if( iDb<0 ){ goto trigger_cleanup; } } if( !pTableName || db->mallocFailed ){ goto trigger_cleanup; } pTab = sqlite3SrcListLookup(pParse, pTableName); if( pName2->n==0 && pTab && pTab->pSchema==db->aDb[1].pSchema ){ iDb = 1; } if( db->mallocFailed ) goto trigger_cleanup; assert( pTableName->nSrc==1 ); if( sqlite3FixInit(&sFix, pParse, iDb, "trigger", pName) && sqlite3FixSrcList(&sFix, pTableName) ){ goto trigger_cleanup; } pTab = sqlite3SrcListLookup(pParse, pTableName); if( !pTab ){ goto trigger_cleanup; } if( IsVirtual(pTab) ){ sqlite3ErrorMsg(pParse, "cannot create triggers on virtual tables"); goto trigger_cleanup; } zName = sqlite3NameFromToken(db, pName); if( !zName || SQLITE_OK!=sqlite3CheckObjectName(pParse, zName) ){ goto trigger_cleanup; } if( sqlite3HashFind(&(db->aDb[iDb].pSchema->trigHash), zName,strlen(zName)) ){ if( !noErr ){ sqlite3ErrorMsg(pParse, "trigger %T already exists", pName); } goto trigger_cleanup; } if( sqlite3StrNICmp(pTab->zName, "sqlite_", 7)==0 ){ sqlite3ErrorMsg(pParse, "cannot create trigger on system table"); pParse->nErr++; goto trigger_cleanup; } if( pTab->pSelect && tr_tm!=TK_INSTEAD ){ sqlite3ErrorMsg(pParse, "cannot create %s trigger on view: %S", (tr_tm == TK_BEFORE)?"BEFORE":"AFTER", pTableName, 0); goto trigger_cleanup; } if( !pTab->pSelect && tr_tm==TK_INSTEAD ){ sqlite3ErrorMsg(pParse, "cannot create INSTEAD OF" " trigger on table: %S", pTableName, 0); goto trigger_cleanup; } iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema); 
#ifndef SQLITE_OMIT_AUTHORIZATION 
 { int code = SQLITE_CREATE_TRIGGER; const char *zDb = db->aDb[iTabDb].zName; const char *zDbTrig = isTemp ? db->aDb[1].zName : zDb; if( iTabDb==1 || isTemp ) code = SQLITE_CREATE_TEMP_TRIGGER; if( sqlite3AuthCheck(pParse, code, zName, pTab->zName, zDbTrig) ){ goto trigger_cleanup; } if( sqlite3AuthCheck(pParse, SQLITE_INSERT, SCHEMA_TABLE(iTabDb),0,zDb)){ goto trigger_cleanup; } } 
#endif 
 if (tr_tm == TK_INSTEAD){ tr_tm = TK_BEFORE; } pTrigger = (Trigger*)sqlite3DbMallocZero(db, sizeof(Trigger)); if( pTrigger==0 ) goto trigger_cleanup; pTrigger->name = zName; zName = 0; pTrigger->table = sqlite3DbStrDup(db, pTableName->a[0].zName); pTrigger->pSchema = db->aDb[iDb].pSchema; pTrigger->pTabSchema = pTab->pSchema; pTrigger->op = op; pTrigger->tr_tm = tr_tm==TK_BEFORE ? TRIGGER_BEFORE : TRIGGER_AFTER; pTrigger->pWhen = sqlite3ExprDup(db, pWhen); pTrigger->pColumns = sqlite3IdListDup(db, pColumns); sqlite3TokenCopy(db, &pTrigger->nameToken,pName); assert( pParse->pNewTrigger==0 ); pParse->pNewTrigger = pTrigger; trigger_cleanup: sqlite3DbFree(db, zName); sqlite3SrcListDelete(db, pTableName); sqlite3IdListDelete(db, pColumns); sqlite3ExprDelete(db, pWhen); if( !pParse->pNewTrigger ){ sqlite3DeleteTrigger(db, pTrigger); }else{ assert( pParse->pNewTrigger==pTrigger ); } } SQLITE_PRIVATE void sqlite3FinishTrigger( Parse *pParse, TriggerStep *pStepList, Token *pAll ){ Trigger *pTrig = 0; sqlite3 *db = pParse->db; DbFixer sFix; int iDb; pTrig = pParse->pNewTrigger; pParse->pNewTrigger = 0; if( pParse->nErr || !pTrig ) goto triggerfinish_cleanup; iDb = sqlite3SchemaToIndex(pParse->db, pTrig->pSchema); pTrig->step_list = pStepList; while( pStepList ){ pStepList->pTrig = pTrig; pStepList = pStepList->pNext; } if( sqlite3FixInit(&sFix, pParse, iDb, "trigger", &pTrig->nameToken) && sqlite3FixTriggerStep(&sFix, pTrig->step_list) ){ goto triggerfinish_cleanup; } if( !db->init.busy ){ Vdbe *v; char *z; v = sqlite3GetVdbe(pParse); if( v==0 ) goto triggerfinish_cleanup; sqlite3BeginWriteOperation(pParse, 0, iDb); z = sqlite3DbStrNDup(db, (char*)pAll->z, pAll->n); sqlite3NestedParse(pParse, "INSERT INTO %Q.%s VALUES('trigger',%Q,%Q,0,'CREATE TRIGGER %q')", db->aDb[iDb].zName, SCHEMA_TABLE(iDb), pTrig->name, pTrig->table, z); sqlite3DbFree(db, z); sqlite3ChangeCookie(pParse, iDb); sqlite3VdbeAddOp4(v, OP_ParseSchema, iDb, 0, 0, sqlite3MPrintf( db, "type='trigger' AND name='%q'", pTrig->name), P4_DYNAMIC ); } if( db->init.busy ){ int n; Table *pTab; Trigger *pDel; pDel = sqlite3HashInsert(&db->aDb[iDb].pSchema->trigHash, pTrig->name, strlen(pTrig->name), pTrig); if( pDel ){ assert( pDel==pTrig ); db->mallocFailed = 1; goto triggerfinish_cleanup; } n = strlen(pTrig->table) + 1; pTab = sqlite3HashFind(&pTrig->pTabSchema->tblHash, pTrig->table, n); assert( pTab!=0 ); pTrig->pNext = pTab->pTrigger; pTab->pTrigger = pTrig; pTrig = 0; } triggerfinish_cleanup: sqlite3DeleteTrigger(db, pTrig); assert( !pParse->pNewTrigger ); sqlite3DeleteTriggerStep(db, pStepList); } static void sqlitePersistTriggerStep(sqlite3 *db, TriggerStep *p){ if( p->target.z ){ p->target.z = (u8*)sqlite3DbStrNDup(db, (char*)p->target.z, p->target.n); p->target.dyn = 1; } if( p->pSelect ){ Select *pNew = sqlite3SelectDup(db, p->pSelect); sqlite3SelectDelete(db, p->pSelect); p->pSelect = pNew; } if( p->pWhere ){ Expr *pNew = sqlite3ExprDup(db, p->pWhere); sqlite3ExprDelete(db, p->pWhere); p->pWhere = pNew; } if( p->pExprList ){ ExprList *pNew = sqlite3ExprListDup(db, p->pExprList); sqlite3ExprListDelete(db, p->pExprList); p->pExprList = pNew; } if( p->pIdList ){ IdList *pNew = sqlite3IdListDup(db, p->pIdList); sqlite3IdListDelete(db, p->pIdList); p->pIdList = pNew; } } SQLITE_PRIVATE TriggerStep *sqlite3TriggerSelectStep(sqlite3 *db, Select *pSelect){ TriggerStep *pTriggerStep = sqlite3DbMallocZero(db, sizeof(TriggerStep)); if( pTriggerStep==0 ) { sqlite3SelectDelete(db, pSelect); return 0; } pTriggerStep->op = TK_SELECT; pTriggerStep->pSelect = pSelect; pTriggerStep->orconf = OE_Default; sqlitePersistTriggerStep(db, pTriggerStep); return pTriggerStep; } SQLITE_PRIVATE TriggerStep *sqlite3TriggerInsertStep( sqlite3 *db, Token *pTableName, IdList *pColumn, ExprList *pEList, Select *pSelect, int orconf ){ TriggerStep *pTriggerStep; assert(pEList == 0 || pSelect == 0); assert(pEList != 0 || pSelect != 0 || db->mallocFailed); pTriggerStep = sqlite3DbMallocZero(db, sizeof(TriggerStep)); if( pTriggerStep ){ pTriggerStep->op = TK_INSERT; pTriggerStep->pSelect = pSelect; pTriggerStep->target = *pTableName; pTriggerStep->pIdList = pColumn; pTriggerStep->pExprList = pEList; pTriggerStep->orconf = orconf; sqlitePersistTriggerStep(db, pTriggerStep); }else{ sqlite3IdListDelete(db, pColumn); sqlite3ExprListDelete(db, pEList); sqlite3SelectDelete(db, pSelect); } return pTriggerStep; } SQLITE_PRIVATE TriggerStep *sqlite3TriggerUpdateStep( sqlite3 *db, Token *pTableName, ExprList *pEList, Expr *pWhere, int orconf ){ TriggerStep *pTriggerStep = sqlite3DbMallocZero(db, sizeof(TriggerStep)); if( pTriggerStep==0 ){ sqlite3ExprListDelete(db, pEList); sqlite3ExprDelete(db, pWhere); return 0; } pTriggerStep->op = TK_UPDATE; pTriggerStep->target = *pTableName; pTriggerStep->pExprList = pEList; pTriggerStep->pWhere = pWhere; pTriggerStep->orconf = orconf; sqlitePersistTriggerStep(db, pTriggerStep); return pTriggerStep; } SQLITE_PRIVATE TriggerStep *sqlite3TriggerDeleteStep( sqlite3 *db, Token *pTableName, Expr *pWhere ){ TriggerStep *pTriggerStep = sqlite3DbMallocZero(db, sizeof(TriggerStep)); if( pTriggerStep==0 ){ sqlite3ExprDelete(db, pWhere); return 0; } pTriggerStep->op = TK_DELETE; pTriggerStep->target = *pTableName; pTriggerStep->pWhere = pWhere; pTriggerStep->orconf = OE_Default; sqlitePersistTriggerStep(db, pTriggerStep); return pTriggerStep; } SQLITE_PRIVATE void sqlite3DeleteTrigger(sqlite3 *db, Trigger *pTrigger){ if( pTrigger==0 ) return; sqlite3DeleteTriggerStep(db, pTrigger->step_list); sqlite3DbFree(db, pTrigger->name); sqlite3DbFree(db, pTrigger->table); sqlite3ExprDelete(db, pTrigger->pWhen); sqlite3IdListDelete(db, pTrigger->pColumns); if( pTrigger->nameToken.dyn ) sqlite3DbFree(db, (char*)pTrigger->nameToken.z); sqlite3DbFree(db, pTrigger); } SQLITE_PRIVATE void sqlite3DropTrigger(Parse *pParse, SrcList *pName, int noErr){ Trigger *pTrigger = 0; int i; const char *zDb; const char *zName; int nName; sqlite3 *db = pParse->db; if( db->mallocFailed ) goto drop_trigger_cleanup; if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){ goto drop_trigger_cleanup; } assert( pName->nSrc==1 ); zDb = pName->a[0].zDatabase; zName = pName->a[0].zName; nName = strlen(zName); for(i=OMIT_TEMPDB; i<db->nDb; i++){ int j = (i<2) ? i^1 : i; if( zDb && sqlite3StrICmp(db->aDb[j].zName, zDb) ) continue; pTrigger = sqlite3HashFind(&(db->aDb[j].pSchema->trigHash), zName, nName); if( pTrigger ) break; } if( !pTrigger ){ if( !noErr ){ sqlite3ErrorMsg(pParse, "no such trigger: %S", pName, 0); } goto drop_trigger_cleanup; } sqlite3DropTriggerPtr(pParse, pTrigger); drop_trigger_cleanup: sqlite3SrcListDelete(db, pName); } static Table *tableOfTrigger(Trigger *pTrigger){ int n = strlen(pTrigger->table) + 1; return sqlite3HashFind(&pTrigger->pTabSchema->tblHash, pTrigger->table, n); } SQLITE_PRIVATE void sqlite3DropTriggerPtr(Parse *pParse, Trigger *pTrigger){ Table *pTable; Vdbe *v; sqlite3 *db = pParse->db; int iDb; iDb = sqlite3SchemaToIndex(pParse->db, pTrigger->pSchema); assert( iDb>=0 && iDb<db->nDb ); pTable = tableOfTrigger(pTrigger); assert( pTable ); assert( pTable->pSchema==pTrigger->pSchema || iDb==1 ); 
#ifndef SQLITE_OMIT_AUTHORIZATION 
 { int code = SQLITE_DROP_TRIGGER; const char *zDb = db->aDb[iDb].zName; const char *zTab = SCHEMA_TABLE(iDb); if( iDb==1 ) code = SQLITE_DROP_TEMP_TRIGGER; if( sqlite3AuthCheck(pParse, code, pTrigger->name, pTable->zName, zDb) || sqlite3AuthCheck(pParse, SQLITE_DELETE, zTab, 0, zDb) ){ return; } } 
#endif 
 assert( pTable!=0 ); if( (v = sqlite3GetVdbe(pParse))!=0 ){ int base; static const VdbeOpList dropTrigger[] = { { OP_Rewind, 0, ADDR(9), 0}, { OP_String8, 0, 1, 0}, { OP_Column, 0, 1, 2}, { OP_Ne, 2, ADDR(8), 1}, { OP_String8, 0, 1, 0}, { OP_Column, 0, 0, 2}, { OP_Ne, 2, ADDR(8), 1}, { OP_Delete, 0, 0, 0}, { OP_Next, 0, ADDR(1), 0}, }; sqlite3BeginWriteOperation(pParse, 0, iDb); sqlite3OpenMasterTable(pParse, iDb); base = sqlite3VdbeAddOpList(v, ArraySize(dropTrigger), dropTrigger); sqlite3VdbeChangeP4(v, base+1, pTrigger->name, 0); sqlite3VdbeChangeP4(v, base+4, "trigger", P4_STATIC); sqlite3ChangeCookie(pParse, iDb); sqlite3VdbeAddOp2(v, OP_Close, 0, 0); sqlite3VdbeAddOp4(v, OP_DropTrigger, iDb, 0, 0, pTrigger->name, 0); } } SQLITE_PRIVATE void sqlite3UnlinkAndDeleteTrigger(sqlite3 *db, int iDb, const char *zName){ Trigger *pTrigger; int nName = strlen(zName); pTrigger = sqlite3HashInsert(&(db->aDb[iDb].pSchema->trigHash), zName, nName, 0); if( pTrigger ){ Table *pTable = tableOfTrigger(pTrigger); assert( pTable!=0 ); if( pTable->pTrigger == pTrigger ){ pTable->pTrigger = pTrigger->pNext; }else{ Trigger *cc = pTable->pTrigger; while( cc ){ if( cc->pNext == pTrigger ){ cc->pNext = cc->pNext->pNext; break; } cc = cc->pNext; } assert(cc); } sqlite3DeleteTrigger(db, pTrigger); db->flags |= SQLITE_InternChanges; } } static int checkColumnOverLap(IdList *pIdList, ExprList *pEList){ int e; if( !pIdList || !pEList ) return 1; for(e=0; e<pEList->nExpr; e++){ if( sqlite3IdListIndex(pIdList, pEList->a[e].zName)>=0 ) return 1; } return 0; } SQLITE_PRIVATE int sqlite3TriggersExist( Table *pTab, int op, ExprList *pChanges ){ Trigger *pTrigger; int mask = 0; pTrigger = IsVirtual(pTab) ? 0 : pTab->pTrigger; while( pTrigger ){ if( pTrigger->op==op && checkColumnOverLap(pTrigger->pColumns, pChanges) ){ mask |= pTrigger->tr_tm; } pTrigger = pTrigger->pNext; } return mask; } static SrcList *targetSrcList( Parse *pParse, TriggerStep *pStep ){ Token sDb; int iDb; SrcList *pSrc; iDb = sqlite3SchemaToIndex(pParse->db, pStep->pTrig->pSchema); if( iDb==0 || iDb>=2 ){ assert( iDb<pParse->db->nDb ); sDb.z = (u8*)pParse->db->aDb[iDb].zName; sDb.n = strlen((char*)sDb.z); pSrc = sqlite3SrcListAppend(pParse->db, 0, &sDb, &pStep->target); } else { pSrc = sqlite3SrcListAppend(pParse->db, 0, &pStep->target, 0); } return pSrc; } static int codeTriggerProgram( Parse *pParse, TriggerStep *pStepList, int orconfin ){ TriggerStep * pTriggerStep = pStepList; int orconf; Vdbe *v = pParse->pVdbe; sqlite3 *db = pParse->db; assert( pTriggerStep!=0 ); assert( v!=0 ); sqlite3VdbeAddOp2(v, OP_ContextPush, 0, 0); VdbeComment((v, "begin trigger %s", pStepList->pTrig->name)); while( pTriggerStep ){ orconf = (orconfin == OE_Default)?pTriggerStep->orconf:orconfin; pParse->trigStack->orconf = orconf; switch( pTriggerStep->op ){ case TK_SELECT: { Select *ss = sqlite3SelectDup(db, pTriggerStep->pSelect); if( ss ){ SelectDest dest; sqlite3SelectDestInit(&dest, SRT_Discard, 0); sqlite3Select(pParse, ss, &dest); sqlite3SelectDelete(db, ss); } break; } case TK_UPDATE: { SrcList *pSrc; pSrc = targetSrcList(pParse, pTriggerStep); sqlite3VdbeAddOp2(v, OP_ResetCount, 0, 0); sqlite3Update(pParse, pSrc, sqlite3ExprListDup(db, pTriggerStep->pExprList), sqlite3ExprDup(db, pTriggerStep->pWhere), orconf); sqlite3VdbeAddOp2(v, OP_ResetCount, 1, 0); break; } case TK_INSERT: { SrcList *pSrc; pSrc = targetSrcList(pParse, pTriggerStep); sqlite3VdbeAddOp2(v, OP_ResetCount, 0, 0); sqlite3Insert(pParse, pSrc, sqlite3ExprListDup(db, pTriggerStep->pExprList), sqlite3SelectDup(db, pTriggerStep->pSelect), sqlite3IdListDup(db, pTriggerStep->pIdList), orconf); sqlite3VdbeAddOp2(v, OP_ResetCount, 1, 0); break; } case TK_DELETE: { SrcList *pSrc; sqlite3VdbeAddOp2(v, OP_ResetCount, 0, 0); pSrc = targetSrcList(pParse, pTriggerStep); sqlite3DeleteFrom(pParse, pSrc, sqlite3ExprDup(db, pTriggerStep->pWhere)); sqlite3VdbeAddOp2(v, OP_ResetCount, 1, 0); break; } default: assert(0); } pTriggerStep = pTriggerStep->pNext; } sqlite3VdbeAddOp2(v, OP_ContextPop, 0, 0); VdbeComment((v, "end trigger %s", pStepList->pTrig->name)); return 0; } SQLITE_PRIVATE int sqlite3CodeRowTrigger( Parse *pParse, int op, ExprList *pChanges, int tr_tm, Table *pTab, int newIdx, int oldIdx, int orconf, int ignoreJump, u32 *piOldColMask, u32 *piNewColMask ){ Trigger *p; sqlite3 *db = pParse->db; TriggerStack trigStackEntry; trigStackEntry.oldColMask = 0; trigStackEntry.newColMask = 0; assert(op == TK_UPDATE || op == TK_INSERT || op == TK_DELETE); assert(tr_tm == TRIGGER_BEFORE || tr_tm == TRIGGER_AFTER ); assert(newIdx != -1 || oldIdx != -1); for(p=pTab->pTrigger; p; p=p->pNext){ int fire_this = 0; if( p->op==op && p->tr_tm==tr_tm && (p->pSchema==p->pTabSchema || p->pSchema==db->aDb[1].pSchema) && (op!=TK_UPDATE||!p->pColumns||checkColumnOverLap(p->pColumns,pChanges)) ){ TriggerStack *pS; for(pS=pParse->trigStack; pS && p!=pS->pTrigger; pS=pS->pNext){} if( !pS ){ fire_this = 1; } 
#if 0 
 else{ sqlite3ErrorMsg(pParse, "recursive triggers not supported (%s)", p->name); return SQLITE_ERROR; } 
#endif 
 } if( fire_this ){ int endTrigger; Expr * whenExpr; AuthContext sContext; NameContext sNC; 
#ifndef SQLITE_OMIT_TRACE 
 sqlite3VdbeAddOp4(pParse->pVdbe, OP_Trace, 0, 0, 0, sqlite3MPrintf(db, "-- TRIGGER %s", p->name), P4_DYNAMIC); 
#endif 
 memset(&sNC, 0, sizeof(sNC)); sNC.pParse = pParse; trigStackEntry.pTrigger = p; trigStackEntry.newIdx = newIdx; trigStackEntry.oldIdx = oldIdx; trigStackEntry.pTab = pTab; trigStackEntry.pNext = pParse->trigStack; trigStackEntry.ignoreJump = ignoreJump; pParse->trigStack = &trigStackEntry; sqlite3AuthContextPush(pParse, &sContext, p->name); endTrigger = sqlite3VdbeMakeLabel(pParse->pVdbe); whenExpr = sqlite3ExprDup(db, p->pWhen); if( db->mallocFailed || sqlite3ResolveExprNames(&sNC, whenExpr) ){ pParse->trigStack = trigStackEntry.pNext; sqlite3ExprDelete(db, whenExpr); return 1; } sqlite3ExprIfFalse(pParse, whenExpr, endTrigger, SQLITE_JUMPIFNULL); sqlite3ExprDelete(db, whenExpr); codeTriggerProgram(pParse, p->step_list, orconf); pParse->trigStack = trigStackEntry.pNext; sqlite3AuthContextPop(&sContext); sqlite3VdbeResolveLabel(pParse->pVdbe, endTrigger); } } if( piOldColMask ) *piOldColMask |= trigStackEntry.oldColMask; if( piNewColMask ) *piNewColMask |= trigStackEntry.newColMask; return 0; } 
#endif 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
static void updateVirtualTable( Parse *pParse, SrcList *pSrc, Table *pTab, ExprList *pChanges, Expr *pRowidExpr, int *aXRef, Expr *pWhere ); 
#endif 
SQLITE_PRIVATE void sqlite3ColumnDefault(Vdbe *v, Table *pTab, int i){ if( pTab && !pTab->pSelect ){ sqlite3_value *pValue; u8 enc = ENC(sqlite3VdbeDb(v)); Column *pCol = &pTab->aCol[i]; VdbeComment((v, "%s.%s", pTab->zName, pCol->zName)); assert( i<pTab->nCol ); sqlite3ValueFromExpr(sqlite3VdbeDb(v), pCol->pDflt, enc, pCol->affinity, &pValue); if( pValue ){ sqlite3VdbeChangeP4(v, -1, (const char *)pValue, P4_MEM); } } } SQLITE_PRIVATE void sqlite3Update( Parse *pParse, SrcList *pTabList, ExprList *pChanges, Expr *pWhere, int onError ){ int i, j; Table *pTab; int addr = 0; WhereInfo *pWInfo; Vdbe *v; Index *pIdx; int nIdx; int iCur; sqlite3 *db; int *aRegIdx = 0; int *aXRef = 0; int chngRowid; Expr *pRowidExpr = 0; int openAll = 0; AuthContext sContext; NameContext sNC; int iDb; int j1; int okOnePass; 
#ifndef SQLITE_OMIT_TRIGGER 
 int isView; int triggers_exist = 0; 
#endif 
 int iBeginAfterTrigger; int iEndAfterTrigger; int iBeginBeforeTrigger; int iEndBeforeTrigger; u32 old_col_mask = 0; u32 new_col_mask = 0; int newIdx = -1; int oldIdx = -1; int regRowCount = 0; int regOldRowid; int regNewRowid; int regData; sContext.pParse = 0; db = pParse->db; if( pParse->nErr || db->mallocFailed ){ goto update_cleanup; } assert( pTabList->nSrc==1 ); pTab = sqlite3SrcListLookup(pParse, pTabList); if( pTab==0 ) goto update_cleanup; iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema); 
#ifndef SQLITE_OMIT_TRIGGER 
 triggers_exist = sqlite3TriggersExist(pTab, TK_UPDATE, pChanges); isView = pTab->pSelect!=0; 
#else 
#define triggers_exist 0 
#define isView 0 
#endif 
#ifdef SQLITE_OMIT_VIEW 
#undef isView 
#define isView 0 
#endif 
 if( sqlite3IsReadOnly(pParse, pTab, triggers_exist) ){ goto update_cleanup; } if( sqlite3ViewGetColumnNames(pParse, pTab) ){ goto update_cleanup; } aXRef = sqlite3DbMallocRaw(db, sizeof(int) * pTab->nCol ); if( aXRef==0 ) goto update_cleanup; for(i=0; i<pTab->nCol; i++) aXRef[i] = -1; if( triggers_exist ){ newIdx = pParse->nTab++; oldIdx = pParse->nTab++; } pTabList->a[0].iCursor = iCur = pParse->nTab++; for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){ pParse->nTab++; } memset(&sNC, 0, sizeof(sNC)); sNC.pParse = pParse; sNC.pSrcList = pTabList; chngRowid = 0; for(i=0; i<pChanges->nExpr; i++){ if( sqlite3ResolveExprNames(&sNC, pChanges->a[i].pExpr) ){ goto update_cleanup; } for(j=0; j<pTab->nCol; j++){ if( sqlite3StrICmp(pTab->aCol[j].zName, pChanges->a[i].zName)==0 ){ if( j==pTab->iPKey ){ chngRowid = 1; pRowidExpr = pChanges->a[i].pExpr; } aXRef[j] = i; break; } } if( j>=pTab->nCol ){ if( sqlite3IsRowid(pChanges->a[i].zName) ){ chngRowid = 1; pRowidExpr = pChanges->a[i].pExpr; }else{ sqlite3ErrorMsg(pParse, "no such column: %s", pChanges->a[i].zName); goto update_cleanup; } } 
#ifndef SQLITE_OMIT_AUTHORIZATION 
 { int rc; rc = sqlite3AuthCheck(pParse, SQLITE_UPDATE, pTab->zName, pTab->aCol[j].zName, db->aDb[iDb].zName); if( rc==SQLITE_DENY ){ goto update_cleanup; }else if( rc==SQLITE_IGNORE ){ aXRef[j] = -1; } } 
#endif 
 } for(nIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nIdx++){} if( nIdx>0 ){ aRegIdx = sqlite3DbMallocRaw(db, sizeof(Index*) * nIdx ); if( aRegIdx==0 ) goto update_cleanup; } for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){ int reg; if( chngRowid ){ reg = ++pParse->nMem; }else{ reg = 0; for(i=0; i<pIdx->nColumn; i++){ if( aXRef[pIdx->aiColumn[i]]>=0 ){ reg = ++pParse->nMem; break; } } } aRegIdx[j] = reg; } regOldRowid = regNewRowid = pParse->nMem + 1; pParse->nMem += pTab->nCol + 1; if( chngRowid ){ regNewRowid++; pParse->nMem++; } regData = regNewRowid+1; v = sqlite3GetVdbe(pParse); if( v==0 ) goto update_cleanup; if( pParse->nested==0 ) sqlite3VdbeCountChanges(v); sqlite3BeginWriteOperation(pParse, 1, iDb); 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 if( IsVirtual(pTab) ){ updateVirtualTable(pParse, pTabList, pTab, pChanges, pRowidExpr, aXRef, pWhere); pWhere = 0; pTabList = 0; goto update_cleanup; } 
#endif 
 if( isView ){ sqlite3AuthContextPush(pParse, &sContext, pTab->zName); } if( triggers_exist ){ int iGoto; sqlite3VdbeAddOp2(v, OP_SetNumColumns, 0, pTab->nCol); sqlite3VdbeAddOp2(v, OP_OpenPseudo, oldIdx, 0); sqlite3VdbeAddOp2(v, OP_SetNumColumns, 0, pTab->nCol); sqlite3VdbeAddOp2(v, OP_OpenPseudo, newIdx, 0); iGoto = sqlite3VdbeAddOp2(v, OP_Goto, 0, 0); addr = sqlite3VdbeMakeLabel(v); iBeginBeforeTrigger = sqlite3VdbeCurrentAddr(v); if( sqlite3CodeRowTrigger(pParse, TK_UPDATE, pChanges, TRIGGER_BEFORE, pTab, newIdx, oldIdx, onError, addr, &old_col_mask, &new_col_mask) ){ goto update_cleanup; } iEndBeforeTrigger = sqlite3VdbeAddOp2(v, OP_Goto, 0, 0); iBeginAfterTrigger = sqlite3VdbeCurrentAddr(v); if( sqlite3CodeRowTrigger(pParse, TK_UPDATE, pChanges, TRIGGER_AFTER, pTab, newIdx, oldIdx, onError, addr, &old_col_mask, &new_col_mask) ){ goto update_cleanup; } iEndAfterTrigger = sqlite3VdbeAddOp2(v, OP_Goto, 0, 0); sqlite3VdbeJumpHere(v, iGoto); } 
#if !defined(SQLITE_OMIT_VIEW) && !defined(SQLITE_OMIT_TRIGGER) 
 if( isView ){ sqlite3MaterializeView(pParse, pTab, pWhere, iCur); } 
#endif 
 if( sqlite3ResolveExprNames(&sNC, pWhere) ){ goto update_cleanup; } sqlite3VdbeAddOp2(v, OP_Null, 0, regOldRowid); pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, 0, WHERE_ONEPASS_DESIRED); if( pWInfo==0 ) goto update_cleanup; okOnePass = pWInfo->okOnePass; sqlite3VdbeAddOp2(v, IsVirtual(pTab)?OP_VRowid:OP_Rowid, iCur, regOldRowid); if( !okOnePass ) sqlite3VdbeAddOp2(v, OP_FifoWrite, regOldRowid, 0); sqlite3WhereEnd(pWInfo); if( db->flags & SQLITE_CountRows && !pParse->trigStack ){ regRowCount = ++pParse->nMem; sqlite3VdbeAddOp2(v, OP_Integer, 0, regRowCount); } if( !isView && !IsVirtual(pTab) ){ if( !okOnePass ) sqlite3OpenTable(pParse, iCur, iDb, pTab, OP_OpenWrite); if( onError==OE_Replace ){ openAll = 1; }else{ openAll = 0; for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){ if( pIdx->onError==OE_Replace ){ openAll = 1; break; } } } for(i=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, i++){ if( openAll || aRegIdx[i]>0 ){ KeyInfo *pKey = sqlite3IndexKeyinfo(pParse, pIdx); sqlite3VdbeAddOp4(v, OP_OpenWrite, iCur+i+1, pIdx->tnum, iDb, (char*)pKey, P4_KEYINFO_HANDOFF); assert( pParse->nTab>iCur+i+1 ); } } } if( triggers_exist ){ sqlite3VdbeResolveLabel(v, addr); } if( okOnePass ){ int a1 = sqlite3VdbeAddOp1(v, OP_NotNull, regOldRowid); addr = sqlite3VdbeAddOp0(v, OP_Goto); sqlite3VdbeJumpHere(v, a1); }else{ addr = sqlite3VdbeAddOp2(v, OP_FifoRead, regOldRowid, 0); } if( triggers_exist ){ int regRowid; int regRow; int regCols; sqlite3VdbeAddOp3(v, OP_NotExists, iCur, addr, regOldRowid); regRowid = sqlite3GetTempReg(pParse); regRow = sqlite3GetTempReg(pParse); sqlite3VdbeAddOp2(v, OP_Rowid, iCur, regRowid); if( !old_col_mask ){ sqlite3VdbeAddOp2(v, OP_Null, 0, regRow); }else{ sqlite3VdbeAddOp2(v, OP_RowData, iCur, regRow); } sqlite3VdbeAddOp3(v, OP_Insert, oldIdx, regRow, regRowid); if( chngRowid ){ sqlite3ExprCodeAndCache(pParse, pRowidExpr, regRowid); sqlite3VdbeAddOp1(v, OP_MustBeInt, regRowid); }else{ sqlite3VdbeAddOp2(v, OP_Rowid, iCur, regRowid); } regCols = sqlite3GetTempRange(pParse, pTab->nCol); for(i=0; i<pTab->nCol; i++){ if( i==pTab->iPKey ){ sqlite3VdbeAddOp2(v, OP_Null, 0, regCols+i); continue; } j = aXRef[i]; if( new_col_mask&((u32)1<<i) || new_col_mask==0xffffffff ){ if( j<0 ){ sqlite3VdbeAddOp3(v, OP_Column, iCur, i, regCols+i); sqlite3ColumnDefault(v, pTab, i); }else{ sqlite3ExprCodeAndCache(pParse, pChanges->a[j].pExpr, regCols+i); } }else{ sqlite3VdbeAddOp2(v, OP_Null, 0, regCols+i); } } sqlite3VdbeAddOp3(v, OP_MakeRecord, regCols, pTab->nCol, regRow); if( !isView ){ sqlite3TableAffinityStr(v, pTab); sqlite3ExprCacheAffinityChange(pParse, regCols, pTab->nCol); } sqlite3ReleaseTempRange(pParse, regCols, pTab->nCol); sqlite3VdbeAddOp3(v, OP_Insert, newIdx, regRow, regRowid); sqlite3ReleaseTempReg(pParse, regRowid); sqlite3ReleaseTempReg(pParse, regRow); sqlite3VdbeAddOp2(v, OP_Goto, 0, iBeginBeforeTrigger); sqlite3VdbeJumpHere(v, iEndBeforeTrigger); } if( !isView && !IsVirtual(pTab) ){ sqlite3VdbeAddOp3(v, OP_NotExists, iCur, addr, regOldRowid); if( chngRowid ){ sqlite3ExprCode(pParse, pRowidExpr, regNewRowid); sqlite3VdbeAddOp1(v, OP_MustBeInt, regNewRowid); } for(i=0; i<pTab->nCol; i++){ if( i==pTab->iPKey ){ sqlite3VdbeAddOp2(v, OP_Null, 0, regData+i); continue; } j = aXRef[i]; if( j<0 ){ sqlite3VdbeAddOp3(v, OP_Column, iCur, i, regData+i); sqlite3ColumnDefault(v, pTab, i); }else{ sqlite3ExprCode(pParse, pChanges->a[j].pExpr, regData+i); } } sqlite3GenerateConstraintChecks(pParse, pTab, iCur, regNewRowid, aRegIdx, chngRowid, 1, onError, addr); j1 = sqlite3VdbeAddOp3(v, OP_NotExists, iCur, 0, regOldRowid); sqlite3GenerateRowIndexDelete(pParse, pTab, iCur, aRegIdx); if( chngRowid ){ sqlite3VdbeAddOp2(v, OP_Delete, iCur, 0); } sqlite3VdbeJumpHere(v, j1); sqlite3CompleteInsertion(pParse, pTab, iCur, regNewRowid, aRegIdx, 1, -1, 0); } if( db->flags & SQLITE_CountRows && !pParse->trigStack){ sqlite3VdbeAddOp2(v, OP_AddImm, regRowCount, 1); } if( triggers_exist ){ sqlite3VdbeAddOp2(v, OP_Goto, 0, iBeginAfterTrigger); sqlite3VdbeJumpHere(v, iEndAfterTrigger); } sqlite3VdbeAddOp2(v, OP_Goto, 0, addr); sqlite3VdbeJumpHere(v, addr); for(i=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, i++){ if( openAll || aRegIdx[i]>0 ){ sqlite3VdbeAddOp2(v, OP_Close, iCur+i+1, 0); } } sqlite3VdbeAddOp2(v, OP_Close, iCur, 0); if( triggers_exist ){ sqlite3VdbeAddOp2(v, OP_Close, newIdx, 0); sqlite3VdbeAddOp2(v, OP_Close, oldIdx, 0); } if( db->flags & SQLITE_CountRows && !pParse->trigStack && pParse->nested==0 ){ sqlite3VdbeAddOp2(v, OP_ResultRow, regRowCount, 1); sqlite3VdbeSetNumCols(v, 1); sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "rows updated", SQLITE_STATIC); } update_cleanup: sqlite3AuthContextPop(&sContext); sqlite3DbFree(db, aRegIdx); sqlite3DbFree(db, aXRef); sqlite3SrcListDelete(db, pTabList); sqlite3ExprListDelete(db, pChanges); sqlite3ExprDelete(db, pWhere); return; } 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
static void updateVirtualTable( Parse *pParse, SrcList *pSrc, Table *pTab, ExprList *pChanges, Expr *pRowid, int *aXRef, Expr *pWhere ){ Vdbe *v = pParse->pVdbe; ExprList *pEList = 0; Select *pSelect = 0; Expr *pExpr; int ephemTab; int i; int addr; int iReg; sqlite3 *db = pParse->db; const char *pVtab = (const char*)pTab->pVtab; SelectDest dest; pEList = sqlite3ExprListAppend(pParse, 0, sqlite3CreateIdExpr(pParse, "_rowid_"), 0); if( pRowid ){ pEList = sqlite3ExprListAppend(pParse, pEList, sqlite3ExprDup(db, pRowid), 0); } assert( pTab->iPKey<0 ); for(i=0; i<pTab->nCol; i++){ if( aXRef[i]>=0 ){ pExpr = sqlite3ExprDup(db, pChanges->a[aXRef[i]].pExpr); }else{ pExpr = sqlite3CreateIdExpr(pParse, pTab->aCol[i].zName); } pEList = sqlite3ExprListAppend(pParse, pEList, pExpr, 0); } pSelect = sqlite3SelectNew(pParse, pEList, pSrc, pWhere, 0, 0, 0, 0, 0, 0); assert( v ); ephemTab = pParse->nTab++; sqlite3VdbeAddOp2(v, OP_OpenEphemeral, ephemTab, pTab->nCol+1+(pRowid!=0)); sqlite3SelectDestInit(&dest, SRT_Table, ephemTab); sqlite3Select(pParse, pSelect, &dest); iReg = ++pParse->nMem; pParse->nMem += pTab->nCol+1; sqlite3VdbeAddOp2(v, OP_Rewind, ephemTab, 0); addr = sqlite3VdbeCurrentAddr(v); sqlite3VdbeAddOp3(v, OP_Column, ephemTab, 0, iReg); sqlite3VdbeAddOp3(v, OP_Column, ephemTab, (pRowid?1:0), iReg+1); for(i=0; i<pTab->nCol; i++){ sqlite3VdbeAddOp3(v, OP_Column, ephemTab, i+1+(pRowid!=0), iReg+2+i); } sqlite3VtabMakeWritable(pParse, pTab); sqlite3VdbeAddOp4(v, OP_VUpdate, 0, pTab->nCol+2, iReg, pVtab, P4_VTAB); sqlite3VdbeAddOp2(v, OP_Next, ephemTab, addr); sqlite3VdbeJumpHere(v, addr-1); sqlite3VdbeAddOp2(v, OP_Close, ephemTab, 0); sqlite3SelectDelete(db, pSelect); } 
#endif 
#undef isView 
#if !defined(SQLITE_OMIT_VACUUM) && !defined(SQLITE_OMIT_ATTACH) 
static int execSql(sqlite3 *db, const char *zSql){ sqlite3_stmt *pStmt; if( !zSql ){ return SQLITE_NOMEM; } if( SQLITE_OK!=sqlite3_prepare(db, zSql, -1, &pStmt, 0) ){ return sqlite3_errcode(db); } while( SQLITE_ROW==sqlite3_step(pStmt) ){} return sqlite3_finalize(pStmt); } static int execExecSql(sqlite3 *db, const char *zSql){ sqlite3_stmt *pStmt; int rc; rc = sqlite3_prepare(db, zSql, -1, &pStmt, 0); if( rc!=SQLITE_OK ) return rc; while( SQLITE_ROW==sqlite3_step(pStmt) ){ rc = execSql(db, (char*)sqlite3_column_text(pStmt, 0)); if( rc!=SQLITE_OK ){ sqlite3_finalize(pStmt); return rc; } } return sqlite3_finalize(pStmt); } SQLITE_PRIVATE void sqlite3Vacuum(Parse *pParse){ Vdbe *v = sqlite3GetVdbe(pParse); if( v ){ sqlite3VdbeAddOp2(v, OP_Vacuum, 0, 0); } return; } SQLITE_PRIVATE int sqlite3RunVacuum(char **pzErrMsg, sqlite3 *db){ int rc = SQLITE_OK; Btree *pMain; Pager *pMainPager; Btree *pTemp; char *zSql = 0; int saved_flags; int saved_nChange; int saved_nTotalChange; Db *pDb = 0; int isMemDb; int nRes; saved_flags = db->flags; saved_nChange = db->nChange; saved_nTotalChange = db->nTotalChange; db->flags |= SQLITE_WriteSchema | SQLITE_IgnoreChecks; if( !db->autoCommit ){ sqlite3SetString(pzErrMsg, db, "cannot VACUUM from within a transaction"); rc = SQLITE_ERROR; goto end_of_vacuum; } pMain = db->aDb[0].pBt; pMainPager = sqlite3BtreePager(pMain); isMemDb = sqlite3PagerFile(pMainPager)->pMethods==0; zSql = "ATTACH '' AS vacuum_db;"; rc = execSql(db, zSql); if( rc!=SQLITE_OK ) goto end_of_vacuum; pDb = &db->aDb[db->nDb-1]; assert( strcmp(db->aDb[db->nDb-1].zName,"vacuum_db")==0 ); pTemp = db->aDb[db->nDb-1].pBt; nRes = sqlite3BtreeGetReserve(pMain); 
#ifdef SQLITE_HAS_CODEC 
 if( db->nextPagesize ){ extern void sqlite3CodecGetKey(sqlite3*, int, void**, int*); int nKey; char *zKey; sqlite3CodecGetKey(db, 0, (void**)&zKey, &nKey); if( nKey ) db->nextPagesize = 0; } 
#endif 
 if( sqlite3BtreeSetPageSize(pTemp, sqlite3BtreeGetPageSize(pMain), nRes) || (!isMemDb && sqlite3BtreeSetPageSize(pTemp, db->nextPagesize, nRes)) || db->mallocFailed ){ rc = SQLITE_NOMEM; goto end_of_vacuum; } rc = execSql(db, "PRAGMA vacuum_db.synchronous=OFF"); if( rc!=SQLITE_OK ){ goto end_of_vacuum; } 
#ifndef SQLITE_OMIT_AUTOVACUUM 
 sqlite3BtreeSetAutoVacuum(pTemp, db->nextAutovac>=0 ? db->nextAutovac : sqlite3BtreeGetAutoVacuum(pMain)); 
#endif 
 rc = execSql(db, "BEGIN EXCLUSIVE;"); if( rc!=SQLITE_OK ) goto end_of_vacuum; rc = execExecSql(db, "SELECT 'CREATE TABLE vacuum_db.' || substr(sql,14) " " FROM sqlite_master WHERE type='table' AND name!='sqlite_sequence'" " AND rootpage>0" ); if( rc!=SQLITE_OK ) goto end_of_vacuum; rc = execExecSql(db, "SELECT 'CREATE INDEX vacuum_db.' || substr(sql,14)" " FROM sqlite_master WHERE sql LIKE 'CREATE INDEX %' "); if( rc!=SQLITE_OK ) goto end_of_vacuum; rc = execExecSql(db, "SELECT 'CREATE UNIQUE INDEX vacuum_db.' || substr(sql,21) " " FROM sqlite_master WHERE sql LIKE 'CREATE UNIQUE INDEX %'"); if( rc!=SQLITE_OK ) goto end_of_vacuum; rc = execExecSql(db, "SELECT 'INSERT INTO vacuum_db.' || quote(name) " "|| ' SELECT * FROM ' || quote(name) || ';'" "FROM sqlite_master " "WHERE type = 'table' AND name!='sqlite_sequence' " " AND rootpage>0" ); if( rc!=SQLITE_OK ) goto end_of_vacuum; rc = execExecSql(db, "SELECT 'DELETE FROM vacuum_db.' || quote(name) || ';' " "FROM vacuum_db.sqlite_master WHERE name='sqlite_sequence' " ); if( rc!=SQLITE_OK ) goto end_of_vacuum; rc = execExecSql(db, "SELECT 'INSERT INTO vacuum_db.' || quote(name) " "|| ' SELECT * FROM ' || quote(name) || ';' " "FROM vacuum_db.sqlite_master WHERE name=='sqlite_sequence';" ); if( rc!=SQLITE_OK ) goto end_of_vacuum; rc = execSql(db, "INSERT INTO vacuum_db.sqlite_master " " SELECT type, name, tbl_name, rootpage, sql" " FROM sqlite_master" " WHERE type='view' OR type='trigger'" " OR (type='table' AND rootpage=0)" ); if( rc ) goto end_of_vacuum; if( rc==SQLITE_OK ){ u32 meta; int i; static const unsigned char aCopy[] = { 1, 1, 3, 0, 5, 0, 6, 0, }; assert( 1==sqlite3BtreeIsInTrans(pTemp) ); assert( 1==sqlite3BtreeIsInTrans(pMain) ); for(i=0; i<ArraySize(aCopy); i+=2){ rc = sqlite3BtreeGetMeta(pMain, aCopy[i], &meta); if( rc!=SQLITE_OK ) goto end_of_vacuum; rc = sqlite3BtreeUpdateMeta(pTemp, aCopy[i], meta+aCopy[i+1]); if( rc!=SQLITE_OK ) goto end_of_vacuum; } rc = sqlite3BtreeCopyFile(pMain, pTemp); if( rc!=SQLITE_OK ) goto end_of_vacuum; rc = sqlite3BtreeCommit(pTemp); if( rc!=SQLITE_OK ) goto end_of_vacuum; 
#ifndef SQLITE_OMIT_AUTOVACUUM 
 sqlite3BtreeSetAutoVacuum(pMain, sqlite3BtreeGetAutoVacuum(pTemp)); 
#endif 
 rc = sqlite3BtreeCommit(pMain); } if( rc==SQLITE_OK ){ rc = sqlite3BtreeSetPageSize(pMain, sqlite3BtreeGetPageSize(pTemp), nRes); } end_of_vacuum: db->flags = saved_flags; db->nChange = saved_nChange; db->nTotalChange = saved_nTotalChange; db->autoCommit = 1; if( pDb ){ sqlite3BtreeClose(pDb->pBt); pDb->pBt = 0; pDb->pSchema = 0; } sqlite3ResetInternalSchema(db, 0); return rc; } 
#endif 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
static int createModule( sqlite3 *db, const char *zName, const sqlite3_module *pModule, void *pAux, void (*xDestroy)(void *) ) { int rc, nName; Module *pMod; sqlite3_mutex_enter(db->mutex); nName = strlen(zName); pMod = (Module *)sqlite3DbMallocRaw(db, sizeof(Module) + nName + 1); if( pMod ){ Module *pDel; char *zCopy = (char *)(&pMod[1]); memcpy(zCopy, zName, nName+1); pMod->zName = zCopy; pMod->pModule = pModule; pMod->pAux = pAux; pMod->xDestroy = xDestroy; pDel = (Module *)sqlite3HashInsert(&db->aModule, zCopy, nName, (void*)pMod); if( pDel && pDel->xDestroy ){ pDel->xDestroy(pDel->pAux); } sqlite3DbFree(db, pDel); if( pDel==pMod ){ db->mallocFailed = 1; } sqlite3ResetInternalSchema(db, 0); }else if( xDestroy ){ xDestroy(pAux); } rc = sqlite3ApiExit(db, SQLITE_OK); sqlite3_mutex_leave(db->mutex); return rc; } SQLITE_API int sqlite3_create_module( sqlite3 *db, const char *zName, const sqlite3_module *pModule, void *pAux ){ return createModule(db, zName, pModule, pAux, 0); } SQLITE_API int sqlite3_create_module_v2( sqlite3 *db, const char *zName, const sqlite3_module *pModule, void *pAux, void (*xDestroy)(void *) ){ return createModule(db, zName, pModule, pAux, xDestroy); } SQLITE_PRIVATE void sqlite3VtabLock(sqlite3_vtab *pVtab){ pVtab->nRef++; } SQLITE_PRIVATE void sqlite3VtabUnlock(sqlite3 *db, sqlite3_vtab *pVtab){ pVtab->nRef--; assert(db); assert( sqlite3SafetyCheckOk(db) ); if( pVtab->nRef==0 ){ if( db->magic==SQLITE_MAGIC_BUSY ){ (void)sqlite3SafetyOff(db); pVtab->pModule->xDisconnect(pVtab); (void)sqlite3SafetyOn(db); } else { pVtab->pModule->xDisconnect(pVtab); } } } SQLITE_PRIVATE void sqlite3VtabClear(Table *p){ sqlite3_vtab *pVtab = p->pVtab; sqlite3 *db = p->db; if( pVtab ){ assert( p->pMod && p->pMod->pModule ); sqlite3VtabUnlock(db, pVtab); p->pVtab = 0; } if( p->azModuleArg ){ int i; for(i=0; i<p->nModuleArg; i++){ sqlite3DbFree(db, p->azModuleArg[i]); } sqlite3DbFree(db, p->azModuleArg); } } static void addModuleArgument(sqlite3 *db, Table *pTable, char *zArg){ int i = pTable->nModuleArg++; int nBytes = sizeof(char *)*(1+pTable->nModuleArg); char **azModuleArg; azModuleArg = sqlite3DbRealloc(db, pTable->azModuleArg, nBytes); if( azModuleArg==0 ){ int j; for(j=0; j<i; j++){ sqlite3DbFree(db, pTable->azModuleArg[j]); } sqlite3DbFree(db, zArg); sqlite3DbFree(db, pTable->azModuleArg); pTable->nModuleArg = 0; }else{ azModuleArg[i] = zArg; azModuleArg[i+1] = 0; } pTable->azModuleArg = azModuleArg; } SQLITE_PRIVATE void sqlite3VtabBeginParse( Parse *pParse, Token *pName1, Token *pName2, Token *pModuleName ){ int iDb; Table *pTable; sqlite3 *db; if( pParse->db->flags & SQLITE_SharedCache ){ sqlite3ErrorMsg(pParse, "Cannot use virtual tables in shared-cache mode"); return; } sqlite3StartTable(pParse, pName1, pName2, 0, 0, 1, 0); pTable = pParse->pNewTable; if( pTable==0 || pParse->nErr ) return; assert( 0==pTable->pIndex ); db = pParse->db; iDb = sqlite3SchemaToIndex(db, pTable->pSchema); assert( iDb>=0 ); pTable->tabFlags |= TF_Virtual; pTable->nModuleArg = 0; addModuleArgument(db, pTable, sqlite3NameFromToken(db, pModuleName)); addModuleArgument(db, pTable, sqlite3DbStrDup(db, db->aDb[iDb].zName)); addModuleArgument(db, pTable, sqlite3DbStrDup(db, pTable->zName)); pParse->sNameToken.n = pModuleName->z + pModuleName->n - pName1->z; 
#ifndef SQLITE_OMIT_AUTHORIZATION 
 if( pTable->azModuleArg ){ sqlite3AuthCheck(pParse, SQLITE_CREATE_VTABLE, pTable->zName, pTable->azModuleArg[0], pParse->db->aDb[iDb].zName); } 
#endif 
} static void addArgumentToVtab(Parse *pParse){ if( pParse->sArg.z && pParse->pNewTable ){ const char *z = (const char*)pParse->sArg.z; int n = pParse->sArg.n; sqlite3 *db = pParse->db; addModuleArgument(db, pParse->pNewTable, sqlite3DbStrNDup(db, z, n)); } } SQLITE_PRIVATE void sqlite3VtabFinishParse(Parse *pParse, Token *pEnd){ Table *pTab; sqlite3 *db; char *zModule; Module *pMod = 0; addArgumentToVtab(pParse); pParse->sArg.z = 0; pTab = pParse->pNewTable; if( pTab==0 ) return; db = pParse->db; if( pTab->nModuleArg<1 ) return; zModule = pTab->azModuleArg[0]; pMod = (Module *)sqlite3HashFind(&db->aModule, zModule, strlen(zModule)); pTab->pMod = pMod; if( !db->init.busy ){ char *zStmt; char *zWhere; int iDb; Vdbe *v; if( pEnd ){ pParse->sNameToken.n = pEnd->z - pParse->sNameToken.z + pEnd->n; } zStmt = sqlite3MPrintf(db, "CREATE VIRTUAL TABLE %T", &pParse->sNameToken); iDb = sqlite3SchemaToIndex(db, pTab->pSchema); sqlite3NestedParse(pParse, "UPDATE %Q.%s " "SET type='table', name=%Q, tbl_name=%Q, rootpage=0, sql=%Q " "WHERE rowid=#%d", db->aDb[iDb].zName, SCHEMA_TABLE(iDb), pTab->zName, pTab->zName, zStmt, pParse->regRowid ); sqlite3DbFree(db, zStmt); v = sqlite3GetVdbe(pParse); sqlite3ChangeCookie(pParse, iDb); sqlite3VdbeAddOp2(v, OP_Expire, 0, 0); zWhere = sqlite3MPrintf(db, "name='%q'", pTab->zName); sqlite3VdbeAddOp4(v, OP_ParseSchema, iDb, 1, 0, zWhere, P4_DYNAMIC); sqlite3VdbeAddOp4(v, OP_VCreate, iDb, 0, 0, pTab->zName, strlen(pTab->zName) + 1); } else { Table *pOld; Schema *pSchema = pTab->pSchema; const char *zName = pTab->zName; int nName = strlen(zName) + 1; pOld = sqlite3HashInsert(&pSchema->tblHash, zName, nName, pTab); if( pOld ){ db->mallocFailed = 1; assert( pTab==pOld ); return; } pSchema->db = pParse->db; pParse->pNewTable = 0; } } SQLITE_PRIVATE void sqlite3VtabArgInit(Parse *pParse){ addArgumentToVtab(pParse); pParse->sArg.z = 0; pParse->sArg.n = 0; } SQLITE_PRIVATE void sqlite3VtabArgExtend(Parse *pParse, Token *p){ Token *pArg = &pParse->sArg; if( pArg->z==0 ){ pArg->z = p->z; pArg->n = p->n; }else{ assert(pArg->z < p->z); pArg->n = (p->z + p->n - pArg->z); } } static int vtabCallConstructor( sqlite3 *db, Table *pTab, Module *pMod, int (*xConstruct)(sqlite3*,void*,int,const char*const*,sqlite3_vtab**,char**), char **pzErr ){ int rc; int rc2; sqlite3_vtab *pVtab = 0; const char *const*azArg = (const char *const*)pTab->azModuleArg; int nArg = pTab->nModuleArg; char *zErr = 0; char *zModuleName = sqlite3MPrintf(db, "%s", pTab->zName); if( !zModuleName ){ return SQLITE_NOMEM; } assert( !db->pVTab ); assert( xConstruct ); db->pVTab = pTab; rc = sqlite3SafetyOff(db); assert( rc==SQLITE_OK ); rc = xConstruct(db, pMod->pAux, nArg, azArg, &pVtab, &zErr); rc2 = sqlite3SafetyOn(db); if( rc==SQLITE_OK && pVtab ){ pVtab->pModule = pMod->pModule; pVtab->nRef = 1; pTab->pVtab = pVtab; } if( SQLITE_OK!=rc ){ if( zErr==0 ){ *pzErr = sqlite3MPrintf(db, "vtable constructor failed: %s", zModuleName); }else { *pzErr = sqlite3MPrintf(db, "%s", zErr); sqlite3DbFree(db, zErr); } }else if( db->pVTab ){ const char *zFormat = "vtable constructor did not declare schema: %s"; *pzErr = sqlite3MPrintf(db, zFormat, pTab->zName); rc = SQLITE_ERROR; } if( rc==SQLITE_OK ){ rc = rc2; } db->pVTab = 0; sqlite3DbFree(db, zModuleName); if( rc==SQLITE_OK ){ int iCol; for(iCol=0; iCol<pTab->nCol; iCol++){ char *zType = pTab->aCol[iCol].zType; int nType; int i = 0; if( !zType ) continue; nType = strlen(zType); if( sqlite3StrNICmp("hidden", zType, 6) || (zType[6] && zType[6]!=' ') ){ for(i=0; i<nType; i++){ if( (0==sqlite3StrNICmp(" hidden", &zType[i], 7)) && (zType[i+7]=='\0' || zType[i+7]==' ') ){ i++; break; } } } if( i<nType ){ int j; int nDel = 6 + (zType[i+6] ? 1 : 0); for(j=i; (j+nDel)<=nType; j++){ zType[j] = zType[j+nDel]; } if( zType[i]=='\0' && i>0 ){ assert(zType[i-1]==' '); zType[i-1] = '\0'; } pTab->aCol[iCol].isHidden = 1; } } } return rc; } SQLITE_PRIVATE int sqlite3VtabCallConnect(Parse *pParse, Table *pTab){ Module *pMod; int rc = SQLITE_OK; if( !pTab || (pTab->tabFlags & TF_Virtual)==0 || pTab->pVtab ){ return SQLITE_OK; } pMod = pTab->pMod; if( !pMod ){ const char *zModule = pTab->azModuleArg[0]; sqlite3ErrorMsg(pParse, "no such module: %s", zModule); rc = SQLITE_ERROR; } else { char *zErr = 0; sqlite3 *db = pParse->db; rc = vtabCallConstructor(db, pTab, pMod, pMod->pModule->xConnect, &zErr); if( rc!=SQLITE_OK ){ sqlite3ErrorMsg(pParse, "%s", zErr); } sqlite3DbFree(db, zErr); } return rc; } static int addToVTrans(sqlite3 *db, sqlite3_vtab *pVtab){ const int ARRAY_INCR = 5; if( (db->nVTrans%ARRAY_INCR)==0 ){ sqlite3_vtab **aVTrans; int nBytes = sizeof(sqlite3_vtab *) * (db->nVTrans + ARRAY_INCR); aVTrans = sqlite3DbRealloc(db, (void *)db->aVTrans, nBytes); if( !aVTrans ){ return SQLITE_NOMEM; } memset(&aVTrans[db->nVTrans], 0, sizeof(sqlite3_vtab *)*ARRAY_INCR); db->aVTrans = aVTrans; } db->aVTrans[db->nVTrans++] = pVtab; sqlite3VtabLock(pVtab); return SQLITE_OK; } SQLITE_PRIVATE int sqlite3VtabCallCreate(sqlite3 *db, int iDb, const char *zTab, char **pzErr){ int rc = SQLITE_OK; Table *pTab; Module *pMod; const char *zModule; pTab = sqlite3FindTable(db, zTab, db->aDb[iDb].zName); assert(pTab && (pTab->tabFlags & TF_Virtual)!=0 && !pTab->pVtab); pMod = pTab->pMod; zModule = pTab->azModuleArg[0]; if( !pMod ){ *pzErr = sqlite3MPrintf(db, "no such module: %s", zModule); rc = SQLITE_ERROR; }else{ rc = vtabCallConstructor(db, pTab, pMod, pMod->pModule->xCreate, pzErr); } if( rc==SQLITE_OK && pTab->pVtab ){ rc = addToVTrans(db, pTab->pVtab); } return rc; } SQLITE_API int sqlite3_declare_vtab(sqlite3 *db, const char *zCreateTable){ Parse sParse; int rc = SQLITE_OK; Table *pTab; char *zErr = 0; sqlite3_mutex_enter(db->mutex); pTab = db->pVTab; if( !pTab ){ sqlite3Error(db, SQLITE_MISUSE, 0); sqlite3_mutex_leave(db->mutex); return SQLITE_MISUSE; } assert((pTab->tabFlags & TF_Virtual)!=0 && pTab->nCol==0 && pTab->aCol==0); memset(&sParse, 0, sizeof(Parse)); sParse.declareVtab = 1; sParse.db = db; if( SQLITE_OK == sqlite3RunParser(&sParse, zCreateTable, &zErr) && sParse.pNewTable && !sParse.pNewTable->pSelect && (sParse.pNewTable->tabFlags & TF_Virtual)==0 ){ pTab->aCol = sParse.pNewTable->aCol; pTab->nCol = sParse.pNewTable->nCol; sParse.pNewTable->nCol = 0; sParse.pNewTable->aCol = 0; db->pVTab = 0; } else { sqlite3Error(db, SQLITE_ERROR, zErr); sqlite3DbFree(db, zErr); rc = SQLITE_ERROR; } sParse.declareVtab = 0; sqlite3_finalize((sqlite3_stmt*)sParse.pVdbe); sqlite3DeleteTable(sParse.pNewTable); sParse.pNewTable = 0; assert( (rc&0xff)==rc ); rc = sqlite3ApiExit(db, rc); sqlite3_mutex_leave(db->mutex); return rc; } SQLITE_PRIVATE int sqlite3VtabCallDestroy(sqlite3 *db, int iDb, const char *zTab) { int rc = SQLITE_OK; Table *pTab; pTab = sqlite3FindTable(db, zTab, db->aDb[iDb].zName); assert(pTab); if( pTab->pVtab ){ int (*xDestroy)(sqlite3_vtab *pVTab) = pTab->pMod->pModule->xDestroy; rc = sqlite3SafetyOff(db); assert( rc==SQLITE_OK ); if( xDestroy ){ rc = xDestroy(pTab->pVtab); } (void)sqlite3SafetyOn(db); if( rc==SQLITE_OK ){ int i; for(i=0; i<db->nVTrans; i++){ if( db->aVTrans[i]==pTab->pVtab ){ db->aVTrans[i] = db->aVTrans[--db->nVTrans]; break; } } pTab->pVtab = 0; } } return rc; } static void callFinaliser(sqlite3 *db, int offset){ int i; if( db->aVTrans ){ for(i=0; i<db->nVTrans && db->aVTrans[i]; i++){ sqlite3_vtab *pVtab = db->aVTrans[i]; int (*x)(sqlite3_vtab *); x = *(int (**)(sqlite3_vtab *))((char *)pVtab->pModule + offset); if( x ) x(pVtab); sqlite3VtabUnlock(db, pVtab); } sqlite3DbFree(db, db->aVTrans); db->nVTrans = 0; db->aVTrans = 0; } } SQLITE_PRIVATE int sqlite3VtabSync(sqlite3 *db, char **pzErrmsg){ int i; int rc = SQLITE_OK; int rcsafety; sqlite3_vtab **aVTrans = db->aVTrans; rc = sqlite3SafetyOff(db); db->aVTrans = 0; for(i=0; rc==SQLITE_OK && i<db->nVTrans && aVTrans[i]; i++){ sqlite3_vtab *pVtab = aVTrans[i]; int (*x)(sqlite3_vtab *); x = pVtab->pModule->xSync; if( x ){ rc = x(pVtab); sqlite3DbFree(db, *pzErrmsg); *pzErrmsg = pVtab->zErrMsg; pVtab->zErrMsg = 0; } } db->aVTrans = aVTrans; rcsafety = sqlite3SafetyOn(db); if( rc==SQLITE_OK ){ rc = rcsafety; } return rc; } SQLITE_PRIVATE int sqlite3VtabRollback(sqlite3 *db){ callFinaliser(db, offsetof(sqlite3_module,xRollback)); return SQLITE_OK; } SQLITE_PRIVATE int sqlite3VtabCommit(sqlite3 *db){ callFinaliser(db, offsetof(sqlite3_module,xCommit)); return SQLITE_OK; } SQLITE_PRIVATE int sqlite3VtabBegin(sqlite3 *db, sqlite3_vtab *pVtab){ int rc = SQLITE_OK; const sqlite3_module *pModule; if( sqlite3VtabInSync(db) ){ return SQLITE_LOCKED; } if( !pVtab ){ return SQLITE_OK; } pModule = pVtab->pModule; if( pModule->xBegin ){ int i; for(i=0; (i<db->nVTrans) && 0!=db->aVTrans[i]; i++){ if( db->aVTrans[i]==pVtab ){ return SQLITE_OK; } } rc = pModule->xBegin(pVtab); if( rc==SQLITE_OK ){ rc = addToVTrans(db, pVtab); } } return rc; } SQLITE_PRIVATE FuncDef *sqlite3VtabOverloadFunction( sqlite3 *db, FuncDef *pDef, int nArg, Expr *pExpr ){ Table *pTab; sqlite3_vtab *pVtab; sqlite3_module *pMod; void (*xFunc)(sqlite3_context*,int,sqlite3_value**); void *pArg; FuncDef *pNew; int rc = 0; char *zLowerName; unsigned char *z; if( pExpr==0 ) return pDef; if( pExpr->op!=TK_COLUMN ) return pDef; pTab = pExpr->pTab; if( pTab==0 ) return pDef; if( (pTab->tabFlags & TF_Virtual)==0 ) return pDef; pVtab = pTab->pVtab; assert( pVtab!=0 ); assert( pVtab->pModule!=0 ); pMod = (sqlite3_module *)pVtab->pModule; if( pMod->xFindFunction==0 ) return pDef; zLowerName = sqlite3DbStrDup(db, pDef->zName); if( zLowerName ){ for(z=(unsigned char*)zLowerName; *z; z++){ *z = sqlite3UpperToLower[*z]; } rc = pMod->xFindFunction(pVtab, nArg, zLowerName, &xFunc, &pArg); sqlite3DbFree(db, zLowerName); if( pVtab->zErrMsg ){ sqlite3Error(db, rc, "%s", pVtab->zErrMsg); sqlite3DbFree(db, pVtab->zErrMsg); pVtab->zErrMsg = 0; } } if( rc==0 ){ return pDef; } pNew = sqlite3DbMallocZero(db, sizeof(*pNew) + strlen(pDef->zName) ); if( pNew==0 ){ return pDef; } *pNew = *pDef; pNew->zName = (char *)&pNew[1]; memcpy(pNew->zName, pDef->zName, strlen(pDef->zName)+1); pNew->xFunc = xFunc; pNew->pUserData = pArg; pNew->flags |= SQLITE_FUNC_EPHEM; return pNew; } SQLITE_PRIVATE void sqlite3VtabMakeWritable(Parse *pParse, Table *pTab){ int i, n; assert( IsVirtual(pTab) ); for(i=0; i<pParse->nVtabLock; i++){ if( pTab==pParse->apVtabLock[i] ) return; } n = (pParse->nVtabLock+1)*sizeof(pParse->apVtabLock[0]); pParse->apVtabLock = sqlite3_realloc(pParse->apVtabLock, n); if( pParse->apVtabLock ){ pParse->apVtabLock[pParse->nVtabLock++] = pTab; }else{ pParse->db->mallocFailed = 1; } } 
#endif 
#if defined(SQLITE_TEST) || defined(SQLITE_DEBUG) 
SQLITE_PRIVATE int sqlite3WhereTrace = 0; 
#endif 
#if 0 
#define WHERETRACE(X) if(sqlite3WhereTrace) sqlite3DebugPrintf X 
#else 
#define WHERETRACE(X) 
#endif 
typedef struct WhereClause WhereClause; typedef struct ExprMaskSet ExprMaskSet; typedef struct WhereTerm WhereTerm; struct WhereTerm { Expr *pExpr; i16 iParent; i16 leftCursor; i16 leftColumn; u16 eOperator; u8 flags; u8 nChild; WhereClause *pWC; Bitmask prereqRight; Bitmask prereqAll; }; 
#define TERM_DYNAMIC 0x01 
#define TERM_VIRTUAL 0x02 
#define TERM_CODED 0x04 
#define TERM_COPIED 0x08 
#define TERM_OR_OK 0x10 
struct WhereClause { Parse *pParse; ExprMaskSet *pMaskSet; int nTerm; int nSlot; WhereTerm *a; WhereTerm aStatic[10]; }; struct ExprMaskSet { int n; int ix[BMS]; }; 
#define WO_IN 1 
#define WO_EQ 2 
#define WO_LT (WO_EQ<<(TK_LT-TK_EQ)) 
#define WO_LE (WO_EQ<<(TK_LE-TK_EQ)) 
#define WO_GT (WO_EQ<<(TK_GT-TK_EQ)) 
#define WO_GE (WO_EQ<<(TK_GE-TK_EQ)) 
#define WO_MATCH 64 
#define WO_ISNULL 128 
#define WHERE_ROWID_EQ 0x000100 
#define WHERE_ROWID_RANGE 0x000200 
#define WHERE_COLUMN_EQ 0x001000 
#define WHERE_COLUMN_RANGE 0x002000 
#define WHERE_COLUMN_IN 0x004000 
#define WHERE_TOP_LIMIT 0x010000 
#define WHERE_BTM_LIMIT 0x020000 
#define WHERE_IDX_ONLY 0x080000 
#define WHERE_ORDERBY 0x100000 
#define WHERE_REVERSE 0x200000 
#define WHERE_UNIQUE 0x400000 
#define WHERE_VIRTUALTABLE 0x800000 
static void whereClauseInit( WhereClause *pWC, Parse *pParse, ExprMaskSet *pMaskSet ){ pWC->pParse = pParse; pWC->pMaskSet = pMaskSet; pWC->nTerm = 0; pWC->nSlot = ArraySize(pWC->aStatic); pWC->a = pWC->aStatic; } static void whereClauseClear(WhereClause *pWC){ int i; WhereTerm *a; sqlite3 *db = pWC->pParse->db; for(i=pWC->nTerm-1, a=pWC->a; i>=0; i--, a++){ if( a->flags & TERM_DYNAMIC ){ sqlite3ExprDelete(db, a->pExpr); } } if( pWC->a!=pWC->aStatic ){ sqlite3DbFree(db, pWC->a); } } static int whereClauseInsert(WhereClause *pWC, Expr *p, int flags){ WhereTerm *pTerm; int idx; if( pWC->nTerm>=pWC->nSlot ){ WhereTerm *pOld = pWC->a; sqlite3 *db = pWC->pParse->db; pWC->a = sqlite3DbMallocRaw(db, sizeof(pWC->a[0])*pWC->nSlot*2 ); if( pWC->a==0 ){ if( flags & TERM_DYNAMIC ){ sqlite3ExprDelete(db, p); } pWC->a = pOld; return 0; } memcpy(pWC->a, pOld, sizeof(pWC->a[0])*pWC->nTerm); if( pOld!=pWC->aStatic ){ sqlite3DbFree(db, pOld); } pWC->nSlot *= 2; } pTerm = &pWC->a[idx = pWC->nTerm]; pWC->nTerm++; pTerm->pExpr = p; pTerm->flags = flags; pTerm->pWC = pWC; pTerm->iParent = -1; return idx; } static void whereSplit(WhereClause *pWC, Expr *pExpr, int op){ if( pExpr==0 ) return; if( pExpr->op!=op ){ whereClauseInsert(pWC, pExpr, 0); }else{ whereSplit(pWC, pExpr->pLeft, op); whereSplit(pWC, pExpr->pRight, op); } } 
#define initMaskSet(P) memset(P, 0, sizeof(*P)) 
static Bitmask getMask(ExprMaskSet *pMaskSet, int iCursor){ int i; for(i=0; i<pMaskSet->n; i++){ if( pMaskSet->ix[i]==iCursor ){ return ((Bitmask)1)<<i; } } return 0; } static void createMask(ExprMaskSet *pMaskSet, int iCursor){ assert( pMaskSet->n < ArraySize(pMaskSet->ix) ); pMaskSet->ix[pMaskSet->n++] = iCursor; } static Bitmask exprListTableUsage(ExprMaskSet*, ExprList*); static Bitmask exprSelectTableUsage(ExprMaskSet*, Select*); static Bitmask exprTableUsage(ExprMaskSet *pMaskSet, Expr *p){ Bitmask mask = 0; if( p==0 ) return 0; if( p->op==TK_COLUMN ){ mask = getMask(pMaskSet, p->iTable); return mask; } mask = exprTableUsage(pMaskSet, p->pRight); mask |= exprTableUsage(pMaskSet, p->pLeft); mask |= exprListTableUsage(pMaskSet, p->pList); mask |= exprSelectTableUsage(pMaskSet, p->pSelect); return mask; } static Bitmask exprListTableUsage(ExprMaskSet *pMaskSet, ExprList *pList){ int i; Bitmask mask = 0; if( pList ){ for(i=0; i<pList->nExpr; i++){ mask |= exprTableUsage(pMaskSet, pList->a[i].pExpr); } } return mask; } static Bitmask exprSelectTableUsage(ExprMaskSet *pMaskSet, Select *pS){ Bitmask mask = 0; while( pS ){ mask |= exprListTableUsage(pMaskSet, pS->pEList); mask |= exprListTableUsage(pMaskSet, pS->pGroupBy); mask |= exprListTableUsage(pMaskSet, pS->pOrderBy); mask |= exprTableUsage(pMaskSet, pS->pWhere); mask |= exprTableUsage(pMaskSet, pS->pHaving); pS = pS->pPrior; } return mask; } static int allowedOp(int op){ assert( TK_GT>TK_EQ && TK_GT<TK_GE ); assert( TK_LT>TK_EQ && TK_LT<TK_GE ); assert( TK_LE>TK_EQ && TK_LE<TK_GE ); assert( TK_GE==TK_EQ+4 ); return op==TK_IN || (op>=TK_EQ && op<=TK_GE) || op==TK_ISNULL; } 
#define SWAP(TYPE,A,B) {TYPE t=A; A=B; B=t;} 
static void exprCommute(Parse *pParse, Expr *pExpr){ u16 expRight = (pExpr->pRight->flags & EP_ExpCollate); u16 expLeft = (pExpr->pLeft->flags & EP_ExpCollate); assert( allowedOp(pExpr->op) && pExpr->op!=TK_IN ); pExpr->pRight->pColl = sqlite3ExprCollSeq(pParse, pExpr->pRight); pExpr->pLeft->pColl = sqlite3ExprCollSeq(pParse, pExpr->pLeft); SWAP(CollSeq*,pExpr->pRight->pColl,pExpr->pLeft->pColl); pExpr->pRight->flags = (pExpr->pRight->flags & ~EP_ExpCollate) | expLeft; pExpr->pLeft->flags = (pExpr->pLeft->flags & ~EP_ExpCollate) | expRight; SWAP(Expr*,pExpr->pRight,pExpr->pLeft); if( pExpr->op>=TK_GT ){ assert( TK_LT==TK_GT+2 ); assert( TK_GE==TK_LE+2 ); assert( TK_GT>TK_EQ ); assert( TK_GT<TK_LE ); assert( pExpr->op>=TK_GT && pExpr->op<=TK_GE ); pExpr->op = ((pExpr->op-TK_GT)^2)+TK_GT; } } static int operatorMask(int op){ int c; assert( allowedOp(op) ); if( op==TK_IN ){ c = WO_IN; }else if( op==TK_ISNULL ){ c = WO_ISNULL; }else{ c = WO_EQ<<(op-TK_EQ); } assert( op!=TK_ISNULL || c==WO_ISNULL ); assert( op!=TK_IN || c==WO_IN ); assert( op!=TK_EQ || c==WO_EQ ); assert( op!=TK_LT || c==WO_LT ); assert( op!=TK_LE || c==WO_LE ); assert( op!=TK_GT || c==WO_GT ); assert( op!=TK_GE || c==WO_GE ); return c; } static WhereTerm *findTerm( WhereClause *pWC, int iCur, int iColumn, Bitmask notReady, u16 op, Index *pIdx ){ WhereTerm *pTerm; int k; assert( iCur>=0 ); for(pTerm=pWC->a, k=pWC->nTerm; k; k--, pTerm++){ if( pTerm->leftCursor==iCur && (pTerm->prereqRight & notReady)==0 && pTerm->leftColumn==iColumn && (pTerm->eOperator & op)!=0 ){ if( pIdx && pTerm->eOperator!=WO_ISNULL ){ Expr *pX = pTerm->pExpr; CollSeq *pColl; char idxaff; int j; Parse *pParse = pWC->pParse; idxaff = pIdx->pTable->aCol[iColumn].affinity; if( !sqlite3IndexAffinityOk(pX, idxaff) ) continue; assert(pX->pLeft); pColl = sqlite3BinaryCompareCollSeq(pParse, pX->pLeft, pX->pRight); if( !pColl ){ pColl = pParse->db->pDfltColl; } for(j=0; pIdx->aiColumn[j]!=iColumn; j++){ if( NEVER(j>=pIdx->nColumn) ) return 0; } if( sqlite3StrICmp(pColl->zName, pIdx->azColl[j]) ) continue; } return pTerm; } } return 0; } static void exprAnalyze(SrcList*, WhereClause*, int); static void exprAnalyzeAll( SrcList *pTabList, WhereClause *pWC ){ int i; for(i=pWC->nTerm-1; i>=0; i--){ exprAnalyze(pTabList, pWC, i); } } 
#ifndef SQLITE_OMIT_LIKE_OPTIMIZATION 
static int isLikeOrGlob( Parse *pParse, Expr *pExpr, int *pnPattern, int *pisComplete, int *pnoCase ){ const char *z; Expr *pRight, *pLeft; ExprList *pList; int c, cnt; char wc[3]; CollSeq *pColl; sqlite3 *db = pParse->db; if( !sqlite3IsLikeFunction(db, pExpr, pnoCase, wc) ){ return 0; } 
#ifdef SQLITE_EBCDIC 
 if( *pnoCase ) return 0; 
#endif 
 pList = pExpr->pList; pRight = pList->a[0].pExpr; if( pRight->op!=TK_STRING && (pRight->op!=TK_REGISTER || pRight->iColumn!=TK_STRING) ){ return 0; } pLeft = pList->a[1].pExpr; if( pLeft->op!=TK_COLUMN ){ return 0; } pColl = sqlite3ExprCollSeq(pParse, pLeft); assert( pColl!=0 || pLeft->iColumn==-1 ); if( pColl==0 ){ pColl = db->pDfltColl; } if( (pColl->type!=SQLITE_COLL_BINARY || *pnoCase) && (pColl->type!=SQLITE_COLL_NOCASE || !*pnoCase) ){ return 0; } sqlite3DequoteExpr(db, pRight); z = (char *)pRight->token.z; cnt = 0; if( z ){ while( (c=z[cnt])!=0 && c!=wc[0] && c!=wc[1] && c!=wc[2] ){ cnt++; } } if( cnt==0 || 255==(u8)z[cnt] ){ return 0; } *pisComplete = z[cnt]==wc[0] && z[cnt+1]==0; *pnPattern = cnt; return 1; } 
#endif 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
static int isMatchOfColumn( Expr *pExpr ){ ExprList *pList; if( pExpr->op!=TK_FUNCTION ){ return 0; } if( pExpr->token.n!=5 || sqlite3StrNICmp((const char*)pExpr->token.z,"match",5)!=0 ){ return 0; } pList = pExpr->pList; if( pList->nExpr!=2 ){ return 0; } if( pList->a[1].pExpr->op != TK_COLUMN ){ return 0; } return 1; } 
#endif 
static void transferJoinMarkings(Expr *pDerived, Expr *pBase){ pDerived->flags |= pBase->flags & EP_FromJoin; pDerived->iRightJoinTable = pBase->iRightJoinTable; } 
#if !defined(SQLITE_OMIT_OR_OPTIMIZATION) && !defined(SQLITE_OMIT_SUBQUERY) 
static int orTermIsOptCandidate(WhereTerm *pOrTerm, int iCursor, int iColumn){ int affLeft, affRight; assert( pOrTerm->eOperator==WO_EQ ); if( pOrTerm->leftCursor!=iCursor ){ return 0; } if( pOrTerm->leftColumn!=iColumn ){ return 0; } affRight = sqlite3ExprAffinity(pOrTerm->pExpr->pRight); if( affRight==0 ){ return 1; } affLeft = sqlite3ExprAffinity(pOrTerm->pExpr->pLeft); if( affRight!=affLeft ){ return 0; } return 1; } static int orTermHasOkDuplicate(WhereClause *pOr, WhereTerm *pOrTerm){ if( pOrTerm->flags & TERM_COPIED ){ return 1; } if( (pOrTerm->flags & TERM_VIRTUAL)!=0 && (pOr->a[pOrTerm->iParent].flags & TERM_OR_OK)!=0 ){ return 1; } return 0; } 
#endif 
static void exprAnalyze( SrcList *pSrc, WhereClause *pWC, int idxTerm ){ WhereTerm *pTerm; ExprMaskSet *pMaskSet; Expr *pExpr; Bitmask prereqLeft; Bitmask prereqAll; Bitmask extraRight = 0; int nPattern; int isComplete; int noCase; int op; Parse *pParse = pWC->pParse; sqlite3 *db = pParse->db; if( db->mallocFailed ){ return; } pTerm = &pWC->a[idxTerm]; pMaskSet = pWC->pMaskSet; pExpr = pTerm->pExpr; prereqLeft = exprTableUsage(pMaskSet, pExpr->pLeft); op = pExpr->op; if( op==TK_IN ){ assert( pExpr->pRight==0 ); pTerm->prereqRight = exprListTableUsage(pMaskSet, pExpr->pList) | exprSelectTableUsage(pMaskSet, pExpr->pSelect); }else if( op==TK_ISNULL ){ pTerm->prereqRight = 0; }else{ pTerm->prereqRight = exprTableUsage(pMaskSet, pExpr->pRight); } prereqAll = exprTableUsage(pMaskSet, pExpr); if( ExprHasProperty(pExpr, EP_FromJoin) ){ Bitmask x = getMask(pMaskSet, pExpr->iRightJoinTable); prereqAll |= x; extraRight = x-1; } pTerm->prereqAll = prereqAll; pTerm->leftCursor = -1; pTerm->iParent = -1; pTerm->eOperator = 0; if( allowedOp(op) && (pTerm->prereqRight & prereqLeft)==0 ){ Expr *pLeft = pExpr->pLeft; Expr *pRight = pExpr->pRight; if( pLeft->op==TK_COLUMN ){ pTerm->leftCursor = pLeft->iTable; pTerm->leftColumn = pLeft->iColumn; pTerm->eOperator = operatorMask(op); } if( pRight && pRight->op==TK_COLUMN ){ WhereTerm *pNew; Expr *pDup; if( pTerm->leftCursor>=0 ){ int idxNew; pDup = sqlite3ExprDup(db, pExpr); if( db->mallocFailed ){ sqlite3ExprDelete(db, pDup); return; } idxNew = whereClauseInsert(pWC, pDup, TERM_VIRTUAL|TERM_DYNAMIC); if( idxNew==0 ) return; pNew = &pWC->a[idxNew]; pNew->iParent = idxTerm; pTerm = &pWC->a[idxTerm]; pTerm->nChild = 1; pTerm->flags |= TERM_COPIED; }else{ pDup = pExpr; pNew = pTerm; } exprCommute(pParse, pDup); pLeft = pDup->pLeft; pNew->leftCursor = pLeft->iTable; pNew->leftColumn = pLeft->iColumn; pNew->prereqRight = prereqLeft; pNew->prereqAll = prereqAll; pNew->eOperator = operatorMask(pDup->op); } } 
#ifndef SQLITE_OMIT_BETWEEN_OPTIMIZATION 
 else if( pExpr->op==TK_BETWEEN ){ ExprList *pList = pExpr->pList; int i; static const u8 ops[] = {TK_GE, TK_LE}; assert( pList!=0 ); assert( pList->nExpr==2 ); for(i=0; i<2; i++){ Expr *pNewExpr; int idxNew; pNewExpr = sqlite3Expr(db, ops[i], sqlite3ExprDup(db, pExpr->pLeft), sqlite3ExprDup(db, pList->a[i].pExpr), 0); idxNew = whereClauseInsert(pWC, pNewExpr, TERM_VIRTUAL|TERM_DYNAMIC); exprAnalyze(pSrc, pWC, idxNew); pTerm = &pWC->a[idxTerm]; pWC->a[idxNew].iParent = idxTerm; } pTerm->nChild = 2; } 
#endif 
#if !defined(SQLITE_OMIT_OR_OPTIMIZATION) && !defined(SQLITE_OMIT_SUBQUERY) 
 else if( pExpr->op==TK_OR ){ int ok; int i, j; int iColumn, iCursor; WhereClause sOr; WhereTerm *pOrTerm; assert( (pTerm->flags & TERM_DYNAMIC)==0 ); whereClauseInit(&sOr, pWC->pParse, pMaskSet); whereSplit(&sOr, pExpr, TK_OR); exprAnalyzeAll(pSrc, &sOr); assert( sOr.nTerm>=2 ); j = 0; if( db->mallocFailed ) goto or_not_possible; do{ assert( j<sOr.nTerm ); iColumn = sOr.a[j].leftColumn; iCursor = sOr.a[j].leftCursor; ok = iCursor>=0; for(i=sOr.nTerm-1, pOrTerm=sOr.a; i>=0 && ok; i--, pOrTerm++){ if( pOrTerm->eOperator!=WO_EQ ){ goto or_not_possible; } if( orTermIsOptCandidate(pOrTerm, iCursor, iColumn) ){ pOrTerm->flags |= TERM_OR_OK; }else if( orTermHasOkDuplicate(&sOr, pOrTerm) ){ pOrTerm->flags &= ~TERM_OR_OK; }else{ ok = 0; } } }while( !ok && (sOr.a[j++].flags & TERM_COPIED)!=0 && j<2 ); if( ok ){ ExprList *pList = 0; Expr *pNew, *pDup; Expr *pLeft = 0; for(i=sOr.nTerm-1, pOrTerm=sOr.a; i>=0; i--, pOrTerm++){ if( (pOrTerm->flags & TERM_OR_OK)==0 ) continue; pDup = sqlite3ExprDup(db, pOrTerm->pExpr->pRight); pList = sqlite3ExprListAppend(pWC->pParse, pList, pDup, 0); pLeft = pOrTerm->pExpr->pLeft; } assert( pLeft!=0 ); pDup = sqlite3ExprDup(db, pLeft); pNew = sqlite3Expr(db, TK_IN, pDup, 0, 0); if( pNew ){ int idxNew; transferJoinMarkings(pNew, pExpr); pNew->pList = pList; idxNew = whereClauseInsert(pWC, pNew, TERM_VIRTUAL|TERM_DYNAMIC); exprAnalyze(pSrc, pWC, idxNew); pTerm = &pWC->a[idxTerm]; pWC->a[idxNew].iParent = idxTerm; pTerm->nChild = 1; }else{ sqlite3ExprListDelete(db, pList); } } or_not_possible: whereClauseClear(&sOr); } 
#endif 
#ifndef SQLITE_OMIT_LIKE_OPTIMIZATION 
 if( isLikeOrGlob(pParse, pExpr, &nPattern, &isComplete, &noCase) ){ Expr *pLeft, *pRight; Expr *pStr1, *pStr2; Expr *pNewExpr1, *pNewExpr2; int idxNew1, idxNew2; pLeft = pExpr->pList->a[1].pExpr; pRight = pExpr->pList->a[0].pExpr; pStr1 = sqlite3PExpr(pParse, TK_STRING, 0, 0, 0); if( pStr1 ){ sqlite3TokenCopy(db, &pStr1->token, &pRight->token); pStr1->token.n = nPattern; pStr1->flags = EP_Dequoted; } pStr2 = sqlite3ExprDup(db, pStr1); if( !db->mallocFailed ){ u8 c, *pC; assert( pStr2->token.dyn ); pC = (u8*)&pStr2->token.z[nPattern-1]; c = *pC; if( noCase ){ if( c=='@' ) isComplete = 0; c = sqlite3UpperToLower[c]; } *pC = c + 1; } pNewExpr1 = sqlite3PExpr(pParse, TK_GE, sqlite3ExprDup(db,pLeft), pStr1, 0); idxNew1 = whereClauseInsert(pWC, pNewExpr1, TERM_VIRTUAL|TERM_DYNAMIC); exprAnalyze(pSrc, pWC, idxNew1); pNewExpr2 = sqlite3PExpr(pParse, TK_LT, sqlite3ExprDup(db,pLeft), pStr2, 0); idxNew2 = whereClauseInsert(pWC, pNewExpr2, TERM_VIRTUAL|TERM_DYNAMIC); exprAnalyze(pSrc, pWC, idxNew2); pTerm = &pWC->a[idxTerm]; if( isComplete ){ pWC->a[idxNew1].iParent = idxTerm; pWC->a[idxNew2].iParent = idxTerm; pTerm->nChild = 2; } } 
#endif 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 if( isMatchOfColumn(pExpr) ){ int idxNew; Expr *pRight, *pLeft; WhereTerm *pNewTerm; Bitmask prereqColumn, prereqExpr; pRight = pExpr->pList->a[0].pExpr; pLeft = pExpr->pList->a[1].pExpr; prereqExpr = exprTableUsage(pMaskSet, pRight); prereqColumn = exprTableUsage(pMaskSet, pLeft); if( (prereqExpr & prereqColumn)==0 ){ Expr *pNewExpr; pNewExpr = sqlite3Expr(db, TK_MATCH, 0, sqlite3ExprDup(db, pRight), 0); idxNew = whereClauseInsert(pWC, pNewExpr, TERM_VIRTUAL|TERM_DYNAMIC); pNewTerm = &pWC->a[idxNew]; pNewTerm->prereqRight = prereqExpr; pNewTerm->leftCursor = pLeft->iTable; pNewTerm->leftColumn = pLeft->iColumn; pNewTerm->eOperator = WO_MATCH; pNewTerm->iParent = idxTerm; pTerm = &pWC->a[idxTerm]; pTerm->nChild = 1; pTerm->flags |= TERM_COPIED; pNewTerm->prereqAll = pTerm->prereqAll; } } 
#endif 
 pTerm->prereqRight |= extraRight; } static int referencesOtherTables( ExprList *pList, ExprMaskSet *pMaskSet, int iFirst, int iBase ){ Bitmask allowed = ~getMask(pMaskSet, iBase); while( iFirst<pList->nExpr ){ if( (exprTableUsage(pMaskSet, pList->a[iFirst++].pExpr)&allowed)!=0 ){ return 1; } } return 0; } static int isSortingIndex( Parse *pParse, ExprMaskSet *pMaskSet, Index *pIdx, int base, ExprList *pOrderBy, int nEqCol, int *pbRev ){ int i, j; int sortOrder = 0; int nTerm; struct ExprList_item *pTerm; sqlite3 *db = pParse->db; assert( pOrderBy!=0 ); nTerm = pOrderBy->nExpr; assert( nTerm>0 ); for(i=j=0, pTerm=pOrderBy->a; j<nTerm && i<=pIdx->nColumn; i++){ Expr *pExpr; CollSeq *pColl; int termSortOrder; int iColumn; int iSortOrder; const char *zColl; pExpr = pTerm->pExpr; if( pExpr->op!=TK_COLUMN || pExpr->iTable!=base ){ break; } pColl = sqlite3ExprCollSeq(pParse, pExpr); if( !pColl ){ pColl = db->pDfltColl; } if( i<pIdx->nColumn ){ iColumn = pIdx->aiColumn[i]; if( iColumn==pIdx->pTable->iPKey ){ iColumn = -1; } iSortOrder = pIdx->aSortOrder[i]; zColl = pIdx->azColl[i]; }else{ iColumn = -1; iSortOrder = 0; zColl = pColl->zName; } if( pExpr->iColumn!=iColumn || sqlite3StrICmp(pColl->zName, zColl) ){ if( i<nEqCol ){ continue; }else if( i==pIdx->nColumn ){ break; }else{ return 0; } } assert( pIdx->aSortOrder!=0 ); assert( pTerm->sortOrder==0 || pTerm->sortOrder==1 ); assert( iSortOrder==0 || iSortOrder==1 ); termSortOrder = iSortOrder ^ pTerm->sortOrder; if( i>nEqCol ){ if( termSortOrder!=sortOrder ){ return 0; } }else{ sortOrder = termSortOrder; } j++; pTerm++; if( iColumn<0 && !referencesOtherTables(pOrderBy, pMaskSet, j, base) ){ j = nTerm; } } *pbRev = sortOrder!=0; if( j>=nTerm ){ return 1; } if( pIdx->onError!=OE_None && i==pIdx->nColumn && !referencesOtherTables(pOrderBy, pMaskSet, j, base) ){ return 1; } return 0; } static int sortableByRowid( int base, ExprList *pOrderBy, ExprMaskSet *pMaskSet, int *pbRev ){ Expr *p; assert( pOrderBy!=0 ); assert( pOrderBy->nExpr>0 ); p = pOrderBy->a[0].pExpr; if( p->op==TK_COLUMN && p->iTable==base && p->iColumn==-1 && !referencesOtherTables(pOrderBy, pMaskSet, 1, base) ){ *pbRev = pOrderBy->a[0].sortOrder; return 1; } return 0; } static double estLog(double N){ double logN = 1; double x = 10; while( N>x ){ logN += 1; x *= 10; } return logN; } 
#if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_DEBUG) 
static void TRACE_IDX_INPUTS(sqlite3_index_info *p){ int i; if( !sqlite3WhereTrace ) return; for(i=0; i<p->nConstraint; i++){ sqlite3DebugPrintf(" constraint[%d]: col=%d termid=%d op=%d usabled=%d\n", i, p->aConstraint[i].iColumn, p->aConstraint[i].iTermOffset, p->aConstraint[i].op, p->aConstraint[i].usable); } for(i=0; i<p->nOrderBy; i++){ sqlite3DebugPrintf(" orderby[%d]: col=%d desc=%d\n", i, p->aOrderBy[i].iColumn, p->aOrderBy[i].desc); } } static void TRACE_IDX_OUTPUTS(sqlite3_index_info *p){ int i; if( !sqlite3WhereTrace ) return; for(i=0; i<p->nConstraint; i++){ sqlite3DebugPrintf(" usage[%d]: argvIdx=%d omit=%d\n", i, p->aConstraintUsage[i].argvIndex, p->aConstraintUsage[i].omit); } sqlite3DebugPrintf(" idxNum=%d\n", p->idxNum); sqlite3DebugPrintf(" idxStr=%s\n", p->idxStr); sqlite3DebugPrintf(" orderByConsumed=%d\n", p->orderByConsumed); sqlite3DebugPrintf(" estimatedCost=%g\n", p->estimatedCost); } 
#else 
#define TRACE_IDX_INPUTS(A) 
#define TRACE_IDX_OUTPUTS(A) 
#endif 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
static double bestVirtualIndex( Parse *pParse, WhereClause *pWC, struct SrcList_item *pSrc, Bitmask notReady, ExprList *pOrderBy, int orderByUsable, sqlite3_index_info **ppIdxInfo ){ Table *pTab = pSrc->pTab; sqlite3_vtab *pVtab = pTab->pVtab; sqlite3_index_info *pIdxInfo; struct sqlite3_index_constraint *pIdxCons; struct sqlite3_index_orderby *pIdxOrderBy; struct sqlite3_index_constraint_usage *pUsage; WhereTerm *pTerm; int i, j; int nOrderBy; int rc; pIdxInfo = *ppIdxInfo; if( pIdxInfo==0 ){ WhereTerm *pTerm; int nTerm; WHERETRACE(("Recomputing index info for %s...\n", pTab->zName)); for(i=nTerm=0, pTerm=pWC->a; i<pWC->nTerm; i++, pTerm++){ if( pTerm->leftCursor != pSrc->iCursor ) continue; assert( (pTerm->eOperator&(pTerm->eOperator-1))==0 ); testcase( pTerm->eOperator==WO_IN ); testcase( pTerm->eOperator==WO_ISNULL ); if( pTerm->eOperator & (WO_IN|WO_ISNULL) ) continue; nTerm++; } nOrderBy = 0; if( pOrderBy ){ for(i=0; i<pOrderBy->nExpr; i++){ Expr *pExpr = pOrderBy->a[i].pExpr; if( pExpr->op!=TK_COLUMN || pExpr->iTable!=pSrc->iCursor ) break; } if( i==pOrderBy->nExpr ){ nOrderBy = pOrderBy->nExpr; } } pIdxInfo = sqlite3DbMallocZero(pParse->db, sizeof(*pIdxInfo) + (sizeof(*pIdxCons) + sizeof(*pUsage))*nTerm + sizeof(*pIdxOrderBy)*nOrderBy ); if( pIdxInfo==0 ){ sqlite3ErrorMsg(pParse, "out of memory"); return 0.0; } *ppIdxInfo = pIdxInfo; pIdxCons = (struct sqlite3_index_constraint*)&pIdxInfo[1]; pIdxOrderBy = (struct sqlite3_index_orderby*)&pIdxCons[nTerm]; pUsage = (struct sqlite3_index_constraint_usage*)&pIdxOrderBy[nOrderBy]; *(int*)&pIdxInfo->nConstraint = nTerm; *(int*)&pIdxInfo->nOrderBy = nOrderBy; *(struct sqlite3_index_constraint**)&pIdxInfo->aConstraint = pIdxCons; *(struct sqlite3_index_orderby**)&pIdxInfo->aOrderBy = pIdxOrderBy; *(struct sqlite3_index_constraint_usage**)&pIdxInfo->aConstraintUsage = pUsage; for(i=j=0, pTerm=pWC->a; i<pWC->nTerm; i++, pTerm++){ if( pTerm->leftCursor != pSrc->iCursor ) continue; assert( (pTerm->eOperator&(pTerm->eOperator-1))==0 ); testcase( pTerm->eOperator==WO_IN ); testcase( pTerm->eOperator==WO_ISNULL ); if( pTerm->eOperator & (WO_IN|WO_ISNULL) ) continue; pIdxCons[j].iColumn = pTerm->leftColumn; pIdxCons[j].iTermOffset = i; pIdxCons[j].op = pTerm->eOperator; assert( WO_EQ==SQLITE_INDEX_CONSTRAINT_EQ ); assert( WO_LT==SQLITE_INDEX_CONSTRAINT_LT ); assert( WO_LE==SQLITE_INDEX_CONSTRAINT_LE ); assert( WO_GT==SQLITE_INDEX_CONSTRAINT_GT ); assert( WO_GE==SQLITE_INDEX_CONSTRAINT_GE ); assert( WO_MATCH==SQLITE_INDEX_CONSTRAINT_MATCH ); assert( pTerm->eOperator & (WO_EQ|WO_LT|WO_LE|WO_GT|WO_GE|WO_MATCH) ); j++; } for(i=0; i<nOrderBy; i++){ Expr *pExpr = pOrderBy->a[i].pExpr; pIdxOrderBy[i].iColumn = pExpr->iColumn; pIdxOrderBy[i].desc = pOrderBy->a[i].sortOrder; } } assert( pTab->azModuleArg && pTab->azModuleArg[0] ); assert( pVtab ); 
#if 0 
 if( pTab->pVtab==0 ){ sqlite3ErrorMsg(pParse, "undefined module %s for table %s", pTab->azModuleArg[0], pTab->zName); return 0.0; } 
#endif 
 pIdxCons = *(struct sqlite3_index_constraint**)&pIdxInfo->aConstraint; pUsage = pIdxInfo->aConstraintUsage; for(i=0; i<pIdxInfo->nConstraint; i++, pIdxCons++){ j = pIdxCons->iTermOffset; pTerm = &pWC->a[j]; pIdxCons->usable = (pTerm->prereqRight & notReady)==0; } memset(pUsage, 0, sizeof(pUsage[0])*pIdxInfo->nConstraint); if( pIdxInfo->needToFreeIdxStr ){ sqlite3_free(pIdxInfo->idxStr); } pIdxInfo->idxStr = 0; pIdxInfo->idxNum = 0; pIdxInfo->needToFreeIdxStr = 0; pIdxInfo->orderByConsumed = 0; pIdxInfo->estimatedCost = SQLITE_BIG_DBL / 2.0; nOrderBy = pIdxInfo->nOrderBy; if( pIdxInfo->nOrderBy && !orderByUsable ){ *(int*)&pIdxInfo->nOrderBy = 0; } (void)sqlite3SafetyOff(pParse->db); WHERETRACE(("xBestIndex for %s\n", pTab->zName)); TRACE_IDX_INPUTS(pIdxInfo); rc = pVtab->pModule->xBestIndex(pVtab, pIdxInfo); TRACE_IDX_OUTPUTS(pIdxInfo); (void)sqlite3SafetyOn(pParse->db); if( rc!=SQLITE_OK ){ if( rc==SQLITE_NOMEM ){ pParse->db->mallocFailed = 1; }else if( !pVtab->zErrMsg ){ sqlite3ErrorMsg(pParse, "%s", sqlite3ErrStr(rc)); }else{ sqlite3ErrorMsg(pParse, "%s", pVtab->zErrMsg); } } sqlite3DbFree(pParse->db, pVtab->zErrMsg); pVtab->zErrMsg = 0; for(i=0; i<pIdxInfo->nConstraint; i++){ if( !pIdxInfo->aConstraint[i].usable && pUsage[i].argvIndex>0 ){ sqlite3ErrorMsg(pParse, "table %s: xBestIndex returned an invalid plan", pTab->zName); return 0.0; } } *(int*)&pIdxInfo->nOrderBy = nOrderBy; return pIdxInfo->estimatedCost; } 
#endif 
static double bestIndex( Parse *pParse, WhereClause *pWC, struct SrcList_item *pSrc, Bitmask notReady, ExprList *pOrderBy, Index **ppIndex, int *pFlags, int *pnEq ){ WhereTerm *pTerm; Index *bestIdx = 0; double lowestCost; int bestFlags = 0; int bestNEq = 0; int iCur = pSrc->iCursor; Index *pProbe; int rev; int flags; int nEq; int eqTermMask; double cost; WHERETRACE(("bestIndex: tbl=%s notReady=%llx\n", pSrc->pTab->zName, notReady)); lowestCost = SQLITE_BIG_DBL; pProbe = pSrc->pTab->pIndex; if( pSrc->notIndexed ){ pProbe = 0; } if( pProbe==0 && findTerm(pWC, iCur, -1, 0, WO_EQ|WO_IN|WO_LT|WO_LE|WO_GT|WO_GE,0)==0 && (pOrderBy==0 || !sortableByRowid(iCur, pOrderBy, pWC->pMaskSet, &rev)) ){ *pFlags = 0; *ppIndex = 0; *pnEq = 0; return 0.0; } if( !pSrc->pIndex ){ pTerm = findTerm(pWC, iCur, -1, notReady, WO_EQ|WO_IN, 0); if( pTerm ){ Expr *pExpr; *ppIndex = 0; bestFlags = WHERE_ROWID_EQ; if( pTerm->eOperator & WO_EQ ){ *pFlags = WHERE_ROWID_EQ | WHERE_UNIQUE; *pnEq = 1; WHERETRACE(("... best is rowid\n")); return 0.0; }else if( (pExpr = pTerm->pExpr)->pList!=0 ){ lowestCost = pExpr->pList->nExpr; lowestCost *= estLog(lowestCost); }else{ lowestCost = 200; } WHERETRACE(("... rowid IN cost: %.9g\n", lowestCost)); } cost = pProbe ? pProbe->aiRowEst[0] : 1000000; WHERETRACE(("... table scan base cost: %.9g\n", cost)); flags = WHERE_ROWID_RANGE; pTerm = findTerm(pWC, iCur, -1, notReady, WO_LT|WO_LE|WO_GT|WO_GE, 0); if( pTerm ){ if( findTerm(pWC, iCur, -1, notReady, WO_LT|WO_LE, 0) ){ flags |= WHERE_TOP_LIMIT; cost /= 3; } if( findTerm(pWC, iCur, -1, notReady, WO_GT|WO_GE, 0) ){ flags |= WHERE_BTM_LIMIT; cost /= 3; } WHERETRACE(("... rowid range reduces cost to %.9g\n", cost)); }else{ flags = 0; } if( pOrderBy ){ if( sortableByRowid(iCur, pOrderBy, pWC->pMaskSet, &rev) ){ flags |= WHERE_ORDERBY|WHERE_ROWID_RANGE; if( rev ){ flags |= WHERE_REVERSE; } }else{ cost += cost*estLog(cost); WHERETRACE(("... sorting increases cost to %.9g\n", cost)); } } if( cost<lowestCost ){ lowestCost = cost; bestFlags = flags; } } if( (pSrc->jointype & JT_LEFT)!=0 ){ eqTermMask = WO_EQ|WO_IN; }else{ eqTermMask = WO_EQ|WO_IN|WO_ISNULL; } if( pSrc->pIndex ){ pProbe = pSrc->pIndex; } for(; pProbe; pProbe=(pSrc->pIndex ? 0 : pProbe->pNext)){ int i; double inMultiplier = 1; WHERETRACE(("... index %s:\n", pProbe->zName)); flags = 0; for(i=0; i<pProbe->nColumn; i++){ int j = pProbe->aiColumn[i]; pTerm = findTerm(pWC, iCur, j, notReady, eqTermMask, pProbe); if( pTerm==0 ) break; flags |= WHERE_COLUMN_EQ; if( pTerm->eOperator & WO_IN ){ Expr *pExpr = pTerm->pExpr; flags |= WHERE_COLUMN_IN; if( pExpr->pSelect!=0 ){ inMultiplier *= 25; }else if( ALWAYS(pExpr->pList) ){ inMultiplier *= pExpr->pList->nExpr + 1; } } } cost = pProbe->aiRowEst[i] * inMultiplier * estLog(inMultiplier); nEq = i; if( pProbe->onError!=OE_None && (flags & WHERE_COLUMN_IN)==0 && nEq==pProbe->nColumn ){ flags |= WHERE_UNIQUE; } WHERETRACE(("...... nEq=%d inMult=%.9g cost=%.9g\n",nEq,inMultiplier,cost)); if( nEq<pProbe->nColumn ){ int j = pProbe->aiColumn[nEq]; pTerm = findTerm(pWC, iCur, j, notReady, WO_LT|WO_LE|WO_GT|WO_GE, pProbe); if( pTerm ){ flags |= WHERE_COLUMN_RANGE; if( findTerm(pWC, iCur, j, notReady, WO_LT|WO_LE, pProbe) ){ flags |= WHERE_TOP_LIMIT; cost /= 3; } if( findTerm(pWC, iCur, j, notReady, WO_GT|WO_GE, pProbe) ){ flags |= WHERE_BTM_LIMIT; cost /= 3; } WHERETRACE(("...... range reduces cost to %.9g\n", cost)); } } if( pOrderBy ){ if( (flags & WHERE_COLUMN_IN)==0 && isSortingIndex(pParse,pWC->pMaskSet,pProbe,iCur,pOrderBy,nEq,&rev) ){ if( flags==0 ){ flags = WHERE_COLUMN_RANGE; } flags |= WHERE_ORDERBY; if( rev ){ flags |= WHERE_REVERSE; } }else{ cost += cost*estLog(cost); WHERETRACE(("...... orderby increases cost to %.9g\n", cost)); } } if( flags && pSrc->colUsed < (((Bitmask)1)<<(BMS-1)) ){ Bitmask m = pSrc->colUsed; int j; for(j=0; j<pProbe->nColumn; j++){ int x = pProbe->aiColumn[j]; if( x<BMS-1 ){ m &= ~(((Bitmask)1)<<x); } } if( m==0 ){ flags |= WHERE_IDX_ONLY; cost /= 2; WHERETRACE(("...... idx-only reduces cost to %.9g\n", cost)); } } if( flags && cost < lowestCost ){ bestIdx = pProbe; lowestCost = cost; bestFlags = flags; bestNEq = nEq; } } *ppIndex = bestIdx; WHERETRACE(("best index is %s, cost=%.9g, flags=%x, nEq=%d\n", bestIdx ? bestIdx->zName : "(none)", lowestCost, bestFlags, bestNEq)); *pFlags = bestFlags | eqTermMask; *pnEq = bestNEq; return lowestCost; } static void disableTerm(WhereLevel *pLevel, WhereTerm *pTerm){ if( pTerm && ALWAYS((pTerm->flags & TERM_CODED)==0) && (pLevel->iLeftJoin==0 || ExprHasProperty(pTerm->pExpr, EP_FromJoin)) ){ pTerm->flags |= TERM_CODED; if( pTerm->iParent>=0 ){ WhereTerm *pOther = &pTerm->pWC->a[pTerm->iParent]; if( (--pOther->nChild)==0 ){ disableTerm(pLevel, pOther); } } } } static void codeApplyAffinity(Parse *pParse, int base, int n, Index *pIdx){ if( n>0 ){ Vdbe *v = pParse->pVdbe; assert( v!=0 ); sqlite3VdbeAddOp2(v, OP_Affinity, base, n); sqlite3IndexAffinityStr(v, pIdx); sqlite3ExprCacheAffinityChange(pParse, base, n); } } static int codeEqualityTerm( Parse *pParse, WhereTerm *pTerm, WhereLevel *pLevel, int iTarget ){ Expr *pX = pTerm->pExpr; Vdbe *v = pParse->pVdbe; int iReg; assert( iTarget>0 ); if( pX->op==TK_EQ ){ iReg = sqlite3ExprCodeTarget(pParse, pX->pRight, iTarget); }else if( pX->op==TK_ISNULL ){ iReg = iTarget; sqlite3VdbeAddOp2(v, OP_Null, 0, iReg); 
#ifndef SQLITE_OMIT_SUBQUERY 
 }else{ int eType; int iTab; struct InLoop *pIn; assert( pX->op==TK_IN ); iReg = iTarget; eType = sqlite3FindInIndex(pParse, pX, 0); iTab = pX->iTable; sqlite3VdbeAddOp2(v, OP_Rewind, iTab, 0); VdbeComment((v, "%.*s", pX->span.n, pX->span.z)); if( pLevel->nIn==0 ){ pLevel->nxt = sqlite3VdbeMakeLabel(v); } pLevel->nIn++; pLevel->aInLoop = sqlite3DbReallocOrFree(pParse->db, pLevel->aInLoop, sizeof(pLevel->aInLoop[0])*pLevel->nIn); pIn = pLevel->aInLoop; if( pIn ){ pIn += pLevel->nIn - 1; pIn->iCur = iTab; if( eType==IN_INDEX_ROWID ){ pIn->topAddr = sqlite3VdbeAddOp2(v, OP_Rowid, iTab, iReg); }else{ pIn->topAddr = sqlite3VdbeAddOp3(v, OP_Column, iTab, 0, iReg); } sqlite3VdbeAddOp1(v, OP_IsNull, iReg); }else{ pLevel->nIn = 0; } 
#endif 
 } disableTerm(pLevel, pTerm); return iReg; } static int codeAllEqualityTerms( Parse *pParse, WhereLevel *pLevel, WhereClause *pWC, Bitmask notReady, int nExtraReg ){ int nEq = pLevel->nEq; Vdbe *v = pParse->pVdbe; Index *pIdx = pLevel->pIdx; int iCur = pLevel->iTabCur; WhereTerm *pTerm; int j; int regBase; pLevel->iMem = pParse->nMem + 1; regBase = pParse->nMem + 2; pParse->nMem += pLevel->nEq + 2 + nExtraReg; assert( pIdx->nColumn>=nEq ); for(j=0; j<nEq; j++){ int r1; int k = pIdx->aiColumn[j]; pTerm = findTerm(pWC, iCur, k, notReady, pLevel->flags, pIdx); if( NEVER(pTerm==0) ) break; assert( (pTerm->flags & TERM_CODED)==0 ); r1 = codeEqualityTerm(pParse, pTerm, pLevel, regBase+j); if( r1!=regBase+j ){ sqlite3VdbeAddOp2(v, OP_SCopy, r1, regBase+j); } testcase( pTerm->eOperator & WO_ISNULL ); testcase( pTerm->eOperator & WO_IN ); if( (pTerm->eOperator & (WO_ISNULL|WO_IN))==0 ){ sqlite3VdbeAddOp2(v, OP_IsNull, regBase+j, pLevel->brk); } } return regBase; } 
#if defined(SQLITE_TEST) 
SQLITE_API char sqlite3_query_plan[BMS*2*40]; static int nQPlan = 0; 
#endif 
static void whereInfoFree(sqlite3 *db, WhereInfo *pWInfo){ if( pWInfo ){ int i; for(i=0; i<pWInfo->nLevel; i++){ sqlite3_index_info *pInfo = pWInfo->a[i].pIdxInfo; if( pInfo ){ assert( pInfo->needToFreeIdxStr==0 ); sqlite3DbFree(db, pInfo); } } sqlite3DbFree(db, pWInfo); } } SQLITE_PRIVATE WhereInfo *sqlite3WhereBegin( Parse *pParse, SrcList *pTabList, Expr *pWhere, ExprList **ppOrderBy, u8 wflags ){ int i; WhereInfo *pWInfo; Vdbe *v = pParse->pVdbe; int brk, cont = 0; Bitmask notReady; WhereTerm *pTerm; ExprMaskSet maskSet; WhereClause wc; struct SrcList_item *pTabItem; WhereLevel *pLevel; int iFrom; int andFlags; sqlite3 *db; ExprList *pOrderBy = 0; if( pTabList->nSrc>BMS ){ sqlite3ErrorMsg(pParse, "at most %d tables in a join", BMS); return 0; } if( ppOrderBy ){ pOrderBy = *ppOrderBy; } initMaskSet(&maskSet); whereClauseInit(&wc, pParse, &maskSet); sqlite3ExprCodeConstants(pParse, pWhere); whereSplit(&wc, pWhere, TK_AND); db = pParse->db; pWInfo = sqlite3DbMallocZero(db, sizeof(WhereInfo) + pTabList->nSrc*sizeof(WhereLevel)); if( db->mallocFailed ){ goto whereBeginError; } pWInfo->nLevel = pTabList->nSrc; pWInfo->pParse = pParse; pWInfo->pTabList = pTabList; pWInfo->iBreak = sqlite3VdbeMakeLabel(v); if( pWhere && (pTabList->nSrc==0 || sqlite3ExprIsConstantNotJoin(pWhere)) ){ sqlite3ExprIfFalse(pParse, pWhere, pWInfo->iBreak, SQLITE_JUMPIFNULL); pWhere = 0; } for(i=0; i<pTabList->nSrc; i++){ createMask(&maskSet, pTabList->a[i].iCursor); } 
#ifndef NDEBUG 
 { Bitmask toTheLeft = 0; for(i=0; i<pTabList->nSrc; i++){ Bitmask m = getMask(&maskSet, pTabList->a[i].iCursor); assert( (m-1)==toTheLeft ); toTheLeft |= m; } } 
#endif 
 exprAnalyzeAll(pTabList, &wc); if( db->mallocFailed ){ goto whereBeginError; } notReady = ~(Bitmask)0; pTabItem = pTabList->a; pLevel = pWInfo->a; andFlags = ~0; WHERETRACE(("*** Optimizer Start ***\n")); for(i=iFrom=0, pLevel=pWInfo->a; i<pTabList->nSrc; i++, pLevel++){ Index *pIdx; int flags; int nEq; double cost; int j; Index *pBest = 0; int bestFlags = 0; int bestNEq = 0; double lowestCost; int bestJ = 0; Bitmask m; int once = 0; sqlite3_index_info *pIndex; lowestCost = SQLITE_BIG_DBL; for(j=iFrom, pTabItem=&pTabList->a[j]; j<pTabList->nSrc; j++, pTabItem++){ int doNotReorder; doNotReorder = (pTabItem->jointype & (JT_LEFT|JT_CROSS))!=0; if( once && doNotReorder ) break; m = getMask(&maskSet, pTabItem->iCursor); if( (m & notReady)==0 ){ if( j==iFrom ) iFrom++; continue; } assert( pTabItem->pTab ); 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 if( IsVirtual(pTabItem->pTab) ){ sqlite3_index_info **ppIdxInfo = &pWInfo->a[j].pIdxInfo; cost = bestVirtualIndex(pParse, &wc, pTabItem, notReady, ppOrderBy ? *ppOrderBy : 0, i==0, ppIdxInfo); flags = WHERE_VIRTUALTABLE; pIndex = *ppIdxInfo; if( pIndex && pIndex->orderByConsumed ){ flags = WHERE_VIRTUALTABLE | WHERE_ORDERBY; } pIdx = 0; nEq = 0; if( (SQLITE_BIG_DBL/2.0)<cost ){ cost = (SQLITE_BIG_DBL/2.0); } }else 
#endif 
 { cost = bestIndex(pParse, &wc, pTabItem, notReady, (i==0 && ppOrderBy) ? *ppOrderBy : 0, &pIdx, &flags, &nEq); pIndex = 0; } if( cost<lowestCost ){ once = 1; lowestCost = cost; pBest = pIdx; bestFlags = flags; bestNEq = nEq; bestJ = j; pLevel->pBestIdx = pIndex; } if( doNotReorder ) break; } WHERETRACE(("*** Optimizer selects table %d for loop %d\n", bestJ, pLevel-pWInfo->a)); if( (bestFlags & WHERE_ORDERBY)!=0 ){ *ppOrderBy = 0; } andFlags &= bestFlags; pLevel->flags = bestFlags; pLevel->pIdx = pBest; pLevel->nEq = bestNEq; pLevel->aInLoop = 0; pLevel->nIn = 0; if( pBest ){ pLevel->iIdxCur = pParse->nTab++; }else{ pLevel->iIdxCur = -1; } notReady &= ~getMask(&maskSet, pTabList->a[bestJ].iCursor); pLevel->iFrom = bestJ; pIdx = pTabList->a[bestJ].pIndex; assert( !pIdx || !pBest || pIdx==pBest ); if( pIdx && pBest!=pIdx ){ sqlite3ErrorMsg(pParse, "cannot use index: %s", pIdx->zName); goto whereBeginError; } } WHERETRACE(("*** Optimizer Finished ***\n")); if( (andFlags & WHERE_UNIQUE)!=0 && ppOrderBy ){ *ppOrderBy = 0; } assert( (wflags & WHERE_ONEPASS_DESIRED)==0 || pWInfo->nLevel==1 ); if( (wflags & WHERE_ONEPASS_DESIRED)!=0 && (andFlags & WHERE_UNIQUE)!=0 ){ pWInfo->okOnePass = 1; pWInfo->a[0].flags &= ~WHERE_IDX_ONLY; } sqlite3CodeVerifySchema(pParse, -1); for(i=0, pLevel=pWInfo->a; i<pTabList->nSrc; i++, pLevel++){ Table *pTab; Index *pIx; int iDb; int iIdxCur = pLevel->iIdxCur; 
#ifndef SQLITE_OMIT_EXPLAIN 
 if( pParse->explain==2 ){ char *zMsg; struct SrcList_item *pItem = &pTabList->a[pLevel->iFrom]; zMsg = sqlite3MPrintf(db, "TABLE %s", pItem->zName); if( pItem->zAlias ){ zMsg = sqlite3MAppendf(db, zMsg, "%s AS %s", zMsg, pItem->zAlias); } if( (pIx = pLevel->pIdx)!=0 ){ zMsg = sqlite3MAppendf(db, zMsg, "%s WITH INDEX %s", zMsg, pIx->zName); }else if( pLevel->flags & (WHERE_ROWID_EQ|WHERE_ROWID_RANGE) ){ zMsg = sqlite3MAppendf(db, zMsg, "%s USING PRIMARY KEY", zMsg); } 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 else if( pLevel->pBestIdx ){ sqlite3_index_info *pBestIdx = pLevel->pBestIdx; zMsg = sqlite3MAppendf(db, zMsg, "%s VIRTUAL TABLE INDEX %d:%s", zMsg, pBestIdx->idxNum, pBestIdx->idxStr); } 
#endif 
 if( pLevel->flags & WHERE_ORDERBY ){ zMsg = sqlite3MAppendf(db, zMsg, "%s ORDER BY", zMsg); } sqlite3VdbeAddOp4(v, OP_Explain, i, pLevel->iFrom, 0, zMsg, P4_DYNAMIC); } 
#endif 
 pTabItem = &pTabList->a[pLevel->iFrom]; pTab = pTabItem->pTab; iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema); if( (pTab->tabFlags & TF_Ephemeral)!=0 || pTab->pSelect ) continue; 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 if( pLevel->pBestIdx ){ int iCur = pTabItem->iCursor; sqlite3VdbeAddOp4(v, OP_VOpen, iCur, 0, 0, (const char*)pTab->pVtab, P4_VTAB); }else 
#endif 
 if( (pLevel->flags & WHERE_IDX_ONLY)==0 ){ int op = pWInfo->okOnePass ? OP_OpenWrite : OP_OpenRead; sqlite3OpenTable(pParse, pTabItem->iCursor, iDb, pTab, op); if( !pWInfo->okOnePass && pTab->nCol<BMS ){ Bitmask b = pTabItem->colUsed; int n = 0; for(; b; b=b>>1, n++){} sqlite3VdbeChangeP2(v, sqlite3VdbeCurrentAddr(v)-2, n); assert( n<=pTab->nCol ); } }else{ sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName); } pLevel->iTabCur = pTabItem->iCursor; if( (pIx = pLevel->pIdx)!=0 ){ KeyInfo *pKey = sqlite3IndexKeyinfo(pParse, pIx); assert( pIx->pSchema==pTab->pSchema ); sqlite3VdbeAddOp2(v, OP_SetNumColumns, 0, pIx->nColumn+1); sqlite3VdbeAddOp4(v, OP_OpenRead, iIdxCur, pIx->tnum, iDb, (char*)pKey, P4_KEYINFO_HANDOFF); VdbeComment((v, "%s", pIx->zName)); } sqlite3CodeVerifySchema(pParse, iDb); } pWInfo->iTop = sqlite3VdbeCurrentAddr(v); notReady = ~(Bitmask)0; for(i=0, pLevel=pWInfo->a; i<pTabList->nSrc; i++, pLevel++){ int j, k; int iCur = pTabItem->iCursor; Index *pIdx; int nxt; int iIdxCur; int omitTable; int bRev; pTabItem = &pTabList->a[pLevel->iFrom]; iCur = pTabItem->iCursor; pIdx = pLevel->pIdx; iIdxCur = pLevel->iIdxCur; bRev = (pLevel->flags & WHERE_REVERSE)!=0; omitTable = (pLevel->flags & WHERE_IDX_ONLY)!=0; brk = pLevel->brk = pLevel->nxt = sqlite3VdbeMakeLabel(v); cont = pLevel->cont = sqlite3VdbeMakeLabel(v); if( pLevel->iFrom>0 && (pTabItem[0].jointype & JT_LEFT)!=0 ){ pLevel->iLeftJoin = ++pParse->nMem; sqlite3VdbeAddOp2(v, OP_Integer, 0, pLevel->iLeftJoin); VdbeComment((v, "init LEFT JOIN no-match flag")); } 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 if( pLevel->pBestIdx ){ int j; int iReg; sqlite3_index_info *pBestIdx = pLevel->pBestIdx; int nConstraint = pBestIdx->nConstraint; struct sqlite3_index_constraint_usage *aUsage = pBestIdx->aConstraintUsage; const struct sqlite3_index_constraint *aConstraint = pBestIdx->aConstraint; iReg = sqlite3GetTempRange(pParse, nConstraint+2); pParse->disableColCache++; for(j=1; j<=nConstraint; j++){ int k; for(k=0; k<nConstraint; k++){ if( aUsage[k].argvIndex==j ){ int iTerm = aConstraint[k].iTermOffset; assert( pParse->disableColCache ); sqlite3ExprCode(pParse, wc.a[iTerm].pExpr->pRight, iReg+j+1); break; } } if( k==nConstraint ) break; } assert( pParse->disableColCache ); pParse->disableColCache--; sqlite3VdbeAddOp2(v, OP_Integer, pBestIdx->idxNum, iReg); sqlite3VdbeAddOp2(v, OP_Integer, j-1, iReg+1); sqlite3VdbeAddOp4(v, OP_VFilter, iCur, brk, iReg, pBestIdx->idxStr, pBestIdx->needToFreeIdxStr ? P4_MPRINTF : P4_STATIC); sqlite3ReleaseTempRange(pParse, iReg, nConstraint+2); pBestIdx->needToFreeIdxStr = 0; for(j=0; j<nConstraint; j++){ if( aUsage[j].omit ){ int iTerm = aConstraint[j].iTermOffset; disableTerm(pLevel, &wc.a[iTerm]); } } pLevel->op = OP_VNext; pLevel->p1 = iCur; pLevel->p2 = sqlite3VdbeCurrentAddr(v); }else 
#endif 
 if( pLevel->flags & WHERE_ROWID_EQ ){ int r1; int rtmp = sqlite3GetTempReg(pParse); pTerm = findTerm(&wc, iCur, -1, notReady, WO_EQ|WO_IN, 0); assert( pTerm!=0 ); assert( pTerm->pExpr!=0 ); assert( pTerm->leftCursor==iCur ); assert( omitTable==0 ); r1 = codeEqualityTerm(pParse, pTerm, pLevel, rtmp); nxt = pLevel->nxt; sqlite3VdbeAddOp2(v, OP_MustBeInt, r1, nxt); sqlite3VdbeAddOp3(v, OP_NotExists, iCur, nxt, r1); sqlite3ReleaseTempReg(pParse, rtmp); VdbeComment((v, "pk")); pLevel->op = OP_Noop; }else if( pLevel->flags & WHERE_ROWID_RANGE ){ int testOp = OP_Noop; int start; WhereTerm *pStart, *pEnd; assert( omitTable==0 ); pStart = findTerm(&wc, iCur, -1, notReady, WO_GT|WO_GE, 0); pEnd = findTerm(&wc, iCur, -1, notReady, WO_LT|WO_LE, 0); if( bRev ){ pTerm = pStart; pStart = pEnd; pEnd = pTerm; } if( pStart ){ Expr *pX; int r1; pX = pStart->pExpr; assert( pX!=0 ); assert( pStart->leftCursor==iCur ); r1 = sqlite3GetTempReg(pParse); sqlite3ExprCode(pParse, pX->pRight, r1); sqlite3VdbeAddOp3(v, OP_ForceInt, r1, brk, pX->op==TK_LE || pX->op==TK_GT); sqlite3VdbeAddOp3(v, bRev ? OP_MoveLt : OP_MoveGe, iCur, brk, r1); VdbeComment((v, "pk")); sqlite3ReleaseTempReg(pParse, r1); disableTerm(pLevel, pStart); }else{ sqlite3VdbeAddOp2(v, bRev ? OP_Last : OP_Rewind, iCur, brk); } if( pEnd ){ Expr *pX; pX = pEnd->pExpr; assert( pX!=0 ); assert( pEnd->leftCursor==iCur ); pLevel->iMem = ++pParse->nMem; sqlite3ExprCode(pParse, pX->pRight, pLevel->iMem); if( pX->op==TK_LT || pX->op==TK_GT ){ testOp = bRev ? OP_Le : OP_Ge; }else{ testOp = bRev ? OP_Lt : OP_Gt; } disableTerm(pLevel, pEnd); } start = sqlite3VdbeCurrentAddr(v); pLevel->op = bRev ? OP_Prev : OP_Next; pLevel->p1 = iCur; pLevel->p2 = start; if( testOp!=OP_Noop ){ int r1 = sqlite3GetTempReg(pParse); sqlite3VdbeAddOp2(v, OP_Rowid, iCur, r1); sqlite3VdbeAddOp3(v, testOp, pLevel->iMem, brk, r1); sqlite3VdbeChangeP5(v, SQLITE_AFF_NUMERIC | SQLITE_JUMPIFNULL); sqlite3ReleaseTempReg(pParse, r1); } }else if( pLevel->flags & (WHERE_COLUMN_RANGE|WHERE_COLUMN_EQ) ){ int aStartOp[] = { 0, 0, OP_Rewind, OP_Last, OP_MoveGt, OP_MoveLt, OP_MoveGe, OP_MoveLe }; int aEndOp[] = { OP_Noop, OP_IdxGE, OP_IdxLT }; int nEq = pLevel->nEq; int isMinQuery = 0; int regBase; int r1; WhereTerm *pRangeStart = 0; WhereTerm *pRangeEnd = 0; int startEq; int endEq; int start_constraints; int k = pIdx->aiColumn[nEq]; int nConstraint; int op; regBase = codeAllEqualityTerms(pParse, pLevel, &wc, notReady, 2); nxt = pLevel->nxt; if( (wflags&WHERE_ORDERBY_MIN)!=0 && (pLevel->flags&WHERE_ORDERBY) && (pIdx->nColumn>nEq) ){ assert( pOrderBy->nExpr==1 ); assert( pOrderBy->a[0].pExpr->iColumn==pIdx->aiColumn[nEq] ); isMinQuery = 1; } if( pLevel->flags & WHERE_TOP_LIMIT ){ pRangeEnd = findTerm(&wc, iCur, k, notReady, (WO_LT|WO_LE), pIdx); } if( pLevel->flags & WHERE_BTM_LIMIT ){ pRangeStart = findTerm(&wc, iCur, k, notReady, (WO_GT|WO_GE), pIdx); } if( bRev==(pIdx->aSortOrder[nEq]==SQLITE_SO_ASC) ){ SWAP(WhereTerm *, pRangeEnd, pRangeStart); } testcase( pRangeStart && pRangeStart->eOperator & WO_LE ); testcase( pRangeStart && pRangeStart->eOperator & WO_GE ); testcase( pRangeEnd && pRangeEnd->eOperator & WO_LE ); testcase( pRangeEnd && pRangeEnd->eOperator & WO_GE ); startEq = !pRangeStart || pRangeStart->eOperator & (WO_LE|WO_GE); endEq = !pRangeEnd || pRangeEnd->eOperator & (WO_LE|WO_GE); start_constraints = pRangeStart || nEq>0; nConstraint = nEq; if( pRangeStart ){ int dcc = pParse->disableColCache; if( pRangeEnd ){ pParse->disableColCache++; } sqlite3ExprCode(pParse, pRangeStart->pExpr->pRight, regBase+nEq); pParse->disableColCache = dcc; sqlite3VdbeAddOp2(v, OP_IsNull, regBase+nEq, nxt); nConstraint++; }else if( isMinQuery ){ sqlite3VdbeAddOp2(v, OP_Null, 0, regBase+nEq); nConstraint++; startEq = 0; start_constraints = 1; } codeApplyAffinity(pParse, regBase, nConstraint, pIdx); op = aStartOp[(start_constraints<<2) + (startEq<<1) + bRev]; assert( op!=0 ); testcase( op==OP_Rewind ); testcase( op==OP_Last ); testcase( op==OP_MoveGt ); testcase( op==OP_MoveGe ); testcase( op==OP_MoveLe ); testcase( op==OP_MoveLt ); sqlite3VdbeAddOp4(v, op, iIdxCur, nxt, regBase, SQLITE_INT_TO_PTR(nConstraint), P4_INT32); nConstraint = nEq; if( pRangeEnd ){ sqlite3ExprCode(pParse, pRangeEnd->pExpr->pRight, regBase+nEq); sqlite3VdbeAddOp2(v, OP_IsNull, regBase+nEq, nxt); codeApplyAffinity(pParse, regBase, nEq+1, pIdx); nConstraint++; } pLevel->p2 = sqlite3VdbeCurrentAddr(v); op = aEndOp[(pRangeEnd || nEq) * (1 + bRev)]; testcase( op==OP_Noop ); testcase( op==OP_IdxGE ); testcase( op==OP_IdxLT ); sqlite3VdbeAddOp4(v, op, iIdxCur, nxt, regBase, SQLITE_INT_TO_PTR(nConstraint), P4_INT32); sqlite3VdbeChangeP5(v, endEq!=bRev); r1 = sqlite3GetTempReg(pParse); testcase( pLevel->flags & WHERE_BTM_LIMIT ); testcase( pLevel->flags & WHERE_TOP_LIMIT ); if( pLevel->flags & (WHERE_BTM_LIMIT|WHERE_TOP_LIMIT) ){ sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, nEq, r1); sqlite3VdbeAddOp2(v, OP_IsNull, r1, cont); } if( !omitTable ){ sqlite3VdbeAddOp2(v, OP_IdxRowid, iIdxCur, r1); sqlite3VdbeAddOp3(v, OP_MoveGe, iCur, 0, r1); } sqlite3ReleaseTempReg(pParse, r1); pLevel->op = bRev ? OP_Prev : OP_Next; pLevel->p1 = iIdxCur; disableTerm(pLevel, pRangeStart); disableTerm(pLevel, pRangeEnd); }else{ assert( omitTable==0 ); assert( bRev==0 ); pLevel->op = OP_Next; pLevel->p1 = iCur; pLevel->p2 = 1 + sqlite3VdbeAddOp2(v, OP_Rewind, iCur, brk); pLevel->p5 = SQLITE_STMTSTATUS_FULLSCAN_STEP; } notReady &= ~getMask(&maskSet, iCur); k = 0; for(pTerm=wc.a, j=wc.nTerm; j>0; j--, pTerm++){ Expr *pE; testcase( pTerm->flags & TERM_VIRTUAL ); testcase( pTerm->flags & TERM_CODED ); if( pTerm->flags & (TERM_VIRTUAL|TERM_CODED) ) continue; if( (pTerm->prereqAll & notReady)!=0 ) continue; pE = pTerm->pExpr; assert( pE!=0 ); if( pLevel->iLeftJoin && !ExprHasProperty(pE, EP_FromJoin) ){ continue; } pParse->disableColCache += k; sqlite3ExprIfFalse(pParse, pE, cont, SQLITE_JUMPIFNULL); pParse->disableColCache -= k; k = 1; pTerm->flags |= TERM_CODED; } if( pLevel->iLeftJoin ){ pLevel->top = sqlite3VdbeCurrentAddr(v); sqlite3VdbeAddOp2(v, OP_Integer, 1, pLevel->iLeftJoin); VdbeComment((v, "record LEFT JOIN hit")); sqlite3ExprClearColumnCache(pParse, pLevel->iTabCur); sqlite3ExprClearColumnCache(pParse, pLevel->iIdxCur); for(pTerm=wc.a, j=0; j<wc.nTerm; j++, pTerm++){ testcase( pTerm->flags & TERM_VIRTUAL ); testcase( pTerm->flags & TERM_CODED ); if( pTerm->flags & (TERM_VIRTUAL|TERM_CODED) ) continue; if( (pTerm->prereqAll & notReady)!=0 ) continue; assert( pTerm->pExpr ); sqlite3ExprIfFalse(pParse, pTerm->pExpr, cont, SQLITE_JUMPIFNULL); pTerm->flags |= TERM_CODED; } } } 
#ifdef SQLITE_TEST 
 for(i=0; i<pTabList->nSrc; i++){ char *z; int n; pLevel = &pWInfo->a[i]; pTabItem = &pTabList->a[pLevel->iFrom]; z = pTabItem->zAlias; if( z==0 ) z = pTabItem->pTab->zName; n = strlen(z); if( n+nQPlan < sizeof(sqlite3_query_plan)-10 ){ if( pLevel->flags & WHERE_IDX_ONLY ){ memcpy(&sqlite3_query_plan[nQPlan], "{}", 2); nQPlan += 2; }else{ memcpy(&sqlite3_query_plan[nQPlan], z, n); nQPlan += n; } sqlite3_query_plan[nQPlan++] = ' '; } testcase( pLevel->flags & WHERE_ROWID_EQ ); testcase( pLevel->flags & WHERE_ROWID_RANGE ); if( pLevel->flags & (WHERE_ROWID_EQ|WHERE_ROWID_RANGE) ){ memcpy(&sqlite3_query_plan[nQPlan], "* ", 2); nQPlan += 2; }else if( pLevel->pIdx==0 ){ memcpy(&sqlite3_query_plan[nQPlan], "{} ", 3); nQPlan += 3; }else{ n = strlen(pLevel->pIdx->zName); if( n+nQPlan < sizeof(sqlite3_query_plan)-2 ){ memcpy(&sqlite3_query_plan[nQPlan], pLevel->pIdx->zName, n); nQPlan += n; sqlite3_query_plan[nQPlan++] = ' '; } } } while( nQPlan>0 && sqlite3_query_plan[nQPlan-1]==' ' ){ sqlite3_query_plan[--nQPlan] = 0; } sqlite3_query_plan[nQPlan] = 0; nQPlan = 0; 
#endif 
 pWInfo->iContinue = cont; whereClauseClear(&wc); return pWInfo; whereBeginError: whereClauseClear(&wc); whereInfoFree(db, pWInfo); return 0; } SQLITE_PRIVATE void sqlite3WhereEnd(WhereInfo *pWInfo){ Parse *pParse = pWInfo->pParse; Vdbe *v = pParse->pVdbe; int i; WhereLevel *pLevel; SrcList *pTabList = pWInfo->pTabList; sqlite3 *db = pParse->db; sqlite3ExprClearColumnCache(pParse, -1); for(i=pTabList->nSrc-1; i>=0; i--){ pLevel = &pWInfo->a[i]; sqlite3VdbeResolveLabel(v, pLevel->cont); if( pLevel->op!=OP_Noop ){ sqlite3VdbeAddOp2(v, pLevel->op, pLevel->p1, pLevel->p2); sqlite3VdbeChangeP5(v, pLevel->p5); } if( pLevel->nIn ){ struct InLoop *pIn; int j; sqlite3VdbeResolveLabel(v, pLevel->nxt); for(j=pLevel->nIn, pIn=&pLevel->aInLoop[j-1]; j>0; j--, pIn--){ sqlite3VdbeJumpHere(v, pIn->topAddr+1); sqlite3VdbeAddOp2(v, OP_Next, pIn->iCur, pIn->topAddr); sqlite3VdbeJumpHere(v, pIn->topAddr-1); } sqlite3DbFree(db, pLevel->aInLoop); } sqlite3VdbeResolveLabel(v, pLevel->brk); if( pLevel->iLeftJoin ){ int addr; addr = sqlite3VdbeAddOp1(v, OP_IfPos, pLevel->iLeftJoin); sqlite3VdbeAddOp1(v, OP_NullRow, pTabList->a[i].iCursor); if( pLevel->iIdxCur>=0 ){ sqlite3VdbeAddOp1(v, OP_NullRow, pLevel->iIdxCur); } sqlite3VdbeAddOp2(v, OP_Goto, 0, pLevel->top); sqlite3VdbeJumpHere(v, addr); } } sqlite3VdbeResolveLabel(v, pWInfo->iBreak); for(i=0, pLevel=pWInfo->a; i<pTabList->nSrc; i++, pLevel++){ struct SrcList_item *pTabItem = &pTabList->a[pLevel->iFrom]; Table *pTab = pTabItem->pTab; assert( pTab!=0 ); if( (pTab->tabFlags & TF_Ephemeral)!=0 || pTab->pSelect ) continue; if( !pWInfo->okOnePass && (pLevel->flags & WHERE_IDX_ONLY)==0 ){ sqlite3VdbeAddOp1(v, OP_Close, pTabItem->iCursor); } if( pLevel->pIdx!=0 ){ sqlite3VdbeAddOp1(v, OP_Close, pLevel->iIdxCur); } if( pLevel->pIdx ){ int k, j, last; VdbeOp *pOp; Index *pIdx = pLevel->pIdx; int useIndexOnly = pLevel->flags & WHERE_IDX_ONLY; assert( pIdx!=0 ); pOp = sqlite3VdbeGetOp(v, pWInfo->iTop); last = sqlite3VdbeCurrentAddr(v); for(k=pWInfo->iTop; k<last; k++, pOp++){ if( pOp->p1!=pLevel->iTabCur ) continue; if( pOp->opcode==OP_Column ){ for(j=0; j<pIdx->nColumn; j++){ if( pOp->p2==pIdx->aiColumn[j] ){ pOp->p2 = j; pOp->p1 = pLevel->iIdxCur; break; } } assert(!useIndexOnly || j<pIdx->nColumn); }else if( pOp->opcode==OP_Rowid ){ pOp->p1 = pLevel->iIdxCur; pOp->opcode = OP_IdxRowid; }else if( pOp->opcode==OP_NullRow && useIndexOnly ){ pOp->opcode = OP_Noop; } } } } whereInfoFree(db, pWInfo); return; } struct LimitVal { Expr *pLimit; Expr *pOffset; }; struct LikeOp { Token eOperator; int not; }; struct TrigEvent { int a; IdList * b; }; struct AttachKey { int type; Token key; }; 
#ifndef INTERFACE 
#define INTERFACE 1 
#endif 
#define YYCODETYPE unsigned char 
#define YYNOCODE 249 
#define YYACTIONTYPE unsigned short int 
#define YYWILDCARD 59 
#define sqlite3ParserTOKENTYPE Token 
typedef union { sqlite3ParserTOKENTYPE yy0; Select* yy43; TriggerStep* yy75; struct LimitVal yy84; struct LikeOp yy86; struct {int value; int mask;} yy207; ExprList* yy242; int yy316; IdList* yy352; struct TrigEvent yy354; SrcList* yy419; Expr* yy450; } YYMINORTYPE; 
#ifndef YYSTACKDEPTH 
#define YYSTACKDEPTH 100 
#endif 
#define sqlite3ParserARG_SDECL Parse *pParse; 
#define sqlite3ParserARG_PDECL ,Parse *pParse 
#define sqlite3ParserARG_FETCH Parse *pParse = yypParser->pParse 
#define sqlite3ParserARG_STORE yypParser->pParse = pParse 
#define YYNSTATE 598 
#define YYNRULE 315 
#define YYFALLBACK 1 
#define YY_NO_ACTION (YYNSTATE+YYNRULE+2) 
#define YY_ACCEPT_ACTION (YYNSTATE+YYNRULE+1) 
#define YY_ERROR_ACTION (YYNSTATE+YYNRULE) 
#if 0 
static YYMINORTYPE yyzerominor; 
#else 
static const YYMINORTYPE yyzerominor; 
#endif 
static const YYACTIONTYPE yy_action[] = { 296, 914, 120, 597, 2, 172, 425, 425, 62, 62, 62, 62, 210, 64, 64, 64, 64, 65, 65, 66, 66, 66, 67, 212, 398, 395, 432, 438, 69, 64, 64, 64, 64, 65, 65, 66, 66, 66, 67, 212, 458, 456, 327, 168, 61, 60, 301, 442, 443, 439, 439, 63, 63, 62, 62, 62, 62, 256, 64, 64, 64, 64, 65, 65, 66, 66, 66, 67, 212, 296, 498, 425, 425, 212, 427, 83, 68, 469, 70, 154, 64, 64, 64, 64, 65, 65, 66, 66, 66, 67, 212, 68, 307, 70, 154, 432, 438, 454, 214, 59, 65, 65, 66, 66, 66, 67, 212, 429, 429, 429, 497, 583, 296, 61, 60, 301, 442, 443, 439, 439, 63, 63, 62, 62, 62, 62, 321, 64, 64, 64, 64, 65, 65, 66, 66, 66, 67, 212, 432, 438, 95, 66, 66, 66, 67, 212, 403, 256, 421, 35, 57, 67, 212, 175, 417, 499, 61, 60, 301, 442, 443, 439, 439, 63, 63, 62, 62, 62, 62, 19, 64, 64, 64, 64, 65, 65, 66, 66, 66, 67, 212, 296, 225, 532, 299, 581, 109, 422, 242, 458, 416, 335, 414, 21, 502, 503, 346, 403, 527, 176, 160, 454, 214, 580, 579, 344, 500, 432, 438, 149, 150, 404, 405, 539, 514, 418, 151, 541, 8, 498, 538, 577, 578, 427, 296, 61, 60, 301, 442, 443, 439, 439, 63, 63, 62, 62, 62, 62, 196, 64, 64, 64, 64, 65, 65, 66, 66, 66, 67, 212, 432, 438, 454, 598, 398, 395, 429, 429, 429, 369, 558, 481, 404, 405, 372, 576, 213, 296, 61, 60, 301, 442, 443, 439, 439, 63, 63, 62, 62, 62, 62, 321, 64, 64, 64, 64, 65, 65, 66, 66, 66, 67, 212, 432, 438, 555, 503, 304, 557, 532, 218, 557, 552, 421, 36, 234, 397, 2, 542, 21, 540, 61, 60, 301, 442, 443, 439, 439, 63, 63, 62, 62, 62, 62, 388, 64, 64, 64, 64, 65, 65, 66, 66, 66, 67, 212, 415, 530, 85, 381, 78, 323, 296, 210, 304, 527, 493, 492, 379, 274, 273, 379, 274, 273, 347, 463, 241, 387, 268, 210, 533, 581, 210, 403, 20, 224, 144, 464, 432, 438, 485, 164, 114, 248, 349, 253, 350, 177, 554, 580, 465, 420, 331, 81, 257, 419, 61, 60, 301, 442, 443, 439, 439, 63, 63, 62, 62, 62, 62, 391, 64, 64, 64, 64, 65, 65, 66, 66, 66, 67, 212, 296, 224, 203, 249, 496, 403, 440, 837, 114, 248, 349, 253, 350, 177, 250, 321, 152, 404, 405, 321, 257, 303, 324, 155, 445, 445, 432, 438, 317, 400, 389, 213, 68, 209, 70, 154, 422, 421, 35, 393, 202, 421, 42, 481, 61, 60, 301, 442, 443, 439, 439, 63, 63, 62, 62, 62, 62, 422, 64, 64, 64, 64, 65, 65, 66, 66, 66, 67, 212, 296, 404, 405, 183, 513, 422, 351, 354, 355, 403, 77, 335, 79, 489, 216, 183, 334, 356, 351, 354, 355, 433, 434, 406, 407, 408, 432, 438, 235, 356, 386, 68, 291, 70, 154, 456, 531, 168, 198, 302, 449, 450, 436, 437, 61, 60, 301, 442, 443, 439, 439, 63, 63, 62, 62, 62, 62, 394, 64, 64, 64, 64, 65, 65, 66, 66, 66, 67, 212, 296, 321, 435, 422, 260, 404, 405, 321, 183, 153, 321, 351, 354, 355, 446, 332, 321, 595, 905, 321, 905, 1, 356, 421, 28, 403, 432, 438, 376, 421, 42, 477, 421, 35, 213, 548, 366, 548, 421, 50, 159, 421, 50, 422, 61, 60, 301, 442, 443, 439, 439, 63, 63, 62, 62, 62, 62, 592, 64, 64, 64, 64, 65, 65, 66, 66, 66, 67, 212, 296, 337, 217, 463, 256, 94, 339, 326, 449, 450, 172, 340, 425, 345, 532, 464, 312, 595, 904, 313, 904, 404, 405, 588, 21, 226, 432, 438, 465, 243, 504, 324, 322, 445, 445, 421, 3, 459, 230, 308, 505, 194, 278, 296, 61, 60, 301, 442, 443, 439, 439, 63, 63, 62, 62, 62, 62, 592, 64, 64, 64, 64, 65, 65, 66, 66, 66, 67, 212, 432, 438, 213, 179, 180, 181, 422, 324, 425, 445, 445, 281, 262, 279, 402, 194, 481, 296, 61, 60, 301, 442, 443, 439, 439, 63, 63, 62, 62, 62, 62, 377, 64, 64, 64, 64, 65, 65, 66, 66, 66, 67, 212, 432, 438, 591, 295, 115, 268, 422, 266, 211, 264, 373, 324, 246, 445, 445, 56, 256, 296, 61, 71, 301, 442, 443, 439, 439, 63, 63, 62, 62, 62, 62, 377, 64, 64, 64, 64, 65, 65, 66, 66, 66, 67, 212, 432, 438, 550, 269, 474, 18, 549, 280, 309, 343, 380, 171, 160, 256, 268, 5, 268, 296, 368, 60, 301, 442, 443, 439, 439, 63, 63, 62, 62, 62, 62, 321, 64, 64, 64, 64, 65, 65, 66, 66, 66, 67, 212, 432, 438, 403, 10, 403, 310, 268, 403, 268, 485, 421, 29, 566, 22, 568, 420, 428, 425, 376, 419, 301, 442, 443, 439, 439, 63, 63, 62, 62, 62, 62, 321, 64, 64, 64, 64, 65, 65, 66, 66, 66, 67, 212, 73, 328, 485, 4, 569, 268, 570, 300, 268, 147, 421, 24, 321, 359, 321, 325, 73, 328, 491, 4, 455, 321, 342, 300, 404, 405, 404, 405, 367, 404, 405, 325, 330, 321, 421, 33, 421, 54, 321, 425, 178, 229, 458, 421, 53, 321, 227, 321, 330, 228, 478, 165, 321, 315, 119, 421, 99, 333, 458, 321, 421, 97, 76, 75, 311, 268, 519, 421, 102, 421, 103, 74, 319, 320, 421, 108, 427, 467, 76, 75, 490, 421, 110, 452, 452, 321, 520, 74, 319, 320, 73, 328, 427, 4, 210, 298, 321, 300, 321, 156, 257, 321, 210, 185, 182, 325, 284, 421, 17, 429, 429, 429, 430, 431, 12, 593, 378, 188, 421, 100, 421, 34, 330, 421, 98, 429, 429, 429, 430, 431, 12, 475, 458, 422, 162, 480, 321, 422, 306, 231, 232, 233, 105, 484, 632, 476, 321, 486, 447, 321, 23, 422, 76, 75, 594, 207, 178, 286, 421, 25, 254, 74, 319, 320, 287, 321, 427, 321, 421, 55, 321, 421, 111, 321, 471, 321, 205, 515, 557, 511, 363, 472, 204, 321, 516, 206, 321, 421, 112, 421, 113, 321, 421, 26, 321, 421, 37, 421, 38, 429, 429, 429, 430, 431, 12, 421, 27, 521, 421, 39, 321, 298, 158, 421, 40, 255, 421, 41, 321, 483, 321, 173, 523, 321, 182, 321, 522, 321, 384, 283, 273, 321, 421, 43, 297, 534, 321, 476, 321, 210, 421, 44, 421, 45, 321, 421, 30, 421, 31, 421, 46, 508, 509, 421, 47, 259, 321, 182, 421, 48, 421, 49, 321, 358, 390, 182, 421, 32, 321, 261, 518, 517, 553, 561, 182, 173, 412, 191, 421, 11, 562, 573, 92, 92, 421, 51, 590, 263, 294, 265, 421, 52, 267, 272, 371, 146, 374, 375, 275, 276, 277, 565, 575, 285, 288, 289, 587, 470, 451, 236, 453, 329, 244, 473, 514, 251, 524, 560, 163, 401, 572, 426, 525, 282, 528, 409, 7, 410, 411, 385, 318, 85, 237, 338, 526, 84, 336, 353, 58, 80, 215, 170, 468, 121, 86, 341, 348, 305, 501, 506, 124, 511, 222, 360, 423, 252, 186, 512, 510, 221, 223, 238, 507, 239, 535, 240, 292, 424, 529, 536, 537, 293, 543, 187, 189, 245, 362, 482, 488, 247, 190, 364, 89, 545, 192, 117, 370, 132, 556, 563, 195, 382, 383, 314, 133, 134, 571, 138, 135, 136, 584, 589, 585, 142, 399, 101, 413, 220, 586, 270, 104, 141, 633, 634, 166, 167, 441, 444, 72, 460, 448, 457, 546, 143, 157, 6, 461, 14, 479, 169, 462, 93, 466, 82, 122, 13, 174, 487, 96, 123, 161, 494, 495, 87, 125, 126, 116, 258, 88, 127, 184, 250, 361, 219, 107, 544, 145, 128, 193, 365, 118, 352, 357, 173, 271, 130, 9, 316, 559, 197, 90, 547, 131, 129, 15, 199, 551, 564, 200, 567, 201, 139, 137, 582, 91, 16, 106, 140, 208, 574, 392, 396, 290, 148, 596, }; static const YYCODETYPE yy_lookahead[] = { 16, 140, 141, 142, 143, 21, 23, 23, 69, 70, 71, 72, 110, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 1, 2, 42, 43, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 58, 162, 163, 164, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 148, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 16, 88, 88, 88, 84, 92, 22, 219, 220, 221, 222, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 219, 183, 221, 222, 42, 43, 78, 79, 46, 78, 79, 80, 81, 82, 83, 84, 125, 126, 127, 170, 239, 16, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 148, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 42, 43, 44, 80, 81, 82, 83, 84, 23, 148, 170, 171, 19, 83, 84, 156, 23, 170, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 19, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 16, 183, 148, 151, 148, 21, 190, 148, 58, 169, 213, 157, 158, 186, 187, 218, 23, 177, 202, 203, 78, 79, 166, 167, 208, 161, 42, 43, 78, 79, 88, 89, 177, 178, 170, 181, 182, 68, 88, 184, 98, 99, 92, 16, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 22, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 42, 43, 78, 0, 1, 2, 125, 126, 127, 226, 11, 162, 88, 89, 231, 228, 229, 16, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 148, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 42, 43, 186, 187, 16, 49, 148, 201, 49, 18, 170, 171, 154, 142, 143, 157, 158, 182, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 91, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 168, 169, 122, 55, 132, 16, 16, 110, 16, 177, 20, 20, 99, 100, 101, 99, 100, 101, 80, 12, 223, 124, 148, 110, 182, 148, 110, 23, 19, 84, 21, 24, 42, 43, 148, 90, 91, 92, 93, 94, 95, 96, 94, 166, 37, 107, 39, 132, 103, 111, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 189, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 16, 84, 156, 92, 20, 23, 92, 134, 91, 92, 93, 94, 95, 96, 103, 148, 22, 88, 89, 148, 103, 210, 106, 156, 108, 109, 42, 43, 144, 145, 228, 229, 219, 149, 221, 222, 190, 170, 171, 240, 156, 170, 171, 162, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 190, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 16, 88, 89, 90, 20, 190, 93, 94, 95, 23, 131, 213, 133, 201, 212, 90, 218, 104, 93, 94, 95, 42, 43, 7, 8, 9, 42, 43, 191, 104, 215, 219, 159, 221, 222, 162, 163, 164, 156, 165, 166, 167, 63, 64, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 242, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 16, 148, 92, 190, 20, 88, 89, 148, 90, 156, 148, 93, 94, 95, 20, 187, 148, 19, 20, 148, 22, 19, 104, 170, 171, 23, 42, 43, 148, 170, 171, 114, 170, 171, 229, 99, 100, 101, 170, 171, 148, 170, 171, 190, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 59, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 16, 211, 212, 12, 148, 21, 213, 165, 166, 167, 21, 148, 23, 148, 148, 24, 217, 19, 20, 217, 22, 88, 89, 157, 158, 214, 42, 43, 37, 148, 39, 106, 148, 108, 109, 170, 171, 20, 146, 183, 49, 156, 14, 16, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 59, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 42, 43, 229, 99, 100, 101, 190, 106, 88, 108, 109, 52, 14, 54, 148, 156, 162, 16, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 215, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 42, 43, 245, 246, 148, 148, 190, 52, 193, 54, 237, 106, 201, 108, 109, 200, 148, 16, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 215, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 42, 43, 25, 189, 22, 232, 29, 134, 183, 16, 237, 202, 203, 148, 148, 192, 148, 16, 41, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 148, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 42, 43, 23, 19, 23, 183, 148, 23, 148, 148, 170, 171, 189, 19, 189, 107, 148, 23, 148, 111, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 148, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 16, 17, 148, 19, 189, 148, 189, 23, 148, 113, 170, 171, 148, 16, 148, 31, 16, 17, 80, 19, 162, 148, 115, 23, 88, 89, 88, 89, 210, 88, 89, 31, 48, 148, 170, 171, 170, 171, 148, 88, 43, 214, 58, 170, 171, 148, 189, 148, 48, 189, 114, 19, 148, 243, 244, 170, 171, 148, 58, 148, 170, 171, 78, 79, 210, 148, 30, 170, 171, 170, 171, 87, 88, 89, 170, 171, 92, 148, 78, 79, 80, 170, 171, 125, 126, 148, 50, 87, 88, 89, 16, 17, 92, 19, 110, 98, 148, 23, 148, 156, 103, 148, 110, 156, 22, 31, 189, 170, 171, 125, 126, 127, 128, 129, 130, 20, 124, 156, 170, 171, 170, 171, 48, 170, 171, 125, 126, 127, 128, 129, 130, 204, 58, 190, 5, 148, 148, 190, 102, 10, 11, 12, 13, 148, 112, 22, 148, 148, 20, 148, 22, 190, 78, 79, 59, 26, 43, 28, 170, 171, 148, 87, 88, 89, 35, 148, 92, 148, 170, 171, 148, 170, 171, 148, 27, 148, 47, 148, 49, 97, 234, 34, 53, 148, 179, 56, 148, 170, 171, 170, 171, 148, 170, 171, 148, 170, 171, 170, 171, 125, 126, 127, 128, 129, 130, 170, 171, 179, 170, 171, 148, 98, 89, 170, 171, 148, 170, 171, 148, 20, 148, 22, 20, 148, 22, 148, 179, 148, 99, 100, 101, 148, 170, 171, 105, 148, 148, 114, 148, 110, 170, 171, 170, 171, 148, 170, 171, 170, 171, 170, 171, 7, 8, 170, 171, 20, 148, 22, 170, 171, 170, 171, 148, 20, 135, 22, 170, 171, 148, 148, 91, 92, 20, 20, 22, 22, 150, 233, 170, 171, 20, 20, 22, 22, 170, 171, 20, 148, 22, 148, 170, 171, 148, 148, 148, 192, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 173, 230, 194, 230, 225, 205, 173, 178, 173, 173, 195, 6, 147, 195, 162, 162, 205, 162, 147, 22, 147, 147, 205, 155, 122, 195, 119, 173, 120, 118, 174, 121, 131, 224, 112, 153, 153, 98, 117, 98, 40, 172, 172, 19, 97, 84, 15, 190, 172, 152, 172, 174, 227, 227, 196, 180, 197, 172, 198, 175, 199, 180, 172, 172, 175, 153, 152, 152, 206, 153, 207, 207, 206, 153, 38, 131, 153, 152, 60, 153, 19, 185, 195, 185, 153, 15, 153, 188, 188, 195, 185, 188, 188, 33, 138, 153, 216, 1, 160, 20, 176, 153, 235, 176, 216, 112, 112, 112, 112, 92, 107, 19, 11, 20, 20, 236, 19, 19, 116, 20, 116, 114, 22, 20, 238, 20, 22, 19, 22, 116, 115, 238, 20, 112, 20, 20, 19, 19, 19, 32, 20, 19, 19, 96, 103, 16, 44, 241, 17, 21, 98, 98, 36, 244, 44, 44, 22, 134, 19, 5, 247, 1, 123, 68, 51, 102, 45, 19, 113, 45, 1, 14, 17, 117, 102, 113, 20, 68, 19, 14, 123, 136, 124, 57, 3, 137, 19, 4, }; 
#define YY_SHIFT_USE_DFLT (-99) 
#define YY_SHIFT_MAX 396 
static const short yy_shift_ofst[] = { 23, 843, 988, -16, 843, 933, 933, 393, 123, 252, -98, 96, 933, 933, 933, 933, 933, -45, 249, 174, 340, -17, 19, 19, 53, 165, 208, 251, 326, 395, 464, 533, 602, 645, 688, 645, 645, 645, 645, 645, 645, 645, 645, 645, 645, 645, 645, 645, 645, 645, 645, 645, 645, 731, 774, 774, 859, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, -61, -61, 6, 6, 281, 22, 61, 856, 284, 340, 340, 68, -17, -11, -99, -99, -99, 131, 328, 609, 609, 547, 616, 253, 607, 340, 607, 340, 340, 340, 340, 340, 340, 340, 340, 340, 340, 340, 340, 340, 340, 340, 340, 340, 233, 851, -98, -98, -98, -99, -99, -99, -18, -18, 405, 467, 327, 551, 543, 635, 343, 466, 795, 800, 797, 496, 340, 340, 274, 340, 340, 810, 340, 340, 982, 340, 340, 340, 588, 982, 340, 340, 895, 895, 895, 340, 340, 340, 588, 340, 340, 588, 340, 750, 485, 340, 340, 588, 340, 340, 340, 588, 340, 340, 340, 588, 588, 340, 340, 340, 340, 340, 345, 724, 755, -17, 817, 817, 359, 1006, 1006, 766, 1006, 972, 1006, -17, 1006, -17, 941, 216, 766, 766, 216, 1171, 1171, 1171, 1171, 1163, -98, 1068, 1073, 1074, 1077, 1076, 1067, 1088, 1088, 1105, 1087, 1105, 1087, 1107, 1107, 1166, 1107, 1113, 1107, 1190, 1127, 1127, 1166, 1107, 1107, 1107, 1190, 1197, 1088, 1197, 1088, 1197, 1088, 1088, 1202, 1110, 1197, 1088, 1184, 1184, 1227, 1068, 1088, 1236, 1236, 1236, 1236, 1068, 1184, 1227, 1088, 1226, 1226, 1088, 1088, 1122, -99, -99, -99, -99, -99, 459, 646, 591, 685, 891, 325, 987, 1058, 322, 1103, 1038, 1061, 1094, 1102, 1111, 1112, 1119, 1120, 150, 1125, 954, 1262, 1245, 1159, 1160, 1161, 1162, 1183, 1169, 1258, 1259, 1260, 1263, 1267, 1264, 1265, 1266, 1269, 1271, 1270, 1168, 1272, 1170, 1270, 1173, 1274, 1179, 1181, 1278, 1187, 1280, 1281, 1273, 1268, 1283, 1276, 1284, 1286, 1285, 1288, 1277, 1289, 1213, 1207, 1295, 1297, 1294, 1218, 1282, 1279, 1287, 1300, 1290, 1189, 1219, 1305, 1320, 1326, 1229, 1261, 1275, 1205, 1314, 1221, 1335, 1323, 1222, 1321, 1228, 1238, 1223, 1325, 1224, 1322, 1331, 1292, 1211, 1214, 1333, 1347, 1349, }; 
#define YY_REDUCE_USE_DFLT (-144) 
#define YY_REDUCE_MAX 295 
static const short yy_reduce_ofst[] = { -139, 278, 295, 292, 402, -22, 408, 35, 37, 546, -3, -128, 133, 282, 411, 417, 420, -143, 503, 213, 151, 353, 354, 460, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 483, 656, 699, 723, 725, 732, 744, 749, 756, 758, 763, 770, 796, 807, 809, 812, 847, 857, 860, 876, 878, 881, 884, 886, 894, 897, 902, 905, 921, 929, 931, 934, 936, 938, 942, 947, 949, 955, 967, 973, 979, 224, 224, 224, 224, 168, 224, 224, 36, 33, 210, 484, 224, -121, 224, 224, 224, 224, 45, 21, 8, 109, 487, 487, 164, 99, 222, 541, -91, -1, 474, 598, 587, 677, 638, 429, 713, 639, 641, 674, 676, 716, 719, 686, 776, 257, 362, 802, 806, 820, 545, 582, 669, -60, -15, 128, 178, 317, 40, 317, 317, 377, 441, 481, 499, 502, 510, 553, 586, 596, 502, 684, 717, 768, 788, 786, 846, 854, 858, 317, 786, 871, 888, 864, 887, 906, 926, 946, 980, 317, 998, 1000, 317, 1003, 903, 805, 1004, 1005, 317, 1007, 1008, 1009, 317, 1010, 1011, 1012, 317, 317, 1013, 1014, 1015, 1016, 1017, 985, 962, 974, 1018, 937, 939, 945, 993, 999, 966, 1001, 995, 1002, 1019, 1020, 1021, 1022, 981, 977, 983, 984, 1031, 1037, 1039, 1040, 1034, 1023, 996, 1024, 1025, 1026, 1027, 975, 1048, 1049, 1028, 1029, 1032, 1030, 1035, 1036, 1041, 1042, 1043, 1044, 1050, 991, 992, 1047, 1051, 1056, 1057, 1055, 1063, 1078, 1080, 1082, 1081, 1086, 1089, 1033, 1045, 1091, 1092, 1062, 1064, 1046, 1053, 1097, 1065, 1066, 1069, 1070, 1060, 1071, 1054, 1099, 1052, 1059, 1108, 1114, 1072, 1104, 1090, 1093, 1075, 1079, }; static const YYACTIONTYPE yy_default[] = { 603, 832, 913, 719, 913, 832, 913, 913, 859, 913, 723, 888, 830, 913, 913, 913, 913, 804, 913, 859, 913, 635, 859, 859, 755, 913, 913, 913, 913, 913, 913, 913, 913, 756, 913, 834, 829, 825, 827, 826, 833, 757, 746, 753, 760, 735, 872, 762, 763, 769, 770, 889, 887, 792, 791, 810, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 794, 816, 793, 803, 628, 795, 796, 688, 623, 913, 913, 797, 913, 798, 811, 812, 813, 913, 913, 913, 913, 913, 913, 603, 719, 913, 719, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 713, 723, 906, 913, 913, 679, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 611, 609, 913, 711, 913, 913, 637, 913, 913, 721, 913, 913, 913, 726, 727, 913, 913, 913, 913, 913, 913, 913, 913, 625, 913, 913, 700, 913, 865, 913, 913, 913, 879, 913, 913, 913, 877, 913, 913, 913, 702, 765, 845, 913, 892, 894, 913, 913, 711, 720, 913, 913, 913, 828, 749, 749, 737, 749, 658, 749, 913, 749, 913, 661, 759, 737, 737, 759, 608, 608, 608, 608, 678, 913, 759, 750, 752, 742, 754, 913, 728, 728, 736, 741, 736, 741, 690, 690, 675, 690, 661, 690, 838, 842, 842, 675, 690, 690, 690, 838, 620, 728, 620, 728, 620, 728, 728, 869, 871, 620, 728, 692, 692, 771, 759, 728, 699, 699, 699, 699, 759, 692, 771, 728, 891, 891, 728, 728, 899, 645, 663, 663, 906, 911, 913, 913, 913, 913, 778, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 852, 913, 913, 913, 913, 783, 779, 913, 780, 913, 705, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 831, 913, 743, 913, 751, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 867, 868, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 913, 898, 913, 913, 901, 604, 913, 599, 601, 602, 606, 607, 610, 632, 633, 634, 612, 613, 614, 615, 616, 617, 618, 624, 626, 644, 646, 630, 648, 709, 710, 775, 703, 704, 708, 631, 786, 777, 781, 782, 784, 785, 799, 800, 802, 808, 815, 818, 801, 806, 807, 809, 814, 817, 706, 707, 821, 638, 639, 642, 643, 855, 857, 856, 858, 641, 640, 787, 790, 823, 824, 880, 881, 882, 883, 884, 819, 729, 822, 805, 744, 747, 748, 745, 712, 722, 731, 732, 733, 734, 717, 718, 724, 740, 773, 774, 738, 739, 725, 714, 715, 716, 820, 776, 788, 789, 649, 650, 783, 651, 652, 653, 691, 694, 695, 696, 654, 673, 676, 677, 655, 662, 656, 657, 664, 665, 666, 669, 670, 671, 672, 667, 668, 839, 840, 843, 841, 659, 660, 674, 647, 636, 629, 680, 683, 684, 685, 686, 687, 689, 681, 682, 627, 619, 621, 730, 861, 870, 866, 862, 863, 864, 622, 835, 836, 693, 767, 768, 860, 873, 875, 772, 876, 878, 874, 903, 697, 698, 701, 844, 885, 758, 761, 764, 766, 846, 847, 848, 849, 850, 853, 854, 851, 886, 890, 893, 895, 896, 897, 900, 902, 907, 908, 909, 912, 910, 605, 600, }; 
#define YY_SZ_ACTTAB (int)(sizeof(yy_action)/sizeof(yy_action[0])) 
#ifdef YYFALLBACK 
static const YYCODETYPE yyFallback[] = { 0, 0, 23, 23, 23, 23, 0, 23, 23, 23, 0, 23, 0, 0, 0, 23, 0, 0, 23, 0, 0, 0, 0, 0, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, }; 
#endif 
struct yyStackEntry { YYACTIONTYPE stateno; YYCODETYPE major; YYMINORTYPE minor; }; typedef struct yyStackEntry yyStackEntry; struct yyParser { int yyidx; 
#ifdef YYTRACKMAXSTACKDEPTH 
 int yyidxMax; 
#endif 
 int yyerrcnt; sqlite3ParserARG_SDECL 
#if YYSTACKDEPTH<=0 
 int yystksz; yyStackEntry *yystack; 
#else 
 yyStackEntry yystack[YYSTACKDEPTH]; 
#endif 
}; typedef struct yyParser yyParser; 
#ifndef NDEBUG 
static FILE *yyTraceFILE = 0; static char *yyTracePrompt = 0; 
#endif 
#ifndef NDEBUG 
SQLITE_PRIVATE void sqlite3ParserTrace(FILE *TraceFILE, char *zTracePrompt){ yyTraceFILE = TraceFILE; yyTracePrompt = zTracePrompt; if( yyTraceFILE==0 ) yyTracePrompt = 0; else if( yyTracePrompt==0 ) yyTraceFILE = 0; } 
#endif 
#ifndef NDEBUG 
static const char *const yyTokenName[] = { "$", "SEMI", "EXPLAIN", "QUERY", "PLAN", "BEGIN", "TRANSACTION", "DEFERRED", "IMMEDIATE", "EXCLUSIVE", "COMMIT", "END", "ROLLBACK", "CREATE", "TABLE", "IF", "NOT", "EXISTS", "TEMP", "LP", "RP", "AS", "COMMA", "ID", "ABORT", "AFTER", "ANALYZE", "ASC", "ATTACH", "BEFORE", "CASCADE", "CAST", "CONFLICT", "DATABASE", "DESC", "DETACH", "EACH", "FAIL", "FOR", "IGNORE", "INITIALLY", "INSTEAD", "LIKE_KW", "MATCH", "KEY", "OF", "OFFSET", "PRAGMA", "RAISE", "REPLACE", "RESTRICT", "ROW", "TRIGGER", "VACUUM", "VIEW", "VIRTUAL", "REINDEX", "RENAME", "CTIME_KW", "ANY", "OR", "AND", "IS", "BETWEEN", "IN", "ISNULL", "NOTNULL", "NE", "EQ", "GT", "LE", "LT", "GE", "ESCAPE", "BITAND", "BITOR", "LSHIFT", "RSHIFT", "PLUS", "MINUS", "STAR", "SLASH", "REM", "CONCAT", "COLLATE", "UMINUS", "UPLUS", "BITNOT", "STRING", "JOIN_KW", "CONSTRAINT", "DEFAULT", "NULL", "PRIMARY", "UNIQUE", "CHECK", "REFERENCES", "AUTOINCR", "ON", "DELETE", "UPDATE", "INSERT", "SET", "DEFERRABLE", "FOREIGN", "DROP", "UNION", "ALL", "EXCEPT", "INTERSECT", "SELECT", "DISTINCT", "DOT", "FROM", "JOIN", "INDEXED", "BY", "USING", "ORDER", "GROUP", "HAVING", "LIMIT", "WHERE", "INTO", "VALUES", "INTEGER", "FLOAT", "BLOB", "REGISTER", "VARIABLE", "CASE", "WHEN", "THEN", "ELSE", "INDEX", "ALTER", "TO", "ADD", "COLUMNKW", "error", "input", "cmdlist", "ecmd", "explain", "cmdx", "cmd", "transtype", "trans_opt", "nm", "create_table", "create_table_args", "temp", "ifnotexists", "dbnm", "columnlist", "conslist_opt", "select", "column", "columnid", "type", "carglist", "id", "ids", "typetoken", "typename", "signed", "plus_num", "minus_num", "carg", "ccons", "term", "expr", "onconf", "sortorder", "autoinc", "idxlist_opt", "refargs", "defer_subclause", "refarg", "refact", "init_deferred_pred_opt", "conslist", "tcons", "idxlist", "defer_subclause_opt", "orconf", "resolvetype", "raisetype", "ifexists", "fullname", "oneselect", "multiselect_op", "distinct", "selcollist", "from", "where_opt", "groupby_opt", "having_opt", "orderby_opt", "limit_opt", "sclp", "as", "seltablist", "stl_prefix", "joinop", "indexed_opt", "on_opt", "using_opt", "seltablist_paren", "joinop2", "inscollist", "sortlist", "sortitem", "nexprlist", "setlist", "insert_cmd", "inscollist_opt", "itemlist", "exprlist", "likeop", "escape", "between_op", "in_op", "case_operand", "case_exprlist", "case_else", "uniqueflag", "collate", "nmnum", "plus_opt", "number", "trigger_decl", "trigger_cmd_list", "trigger_time", "trigger_event", "foreach_clause", "when_clause", "trigger_cmd", "database_kw_opt", "key_opt", "add_column_fullname", "kwcolumn_opt", "create_vtab", "vtabarglist", "vtabarg", "vtabargtoken", "lp", "anylist", }; 
#endif 
#ifndef NDEBUG 
static const char *const yyRuleName[] = { "input ::= cmdlist", "cmdlist ::= cmdlist ecmd", "cmdlist ::= ecmd", "ecmd ::= SEMI", "ecmd ::= explain cmdx SEMI", "explain ::=", "explain ::= EXPLAIN", "explain ::= EXPLAIN QUERY PLAN", "cmdx ::= cmd", "cmd ::= BEGIN transtype trans_opt", "trans_opt ::=", "trans_opt ::= TRANSACTION", "trans_opt ::= TRANSACTION nm", "transtype ::=", "transtype ::= DEFERRED", "transtype ::= IMMEDIATE", "transtype ::= EXCLUSIVE", "cmd ::= COMMIT trans_opt", "cmd ::= END trans_opt", "cmd ::= ROLLBACK trans_opt", "cmd ::= create_table create_table_args", "create_table ::= CREATE temp TABLE ifnotexists nm dbnm", "ifnotexists ::=", "ifnotexists ::= IF NOT EXISTS", "temp ::= TEMP", "temp ::=", "create_table_args ::= LP columnlist conslist_opt RP", "create_table_args ::= AS select", "columnlist ::= columnlist COMMA column", "columnlist ::= column", "column ::= columnid type carglist", "columnid ::= nm", "id ::= ID", "ids ::= ID|STRING", "nm ::= ID", "nm ::= STRING", "nm ::= JOIN_KW", "type ::=", "type ::= typetoken", "typetoken ::= typename", "typetoken ::= typename LP signed RP", "typetoken ::= typename LP signed COMMA signed RP", "typename ::= ids", "typename ::= typename ids", "signed ::= plus_num", "signed ::= minus_num", "carglist ::= carglist carg", "carglist ::=", "carg ::= CONSTRAINT nm ccons", "carg ::= ccons", "ccons ::= DEFAULT term", "ccons ::= DEFAULT LP expr RP", "ccons ::= DEFAULT PLUS term", "ccons ::= DEFAULT MINUS term", "ccons ::= DEFAULT id", "ccons ::= NULL onconf", "ccons ::= NOT NULL onconf", "ccons ::= PRIMARY KEY sortorder onconf autoinc", "ccons ::= UNIQUE onconf", "ccons ::= CHECK LP expr RP", "ccons ::= REFERENCES nm idxlist_opt refargs", "ccons ::= defer_subclause", "ccons ::= COLLATE ids", "autoinc ::=", "autoinc ::= AUTOINCR", "refargs ::=", "refargs ::= refargs refarg", "refarg ::= MATCH nm", "refarg ::= ON DELETE refact", "refarg ::= ON UPDATE refact", "refarg ::= ON INSERT refact", "refact ::= SET NULL", "refact ::= SET DEFAULT", "refact ::= CASCADE", "refact ::= RESTRICT", "defer_subclause ::= NOT DEFERRABLE init_deferred_pred_opt", "defer_subclause ::= DEFERRABLE init_deferred_pred_opt", "init_deferred_pred_opt ::=", "init_deferred_pred_opt ::= INITIALLY DEFERRED", "init_deferred_pred_opt ::= INITIALLY IMMEDIATE", "conslist_opt ::=", "conslist_opt ::= COMMA conslist", "conslist ::= conslist COMMA tcons", "conslist ::= conslist tcons", "conslist ::= tcons", "tcons ::= CONSTRAINT nm", "tcons ::= PRIMARY KEY LP idxlist autoinc RP onconf", "tcons ::= UNIQUE LP idxlist RP onconf", "tcons ::= CHECK LP expr RP onconf", "tcons ::= FOREIGN KEY LP idxlist RP REFERENCES nm idxlist_opt refargs defer_subclause_opt", "defer_subclause_opt ::=", "defer_subclause_opt ::= defer_subclause", "onconf ::=", "onconf ::= ON CONFLICT resolvetype", "orconf ::=", "orconf ::= OR resolvetype", "resolvetype ::= raisetype", "resolvetype ::= IGNORE", "resolvetype ::= REPLACE", "cmd ::= DROP TABLE ifexists fullname", "ifexists ::= IF EXISTS", "ifexists ::=", "cmd ::= CREATE temp VIEW ifnotexists nm dbnm AS select", "cmd ::= DROP VIEW ifexists fullname", "cmd ::= select", "select ::= oneselect", "select ::= select multiselect_op oneselect", "multiselect_op ::= UNION", "multiselect_op ::= UNION ALL", "multiselect_op ::= EXCEPT|INTERSECT", "oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt", "distinct ::= DISTINCT", "distinct ::= ALL", "distinct ::=", "sclp ::= selcollist COMMA", "sclp ::=", "selcollist ::= sclp expr as", "selcollist ::= sclp STAR", "selcollist ::= sclp nm DOT STAR", "as ::= AS nm", "as ::= ids", "as ::=", "from ::=", "from ::= FROM seltablist", "stl_prefix ::= seltablist joinop", "stl_prefix ::=", "seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt", "seltablist ::= stl_prefix LP seltablist_paren RP as on_opt using_opt", "seltablist_paren ::= select", "seltablist_paren ::= seltablist", "dbnm ::=", "dbnm ::= DOT nm", "fullname ::= nm dbnm", "joinop ::= COMMA|JOIN", "joinop ::= JOIN_KW JOIN", "joinop ::= JOIN_KW nm JOIN", "joinop ::= JOIN_KW nm nm JOIN", "on_opt ::= ON expr", "on_opt ::=", "indexed_opt ::=", "indexed_opt ::= INDEXED BY nm", "indexed_opt ::= NOT INDEXED", "using_opt ::= USING LP inscollist RP", "using_opt ::=", "orderby_opt ::=", "orderby_opt ::= ORDER BY sortlist", "sortlist ::= sortlist COMMA sortitem sortorder", "sortlist ::= sortitem sortorder", "sortitem ::= expr", "sortorder ::= ASC", "sortorder ::= DESC", "sortorder ::=", "groupby_opt ::=", "groupby_opt ::= GROUP BY nexprlist", "having_opt ::=", "having_opt ::= HAVING expr", "limit_opt ::=", "limit_opt ::= LIMIT expr", "limit_opt ::= LIMIT expr OFFSET expr", "limit_opt ::= LIMIT expr COMMA expr", "cmd ::= DELETE FROM fullname indexed_opt where_opt", "where_opt ::=", "where_opt ::= WHERE expr", "cmd ::= UPDATE orconf fullname indexed_opt SET setlist where_opt", "setlist ::= setlist COMMA nm EQ expr", "setlist ::= nm EQ expr", "cmd ::= insert_cmd INTO fullname inscollist_opt VALUES LP itemlist RP", "cmd ::= insert_cmd INTO fullname inscollist_opt select", "cmd ::= insert_cmd INTO fullname inscollist_opt DEFAULT VALUES", "insert_cmd ::= INSERT orconf", "insert_cmd ::= REPLACE", "itemlist ::= itemlist COMMA expr", "itemlist ::= expr", "inscollist_opt ::=", "inscollist_opt ::= LP inscollist RP", "inscollist ::= inscollist COMMA nm", "inscollist ::= nm", "expr ::= term", "expr ::= LP expr RP", "term ::= NULL", "expr ::= ID", "expr ::= JOIN_KW", "expr ::= nm DOT nm", "expr ::= nm DOT nm DOT nm", "term ::= INTEGER|FLOAT|BLOB", "term ::= STRING", "expr ::= REGISTER", "expr ::= VARIABLE", "expr ::= expr COLLATE ids", "expr ::= CAST LP expr AS typetoken RP", "expr ::= ID LP distinct exprlist RP", "expr ::= ID LP STAR RP", "term ::= CTIME_KW", "expr ::= expr AND expr", "expr ::= expr OR expr", "expr ::= expr LT|GT|GE|LE expr", "expr ::= expr EQ|NE expr", "expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr", "expr ::= expr PLUS|MINUS expr", "expr ::= expr STAR|SLASH|REM expr", "expr ::= expr CONCAT expr", "likeop ::= LIKE_KW", "likeop ::= NOT LIKE_KW", "likeop ::= MATCH", "likeop ::= NOT MATCH", "escape ::= ESCAPE expr", "escape ::=", "expr ::= expr likeop expr escape", "expr ::= expr ISNULL|NOTNULL", "expr ::= expr IS NULL", "expr ::= expr NOT NULL", "expr ::= expr IS NOT NULL", "expr ::= NOT expr", "expr ::= BITNOT expr", "expr ::= MINUS expr", "expr ::= PLUS expr", "between_op ::= BETWEEN", "between_op ::= NOT BETWEEN", "expr ::= expr between_op expr AND expr", "in_op ::= IN", "in_op ::= NOT IN", "expr ::= expr in_op LP exprlist RP", "expr ::= LP select RP", "expr ::= expr in_op LP select RP", "expr ::= expr in_op nm dbnm", "expr ::= EXISTS LP select RP", "expr ::= CASE case_operand case_exprlist case_else END", "case_exprlist ::= case_exprlist WHEN expr THEN expr", "case_exprlist ::= WHEN expr THEN expr", "case_else ::= ELSE expr", "case_else ::=", "case_operand ::= expr", "case_operand ::=", "exprlist ::= nexprlist", "exprlist ::=", "nexprlist ::= nexprlist COMMA expr", "nexprlist ::= expr", "cmd ::= CREATE uniqueflag INDEX ifnotexists nm dbnm ON nm LP idxlist RP", "uniqueflag ::= UNIQUE", "uniqueflag ::=", "idxlist_opt ::=", "idxlist_opt ::= LP idxlist RP", "idxlist ::= idxlist COMMA nm collate sortorder", "idxlist ::= nm collate sortorder", "collate ::=", "collate ::= COLLATE ids", "cmd ::= DROP INDEX ifexists fullname", "cmd ::= VACUUM", "cmd ::= VACUUM nm", "cmd ::= PRAGMA nm dbnm EQ nmnum", "cmd ::= PRAGMA nm dbnm EQ ON", "cmd ::= PRAGMA nm dbnm EQ DELETE", "cmd ::= PRAGMA nm dbnm EQ minus_num", "cmd ::= PRAGMA nm dbnm LP nmnum RP", "cmd ::= PRAGMA nm dbnm", "nmnum ::= plus_num", "nmnum ::= nm", "plus_num ::= plus_opt number", "minus_num ::= MINUS number", "number ::= INTEGER|FLOAT", "plus_opt ::= PLUS", "plus_opt ::=", "cmd ::= CREATE trigger_decl BEGIN trigger_cmd_list END", "trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause", "trigger_time ::= BEFORE", "trigger_time ::= AFTER", "trigger_time ::= INSTEAD OF", "trigger_time ::=", "trigger_event ::= DELETE|INSERT", "trigger_event ::= UPDATE", "trigger_event ::= UPDATE OF inscollist", "foreach_clause ::=", "foreach_clause ::= FOR EACH ROW", "when_clause ::=", "when_clause ::= WHEN expr", "trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI", "trigger_cmd_list ::= trigger_cmd SEMI", "trigger_cmd ::= UPDATE orconf nm SET setlist where_opt", "trigger_cmd ::= insert_cmd INTO nm inscollist_opt VALUES LP itemlist RP", "trigger_cmd ::= insert_cmd INTO nm inscollist_opt select", "trigger_cmd ::= DELETE FROM nm where_opt", "trigger_cmd ::= select", "expr ::= RAISE LP IGNORE RP", "expr ::= RAISE LP raisetype COMMA nm RP", "raisetype ::= ROLLBACK", "raisetype ::= ABORT", "raisetype ::= FAIL", "cmd ::= DROP TRIGGER ifexists fullname", "cmd ::= ATTACH database_kw_opt expr AS expr key_opt", "cmd ::= DETACH database_kw_opt expr", "key_opt ::=", "key_opt ::= KEY expr", "database_kw_opt ::= DATABASE", "database_kw_opt ::=", "cmd ::= REINDEX", "cmd ::= REINDEX nm dbnm", "cmd ::= ANALYZE", "cmd ::= ANALYZE nm dbnm", "cmd ::= ALTER TABLE fullname RENAME TO nm", "cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt column", "add_column_fullname ::= fullname", "kwcolumn_opt ::=", "kwcolumn_opt ::= COLUMNKW", "cmd ::= create_vtab", "cmd ::= create_vtab LP vtabarglist RP", "create_vtab ::= CREATE VIRTUAL TABLE nm dbnm USING nm", "vtabarglist ::= vtabarg", "vtabarglist ::= vtabarglist COMMA vtabarg", "vtabarg ::=", "vtabarg ::= vtabarg vtabargtoken", "vtabargtoken ::= ANY", "vtabargtoken ::= lp anylist RP", "lp ::= LP", "anylist ::=", "anylist ::= anylist ANY", }; 
#endif 
#if YYSTACKDEPTH<=0 
static void yyGrowStack(yyParser *p){ int newSize; yyStackEntry *pNew; newSize = p->yystksz*2 + 100; pNew = realloc(p->yystack, newSize*sizeof(pNew[0])); if( pNew ){ p->yystack = pNew; p->yystksz = newSize; 
#ifndef NDEBUG 
 if( yyTraceFILE ){ fprintf(yyTraceFILE,"%sStack grows to %d entries!\n", yyTracePrompt, p->yystksz); } 
#endif 
 } } 
#endif 
SQLITE_PRIVATE void *sqlite3ParserAlloc(void *(*mallocProc)(size_t)){ yyParser *pParser; pParser = (yyParser*)(*mallocProc)( (size_t)sizeof(yyParser) ); if( pParser ){ pParser->yyidx = -1; 
#ifdef YYTRACKMAXSTACKDEPTH 
 pParser->yyidxMax = 0; 
#endif 
#if YYSTACKDEPTH<=0 
 pParser->yystack = NULL; pParser->yystksz = 0; yyGrowStack(pParser); 
#endif 
 } return pParser; } static void yy_destructor( yyParser *yypParser, YYCODETYPE yymajor, YYMINORTYPE *yypminor ){ sqlite3ParserARG_FETCH; switch( yymajor ){ case 156: case 190: case 208: { sqlite3SelectDelete(pParse->db, (yypminor->yy43)); } break; case 170: case 171: case 195: case 197: case 206: case 212: case 220: case 223: case 225: case 236: case 239: { sqlite3ExprDelete(pParse->db, (yypminor->yy450)); } break; case 175: case 183: case 193: case 196: case 198: case 200: case 211: case 213: case 214: case 217: case 218: case 224: { sqlite3ExprListDelete(pParse->db, (yypminor->yy242)); } break; case 189: case 194: case 202: case 203: { sqlite3SrcListDelete(pParse->db, (yypminor->yy419)); } break; case 207: case 210: case 216: { sqlite3IdListDelete(pParse->db, (yypminor->yy352)); } break; case 232: case 237: { sqlite3DeleteTriggerStep(pParse->db, (yypminor->yy75)); } break; case 234: { sqlite3IdListDelete(pParse->db, (yypminor->yy354).b); } break; default: break; } } static int yy_pop_parser_stack(yyParser *pParser){ YYCODETYPE yymajor; yyStackEntry *yytos = &pParser->yystack[pParser->yyidx]; if( pParser->yyidx<0 ) return 0; 
#ifndef NDEBUG 
 if( yyTraceFILE && pParser->yyidx>=0 ){ fprintf(yyTraceFILE,"%sPopping %s\n", yyTracePrompt, yyTokenName[yytos->major]); } 
#endif 
 yymajor = yytos->major; yy_destructor(pParser, yymajor, &yytos->minor); pParser->yyidx--; return yymajor; } SQLITE_PRIVATE void sqlite3ParserFree( void *p, void (*freeProc)(void*) ){ yyParser *pParser = (yyParser*)p; if( pParser==0 ) return; while( pParser->yyidx>=0 ) yy_pop_parser_stack(pParser); 
#if YYSTACKDEPTH<=0 
 free(pParser->yystack); 
#endif 
 (*freeProc)((void*)pParser); } 
#ifdef YYTRACKMAXSTACKDEPTH 
SQLITE_PRIVATE int sqlite3ParserStackPeak(void *p){ yyParser *pParser = (yyParser*)p; return pParser->yyidxMax; } 
#endif 
static int yy_find_shift_action( yyParser *pParser, YYCODETYPE iLookAhead ){ int i; int stateno = pParser->yystack[pParser->yyidx].stateno; if( stateno>YY_SHIFT_MAX || (i = yy_shift_ofst[stateno])==YY_SHIFT_USE_DFLT ){ return yy_default[stateno]; } assert( iLookAhead!=YYNOCODE ); i += iLookAhead; if( i<0 || i>=YY_SZ_ACTTAB || yy_lookahead[i]!=iLookAhead ){ if( iLookAhead>0 ){ 
#ifdef YYFALLBACK 
 int iFallback; if( iLookAhead<sizeof(yyFallback)/sizeof(yyFallback[0]) && (iFallback = yyFallback[iLookAhead])!=0 ){ 
#ifndef NDEBUG 
 if( yyTraceFILE ){ fprintf(yyTraceFILE, "%sFALLBACK %s => %s\n", yyTracePrompt, yyTokenName[iLookAhead], yyTokenName[iFallback]); } 
#endif 
 return yy_find_shift_action(pParser, iFallback); } 
#endif 
#ifdef YYWILDCARD 
 { int j = i - iLookAhead + YYWILDCARD; if( j>=0 && j<YY_SZ_ACTTAB && yy_lookahead[j]==YYWILDCARD ){ 
#ifndef NDEBUG 
 if( yyTraceFILE ){ fprintf(yyTraceFILE, "%sWILDCARD %s => %s\n", yyTracePrompt, yyTokenName[iLookAhead], yyTokenName[YYWILDCARD]); } 
#endif 
 return yy_action[j]; } } 
#endif 
 } return yy_default[stateno]; }else{ return yy_action[i]; } } static int yy_find_reduce_action( int stateno, YYCODETYPE iLookAhead ){ int i; 
#ifdef YYERRORSYMBOL 
 if( stateno>YY_REDUCE_MAX ){ return yy_default[stateno]; } 
#else 
 assert( stateno<=YY_REDUCE_MAX ); 
#endif 
 i = yy_reduce_ofst[stateno]; assert( i!=YY_REDUCE_USE_DFLT ); assert( iLookAhead!=YYNOCODE ); i += iLookAhead; 
#ifdef YYERRORSYMBOL 
 if( i<0 || i>=YY_SZ_ACTTAB || yy_lookahead[i]!=iLookAhead ){ return yy_default[stateno]; } 
#else 
 assert( i>=0 && i<YY_SZ_ACTTAB ); assert( yy_lookahead[i]==iLookAhead ); 
#endif 
 return yy_action[i]; } static void yyStackOverflow(yyParser *yypParser, YYMINORTYPE *yypMinor){ sqlite3ParserARG_FETCH; yypParser->yyidx--; 
#ifndef NDEBUG 
 if( yyTraceFILE ){ fprintf(yyTraceFILE,"%sStack Overflow!\n",yyTracePrompt); } 
#endif 
 while( yypParser->yyidx>=0 ) yy_pop_parser_stack(yypParser); sqlite3ErrorMsg(pParse, "parser stack overflow"); pParse->parseError = 1; sqlite3ParserARG_STORE; } static void yy_shift( yyParser *yypParser, int yyNewState, int yyMajor, YYMINORTYPE *yypMinor ){ yyStackEntry *yytos; yypParser->yyidx++; 
#ifdef YYTRACKMAXSTACKDEPTH 
 if( yypParser->yyidx>yypParser->yyidxMax ){ yypParser->yyidxMax = yypParser->yyidx; } 
#endif 
#if YYSTACKDEPTH>0 
 if( yypParser->yyidx>=YYSTACKDEPTH ){ yyStackOverflow(yypParser, yypMinor); return; } 
#else 
 if( yypParser->yyidx>=yypParser->yystksz ){ yyGrowStack(yypParser); if( yypParser->yyidx>=yypParser->yystksz ){ yyStackOverflow(yypParser, yypMinor); return; } } 
#endif 
 yytos = &yypParser->yystack[yypParser->yyidx]; yytos->stateno = yyNewState; yytos->major = yyMajor; yytos->minor = *yypMinor; 
#ifndef NDEBUG 
 if( yyTraceFILE && yypParser->yyidx>0 ){ int i; fprintf(yyTraceFILE,"%sShift %d\n",yyTracePrompt,yyNewState); fprintf(yyTraceFILE,"%sStack:",yyTracePrompt); for(i=1; i<=yypParser->yyidx; i++) fprintf(yyTraceFILE," %s",yyTokenName[yypParser->yystack[i].major]); fprintf(yyTraceFILE,"\n"); } 
#endif 
} static const struct { YYCODETYPE lhs; unsigned char nrhs; } yyRuleInfo[] = { { 140, 1 }, { 141, 2 }, { 141, 1 }, { 142, 1 }, { 142, 3 }, { 143, 0 }, { 143, 1 }, { 143, 3 }, { 144, 1 }, { 145, 3 }, { 147, 0 }, { 147, 1 }, { 147, 2 }, { 146, 0 }, { 146, 1 }, { 146, 1 }, { 146, 1 }, { 145, 2 }, { 145, 2 }, { 145, 2 }, { 145, 2 }, { 149, 6 }, { 152, 0 }, { 152, 3 }, { 151, 1 }, { 151, 0 }, { 150, 4 }, { 150, 2 }, { 154, 3 }, { 154, 1 }, { 157, 3 }, { 158, 1 }, { 161, 1 }, { 162, 1 }, { 148, 1 }, { 148, 1 }, { 148, 1 }, { 159, 0 }, { 159, 1 }, { 163, 1 }, { 163, 4 }, { 163, 6 }, { 164, 1 }, { 164, 2 }, { 165, 1 }, { 165, 1 }, { 160, 2 }, { 160, 0 }, { 168, 3 }, { 168, 1 }, { 169, 2 }, { 169, 4 }, { 169, 3 }, { 169, 3 }, { 169, 2 }, { 169, 2 }, { 169, 3 }, { 169, 5 }, { 169, 2 }, { 169, 4 }, { 169, 4 }, { 169, 1 }, { 169, 2 }, { 174, 0 }, { 174, 1 }, { 176, 0 }, { 176, 2 }, { 178, 2 }, { 178, 3 }, { 178, 3 }, { 178, 3 }, { 179, 2 }, { 179, 2 }, { 179, 1 }, { 179, 1 }, { 177, 3 }, { 177, 2 }, { 180, 0 }, { 180, 2 }, { 180, 2 }, { 155, 0 }, { 155, 2 }, { 181, 3 }, { 181, 2 }, { 181, 1 }, { 182, 2 }, { 182, 7 }, { 182, 5 }, { 182, 5 }, { 182, 10 }, { 184, 0 }, { 184, 1 }, { 172, 0 }, { 172, 3 }, { 185, 0 }, { 185, 2 }, { 186, 1 }, { 186, 1 }, { 186, 1 }, { 145, 4 }, { 188, 2 }, { 188, 0 }, { 145, 8 }, { 145, 4 }, { 145, 1 }, { 156, 1 }, { 156, 3 }, { 191, 1 }, { 191, 2 }, { 191, 1 }, { 190, 9 }, { 192, 1 }, { 192, 1 }, { 192, 0 }, { 200, 2 }, { 200, 0 }, { 193, 3 }, { 193, 2 }, { 193, 4 }, { 201, 2 }, { 201, 1 }, { 201, 0 }, { 194, 0 }, { 194, 2 }, { 203, 2 }, { 203, 0 }, { 202, 7 }, { 202, 7 }, { 208, 1 }, { 208, 1 }, { 153, 0 }, { 153, 2 }, { 189, 2 }, { 204, 1 }, { 204, 2 }, { 204, 3 }, { 204, 4 }, { 206, 2 }, { 206, 0 }, { 205, 0 }, { 205, 3 }, { 205, 2 }, { 207, 4 }, { 207, 0 }, { 198, 0 }, { 198, 3 }, { 211, 4 }, { 211, 2 }, { 212, 1 }, { 173, 1 }, { 173, 1 }, { 173, 0 }, { 196, 0 }, { 196, 3 }, { 197, 0 }, { 197, 2 }, { 199, 0 }, { 199, 2 }, { 199, 4 }, { 199, 4 }, { 145, 5 }, { 195, 0 }, { 195, 2 }, { 145, 7 }, { 214, 5 }, { 214, 3 }, { 145, 8 }, { 145, 5 }, { 145, 6 }, { 215, 2 }, { 215, 1 }, { 217, 3 }, { 217, 1 }, { 216, 0 }, { 216, 3 }, { 210, 3 }, { 210, 1 }, { 171, 1 }, { 171, 3 }, { 170, 1 }, { 171, 1 }, { 171, 1 }, { 171, 3 }, { 171, 5 }, { 170, 1 }, { 170, 1 }, { 171, 1 }, { 171, 1 }, { 171, 3 }, { 171, 6 }, { 171, 5 }, { 171, 4 }, { 170, 1 }, { 171, 3 }, { 171, 3 }, { 171, 3 }, { 171, 3 }, { 171, 3 }, { 171, 3 }, { 171, 3 }, { 171, 3 }, { 219, 1 }, { 219, 2 }, { 219, 1 }, { 219, 2 }, { 220, 2 }, { 220, 0 }, { 171, 4 }, { 171, 2 }, { 171, 3 }, { 171, 3 }, { 171, 4 }, { 171, 2 }, { 171, 2 }, { 171, 2 }, { 171, 2 }, { 221, 1 }, { 221, 2 }, { 171, 5 }, { 222, 1 }, { 222, 2 }, { 171, 5 }, { 171, 3 }, { 171, 5 }, { 171, 4 }, { 171, 4 }, { 171, 5 }, { 224, 5 }, { 224, 4 }, { 225, 2 }, { 225, 0 }, { 223, 1 }, { 223, 0 }, { 218, 1 }, { 218, 0 }, { 213, 3 }, { 213, 1 }, { 145, 11 }, { 226, 1 }, { 226, 0 }, { 175, 0 }, { 175, 3 }, { 183, 5 }, { 183, 3 }, { 227, 0 }, { 227, 2 }, { 145, 4 }, { 145, 1 }, { 145, 2 }, { 145, 5 }, { 145, 5 }, { 145, 5 }, { 145, 5 }, { 145, 6 }, { 145, 3 }, { 228, 1 }, { 228, 1 }, { 166, 2 }, { 167, 2 }, { 230, 1 }, { 229, 1 }, { 229, 0 }, { 145, 5 }, { 231, 11 }, { 233, 1 }, { 233, 1 }, { 233, 2 }, { 233, 0 }, { 234, 1 }, { 234, 1 }, { 234, 3 }, { 235, 0 }, { 235, 3 }, { 236, 0 }, { 236, 2 }, { 232, 3 }, { 232, 2 }, { 237, 6 }, { 237, 8 }, { 237, 5 }, { 237, 4 }, { 237, 1 }, { 171, 4 }, { 171, 6 }, { 187, 1 }, { 187, 1 }, { 187, 1 }, { 145, 4 }, { 145, 6 }, { 145, 3 }, { 239, 0 }, { 239, 2 }, { 238, 1 }, { 238, 0 }, { 145, 1 }, { 145, 3 }, { 145, 1 }, { 145, 3 }, { 145, 6 }, { 145, 6 }, { 240, 1 }, { 241, 0 }, { 241, 1 }, { 145, 1 }, { 145, 4 }, { 242, 7 }, { 243, 1 }, { 243, 3 }, { 244, 0 }, { 244, 2 }, { 245, 1 }, { 245, 3 }, { 246, 1 }, { 247, 0 }, { 247, 2 }, }; static void yy_accept(yyParser*); static void yy_reduce( yyParser *yypParser, int yyruleno ){ int yygoto; int yyact; YYMINORTYPE yygotominor; yyStackEntry *yymsp; int yysize; sqlite3ParserARG_FETCH; yymsp = &yypParser->yystack[yypParser->yyidx]; 
#ifndef NDEBUG 
 if( yyTraceFILE && yyruleno>=0 && yyruleno<(int)(sizeof(yyRuleName)/sizeof(yyRuleName[0])) ){ fprintf(yyTraceFILE, "%sReduce [%s].\n", yyTracePrompt, yyRuleName[yyruleno]); } 
#endif 
 yygotominor = yyzerominor; switch( yyruleno ){ case 0: case 1: case 2: case 3: case 4: case 10: case 11: case 12: case 20: case 28: case 29: case 37: case 44: case 45: case 46: case 47: case 48: case 49: case 55: case 82: case 83: case 84: case 85: case 260: case 261: case 271: case 272: case 292: case 293: case 301: case 302: case 306: case 307: case 309: case 313: { } break; case 5: { sqlite3BeginParse(pParse, 0); } break; case 6: { sqlite3BeginParse(pParse, 1); } break; case 7: { sqlite3BeginParse(pParse, 2); } break; case 8: { sqlite3FinishCoding(pParse); } break; case 9: {sqlite3BeginTransaction(pParse, yymsp[-1].minor.yy316);} break; case 13: {yygotominor.yy316 = TK_DEFERRED;} break; case 14: case 15: case 16: case 107: case 109: {yygotominor.yy316 = yymsp[0].major;} break; case 17: case 18: {sqlite3CommitTransaction(pParse);} break; case 19: {sqlite3RollbackTransaction(pParse);} break; case 21: { sqlite3StartTable(pParse,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0,yymsp[-4].minor.yy316,0,0,yymsp[-2].minor.yy316); } break; case 22: case 25: case 63: case 77: case 79: case 90: case 101: case 112: case 113: case 216: case 219: {yygotominor.yy316 = 0;} break; case 23: case 24: case 64: case 78: case 100: case 111: case 217: case 220: {yygotominor.yy316 = 1;} break; case 26: { sqlite3EndTable(pParse,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0,0); } break; case 27: { sqlite3EndTable(pParse,0,0,yymsp[0].minor.yy43); sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy43); } break; case 30: { yygotominor.yy0.z = yymsp[-2].minor.yy0.z; yygotominor.yy0.n = (pParse->sLastToken.z-yymsp[-2].minor.yy0.z) + pParse->sLastToken.n; } break; case 31: { sqlite3AddColumn(pParse,&yymsp[0].minor.yy0); yygotominor.yy0 = yymsp[0].minor.yy0; } break; case 32: case 33: case 34: case 35: case 36: case 39: case 42: case 119: case 120: case 131: case 140: case 245: case 255: case 256: case 257: case 258: case 259: {yygotominor.yy0 = yymsp[0].minor.yy0;} break; case 38: {sqlite3AddColumnType(pParse,&yymsp[0].minor.yy0);} break; case 40: { yygotominor.yy0.z = yymsp[-3].minor.yy0.z; yygotominor.yy0.n = &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n] - yymsp[-3].minor.yy0.z; } break; case 41: { yygotominor.yy0.z = yymsp[-5].minor.yy0.z; yygotominor.yy0.n = &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n] - yymsp[-5].minor.yy0.z; } break; case 43: {yygotominor.yy0.z=yymsp[-1].minor.yy0.z; yygotominor.yy0.n=yymsp[0].minor.yy0.n+(yymsp[0].minor.yy0.z-yymsp[-1].minor.yy0.z);} break; case 50: case 52: {sqlite3AddDefaultValue(pParse,yymsp[0].minor.yy450);} break; case 51: {sqlite3AddDefaultValue(pParse,yymsp[-1].minor.yy450);} break; case 53: { Expr *p = sqlite3PExpr(pParse, TK_UMINUS, yymsp[0].minor.yy450, 0, 0); sqlite3ExprSpan(p,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy450->span); sqlite3AddDefaultValue(pParse,p); } break; case 54: { Expr *p = sqlite3PExpr(pParse, TK_STRING, 0, 0, &yymsp[0].minor.yy0); sqlite3AddDefaultValue(pParse,p); } break; case 56: {sqlite3AddNotNull(pParse, yymsp[0].minor.yy316);} break; case 57: {sqlite3AddPrimaryKey(pParse,0,yymsp[-1].minor.yy316,yymsp[0].minor.yy316,yymsp[-2].minor.yy316);} break; case 58: {sqlite3CreateIndex(pParse,0,0,0,0,yymsp[0].minor.yy316,0,0,0,0);} break; case 59: {sqlite3AddCheckConstraint(pParse,yymsp[-1].minor.yy450);} break; case 60: {sqlite3CreateForeignKey(pParse,0,&yymsp[-2].minor.yy0,yymsp[-1].minor.yy242,yymsp[0].minor.yy316);} break; case 61: {sqlite3DeferForeignKey(pParse,yymsp[0].minor.yy316);} break; case 62: {sqlite3AddCollateType(pParse, &yymsp[0].minor.yy0);} break; case 65: { yygotominor.yy316 = OE_Restrict * 0x010101; } break; case 66: { yygotominor.yy316 = (yymsp[-1].minor.yy316 & ~yymsp[0].minor.yy207.mask) | yymsp[0].minor.yy207.value; } break; case 67: { yygotominor.yy207.value = 0; yygotominor.yy207.mask = 0x000000; } break; case 68: { yygotominor.yy207.value = yymsp[0].minor.yy316; yygotominor.yy207.mask = 0x0000ff; } break; case 69: { yygotominor.yy207.value = yymsp[0].minor.yy316<<8; yygotominor.yy207.mask = 0x00ff00; } break; case 70: { yygotominor.yy207.value = yymsp[0].minor.yy316<<16; yygotominor.yy207.mask = 0xff0000; } break; case 71: { yygotominor.yy316 = OE_SetNull; } break; case 72: { yygotominor.yy316 = OE_SetDflt; } break; case 73: { yygotominor.yy316 = OE_Cascade; } break; case 74: { yygotominor.yy316 = OE_Restrict; } break; case 75: case 76: case 91: case 93: case 95: case 96: case 169: {yygotominor.yy316 = yymsp[0].minor.yy316;} break; case 80: {yygotominor.yy0.n = 0; yygotominor.yy0.z = 0;} break; case 81: {yygotominor.yy0 = yymsp[-1].minor.yy0;} break; case 86: {sqlite3AddPrimaryKey(pParse,yymsp[-3].minor.yy242,yymsp[0].minor.yy316,yymsp[-2].minor.yy316,0);} break; case 87: {sqlite3CreateIndex(pParse,0,0,0,yymsp[-2].minor.yy242,yymsp[0].minor.yy316,0,0,0,0);} break; case 88: {sqlite3AddCheckConstraint(pParse,yymsp[-2].minor.yy450);} break; case 89: { sqlite3CreateForeignKey(pParse, yymsp[-6].minor.yy242, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy242, yymsp[-1].minor.yy316); sqlite3DeferForeignKey(pParse, yymsp[0].minor.yy316); } break; case 92: case 94: {yygotominor.yy316 = OE_Default;} break; case 97: {yygotominor.yy316 = OE_Ignore;} break; case 98: case 170: {yygotominor.yy316 = OE_Replace;} break; case 99: { sqlite3DropTable(pParse, yymsp[0].minor.yy419, 0, yymsp[-1].minor.yy316); } break; case 102: { sqlite3CreateView(pParse, &yymsp[-7].minor.yy0, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, yymsp[0].minor.yy43, yymsp[-6].minor.yy316, yymsp[-4].minor.yy316); } break; case 103: { sqlite3DropTable(pParse, yymsp[0].minor.yy419, 1, yymsp[-1].minor.yy316); } break; case 104: { SelectDest dest = {SRT_Output, 0, 0, 0, 0}; sqlite3Select(pParse, yymsp[0].minor.yy43, &dest); sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy43); } break; case 105: case 128: {yygotominor.yy43 = yymsp[0].minor.yy43;} break; case 106: { if( yymsp[0].minor.yy43 ){ yymsp[0].minor.yy43->op = yymsp[-1].minor.yy316; yymsp[0].minor.yy43->pPrior = yymsp[-2].minor.yy43; }else{ sqlite3SelectDelete(pParse->db, yymsp[-2].minor.yy43); } yygotominor.yy43 = yymsp[0].minor.yy43; } break; case 108: {yygotominor.yy316 = TK_ALL;} break; case 110: { yygotominor.yy43 = sqlite3SelectNew(pParse,yymsp[-6].minor.yy242,yymsp[-5].minor.yy419,yymsp[-4].minor.yy450,yymsp[-3].minor.yy242,yymsp[-2].minor.yy450,yymsp[-1].minor.yy242,yymsp[-7].minor.yy316,yymsp[0].minor.yy84.pLimit,yymsp[0].minor.yy84.pOffset); } break; case 114: case 241: {yygotominor.yy242 = yymsp[-1].minor.yy242;} break; case 115: case 144: case 152: case 234: case 240: {yygotominor.yy242 = 0;} break; case 116: { yygotominor.yy242 = sqlite3ExprListAppend(pParse,yymsp[-2].minor.yy242,yymsp[-1].minor.yy450,yymsp[0].minor.yy0.n?&yymsp[0].minor.yy0:0); } break; case 117: { Expr *p = sqlite3PExpr(pParse, TK_ALL, 0, 0, 0); yygotominor.yy242 = sqlite3ExprListAppend(pParse, yymsp[-1].minor.yy242, p, 0); } break; case 118: { Expr *pRight = sqlite3PExpr(pParse, TK_ALL, 0, 0, &yymsp[0].minor.yy0); Expr *pLeft = sqlite3PExpr(pParse, TK_ID, 0, 0, &yymsp[-2].minor.yy0); Expr *pDot = sqlite3PExpr(pParse, TK_DOT, pLeft, pRight, 0); yygotominor.yy242 = sqlite3ExprListAppend(pParse,yymsp[-3].minor.yy242, pDot, 0); } break; case 121: {yygotominor.yy0.n = 0;} break; case 122: {yygotominor.yy419 = sqlite3DbMallocZero(pParse->db, sizeof(*yygotominor.yy419));} break; case 123: { yygotominor.yy419 = yymsp[0].minor.yy419; sqlite3SrcListShiftJoinType(yygotominor.yy419); } break; case 124: { yygotominor.yy419 = yymsp[-1].minor.yy419; if( yygotominor.yy419 && yygotominor.yy419->nSrc>0 ) yygotominor.yy419->a[yygotominor.yy419->nSrc-1].jointype = yymsp[0].minor.yy316; } break; case 125: {yygotominor.yy419 = 0;} break; case 126: { yygotominor.yy419 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy419,&yymsp[-5].minor.yy0,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,0,yymsp[-1].minor.yy450,yymsp[0].minor.yy352); sqlite3SrcListIndexedBy(pParse, yygotominor.yy419, &yymsp[-2].minor.yy0); } break; case 127: { yygotominor.yy419 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy419,0,0,&yymsp[-2].minor.yy0,yymsp[-4].minor.yy43,yymsp[-1].minor.yy450,yymsp[0].minor.yy352); } break; case 129: { sqlite3SrcListShiftJoinType(yymsp[0].minor.yy419); yygotominor.yy43 = sqlite3SelectNew(pParse,0,yymsp[0].minor.yy419,0,0,0,0,0,0,0); } break; case 130: case 139: {yygotominor.yy0.z=0; yygotominor.yy0.n=0;} break; case 132: {yygotominor.yy419 = sqlite3SrcListAppend(pParse->db,0,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0);} break; case 133: { yygotominor.yy316 = JT_INNER; } break; case 134: { yygotominor.yy316 = sqlite3JoinType(pParse,&yymsp[-1].minor.yy0,0,0); } break; case 135: { yygotominor.yy316 = sqlite3JoinType(pParse,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0,0); } break; case 136: { yygotominor.yy316 = sqlite3JoinType(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0); } break; case 137: case 148: case 155: case 162: case 177: case 205: case 229: case 231: {yygotominor.yy450 = yymsp[0].minor.yy450;} break; case 138: case 154: case 161: case 206: case 230: case 232: {yygotominor.yy450 = 0;} break; case 141: {yygotominor.yy0.z=0; yygotominor.yy0.n=1;} break; case 142: case 174: {yygotominor.yy352 = yymsp[-1].minor.yy352;} break; case 143: case 173: {yygotominor.yy352 = 0;} break; case 145: case 153: case 233: {yygotominor.yy242 = yymsp[0].minor.yy242;} break; case 146: { yygotominor.yy242 = sqlite3ExprListAppend(pParse,yymsp[-3].minor.yy242,yymsp[-1].minor.yy450,0); if( yygotominor.yy242 ) yygotominor.yy242->a[yygotominor.yy242->nExpr-1].sortOrder = yymsp[0].minor.yy316; } break; case 147: { yygotominor.yy242 = sqlite3ExprListAppend(pParse,0,yymsp[-1].minor.yy450,0); if( yygotominor.yy242 && yygotominor.yy242->a ) yygotominor.yy242->a[0].sortOrder = yymsp[0].minor.yy316; } break; case 149: case 151: {yygotominor.yy316 = SQLITE_SO_ASC;} break; case 150: {yygotominor.yy316 = SQLITE_SO_DESC;} break; case 156: {yygotominor.yy84.pLimit = 0; yygotominor.yy84.pOffset = 0;} break; case 157: {yygotominor.yy84.pLimit = yymsp[0].minor.yy450; yygotominor.yy84.pOffset = 0;} break; case 158: {yygotominor.yy84.pLimit = yymsp[-2].minor.yy450; yygotominor.yy84.pOffset = yymsp[0].minor.yy450;} break; case 159: {yygotominor.yy84.pOffset = yymsp[-2].minor.yy450; yygotominor.yy84.pLimit = yymsp[0].minor.yy450;} break; case 160: { sqlite3SrcListIndexedBy(pParse, yymsp[-2].minor.yy419, &yymsp[-1].minor.yy0); sqlite3DeleteFrom(pParse,yymsp[-2].minor.yy419,yymsp[0].minor.yy450); } break; case 163: { sqlite3SrcListIndexedBy(pParse, yymsp[-4].minor.yy419, &yymsp[-3].minor.yy0); sqlite3ExprListCheckLength(pParse,yymsp[-1].minor.yy242,"set list"); sqlite3Update(pParse,yymsp[-4].minor.yy419,yymsp[-1].minor.yy242,yymsp[0].minor.yy450,yymsp[-5].minor.yy316); } break; case 164: {yygotominor.yy242 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy242,yymsp[0].minor.yy450,&yymsp[-2].minor.yy0);} break; case 165: {yygotominor.yy242 = sqlite3ExprListAppend(pParse,0,yymsp[0].minor.yy450,&yymsp[-2].minor.yy0);} break; case 166: {sqlite3Insert(pParse, yymsp[-5].minor.yy419, yymsp[-1].minor.yy242, 0, yymsp[-4].minor.yy352, yymsp[-7].minor.yy316);} break; case 167: {sqlite3Insert(pParse, yymsp[-2].minor.yy419, 0, yymsp[0].minor.yy43, yymsp[-1].minor.yy352, yymsp[-4].minor.yy316);} break; case 168: {sqlite3Insert(pParse, yymsp[-3].minor.yy419, 0, 0, yymsp[-2].minor.yy352, yymsp[-5].minor.yy316);} break; case 171: case 235: {yygotominor.yy242 = sqlite3ExprListAppend(pParse,yymsp[-2].minor.yy242,yymsp[0].minor.yy450,0);} break; case 172: case 236: {yygotominor.yy242 = sqlite3ExprListAppend(pParse,0,yymsp[0].minor.yy450,0);} break; case 175: {yygotominor.yy352 = sqlite3IdListAppend(pParse->db,yymsp[-2].minor.yy352,&yymsp[0].minor.yy0);} break; case 176: {yygotominor.yy352 = sqlite3IdListAppend(pParse->db,0,&yymsp[0].minor.yy0);} break; case 178: {yygotominor.yy450 = yymsp[-1].minor.yy450; sqlite3ExprSpan(yygotominor.yy450,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0); } break; case 179: case 184: case 185: {yygotominor.yy450 = sqlite3PExpr(pParse, yymsp[0].major, 0, 0, &yymsp[0].minor.yy0);} break; case 180: case 181: {yygotominor.yy450 = sqlite3PExpr(pParse, TK_ID, 0, 0, &yymsp[0].minor.yy0);} break; case 182: { Expr *temp1 = sqlite3PExpr(pParse, TK_ID, 0, 0, &yymsp[-2].minor.yy0); Expr *temp2 = sqlite3PExpr(pParse, TK_ID, 0, 0, &yymsp[0].minor.yy0); yygotominor.yy450 = sqlite3PExpr(pParse, TK_DOT, temp1, temp2, 0); } break; case 183: { Expr *temp1 = sqlite3PExpr(pParse, TK_ID, 0, 0, &yymsp[-4].minor.yy0); Expr *temp2 = sqlite3PExpr(pParse, TK_ID, 0, 0, &yymsp[-2].minor.yy0); Expr *temp3 = sqlite3PExpr(pParse, TK_ID, 0, 0, &yymsp[0].minor.yy0); Expr *temp4 = sqlite3PExpr(pParse, TK_DOT, temp2, temp3, 0); yygotominor.yy450 = sqlite3PExpr(pParse, TK_DOT, temp1, temp4, 0); } break; case 186: {yygotominor.yy450 = sqlite3RegisterExpr(pParse, &yymsp[0].minor.yy0);} break; case 187: { Token *pToken = &yymsp[0].minor.yy0; Expr *pExpr = yygotominor.yy450 = sqlite3PExpr(pParse, TK_VARIABLE, 0, 0, pToken); sqlite3ExprAssignVarNumber(pParse, pExpr); } break; case 188: { yygotominor.yy450 = sqlite3ExprSetColl(pParse, yymsp[-2].minor.yy450, &yymsp[0].minor.yy0); } break; case 189: { yygotominor.yy450 = sqlite3PExpr(pParse, TK_CAST, yymsp[-3].minor.yy450, 0, &yymsp[-1].minor.yy0); sqlite3ExprSpan(yygotominor.yy450,&yymsp[-5].minor.yy0,&yymsp[0].minor.yy0); } break; case 190: { if( yymsp[-1].minor.yy242 && yymsp[-1].minor.yy242->nExpr>SQLITE_MAX_FUNCTION_ARG ){ sqlite3ErrorMsg(pParse, "too many arguments on function %T", &yymsp[-4].minor.yy0); } yygotominor.yy450 = sqlite3ExprFunction(pParse, yymsp[-1].minor.yy242, &yymsp[-4].minor.yy0); sqlite3ExprSpan(yygotominor.yy450,&yymsp[-4].minor.yy0,&yymsp[0].minor.yy0); if( yymsp[-2].minor.yy316 && yygotominor.yy450 ){ yygotominor.yy450->flags |= EP_Distinct; } } break; case 191: { yygotominor.yy450 = sqlite3ExprFunction(pParse, 0, &yymsp[-3].minor.yy0); sqlite3ExprSpan(yygotominor.yy450,&yymsp[-3].minor.yy0,&yymsp[0].minor.yy0); } break; case 192: { yygotominor.yy450 = sqlite3ExprFunction(pParse, 0,&yymsp[0].minor.yy0); if( yygotominor.yy450 ){ yygotominor.yy450->op = TK_CONST_FUNC; yygotominor.yy450->span = yymsp[0].minor.yy0; } } break; case 193: case 194: case 195: case 196: case 197: case 198: case 199: case 200: {yygotominor.yy450 = sqlite3PExpr(pParse,yymsp[-1].major,yymsp[-2].minor.yy450,yymsp[0].minor.yy450,0);} break; case 201: case 203: {yygotominor.yy86.eOperator = yymsp[0].minor.yy0; yygotominor.yy86.not = 0;} break; case 202: case 204: {yygotominor.yy86.eOperator = yymsp[0].minor.yy0; yygotominor.yy86.not = 1;} break; case 207: { ExprList *pList; pList = sqlite3ExprListAppend(pParse,0, yymsp[-1].minor.yy450, 0); pList = sqlite3ExprListAppend(pParse,pList, yymsp[-3].minor.yy450, 0); if( yymsp[0].minor.yy450 ){ pList = sqlite3ExprListAppend(pParse,pList, yymsp[0].minor.yy450, 0); } yygotominor.yy450 = sqlite3ExprFunction(pParse, pList, &yymsp[-2].minor.yy86.eOperator); if( yymsp[-2].minor.yy86.not ) yygotominor.yy450 = sqlite3PExpr(pParse, TK_NOT, yygotominor.yy450, 0, 0); sqlite3ExprSpan(yygotominor.yy450, &yymsp[-3].minor.yy450->span, &yymsp[-1].minor.yy450->span); if( yygotominor.yy450 ) yygotominor.yy450->flags |= EP_InfixFunc; } break; case 208: { yygotominor.yy450 = sqlite3PExpr(pParse, yymsp[0].major, yymsp[-1].minor.yy450, 0, 0); sqlite3ExprSpan(yygotominor.yy450,&yymsp[-1].minor.yy450->span,&yymsp[0].minor.yy0); } break; case 209: { yygotominor.yy450 = sqlite3PExpr(pParse, TK_ISNULL, yymsp[-2].minor.yy450, 0, 0); sqlite3ExprSpan(yygotominor.yy450,&yymsp[-2].minor.yy450->span,&yymsp[0].minor.yy0); } break; case 210: { yygotominor.yy450 = sqlite3PExpr(pParse, TK_NOTNULL, yymsp[-2].minor.yy450, 0, 0); sqlite3ExprSpan(yygotominor.yy450,&yymsp[-2].minor.yy450->span,&yymsp[0].minor.yy0); } break; case 211: { yygotominor.yy450 = sqlite3PExpr(pParse, TK_NOTNULL, yymsp[-3].minor.yy450, 0, 0); sqlite3ExprSpan(yygotominor.yy450,&yymsp[-3].minor.yy450->span,&yymsp[0].minor.yy0); } break; case 212: case 213: { yygotominor.yy450 = sqlite3PExpr(pParse, yymsp[-1].major, yymsp[0].minor.yy450, 0, 0); sqlite3ExprSpan(yygotominor.yy450,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy450->span); } break; case 214: { yygotominor.yy450 = sqlite3PExpr(pParse, TK_UMINUS, yymsp[0].minor.yy450, 0, 0); sqlite3ExprSpan(yygotominor.yy450,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy450->span); } break; case 215: { yygotominor.yy450 = sqlite3PExpr(pParse, TK_UPLUS, yymsp[0].minor.yy450, 0, 0); sqlite3ExprSpan(yygotominor.yy450,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy450->span); } break; case 218: { ExprList *pList = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy450, 0); pList = sqlite3ExprListAppend(pParse,pList, yymsp[0].minor.yy450, 0); yygotominor.yy450 = sqlite3PExpr(pParse, TK_BETWEEN, yymsp[-4].minor.yy450, 0, 0); if( yygotominor.yy450 ){ yygotominor.yy450->pList = pList; }else{ sqlite3ExprListDelete(pParse->db, pList); } if( yymsp[-3].minor.yy316 ) yygotominor.yy450 = sqlite3PExpr(pParse, TK_NOT, yygotominor.yy450, 0, 0); sqlite3ExprSpan(yygotominor.yy450,&yymsp[-4].minor.yy450->span,&yymsp[0].minor.yy450->span); } break; case 221: { yygotominor.yy450 = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy450, 0, 0); if( yygotominor.yy450 ){ yygotominor.yy450->pList = yymsp[-1].minor.yy242; sqlite3ExprSetHeight(pParse, yygotominor.yy450); }else{ sqlite3ExprListDelete(pParse->db, yymsp[-1].minor.yy242); } if( yymsp[-3].minor.yy316 ) yygotominor.yy450 = sqlite3PExpr(pParse, TK_NOT, yygotominor.yy450, 0, 0); sqlite3ExprSpan(yygotominor.yy450,&yymsp[-4].minor.yy450->span,&yymsp[0].minor.yy0); } break; case 222: { yygotominor.yy450 = sqlite3PExpr(pParse, TK_SELECT, 0, 0, 0); if( yygotominor.yy450 ){ yygotominor.yy450->pSelect = yymsp[-1].minor.yy43; sqlite3ExprSetHeight(pParse, yygotominor.yy450); }else{ sqlite3SelectDelete(pParse->db, yymsp[-1].minor.yy43); } sqlite3ExprSpan(yygotominor.yy450,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0); } break; case 223: { yygotominor.yy450 = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy450, 0, 0); if( yygotominor.yy450 ){ yygotominor.yy450->pSelect = yymsp[-1].minor.yy43; sqlite3ExprSetHeight(pParse, yygotominor.yy450); }else{ sqlite3SelectDelete(pParse->db, yymsp[-1].minor.yy43); } if( yymsp[-3].minor.yy316 ) yygotominor.yy450 = sqlite3PExpr(pParse, TK_NOT, yygotominor.yy450, 0, 0); sqlite3ExprSpan(yygotominor.yy450,&yymsp[-4].minor.yy450->span,&yymsp[0].minor.yy0); } break; case 224: { SrcList *pSrc = sqlite3SrcListAppend(pParse->db, 0,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0); yygotominor.yy450 = sqlite3PExpr(pParse, TK_IN, yymsp[-3].minor.yy450, 0, 0); if( yygotominor.yy450 ){ yygotominor.yy450->pSelect = sqlite3SelectNew(pParse, 0,pSrc,0,0,0,0,0,0,0); sqlite3ExprSetHeight(pParse, yygotominor.yy450); }else{ sqlite3SrcListDelete(pParse->db, pSrc); } if( yymsp[-2].minor.yy316 ) yygotominor.yy450 = sqlite3PExpr(pParse, TK_NOT, yygotominor.yy450, 0, 0); sqlite3ExprSpan(yygotominor.yy450,&yymsp[-3].minor.yy450->span,yymsp[0].minor.yy0.z?&yymsp[0].minor.yy0:&yymsp[-1].minor.yy0); } break; case 225: { Expr *p = yygotominor.yy450 = sqlite3PExpr(pParse, TK_EXISTS, 0, 0, 0); if( p ){ p->pSelect = yymsp[-1].minor.yy43; sqlite3ExprSpan(p,&yymsp[-3].minor.yy0,&yymsp[0].minor.yy0); sqlite3ExprSetHeight(pParse, yygotominor.yy450); }else{ sqlite3SelectDelete(pParse->db, yymsp[-1].minor.yy43); } } break; case 226: { yygotominor.yy450 = sqlite3PExpr(pParse, TK_CASE, yymsp[-3].minor.yy450, yymsp[-1].minor.yy450, 0); if( yygotominor.yy450 ){ yygotominor.yy450->pList = yymsp[-2].minor.yy242; sqlite3ExprSetHeight(pParse, yygotominor.yy450); }else{ sqlite3ExprListDelete(pParse->db, yymsp[-2].minor.yy242); } sqlite3ExprSpan(yygotominor.yy450, &yymsp[-4].minor.yy0, &yymsp[0].minor.yy0); } break; case 227: { yygotominor.yy242 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy242, yymsp[-2].minor.yy450, 0); yygotominor.yy242 = sqlite3ExprListAppend(pParse,yygotominor.yy242, yymsp[0].minor.yy450, 0); } break; case 228: { yygotominor.yy242 = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy450, 0); yygotominor.yy242 = sqlite3ExprListAppend(pParse,yygotominor.yy242, yymsp[0].minor.yy450, 0); } break; case 237: { sqlite3CreateIndex(pParse, &yymsp[-6].minor.yy0, &yymsp[-5].minor.yy0, sqlite3SrcListAppend(pParse->db,0,&yymsp[-3].minor.yy0,0), yymsp[-1].minor.yy242, yymsp[-9].minor.yy316, &yymsp[-10].minor.yy0, &yymsp[0].minor.yy0, SQLITE_SO_ASC, yymsp[-7].minor.yy316); } break; case 238: case 285: {yygotominor.yy316 = OE_Abort;} break; case 239: {yygotominor.yy316 = OE_None;} break; case 242: { Expr *p = 0; if( yymsp[-1].minor.yy0.n>0 ){ p = sqlite3PExpr(pParse, TK_COLUMN, 0, 0, 0); sqlite3ExprSetColl(pParse, p, &yymsp[-1].minor.yy0); } yygotominor.yy242 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy242, p, &yymsp[-2].minor.yy0); sqlite3ExprListCheckLength(pParse, yygotominor.yy242, "index"); if( yygotominor.yy242 ) yygotominor.yy242->a[yygotominor.yy242->nExpr-1].sortOrder = yymsp[0].minor.yy316; } break; case 243: { Expr *p = 0; if( yymsp[-1].minor.yy0.n>0 ){ p = sqlite3PExpr(pParse, TK_COLUMN, 0, 0, 0); sqlite3ExprSetColl(pParse, p, &yymsp[-1].minor.yy0); } yygotominor.yy242 = sqlite3ExprListAppend(pParse,0, p, &yymsp[-2].minor.yy0); sqlite3ExprListCheckLength(pParse, yygotominor.yy242, "index"); if( yygotominor.yy242 ) yygotominor.yy242->a[yygotominor.yy242->nExpr-1].sortOrder = yymsp[0].minor.yy316; } break; case 244: {yygotominor.yy0.z = 0; yygotominor.yy0.n = 0;} break; case 246: {sqlite3DropIndex(pParse, yymsp[0].minor.yy419, yymsp[-1].minor.yy316);} break; case 247: case 248: {sqlite3Vacuum(pParse);} break; case 249: case 250: case 251: {sqlite3Pragma(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0,0);} break; case 252: { sqlite3Pragma(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0,1); } break; case 253: {sqlite3Pragma(pParse,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,&yymsp[-1].minor.yy0,0);} break; case 254: {sqlite3Pragma(pParse,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0,0,0);} break; case 262: { Token all; all.z = yymsp[-3].minor.yy0.z; all.n = (yymsp[0].minor.yy0.z - yymsp[-3].minor.yy0.z) + yymsp[0].minor.yy0.n; sqlite3FinishTrigger(pParse, yymsp[-1].minor.yy75, &all); } break; case 263: { sqlite3BeginTrigger(pParse, &yymsp[-7].minor.yy0, &yymsp[-6].minor.yy0, yymsp[-5].minor.yy316, yymsp[-4].minor.yy354.a, yymsp[-4].minor.yy354.b, yymsp[-2].minor.yy419, yymsp[0].minor.yy450, yymsp[-10].minor.yy316, yymsp[-8].minor.yy316); yygotominor.yy0 = (yymsp[-6].minor.yy0.n==0?yymsp[-7].minor.yy0:yymsp[-6].minor.yy0); } break; case 264: case 267: { yygotominor.yy316 = TK_BEFORE; } break; case 265: { yygotominor.yy316 = TK_AFTER; } break; case 266: { yygotominor.yy316 = TK_INSTEAD;} break; case 268: case 269: {yygotominor.yy354.a = yymsp[0].major; yygotominor.yy354.b = 0;} break; case 270: {yygotominor.yy354.a = TK_UPDATE; yygotominor.yy354.b = yymsp[0].minor.yy352;} break; case 273: case 290: { yygotominor.yy450 = 0; } break; case 274: case 291: { yygotominor.yy450 = yymsp[0].minor.yy450; } break; case 275: { assert( yymsp[-2].minor.yy75!=0 ); yymsp[-2].minor.yy75->pLast->pNext = yymsp[-1].minor.yy75; yymsp[-2].minor.yy75->pLast = yymsp[-1].minor.yy75; yygotominor.yy75 = yymsp[-2].minor.yy75; } break; case 276: { assert( yymsp[-1].minor.yy75!=0 ); yymsp[-1].minor.yy75->pLast = yymsp[-1].minor.yy75; yygotominor.yy75 = yymsp[-1].minor.yy75; } break; case 277: { yygotominor.yy75 = sqlite3TriggerUpdateStep(pParse->db, &yymsp[-3].minor.yy0, yymsp[-1].minor.yy242, yymsp[0].minor.yy450, yymsp[-4].minor.yy316); } break; case 278: {yygotominor.yy75 = sqlite3TriggerInsertStep(pParse->db, &yymsp[-5].minor.yy0, yymsp[-4].minor.yy352, yymsp[-1].minor.yy242, 0, yymsp[-7].minor.yy316);} break; case 279: {yygotominor.yy75 = sqlite3TriggerInsertStep(pParse->db, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy352, 0, yymsp[0].minor.yy43, yymsp[-4].minor.yy316);} break; case 280: {yygotominor.yy75 = sqlite3TriggerDeleteStep(pParse->db, &yymsp[-1].minor.yy0, yymsp[0].minor.yy450);} break; case 281: {yygotominor.yy75 = sqlite3TriggerSelectStep(pParse->db, yymsp[0].minor.yy43); } break; case 282: { yygotominor.yy450 = sqlite3PExpr(pParse, TK_RAISE, 0, 0, 0); if( yygotominor.yy450 ){ yygotominor.yy450->iColumn = OE_Ignore; sqlite3ExprSpan(yygotominor.yy450, &yymsp[-3].minor.yy0, &yymsp[0].minor.yy0); } } break; case 283: { yygotominor.yy450 = sqlite3PExpr(pParse, TK_RAISE, 0, 0, &yymsp[-1].minor.yy0); if( yygotominor.yy450 ) { yygotominor.yy450->iColumn = yymsp[-3].minor.yy316; sqlite3ExprSpan(yygotominor.yy450, &yymsp[-5].minor.yy0, &yymsp[0].minor.yy0); } } break; case 284: {yygotominor.yy316 = OE_Rollback;} break; case 286: {yygotominor.yy316 = OE_Fail;} break; case 287: { sqlite3DropTrigger(pParse,yymsp[0].minor.yy419,yymsp[-1].minor.yy316); } break; case 288: { sqlite3Attach(pParse, yymsp[-3].minor.yy450, yymsp[-1].minor.yy450, yymsp[0].minor.yy450); } break; case 289: { sqlite3Detach(pParse, yymsp[0].minor.yy450); } break; case 294: {sqlite3Reindex(pParse, 0, 0);} break; case 295: {sqlite3Reindex(pParse, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0);} break; case 296: {sqlite3Analyze(pParse, 0, 0);} break; case 297: {sqlite3Analyze(pParse, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0);} break; case 298: { sqlite3AlterRenameTable(pParse,yymsp[-3].minor.yy419,&yymsp[0].minor.yy0); } break; case 299: { sqlite3AlterFinishAddColumn(pParse, &yymsp[0].minor.yy0); } break; case 300: { sqlite3AlterBeginAddColumn(pParse, yymsp[0].minor.yy419); } break; case 303: {sqlite3VtabFinishParse(pParse,0);} break; case 304: {sqlite3VtabFinishParse(pParse,&yymsp[0].minor.yy0);} break; case 305: { sqlite3VtabBeginParse(pParse, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0); } break; case 308: {sqlite3VtabArgInit(pParse);} break; case 310: case 311: case 312: case 314: {sqlite3VtabArgExtend(pParse,&yymsp[0].minor.yy0);} break; }; yygoto = yyRuleInfo[yyruleno].lhs; yysize = yyRuleInfo[yyruleno].nrhs; yypParser->yyidx -= yysize; yyact = yy_find_reduce_action(yymsp[-yysize].stateno,yygoto); if( yyact < YYNSTATE ){ 
#ifdef NDEBUG 
 if( yysize ){ yypParser->yyidx++; yymsp -= yysize-1; yymsp->stateno = yyact; yymsp->major = yygoto; yymsp->minor = yygotominor; }else 
#endif 
 { yy_shift(yypParser,yyact,yygoto,&yygotominor); } }else{ assert( yyact == YYNSTATE + YYNRULE + 1 ); yy_accept(yypParser); } } static void yy_parse_failed( yyParser *yypParser ){ sqlite3ParserARG_FETCH; 
#ifndef NDEBUG 
 if( yyTraceFILE ){ fprintf(yyTraceFILE,"%sFail!\n",yyTracePrompt); } 
#endif 
 while( yypParser->yyidx>=0 ) yy_pop_parser_stack(yypParser); sqlite3ParserARG_STORE; } static void yy_syntax_error( yyParser *yypParser, int yymajor, YYMINORTYPE yyminor ){ sqlite3ParserARG_FETCH; 
#define TOKEN (yyminor.yy0) 
 assert( TOKEN.z[0] ); sqlite3ErrorMsg(pParse, "near \"%T\": syntax error", &TOKEN); pParse->parseError = 1; sqlite3ParserARG_STORE; } static void yy_accept( yyParser *yypParser ){ sqlite3ParserARG_FETCH; 
#ifndef NDEBUG 
 if( yyTraceFILE ){ fprintf(yyTraceFILE,"%sAccept!\n",yyTracePrompt); } 
#endif 
 while( yypParser->yyidx>=0 ) yy_pop_parser_stack(yypParser); sqlite3ParserARG_STORE; } SQLITE_PRIVATE void sqlite3Parser( void *yyp, int yymajor, sqlite3ParserTOKENTYPE yyminor sqlite3ParserARG_PDECL ){ YYMINORTYPE yyminorunion; int yyact; int yyendofinput; 
#ifdef YYERRORSYMBOL 
 int yyerrorhit = 0; 
#endif 
 yyParser *yypParser; yypParser = (yyParser*)yyp; if( yypParser->yyidx<0 ){ 
#if YYSTACKDEPTH<=0 
 if( yypParser->yystksz <=0 ){ yyminorunion = yyzerominor; yyStackOverflow(yypParser, &yyminorunion); return; } 
#endif 
 yypParser->yyidx = 0; yypParser->yyerrcnt = -1; yypParser->yystack[0].stateno = 0; yypParser->yystack[0].major = 0; } yyminorunion.yy0 = yyminor; yyendofinput = (yymajor==0); sqlite3ParserARG_STORE; 
#ifndef NDEBUG 
 if( yyTraceFILE ){ fprintf(yyTraceFILE,"%sInput %s\n",yyTracePrompt,yyTokenName[yymajor]); } 
#endif 
 do{ yyact = yy_find_shift_action(yypParser,yymajor); if( yyact<YYNSTATE ){ assert( !yyendofinput ); yy_shift(yypParser,yyact,yymajor,&yyminorunion); yypParser->yyerrcnt--; yymajor = YYNOCODE; }else if( yyact < YYNSTATE + YYNRULE ){ yy_reduce(yypParser,yyact-YYNSTATE); }else{ assert( yyact == YY_ERROR_ACTION ); 
#ifdef YYERRORSYMBOL 
 int yymx; 
#endif 
#ifndef NDEBUG 
 if( yyTraceFILE ){ fprintf(yyTraceFILE,"%sSyntax Error!\n",yyTracePrompt); } 
#endif 
#ifdef YYERRORSYMBOL 
 if( yypParser->yyerrcnt<0 ){ yy_syntax_error(yypParser,yymajor,yyminorunion); } yymx = yypParser->yystack[yypParser->yyidx].major; if( yymx==YYERRORSYMBOL || yyerrorhit ){ 
#ifndef NDEBUG 
 if( yyTraceFILE ){ fprintf(yyTraceFILE,"%sDiscard input token %s\n", yyTracePrompt,yyTokenName[yymajor]); } 
#endif 
 yy_destructor(yypParser, yymajor,&yyminorunion); yymajor = YYNOCODE; }else{ while( yypParser->yyidx >= 0 && yymx != YYERRORSYMBOL && (yyact = yy_find_reduce_action( yypParser->yystack[yypParser->yyidx].stateno, YYERRORSYMBOL)) >= YYNSTATE ){ yy_pop_parser_stack(yypParser); } if( yypParser->yyidx < 0 || yymajor==0 ){ yy_destructor(yypParser,yymajor,&yyminorunion); yy_parse_failed(yypParser); yymajor = YYNOCODE; }else if( yymx!=YYERRORSYMBOL ){ YYMINORTYPE u2; u2.YYERRSYMDT = 0; yy_shift(yypParser,yyact,YYERRORSYMBOL,&u2); } } yypParser->yyerrcnt = 3; yyerrorhit = 1; 
#else 
 if( yypParser->yyerrcnt<=0 ){ yy_syntax_error(yypParser,yymajor,yyminorunion); } yypParser->yyerrcnt = 3; yy_destructor(yypParser,yymajor,&yyminorunion); if( yyendofinput ){ yy_parse_failed(yypParser); } yymajor = YYNOCODE; 
#endif 
 } }while( yymajor!=YYNOCODE && yypParser->yyidx>=0 ); return; } 
#ifdef SQLITE_ASCII 
#define charMap(X) sqlite3UpperToLower[(unsigned char)X] 
#endif 
#ifdef SQLITE_EBCDIC 
#define charMap(X) ebcdicToAscii[(unsigned char)X] 
const unsigned char ebcdicToAscii[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 97, 98, 99,100,101,102,103,104,105, 0, 0, 0, 0, 0, 0, 0,106,107,108,109,110,111,112,113,114, 0, 0, 0, 0, 0, 0, 0, 0,115,116,117,118,119,120,121,122, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 97, 98, 99,100,101,102,103,104,105, 0, 0, 0, 0, 0, 0, 0,106,107,108,109,110,111,112,113,114, 0, 0, 0, 0, 0, 0, 0, 0,115,116,117,118,119,120,121,122, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, }; 
#endif 
static int keywordCode(const char *z, int n){ static const char zText[528] = "REINDEXEDESCAPEACHECKEYBEFOREIGNOREGEXPLAINSTEADDATABASELECTABLE" "FTHENDEFERRABLELSEXCEPTRANSACTIONATURALTERAISEXCLUSIVEXISTSCONSTRAINT" "ERSECTRIGGEREFERENCESUNIQUERYATTACHAVINGROUPDATEMPORARYBEGINNER" "ENAMEBETWEENOTNULLIKECASCADELETECASECOLLATECREATECURRENT_DATE" "DETACHIMMEDIATEJOINSERTMATCHPLANALYZEPRAGMABORTVALUESVIRTUALIMIT" "WHENWHEREPLACEAFTERESTRICTANDEFAULTAUTOINCREMENTCASTCOLUMNCOMMIT" "CONFLICTCROSSCURRENT_TIMESTAMPRIMARYDEFERREDISTINCTDROPFAILFROM" "FULLGLOBYIFINTOFFSETISNULLORDERIGHTOUTEROLLBACKROWUNIONUSINGVACUUM" "VIEWINITIALLY"; static const unsigned char aHash[127] = { 65, 94, 110, 63, 0, 44, 0, 0, 71, 0, 66, 0, 0, 104, 12, 67, 15, 0, 108, 74, 105, 101, 0, 19, 0, 0, 114, 0, 112, 78, 0, 22, 82, 0, 9, 0, 0, 59, 60, 0, 58, 6, 0, 39, 79, 91, 0, 111, 90, 0, 0, 45, 0, 92, 24, 0, 17, 0, 115, 40, 23, 0, 5, 99, 25, 85, 0, 0, 117, 95, 50, 116, 47, 7, 42, 0, 80, 0, 89, 26, 0, 88, 0, 0, 0, 84, 81, 86, 77, 98, 14, 34, 97, 0, 70, 0, 18, 76, 100, 31, 0, 113, 69, 106, 52, 46, 73, 0, 0, 83, 102, 0, 109, 0, 35, 0, 0, 28, 0, 75, 48, 53, 0, 20, 51, 0, 43, }; static const unsigned char aNext[117] = { 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 38, 0, 32, 21, 0, 0, 0, 0, 29, 0, 0, 37, 0, 0, 0, 1, 55, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 54, 0, 0, 0, 0, 30, 0, 16, 33, 10, 0, 0, 0, 0, 0, 0, 0, 11, 61, 68, 0, 8, 0, 93, 87, 0, 96, 0, 49, 0, 0, 64, 0, 41, 103, 0, 27, 107, 36, 62, 72, 0, 0, 57, 0, 0, }; static const unsigned char aLen[117] = { 7, 7, 5, 4, 6, 4, 5, 3, 6, 7, 3, 6, 6, 7, 7, 3, 8, 2, 6, 5, 4, 4, 3, 10, 4, 6, 11, 2, 7, 5, 5, 9, 6, 10, 9, 7, 10, 6, 5, 6, 6, 5, 6, 4, 9, 2, 5, 5, 6, 7, 7, 3, 4, 4, 7, 3, 6, 4, 7, 6, 12, 6, 9, 4, 6, 5, 4, 7, 6, 5, 6, 7, 5, 4, 5, 7, 5, 8, 3, 7, 13, 2, 2, 4, 6, 6, 8, 5, 17, 12, 7, 8, 8, 2, 4, 4, 4, 4, 4, 2, 2, 4, 6, 2, 3, 6, 5, 5, 5, 8, 3, 5, 5, 6, 4, 9, 3, }; static const unsigned short int aOffset[117] = { 0, 2, 2, 8, 9, 14, 16, 20, 23, 25, 25, 29, 33, 36, 41, 46, 48, 53, 54, 59, 62, 65, 67, 69, 78, 81, 86, 95, 96, 101, 105, 109, 117, 123, 130, 138, 144, 154, 157, 162, 167, 172, 175, 179, 179, 183, 188, 191, 195, 201, 207, 207, 210, 213, 217, 218, 222, 228, 232, 239, 245, 257, 263, 272, 274, 280, 285, 287, 294, 299, 304, 310, 316, 321, 325, 328, 335, 339, 347, 349, 356, 358, 360, 369, 373, 379, 385, 393, 398, 398, 414, 421, 428, 429, 436, 440, 444, 448, 452, 455, 457, 459, 462, 462, 465, 468, 474, 478, 483, 487, 495, 498, 503, 508, 514, 518, 523, }; static const unsigned char aCode[117] = { TK_REINDEX, TK_INDEXED, TK_INDEX, TK_DESC, TK_ESCAPE, TK_EACH, TK_CHECK, TK_KEY, TK_BEFORE, TK_FOREIGN, TK_FOR, TK_IGNORE, TK_LIKE_KW, TK_EXPLAIN, TK_INSTEAD, TK_ADD, TK_DATABASE, TK_AS, TK_SELECT, TK_TABLE, TK_JOIN_KW, TK_THEN, TK_END, TK_DEFERRABLE, TK_ELSE, TK_EXCEPT, TK_TRANSACTION,TK_ON, TK_JOIN_KW, TK_ALTER, TK_RAISE, TK_EXCLUSIVE, TK_EXISTS, TK_CONSTRAINT, TK_INTERSECT, TK_TRIGGER, TK_REFERENCES, TK_UNIQUE, TK_QUERY, TK_ATTACH, TK_HAVING, TK_GROUP, TK_UPDATE, TK_TEMP, TK_TEMP, TK_OR, TK_BEGIN, TK_JOIN_KW, TK_RENAME, TK_BETWEEN, TK_NOTNULL, TK_NOT, TK_NULL, TK_LIKE_KW, TK_CASCADE, TK_ASC, TK_DELETE, TK_CASE, TK_COLLATE, TK_CREATE, TK_CTIME_KW, TK_DETACH, TK_IMMEDIATE, TK_JOIN, TK_INSERT, TK_MATCH, TK_PLAN, TK_ANALYZE, TK_PRAGMA, TK_ABORT, TK_VALUES, TK_VIRTUAL, TK_LIMIT, TK_WHEN, TK_WHERE, TK_REPLACE, TK_AFTER, TK_RESTRICT, TK_AND, TK_DEFAULT, TK_AUTOINCR, TK_TO, TK_IN, TK_CAST, TK_COLUMNKW, TK_COMMIT, TK_CONFLICT, TK_JOIN_KW, TK_CTIME_KW, TK_CTIME_KW, TK_PRIMARY, TK_DEFERRED, TK_DISTINCT, TK_IS, TK_DROP, TK_FAIL, TK_FROM, TK_JOIN_KW, TK_LIKE_KW, TK_BY, TK_IF, TK_INTO, TK_OFFSET, TK_OF, TK_SET, TK_ISNULL, TK_ORDER, TK_JOIN_KW, TK_JOIN_KW, TK_ROLLBACK, TK_ROW, TK_UNION, TK_USING, TK_VACUUM, TK_VIEW, TK_INITIALLY, TK_ALL, }; int h, i; if( n<2 ) return TK_ID; h = ((charMap(z[0])*4) ^ (charMap(z[n-1])*3) ^ n) % 127; for(i=((int)aHash[h])-1; i>=0; i=((int)aNext[i])-1){ if( aLen[i]==n && sqlite3StrNICmp(&zText[aOffset[i]],z,n)==0 ){ return aCode[i]; } } return TK_ID; } SQLITE_PRIVATE int sqlite3KeywordCode(const unsigned char *z, int n){ return keywordCode((char*)z, n); } 
#ifdef SQLITE_ASCII 
SQLITE_PRIVATE const char sqlite3IsAsciiIdChar[] = { 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, }; 
#define IdChar(C) (((c=C)&0x80)!=0 || (c>0x1f && sqlite3IsAsciiIdChar[c-0x20])) 
#endif 
#ifdef SQLITE_EBCDIC 
SQLITE_PRIVATE const char sqlite3IsEbcdicIdChar[] = { 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, }; 
#define IdChar(C) (((c=C)>=0x42 && sqlite3IsEbcdicIdChar[c-0x40])) 
#endif 
SQLITE_PRIVATE int sqlite3GetToken(const unsigned char *z, int *tokenType){ int i, c; switch( *z ){ case ' ': case '\t': case '\n': case '\f': case '\r': { for(i=1; isspace(z[i]); i++){} *tokenType = TK_SPACE; return i; } case '-': { if( z[1]=='-' ){ for(i=2; (c=z[i])!=0 && c!='\n'; i++){} *tokenType = TK_SPACE; return i; } *tokenType = TK_MINUS; return 1; } case '(': { *tokenType = TK_LP; return 1; } case ')': { *tokenType = TK_RP; return 1; } case ';': { *tokenType = TK_SEMI; return 1; } case '+': { *tokenType = TK_PLUS; return 1; } case '*': { *tokenType = TK_STAR; return 1; } case '/': { if( z[1]!='*' || z[2]==0 ){ *tokenType = TK_SLASH; return 1; } for(i=3, c=z[2]; (c!='*' || z[i]!='/') && (c=z[i])!=0; i++){} if( c ) i++; *tokenType = TK_SPACE; return i; } case '%': { *tokenType = TK_REM; return 1; } case '=': { *tokenType = TK_EQ; return 1 + (z[1]=='='); } case '<': { if( (c=z[1])=='=' ){ *tokenType = TK_LE; return 2; }else if( c=='>' ){ *tokenType = TK_NE; return 2; }else if( c=='<' ){ *tokenType = TK_LSHIFT; return 2; }else{ *tokenType = TK_LT; return 1; } } case '>': { if( (c=z[1])=='=' ){ *tokenType = TK_GE; return 2; }else if( c=='>' ){ *tokenType = TK_RSHIFT; return 2; }else{ *tokenType = TK_GT; return 1; } } case '!': { if( z[1]!='=' ){ *tokenType = TK_ILLEGAL; return 2; }else{ *tokenType = TK_NE; return 2; } } case '|': { if( z[1]!='|' ){ *tokenType = TK_BITOR; return 1; }else{ *tokenType = TK_CONCAT; return 2; } } case ',': { *tokenType = TK_COMMA; return 1; } case '&': { *tokenType = TK_BITAND; return 1; } case '~': { *tokenType = TK_BITNOT; return 1; } case '`': case '\'': case '"': { int delim = z[0]; for(i=1; (c=z[i])!=0; i++){ if( c==delim ){ if( z[i+1]==delim ){ i++; }else{ break; } } } if( c=='\'' ){ *tokenType = TK_STRING; return i+1; }else if( c!=0 ){ *tokenType = TK_ID; return i+1; }else{ *tokenType = TK_ILLEGAL; return i; } } case '.': { 
#ifndef SQLITE_OMIT_FLOATING_POINT 
 if( !isdigit(z[1]) ) 
#endif 
 { *tokenType = TK_DOT; return 1; } } case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': { *tokenType = TK_INTEGER; for(i=0; isdigit(z[i]); i++){} 
#ifndef SQLITE_OMIT_FLOATING_POINT 
 if( z[i]=='.' ){ i++; while( isdigit(z[i]) ){ i++; } *tokenType = TK_FLOAT; } if( (z[i]=='e' || z[i]=='E') && ( isdigit(z[i+1]) || ((z[i+1]=='+' || z[i+1]=='-') && isdigit(z[i+2])) ) ){ i += 2; while( isdigit(z[i]) ){ i++; } *tokenType = TK_FLOAT; } 
#endif 
 while( IdChar(z[i]) ){ *tokenType = TK_ILLEGAL; i++; } return i; } case '[': { for(i=1, c=z[0]; c!=']' && (c=z[i])!=0; i++){} *tokenType = c==']' ? TK_ID : TK_ILLEGAL; return i; } case '?': { *tokenType = TK_VARIABLE; for(i=1; isdigit(z[i]); i++){} return i; } case '#': { for(i=1; isdigit(z[i]); i++){} if( i>1 ){ *tokenType = TK_REGISTER; return i; } } 
#ifndef SQLITE_OMIT_TCL_VARIABLE 
 case '$': 
#endif 
 case '@': case ':': { int n = 0; *tokenType = TK_VARIABLE; for(i=1; (c=z[i])!=0; i++){ if( IdChar(c) ){ n++; 
#ifndef SQLITE_OMIT_TCL_VARIABLE 
 }else if( c=='(' && n>0 ){ do{ i++; }while( (c=z[i])!=0 && !isspace(c) && c!=')' ); if( c==')' ){ i++; }else{ *tokenType = TK_ILLEGAL; } break; }else if( c==':' && z[i+1]==':' ){ i++; 
#endif 
 }else{ break; } } if( n==0 ) *tokenType = TK_ILLEGAL; return i; } 
#ifndef SQLITE_OMIT_BLOB_LITERAL 
 case 'x': case 'X': { if( z[1]=='\'' ){ *tokenType = TK_BLOB; for(i=2; (c=z[i])!=0 && c!='\''; i++){ if( !isxdigit(c) ){ *tokenType = TK_ILLEGAL; } } if( i%2 || !c ) *tokenType = TK_ILLEGAL; if( c ) i++; return i; } } 
#endif 
 default: { if( !IdChar(*z) ){ break; } for(i=1; IdChar(z[i]); i++){} *tokenType = keywordCode((char*)z, i); return i; } } *tokenType = TK_ILLEGAL; return 1; } SQLITE_PRIVATE int sqlite3RunParser(Parse *pParse, const char *zSql, char **pzErrMsg){ int nErr = 0; int i; void *pEngine; int tokenType; int lastTokenParsed = -1; sqlite3 *db = pParse->db; int mxSqlLen = db->aLimit[SQLITE_LIMIT_SQL_LENGTH]; if( db->activeVdbeCnt==0 ){ db->u1.isInterrupted = 0; } pParse->rc = SQLITE_OK; pParse->zTail = pParse->zSql = zSql; i = 0; assert( pzErrMsg!=0 ); pEngine = sqlite3ParserAlloc((void*(*)(size_t))sqlite3Malloc); if( pEngine==0 ){ db->mallocFailed = 1; return SQLITE_NOMEM; } assert( pParse->sLastToken.dyn==0 ); assert( pParse->pNewTable==0 ); assert( pParse->pNewTrigger==0 ); assert( pParse->nVar==0 ); assert( pParse->nVarExpr==0 ); assert( pParse->nVarExprAlloc==0 ); assert( pParse->apVarExpr==0 ); while( !db->mallocFailed && zSql[i]!=0 ){ assert( i>=0 ); pParse->sLastToken.z = (u8*)&zSql[i]; assert( pParse->sLastToken.dyn==0 ); pParse->sLastToken.n = sqlite3GetToken((unsigned char*)&zSql[i],&tokenType); i += pParse->sLastToken.n; if( i>mxSqlLen ){ pParse->rc = SQLITE_TOOBIG; break; } switch( tokenType ){ case TK_SPACE: { if( db->u1.isInterrupted ){ pParse->rc = SQLITE_INTERRUPT; sqlite3SetString(pzErrMsg, db, "interrupt"); goto abort_parse; } break; } case TK_ILLEGAL: { sqlite3DbFree(db, *pzErrMsg); *pzErrMsg = sqlite3MPrintf(db, "unrecognized token: \"%T\"", &pParse->sLastToken); nErr++; goto abort_parse; } case TK_SEMI: { pParse->zTail = &zSql[i]; } default: { sqlite3Parser(pEngine, tokenType, pParse->sLastToken, pParse); lastTokenParsed = tokenType; if( pParse->rc!=SQLITE_OK ){ goto abort_parse; } break; } } } abort_parse: if( zSql[i]==0 && nErr==0 && pParse->rc==SQLITE_OK ){ if( lastTokenParsed!=TK_SEMI ){ sqlite3Parser(pEngine, TK_SEMI, pParse->sLastToken, pParse); pParse->zTail = &zSql[i]; } sqlite3Parser(pEngine, 0, pParse->sLastToken, pParse); } 
#ifdef YYTRACKMAXSTACKDEPTH 
 sqlite3StatusSet(SQLITE_STATUS_PARSER_STACK, sqlite3ParserStackPeak(pEngine) ); 
#endif 
 sqlite3ParserFree(pEngine, sqlite3_free); if( db->mallocFailed ){ pParse->rc = SQLITE_NOMEM; } if( pParse->rc!=SQLITE_OK && pParse->rc!=SQLITE_DONE && pParse->zErrMsg==0 ){ sqlite3SetString(&pParse->zErrMsg, db, "%s", sqlite3ErrStr(pParse->rc)); } if( pParse->zErrMsg ){ if( *pzErrMsg==0 ){ *pzErrMsg = pParse->zErrMsg; }else{ sqlite3DbFree(db, pParse->zErrMsg); } pParse->zErrMsg = 0; nErr++; } if( pParse->pVdbe && pParse->nErr>0 && pParse->nested==0 ){ sqlite3VdbeDelete(pParse->pVdbe); pParse->pVdbe = 0; } 
#ifndef SQLITE_OMIT_SHARED_CACHE 
 if( pParse->nested==0 ){ sqlite3DbFree(db, pParse->aTableLock); pParse->aTableLock = 0; pParse->nTableLock = 0; } 
#endif 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 sqlite3DbFree(db, pParse->apVtabLock); 
#endif 
 if( !IN_DECLARE_VTAB ){ sqlite3DeleteTable(pParse->pNewTable); } sqlite3DeleteTrigger(db, pParse->pNewTrigger); sqlite3DbFree(db, pParse->apVarExpr); sqlite3DbFree(db, pParse->aAlias); while( pParse->pZombieTab ){ Table *p = pParse->pZombieTab; pParse->pZombieTab = p->pNextZombie; sqlite3DeleteTable(p); } if( nErr>0 && (pParse->rc==SQLITE_OK || pParse->rc==SQLITE_DONE) ){ pParse->rc = SQLITE_ERROR; } return nErr; } 
#ifndef SQLITE_OMIT_COMPLETE 
#ifndef SQLITE_AMALGAMATION 
#ifdef SQLITE_ASCII 
SQLITE_PRIVATE const char sqlite3IsAsciiIdChar[]; 
#define IdChar(C) (((c=C)&0x80)!=0 || (c>0x1f && sqlite3IsAsciiIdChar[c-0x20])) 
#endif 
#ifdef SQLITE_EBCDIC 
SQLITE_PRIVATE const char sqlite3IsEbcdicIdChar[]; 
#define IdChar(C) (((c=C)>=0x42 && sqlite3IsEbcdicIdChar[c-0x40])) 
#endif 
#endif 
#define tkSEMI 0 
#define tkWS 1 
#define tkOTHER 2 
#define tkEXPLAIN 3 
#define tkCREATE 4 
#define tkTEMP 5 
#define tkTRIGGER 6 
#define tkEND 7 
SQLITE_API int sqlite3_complete(const char *zSql){ u8 state = 0; u8 token; 
#ifndef SQLITE_OMIT_TRIGGER 
 static const u8 trans[7][8] = { { 0, 0, 1, 2, 3, 1, 1, 1, }, { 0, 1, 1, 1, 1, 1, 1, 1, }, { 0, 2, 1, 1, 3, 1, 1, 1, }, { 0, 3, 1, 1, 1, 3, 4, 1, }, { 5, 4, 4, 4, 4, 4, 4, 4, }, { 5, 5, 4, 4, 4, 4, 4, 6, }, { 0, 6, 4, 4, 4, 4, 4, 4, }, }; 
#else 
 static const u8 trans[2][3] = { { 0, 0, 1, }, { 0, 1, 1, }, }; 
#endif 
 while( *zSql ){ switch( *zSql ){ case ';': { token = tkSEMI; break; } case ' ': case '\r': case '\t': case '\n': case '\f': { token = tkWS; break; } case '/': { if( zSql[1]!='*' ){ token = tkOTHER; break; } zSql += 2; while( zSql[0] && (zSql[0]!='*' || zSql[1]!='/') ){ zSql++; } if( zSql[0]==0 ) return 0; zSql++; token = tkWS; break; } case '-': { if( zSql[1]!='-' ){ token = tkOTHER; break; } while( *zSql && *zSql!='\n' ){ zSql++; } if( *zSql==0 ) return state==0; token = tkWS; break; } case '[': { zSql++; while( *zSql && *zSql!=']' ){ zSql++; } if( *zSql==0 ) return 0; token = tkOTHER; break; } case '`': case '"': case '\'': { int c = *zSql; zSql++; while( *zSql && *zSql!=c ){ zSql++; } if( *zSql==0 ) return 0; token = tkOTHER; break; } default: { int c; if( IdChar((u8)*zSql) ){ int nId; for(nId=1; IdChar(zSql[nId]); nId++){} 
#ifdef SQLITE_OMIT_TRIGGER 
 token = tkOTHER; 
#else 
 switch( *zSql ){ case 'c': case 'C': { if( nId==6 && sqlite3StrNICmp(zSql, "create", 6)==0 ){ token = tkCREATE; }else{ token = tkOTHER; } break; } case 't': case 'T': { if( nId==7 && sqlite3StrNICmp(zSql, "trigger", 7)==0 ){ token = tkTRIGGER; }else if( nId==4 && sqlite3StrNICmp(zSql, "temp", 4)==0 ){ token = tkTEMP; }else if( nId==9 && sqlite3StrNICmp(zSql, "temporary", 9)==0 ){ token = tkTEMP; }else{ token = tkOTHER; } break; } case 'e': case 'E': { if( nId==3 && sqlite3StrNICmp(zSql, "end", 3)==0 ){ token = tkEND; }else 
#ifndef SQLITE_OMIT_EXPLAIN 
 if( nId==7 && sqlite3StrNICmp(zSql, "explain", 7)==0 ){ token = tkEXPLAIN; }else 
#endif 
 { token = tkOTHER; } break; } default: { token = tkOTHER; break; } } 
#endif 
 zSql += nId-1; }else{ token = tkOTHER; } break; } } state = trans[state][token]; zSql++; } return state==0; } 
#ifndef SQLITE_OMIT_UTF16 
SQLITE_API int sqlite3_complete16(const void *zSql){ sqlite3_value *pVal; char const *zSql8; int rc = SQLITE_NOMEM; 
#ifndef SQLITE_OMIT_AUTOINIT 
 rc = sqlite3_initialize(); if( rc ) return rc; 
#endif 
 pVal = sqlite3ValueNew(0); sqlite3ValueSetStr(pVal, -1, zSql, SQLITE_UTF16NATIVE, SQLITE_STATIC); zSql8 = sqlite3ValueText(pVal, SQLITE_UTF8); if( zSql8 ){ rc = sqlite3_complete(zSql8); }else{ rc = SQLITE_NOMEM; } sqlite3ValueFree(pVal); return sqlite3ApiExit(0, rc); } 
#endif 
#endif 
#ifdef SQLITE_ENABLE_FTS3 
#if 0 
extern "C" { 
#endif 
SQLITE_PRIVATE int sqlite3Fts3Init(sqlite3 *db); 
#if 0 
} 
#endif 
#endif 
#ifdef SQLITE_ENABLE_RTREE 
#if 0 
extern "C" { 
#endif 
SQLITE_PRIVATE int sqlite3RtreeInit(sqlite3 *db); 
#if 0 
} 
#endif 
#endif 
#ifdef SQLITE_ENABLE_ICU 
#if 0 
extern "C" { 
#endif 
SQLITE_PRIVATE int sqlite3IcuInit(sqlite3 *db); 
#if 0 
} 
#endif 
#endif 
SQLITE_API const char sqlite3_version[] = SQLITE_VERSION; SQLITE_API const char *sqlite3_libversion(void){ return sqlite3_version; } SQLITE_API int sqlite3_libversion_number(void){ return SQLITE_VERSION_NUMBER; } SQLITE_API int sqlite3_threadsafe(void){ return SQLITE_THREADSAFE; } 
#if !defined(SQLITE_OMIT_TRACE) && defined(SQLITE_ENABLE_IOTRACE) 
SQLITE_PRIVATE void (*sqlite3IoTrace)(const char*, ...) = 0; 
#endif 
SQLITE_API char *sqlite3_temp_directory = 0; SQLITE_API int sqlite3_initialize(void){ sqlite3_mutex *pMaster; int rc; 
#ifdef SQLITE_OMIT_WSD 
 rc = sqlite3_wsd_init(4096, 24); if( rc!=SQLITE_OK ){ return rc; } 
#endif 
 if( sqlite3GlobalConfig.isInit ) return SQLITE_OK; rc = sqlite3MutexInit(); if( rc ) return rc; pMaster = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER); sqlite3_mutex_enter(pMaster); if( !sqlite3GlobalConfig.isMallocInit ){ rc = sqlite3MallocInit(); } if( rc==SQLITE_OK ){ sqlite3GlobalConfig.isMallocInit = 1; if( !sqlite3GlobalConfig.pInitMutex ){ sqlite3GlobalConfig.pInitMutex = sqlite3MutexAlloc(SQLITE_MUTEX_RECURSIVE); if( sqlite3GlobalConfig.bCoreMutex && !sqlite3GlobalConfig.pInitMutex ){ rc = SQLITE_NOMEM; } } } if( rc==SQLITE_OK ){ sqlite3GlobalConfig.nRefInitMutex++; } sqlite3_mutex_leave(pMaster); if( rc!=SQLITE_OK ){ return rc; } sqlite3_mutex_enter(sqlite3GlobalConfig.pInitMutex); if( sqlite3GlobalConfig.isInit==0 && sqlite3GlobalConfig.inProgress==0 ){ FuncDefHash *pHash = &GLOBAL(FuncDefHash, sqlite3GlobalFunctions); sqlite3GlobalConfig.inProgress = 1; memset(pHash, 0, sizeof(sqlite3GlobalFunctions)); sqlite3RegisterGlobalFunctions(); rc = sqlite3_os_init(); if( rc==SQLITE_OK ){ rc = sqlite3PcacheInitialize(); sqlite3PCacheBufferSetup( sqlite3GlobalConfig.pPage, sqlite3GlobalConfig.szPage, sqlite3GlobalConfig.nPage); } sqlite3GlobalConfig.inProgress = 0; sqlite3GlobalConfig.isInit = (rc==SQLITE_OK ? 1 : 0); } sqlite3_mutex_leave(sqlite3GlobalConfig.pInitMutex); sqlite3_mutex_enter(pMaster); sqlite3GlobalConfig.nRefInitMutex--; if( sqlite3GlobalConfig.nRefInitMutex<=0 ){ assert( sqlite3GlobalConfig.nRefInitMutex==0 ); sqlite3_mutex_free(sqlite3GlobalConfig.pInitMutex); sqlite3GlobalConfig.pInitMutex = 0; } sqlite3_mutex_leave(pMaster); 
#ifndef NDEBUG 
 if ( rc==SQLITE_OK ){ u64 x = (((u64)1)<<63)-1; double y; assert(sizeof(x)==8); assert(sizeof(x)==sizeof(y)); memcpy(&y, &x, 8); assert( sqlite3IsNaN(y) ); } 
#endif 
 return rc; } SQLITE_API int sqlite3_shutdown(void){ sqlite3GlobalConfig.isMallocInit = 0; sqlite3PcacheShutdown(); if( sqlite3GlobalConfig.isInit ){ sqlite3_os_end(); } sqlite3MallocEnd(); sqlite3MutexEnd(); sqlite3GlobalConfig.isInit = 0; return SQLITE_OK; } SQLITE_API int sqlite3_config(int op, ...){ va_list ap; int rc = SQLITE_OK; if( sqlite3GlobalConfig.isInit ) return SQLITE_MISUSE; va_start(ap, op); switch( op ){ 
#if SQLITE_THREADSAFE 
 case SQLITE_CONFIG_SINGLETHREAD: { sqlite3GlobalConfig.bCoreMutex = 0; sqlite3GlobalConfig.bFullMutex = 0; break; } case SQLITE_CONFIG_MULTITHREAD: { sqlite3GlobalConfig.bCoreMutex = 1; sqlite3GlobalConfig.bFullMutex = 0; break; } case SQLITE_CONFIG_SERIALIZED: { sqlite3GlobalConfig.bCoreMutex = 1; sqlite3GlobalConfig.bFullMutex = 1; break; } case SQLITE_CONFIG_MUTEX: { sqlite3GlobalConfig.mutex = *va_arg(ap, sqlite3_mutex_methods*); break; } case SQLITE_CONFIG_GETMUTEX: { *va_arg(ap, sqlite3_mutex_methods*) = sqlite3GlobalConfig.mutex; break; } 
#endif 
 case SQLITE_CONFIG_MALLOC: { sqlite3GlobalConfig.m = *va_arg(ap, sqlite3_mem_methods*); break; } case SQLITE_CONFIG_GETMALLOC: { if( sqlite3GlobalConfig.m.xMalloc==0 ) sqlite3MemSetDefault(); *va_arg(ap, sqlite3_mem_methods*) = sqlite3GlobalConfig.m; break; } case SQLITE_CONFIG_MEMSTATUS: { sqlite3GlobalConfig.bMemstat = va_arg(ap, int); break; } case SQLITE_CONFIG_SCRATCH: { sqlite3GlobalConfig.pScratch = va_arg(ap, void*); sqlite3GlobalConfig.szScratch = va_arg(ap, int); sqlite3GlobalConfig.nScratch = va_arg(ap, int); break; } case SQLITE_CONFIG_PAGECACHE: { sqlite3GlobalConfig.pPage = va_arg(ap, void*); sqlite3GlobalConfig.szPage = va_arg(ap, int); sqlite3GlobalConfig.nPage = va_arg(ap, int); break; } case SQLITE_CONFIG_PCACHE: { sqlite3GlobalConfig.pcache = *va_arg(ap, sqlite3_pcache_methods*); break; } case SQLITE_CONFIG_GETPCACHE: { if( sqlite3GlobalConfig.pcache.xInit==0 ){ sqlite3PCacheSetDefault(); } *va_arg(ap, sqlite3_pcache_methods*) = sqlite3GlobalConfig.pcache; break; } 
#if defined(SQLITE_ENABLE_MEMSYS3) || defined(SQLITE_ENABLE_MEMSYS5) 
 case SQLITE_CONFIG_HEAP: { sqlite3GlobalConfig.pHeap = va_arg(ap, void*); sqlite3GlobalConfig.nHeap = va_arg(ap, int); sqlite3GlobalConfig.mnReq = va_arg(ap, int); if( sqlite3GlobalConfig.pHeap==0 ){ memset(&sqlite3GlobalConfig.m, 0, sizeof(sqlite3GlobalConfig.m)); }else{ 
#ifdef SQLITE_ENABLE_MEMSYS3 
 sqlite3GlobalConfig.m = *sqlite3MemGetMemsys3(); 
#endif 
#ifdef SQLITE_ENABLE_MEMSYS5 
 sqlite3GlobalConfig.m = *sqlite3MemGetMemsys5(); 
#endif 
 } break; } 
#endif 
 case SQLITE_CONFIG_LOOKASIDE: { sqlite3GlobalConfig.szLookaside = va_arg(ap, int); sqlite3GlobalConfig.nLookaside = va_arg(ap, int); break; } default: { rc = SQLITE_ERROR; break; } } va_end(ap); return rc; } static int setupLookaside(sqlite3 *db, void *pBuf, int sz, int cnt){ void *pStart; if( db->lookaside.nOut ){ return SQLITE_BUSY; } if( sz<0 ) sz = 0; if( cnt<0 ) cnt = 0; if( pBuf==0 ){ sz = (sz + 7)&~7; sqlite3BeginBenignMalloc(); pStart = sqlite3Malloc( sz*cnt ); sqlite3EndBenignMalloc(); }else{ sz = sz&~7; pStart = pBuf; } if( db->lookaside.bMalloced ){ sqlite3_free(db->lookaside.pStart); } db->lookaside.pStart = pStart; db->lookaside.pFree = 0; db->lookaside.sz = sz; db->lookaside.bMalloced = pBuf==0; if( pStart ){ int i; LookasideSlot *p; p = (LookasideSlot*)pStart; for(i=cnt-1; i>=0; i--){ p->pNext = db->lookaside.pFree; db->lookaside.pFree = p; p = (LookasideSlot*)&((u8*)p)[sz]; } db->lookaside.pEnd = p; db->lookaside.bEnabled = 1; }else{ db->lookaside.pEnd = 0; db->lookaside.bEnabled = 0; } return SQLITE_OK; } SQLITE_API sqlite3_mutex *sqlite3_db_mutex(sqlite3 *db){ return db->mutex; } SQLITE_API int sqlite3_db_config(sqlite3 *db, int op, ...){ va_list ap; int rc; va_start(ap, op); switch( op ){ case SQLITE_DBCONFIG_LOOKASIDE: { void *pBuf = va_arg(ap, void*); int sz = va_arg(ap, int); int cnt = va_arg(ap, int); rc = setupLookaside(db, pBuf, sz, cnt); break; } default: { rc = SQLITE_ERROR; break; } } va_end(ap); return rc; } 
#ifdef SQLITE_COVERAGE_TEST 
SQLITE_PRIVATE void sqlite3Coverage(int x){ static int dummy = 0; dummy += x; } 
#endif 
static int allSpaces(const char *z, int n){ while( n>0 && z[n-1]==' ' ){ n--; } return n==0; } static int binCollFunc( void *padFlag, int nKey1, const void *pKey1, int nKey2, const void *pKey2 ){ int rc, n; n = nKey1<nKey2 ? nKey1 : nKey2; rc = memcmp(pKey1, pKey2, n); if( rc==0 ){ if( padFlag && allSpaces(((char*)pKey1)+n, nKey1-n) && allSpaces(((char*)pKey2)+n, nKey2-n) ){ }else{ rc = nKey1 - nKey2; } } return rc; } static int nocaseCollatingFunc( void *NotUsed, int nKey1, const void *pKey1, int nKey2, const void *pKey2 ){ int r = sqlite3StrNICmp( (const char *)pKey1, (const char *)pKey2, (nKey1<nKey2)?nKey1:nKey2); UNUSED_PARAMETER(NotUsed); if( 0==r ){ r = nKey1-nKey2; } return r; } SQLITE_API sqlite_int64 sqlite3_last_insert_rowid(sqlite3 *db){ return db->lastRowid; } SQLITE_API int sqlite3_changes(sqlite3 *db){ return db->nChange; } SQLITE_API int sqlite3_total_changes(sqlite3 *db){ return db->nTotalChange; } SQLITE_API int sqlite3_close(sqlite3 *db){ HashElem *i; int j; if( !db ){ return SQLITE_OK; } if( !sqlite3SafetyCheckSickOrOk(db) ){ return SQLITE_MISUSE; } sqlite3_mutex_enter(db->mutex); 
#ifdef SQLITE_SSE 
 { extern void sqlite3SseCleanup(sqlite3*); sqlite3SseCleanup(db); } 
#endif 
 sqlite3ResetInternalSchema(db, 0); sqlite3VtabRollback(db); if( db->pVdbe ){ sqlite3Error(db, SQLITE_BUSY, "Unable to close due to unfinalised statements"); sqlite3_mutex_leave(db->mutex); return SQLITE_BUSY; } assert( sqlite3SafetyCheckSickOrOk(db) ); for(j=0; j<db->nDb; j++){ struct Db *pDb = &db->aDb[j]; if( pDb->pBt ){ sqlite3BtreeClose(pDb->pBt); pDb->pBt = 0; if( j!=1 ){ pDb->pSchema = 0; } } } sqlite3ResetInternalSchema(db, 0); assert( db->nDb<=2 ); assert( db->aDb==db->aDbStatic ); for(j=0; j<ArraySize(db->aFunc.a); j++){ FuncDef *pNext, *pHash, *p; for(p=db->aFunc.a[j]; p; p=pHash){ pHash = p->pHash; while( p ){ pNext = p->pNext; sqlite3DbFree(db, p); p = pNext; } } } for(i=sqliteHashFirst(&db->aCollSeq); i; i=sqliteHashNext(i)){ CollSeq *pColl = (CollSeq *)sqliteHashData(i); for(j=0; j<3; j++){ if( pColl[j].xDel ){ pColl[j].xDel(pColl[j].pUser); } } sqlite3DbFree(db, pColl); } sqlite3HashClear(&db->aCollSeq); 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 for(i=sqliteHashFirst(&db->aModule); i; i=sqliteHashNext(i)){ Module *pMod = (Module *)sqliteHashData(i); if( pMod->xDestroy ){ pMod->xDestroy(pMod->pAux); } sqlite3DbFree(db, pMod); } sqlite3HashClear(&db->aModule); 
#endif 
 sqlite3Error(db, SQLITE_OK, 0); if( db->pErr ){ sqlite3ValueFree(db->pErr); } sqlite3CloseExtensions(db); db->magic = SQLITE_MAGIC_ERROR; sqlite3DbFree(db, db->aDb[1].pSchema); sqlite3_mutex_leave(db->mutex); db->magic = SQLITE_MAGIC_CLOSED; sqlite3_mutex_free(db->mutex); assert( db->lookaside.nOut==0 ); if( db->lookaside.bMalloced ){ sqlite3_free(db->lookaside.pStart); } sqlite3_free(db); return SQLITE_OK; } SQLITE_PRIVATE void sqlite3RollbackAll(sqlite3 *db){ int i; int inTrans = 0; assert( sqlite3_mutex_held(db->mutex) ); sqlite3BeginBenignMalloc(); for(i=0; i<db->nDb; i++){ if( db->aDb[i].pBt ){ if( sqlite3BtreeIsInTrans(db->aDb[i].pBt) ){ inTrans = 1; } sqlite3BtreeRollback(db->aDb[i].pBt); db->aDb[i].inTrans = 0; } } sqlite3VtabRollback(db); sqlite3EndBenignMalloc(); if( db->flags&SQLITE_InternChanges ){ sqlite3ExpirePreparedStatements(db); sqlite3ResetInternalSchema(db, 0); } if( db->xRollbackCallback && (inTrans || !db->autoCommit) ){ db->xRollbackCallback(db->pRollbackArg); } } SQLITE_PRIVATE const char *sqlite3ErrStr(int rc){ const char *z; switch( rc & 0xff ){ case SQLITE_ROW: case SQLITE_DONE: case SQLITE_OK: z = "not an error"; break; case SQLITE_ERROR: z = "SQL logic error or missing database"; break; case SQLITE_PERM: z = "access permission denied"; break; case SQLITE_ABORT: z = "callback requested query abort"; break; case SQLITE_BUSY: z = "database is locked"; break; case SQLITE_LOCKED: z = "database table is locked"; break; case SQLITE_NOMEM: z = "out of memory"; break; case SQLITE_READONLY: z = "attempt to write a readonly database"; break; case SQLITE_INTERRUPT: z = "interrupted"; break; case SQLITE_IOERR: z = "disk I/O error"; break; case SQLITE_CORRUPT: z = "database disk image is malformed"; break; case SQLITE_FULL: z = "database or disk is full"; break; case SQLITE_CANTOPEN: z = "unable to open database file"; break; case SQLITE_EMPTY: z = "table contains no data"; break; case SQLITE_SCHEMA: z = "database schema has changed"; break; case SQLITE_TOOBIG: z = "String or BLOB exceeded size limit"; break; case SQLITE_CONSTRAINT: z = "constraint failed"; break; case SQLITE_MISMATCH: z = "datatype mismatch"; break; case SQLITE_MISUSE: z = "library routine called out of sequence";break; case SQLITE_NOLFS: z = "large file support is disabled"; break; case SQLITE_AUTH: z = "authorization denied"; break; case SQLITE_FORMAT: z = "auxiliary database format error"; break; case SQLITE_RANGE: z = "bind or column index out of range"; break; case SQLITE_NOTADB: z = "file is encrypted or is not a database";break; default: z = "unknown error"; break; } return z; } static int sqliteDefaultBusyCallback( void *ptr, int count ){ 
#if SQLITE_OS_WIN || (defined(HAVE_USLEEP) && HAVE_USLEEP) 
 static const u8 delays[] = { 1, 2, 5, 10, 15, 20, 25, 25, 25, 50, 50, 100 }; static const u8 totals[] = { 0, 1, 3, 8, 18, 33, 53, 78, 103, 128, 178, 228 }; 
#define NDELAY (sizeof(delays)/sizeof(delays[0])) 
 sqlite3 *db = (sqlite3 *)ptr; int timeout = db->busyTimeout; int delay, prior; assert( count>=0 ); if( count < NDELAY ){ delay = delays[count]; prior = totals[count]; }else{ delay = delays[NDELAY-1]; prior = totals[NDELAY-1] + delay*(count-(NDELAY-1)); } if( prior + delay > timeout ){ delay = timeout - prior; if( delay<=0 ) return 0; } sqlite3OsSleep(db->pVfs, delay*1000); return 1; 
#else 
 sqlite3 *db = (sqlite3 *)ptr; int timeout = ((sqlite3 *)ptr)->busyTimeout; if( (count+1)*1000 > timeout ){ return 0; } sqlite3OsSleep(db->pVfs, 1000000); return 1; 
#endif 
} SQLITE_PRIVATE int sqlite3InvokeBusyHandler(BusyHandler *p){ int rc; if( NEVER(p==0) || p->xFunc==0 || p->nBusy<0 ) return 0; rc = p->xFunc(p->pArg, p->nBusy); if( rc==0 ){ p->nBusy = -1; }else{ p->nBusy++; } return rc; } SQLITE_API int sqlite3_busy_handler( sqlite3 *db, int (*xBusy)(void*,int), void *pArg ){ sqlite3_mutex_enter(db->mutex); db->busyHandler.xFunc = xBusy; db->busyHandler.pArg = pArg; db->busyHandler.nBusy = 0; sqlite3_mutex_leave(db->mutex); return SQLITE_OK; } 
#ifndef SQLITE_OMIT_PROGRESS_CALLBACK 
SQLITE_API void sqlite3_progress_handler( sqlite3 *db, int nOps, int (*xProgress)(void*), void *pArg ){ sqlite3_mutex_enter(db->mutex); if( nOps>0 ){ db->xProgress = xProgress; db->nProgressOps = nOps; db->pProgressArg = pArg; }else{ db->xProgress = 0; db->nProgressOps = 0; db->pProgressArg = 0; } sqlite3_mutex_leave(db->mutex); } 
#endif 
SQLITE_API int sqlite3_busy_timeout(sqlite3 *db, int ms){ if( ms>0 ){ db->busyTimeout = ms; sqlite3_busy_handler(db, sqliteDefaultBusyCallback, (void*)db); }else{ sqlite3_busy_handler(db, 0, 0); } return SQLITE_OK; } SQLITE_API void sqlite3_interrupt(sqlite3 *db){ db->u1.isInterrupted = 1; } SQLITE_PRIVATE int sqlite3CreateFunc( sqlite3 *db, const char *zFunctionName, int nArg, int enc, void *pUserData, void (*xFunc)(sqlite3_context*,int,sqlite3_value **), void (*xStep)(sqlite3_context*,int,sqlite3_value **), void (*xFinal)(sqlite3_context*) ){ FuncDef *p; int nName; assert( sqlite3_mutex_held(db->mutex) ); if( zFunctionName==0 || (xFunc && (xFinal || xStep)) || (!xFunc && (xFinal && !xStep)) || (!xFunc && (!xFinal && xStep)) || (nArg<-1 || nArg>SQLITE_MAX_FUNCTION_ARG) || (255<(nName = sqlite3Strlen(db, zFunctionName))) ){ sqlite3Error(db, SQLITE_ERROR, "bad parameters"); return SQLITE_ERROR; } 
#ifndef SQLITE_OMIT_UTF16 
 if( enc==SQLITE_UTF16 ){ enc = SQLITE_UTF16NATIVE; }else if( enc==SQLITE_ANY ){ int rc; rc = sqlite3CreateFunc(db, zFunctionName, nArg, SQLITE_UTF8, pUserData, xFunc, xStep, xFinal); if( rc==SQLITE_OK ){ rc = sqlite3CreateFunc(db, zFunctionName, nArg, SQLITE_UTF16LE, pUserData, xFunc, xStep, xFinal); } if( rc!=SQLITE_OK ){ return rc; } enc = SQLITE_UTF16BE; } 
#else 
 enc = SQLITE_UTF8; 
#endif 
 p = sqlite3FindFunction(db, zFunctionName, nName, nArg, enc, 0); if( p && p->iPrefEnc==enc && p->nArg==nArg ){ if( db->activeVdbeCnt ){ sqlite3Error(db, SQLITE_BUSY, "Unable to delete/modify user-function due to active statements"); assert( !db->mallocFailed ); return SQLITE_BUSY; }else{ sqlite3ExpirePreparedStatements(db); } } p = sqlite3FindFunction(db, zFunctionName, nName, nArg, enc, 1); assert(p || db->mallocFailed); if( !p ){ return SQLITE_NOMEM; } p->flags = 0; p->xFunc = xFunc; p->xStep = xStep; p->xFinalize = xFinal; p->pUserData = pUserData; p->nArg = nArg; return SQLITE_OK; } SQLITE_API int sqlite3_create_function( sqlite3 *db, const char *zFunctionName, int nArg, int enc, void *p, void (*xFunc)(sqlite3_context*,int,sqlite3_value **), void (*xStep)(sqlite3_context*,int,sqlite3_value **), void (*xFinal)(sqlite3_context*) ){ int rc; sqlite3_mutex_enter(db->mutex); rc = sqlite3CreateFunc(db, zFunctionName, nArg, enc, p, xFunc, xStep, xFinal); rc = sqlite3ApiExit(db, rc); sqlite3_mutex_leave(db->mutex); return rc; } 
#ifndef SQLITE_OMIT_UTF16 
SQLITE_API int sqlite3_create_function16( sqlite3 *db, const void *zFunctionName, int nArg, int eTextRep, void *p, void (*xFunc)(sqlite3_context*,int,sqlite3_value**), void (*xStep)(sqlite3_context*,int,sqlite3_value**), void (*xFinal)(sqlite3_context*) ){ int rc; char *zFunc8; sqlite3_mutex_enter(db->mutex); assert( !db->mallocFailed ); zFunc8 = sqlite3Utf16to8(db, zFunctionName, -1); rc = sqlite3CreateFunc(db, zFunc8, nArg, eTextRep, p, xFunc, xStep, xFinal); sqlite3DbFree(db, zFunc8); rc = sqlite3ApiExit(db, rc); sqlite3_mutex_leave(db->mutex); return rc; } 
#endif 
SQLITE_API int sqlite3_overload_function( sqlite3 *db, const char *zName, int nArg ){ int nName = sqlite3Strlen(db, zName); int rc; sqlite3_mutex_enter(db->mutex); if( sqlite3FindFunction(db, zName, nName, nArg, SQLITE_UTF8, 0)==0 ){ sqlite3CreateFunc(db, zName, nArg, SQLITE_UTF8, 0, sqlite3InvalidFunction, 0, 0); } rc = sqlite3ApiExit(db, SQLITE_OK); sqlite3_mutex_leave(db->mutex); return rc; } 
#ifndef SQLITE_OMIT_TRACE 
SQLITE_API void *sqlite3_trace(sqlite3 *db, void (*xTrace)(void*,const char*), void *pArg){ void *pOld; sqlite3_mutex_enter(db->mutex); pOld = db->pTraceArg; db->xTrace = xTrace; db->pTraceArg = pArg; sqlite3_mutex_leave(db->mutex); return pOld; } SQLITE_API void *sqlite3_profile( sqlite3 *db, void (*xProfile)(void*,const char*,sqlite_uint64), void *pArg ){ void *pOld; sqlite3_mutex_enter(db->mutex); pOld = db->pProfileArg; db->xProfile = xProfile; db->pProfileArg = pArg; sqlite3_mutex_leave(db->mutex); return pOld; } 
#endif 
SQLITE_API void *sqlite3_commit_hook( sqlite3 *db, int (*xCallback)(void*), void *pArg ){ void *pOld; sqlite3_mutex_enter(db->mutex); pOld = db->pCommitArg; db->xCommitCallback = xCallback; db->pCommitArg = pArg; sqlite3_mutex_leave(db->mutex); return pOld; } SQLITE_API void *sqlite3_update_hook( sqlite3 *db, void (*xCallback)(void*,int,char const *,char const *,sqlite_int64), void *pArg ){ void *pRet; sqlite3_mutex_enter(db->mutex); pRet = db->pUpdateArg; db->xUpdateCallback = xCallback; db->pUpdateArg = pArg; sqlite3_mutex_leave(db->mutex); return pRet; } SQLITE_API void *sqlite3_rollback_hook( sqlite3 *db, void (*xCallback)(void*), void *pArg ){ void *pRet; sqlite3_mutex_enter(db->mutex); pRet = db->pRollbackArg; db->xRollbackCallback = xCallback; db->pRollbackArg = pArg; sqlite3_mutex_leave(db->mutex); return pRet; } SQLITE_PRIVATE int sqlite3BtreeFactory( const sqlite3 *db, const char *zFilename, int omitJournal, int nCache, int vfsFlags, Btree **ppBtree ){ int btFlags = 0; int rc; assert( sqlite3_mutex_held(db->mutex) ); assert( ppBtree != 0); if( omitJournal ){ btFlags |= BTREE_OMIT_JOURNAL; } if( db->flags & SQLITE_NoReadlock ){ btFlags |= BTREE_NO_READLOCK; } if( zFilename==0 ){ 
#if SQLITE_TEMP_STORE==0 
 
#endif 
#ifndef SQLITE_OMIT_MEMORYDB 
#if SQLITE_TEMP_STORE==1 
 if( db->temp_store==2 ) zFilename = ":memory:"; 
#endif 
#if SQLITE_TEMP_STORE==2 
 if( db->temp_store!=1 ) zFilename = ":memory:"; 
#endif 
#if SQLITE_TEMP_STORE==3 
 zFilename = ":memory:"; 
#endif 
#endif 
 } if( (vfsFlags & SQLITE_OPEN_MAIN_DB)!=0 && (zFilename==0 || *zFilename==0) ){ vfsFlags = (vfsFlags & ~SQLITE_OPEN_MAIN_DB) | SQLITE_OPEN_TEMP_DB; } rc = sqlite3BtreeOpen(zFilename, (sqlite3 *)db, ppBtree, btFlags, vfsFlags); if( rc==SQLITE_OK && 0==sqlite3BtreeSchema(*ppBtree, 0, 0) ){ sqlite3BtreeSetCacheSize(*ppBtree, nCache); } return rc; } SQLITE_API const char *sqlite3_errmsg(sqlite3 *db){ const char *z; if( !db ){ return sqlite3ErrStr(SQLITE_NOMEM); } if( !sqlite3SafetyCheckSickOrOk(db) ){ return sqlite3ErrStr(SQLITE_MISUSE); } sqlite3_mutex_enter(db->mutex); assert( !db->mallocFailed ); z = (char*)sqlite3_value_text(db->pErr); assert( !db->mallocFailed ); if( z==0 ){ z = sqlite3ErrStr(db->errCode); } sqlite3_mutex_leave(db->mutex); return z; } 
#ifndef SQLITE_OMIT_UTF16 
SQLITE_API const void *sqlite3_errmsg16(sqlite3 *db){ static const char outOfMemBe[] = { 0, 'o', 0, 'u', 0, 't', 0, ' ', 0, 'o', 0, 'f', 0, ' ', 0, 'm', 0, 'e', 0, 'm', 0, 'o', 0, 'r', 0, 'y', 0, 0, 0 }; static const char misuseBe [] = { 0, 'l', 0, 'i', 0, 'b', 0, 'r', 0, 'a', 0, 'r', 0, 'y', 0, ' ', 0, 'r', 0, 'o', 0, 'u', 0, 't', 0, 'i', 0, 'n', 0, 'e', 0, ' ', 0, 'c', 0, 'a', 0, 'l', 0, 'l', 0, 'e', 0, 'd', 0, ' ', 0, 'o', 0, 'u', 0, 't', 0, ' ', 0, 'o', 0, 'f', 0, ' ', 0, 's', 0, 'e', 0, 'q', 0, 'u', 0, 'e', 0, 'n', 0, 'c', 0, 'e', 0, 0, 0 }; const void *z; if( !db ){ return (void *)(&outOfMemBe[SQLITE_UTF16NATIVE==SQLITE_UTF16LE?1:0]); } if( !sqlite3SafetyCheckSickOrOk(db) ){ return (void *)(&misuseBe[SQLITE_UTF16NATIVE==SQLITE_UTF16LE?1:0]); } sqlite3_mutex_enter(db->mutex); assert( !db->mallocFailed ); z = sqlite3_value_text16(db->pErr); if( z==0 ){ sqlite3ValueSetStr(db->pErr, -1, sqlite3ErrStr(db->errCode), SQLITE_UTF8, SQLITE_STATIC); z = sqlite3_value_text16(db->pErr); } db->mallocFailed = 0; sqlite3_mutex_leave(db->mutex); return z; } 
#endif 
SQLITE_API int sqlite3_errcode(sqlite3 *db){ if( db && !sqlite3SafetyCheckSickOrOk(db) ){ return SQLITE_MISUSE; } if( !db || db->mallocFailed ){ return SQLITE_NOMEM; } return db->errCode & db->errMask; } SQLITE_API int sqlite3_extended_errcode(sqlite3 *db){ if( db && !sqlite3SafetyCheckSickOrOk(db) ){ return SQLITE_MISUSE; } if( !db || db->mallocFailed ){ return SQLITE_NOMEM; } return db->errCode; } static int createCollation( sqlite3* db, const char *zName, int enc, void* pCtx, int(*xCompare)(void*,int,const void*,int,const void*), void(*xDel)(void*) ){ CollSeq *pColl; int enc2; int nName; assert( sqlite3_mutex_held(db->mutex) ); enc2 = enc & ~SQLITE_UTF16_ALIGNED; if( enc2==SQLITE_UTF16 ){ enc2 = SQLITE_UTF16NATIVE; } if( (enc2&~3)!=0 ){ return SQLITE_MISUSE; } nName = sqlite3Strlen(db, zName); pColl = sqlite3FindCollSeq(db, (u8)enc2, zName, nName, 0); if( pColl && pColl->xCmp ){ if( db->activeVdbeCnt ){ sqlite3Error(db, SQLITE_BUSY, "Unable to delete/modify collation sequence due to active statements"); return SQLITE_BUSY; } sqlite3ExpirePreparedStatements(db); if( (pColl->enc & ~SQLITE_UTF16_ALIGNED)==enc2 ){ CollSeq *aColl = sqlite3HashFind(&db->aCollSeq, zName, nName); int j; for(j=0; j<3; j++){ CollSeq *p = &aColl[j]; if( p->enc==pColl->enc ){ if( p->xDel ){ p->xDel(p->pUser); } p->xCmp = 0; } } } } pColl = sqlite3FindCollSeq(db, (u8)enc2, zName, nName, 1); if( pColl ){ pColl->xCmp = xCompare; pColl->pUser = pCtx; pColl->xDel = xDel; pColl->enc = enc2 | (enc & SQLITE_UTF16_ALIGNED); } sqlite3Error(db, SQLITE_OK, 0); return SQLITE_OK; } static const int aHardLimit[] = { SQLITE_MAX_LENGTH, SQLITE_MAX_SQL_LENGTH, SQLITE_MAX_COLUMN, SQLITE_MAX_EXPR_DEPTH, SQLITE_MAX_COMPOUND_SELECT, SQLITE_MAX_VDBE_OP, SQLITE_MAX_FUNCTION_ARG, SQLITE_MAX_ATTACHED, SQLITE_MAX_LIKE_PATTERN_LENGTH, SQLITE_MAX_VARIABLE_NUMBER, }; 
#if SQLITE_MAX_LENGTH<100 
#error SQLITE_MAX_LENGTH must be at least 100 
#endif 
#if SQLITE_MAX_SQL_LENGTH<100 
#error SQLITE_MAX_SQL_LENGTH must be at least 100 
#endif 
#if SQLITE_MAX_SQL_LENGTH>SQLITE_MAX_LENGTH 
#error SQLITE_MAX_SQL_LENGTH must not be greater than SQLITE_MAX_LENGTH 
#endif 
#if SQLITE_MAX_COMPOUND_SELECT<2 
#error SQLITE_MAX_COMPOUND_SELECT must be at least 2 
#endif 
#if SQLITE_MAX_VDBE_OP<40 
#error SQLITE_MAX_VDBE_OP must be at least 40 
#endif 
#if SQLITE_MAX_FUNCTION_ARG<0 || SQLITE_MAX_FUNCTION_ARG>1000 
#error SQLITE_MAX_FUNCTION_ARG must be between 0 and 1000 
#endif 
#if SQLITE_MAX_ATTACHED<0 || SQLITE_MAX_ATTACHED>30 
#error SQLITE_MAX_ATTACHED must be between 0 and 30 
#endif 
#if SQLITE_MAX_LIKE_PATTERN_LENGTH<1 
#error SQLITE_MAX_LIKE_PATTERN_LENGTH must be at least 1 
#endif 
#if SQLITE_MAX_VARIABLE_NUMBER<1 
#error SQLITE_MAX_VARIABLE_NUMBER must be at least 1 
#endif 
#if SQLITE_MAX_COLUMN>32767 
#error SQLITE_MAX_COLUMN must not exceed 32767 
#endif 
SQLITE_API int sqlite3_limit(sqlite3 *db, int limitId, int newLimit){ int oldLimit; if( limitId<0 || limitId>=SQLITE_N_LIMIT ){ return -1; } oldLimit = db->aLimit[limitId]; if( newLimit>=0 ){ if( newLimit>aHardLimit[limitId] ){ newLimit = aHardLimit[limitId]; } db->aLimit[limitId] = newLimit; } return oldLimit; } static int openDatabase( const char *zFilename, sqlite3 **ppDb, unsigned flags, const char *zVfs ){ sqlite3 *db; int rc; CollSeq *pColl; int isThreadsafe; 
#ifndef SQLITE_OMIT_AUTOINIT 
 rc = sqlite3_initialize(); if( rc ) return rc; 
#endif 
 if( sqlite3GlobalConfig.bCoreMutex==0 ){ isThreadsafe = 0; }else if( flags & SQLITE_OPEN_NOMUTEX ){ isThreadsafe = 0; }else if( flags & SQLITE_OPEN_FULLMUTEX ){ isThreadsafe = 1; }else{ isThreadsafe = sqlite3GlobalConfig.bFullMutex; } flags &= ~( SQLITE_OPEN_DELETEONCLOSE | SQLITE_OPEN_MAIN_DB | SQLITE_OPEN_TEMP_DB | SQLITE_OPEN_TRANSIENT_DB | SQLITE_OPEN_MAIN_JOURNAL | SQLITE_OPEN_TEMP_JOURNAL | SQLITE_OPEN_SUBJOURNAL | SQLITE_OPEN_MASTER_JOURNAL | SQLITE_OPEN_NOMUTEX | SQLITE_OPEN_FULLMUTEX ); db = sqlite3MallocZero( sizeof(sqlite3) ); if( db==0 ) goto opendb_out; if( isThreadsafe ){ db->mutex = sqlite3MutexAlloc(SQLITE_MUTEX_RECURSIVE); if( db->mutex==0 ){ sqlite3_free(db); db = 0; goto opendb_out; } } sqlite3_mutex_enter(db->mutex); db->errMask = 0xff; db->priorNewRowid = 0; db->nDb = 2; db->magic = SQLITE_MAGIC_BUSY; db->aDb = db->aDbStatic; assert( sizeof(db->aLimit)==sizeof(aHardLimit) ); memcpy(db->aLimit, aHardLimit, sizeof(db->aLimit)); db->autoCommit = 1; db->nextAutovac = -1; db->nextPagesize = 0; db->flags |= SQLITE_ShortColNames 
#if SQLITE_DEFAULT_FILE_FORMAT<4 
 | SQLITE_LegacyFileFmt 
#endif 
#ifdef SQLITE_ENABLE_LOAD_EXTENSION 
 | SQLITE_LoadExtension 
#endif 
 ; sqlite3HashInit(&db->aCollSeq, 0); 
#ifndef SQLITE_OMIT_VIRTUALTABLE 
 sqlite3HashInit(&db->aModule, 0); 
#endif 
 db->pVfs = sqlite3_vfs_find(zVfs); if( !db->pVfs ){ rc = SQLITE_ERROR; sqlite3Error(db, rc, "no such vfs: %s", zVfs); goto opendb_out; } createCollation(db, "BINARY", SQLITE_UTF8, 0, binCollFunc, 0); createCollation(db, "BINARY", SQLITE_UTF16BE, 0, binCollFunc, 0); createCollation(db, "BINARY", SQLITE_UTF16LE, 0, binCollFunc, 0); createCollation(db, "RTRIM", SQLITE_UTF8, (void*)1, binCollFunc, 0); if( db->mallocFailed ){ goto opendb_out; } db->pDfltColl = sqlite3FindCollSeq(db, SQLITE_UTF8, "BINARY", 6, 0); assert( db->pDfltColl!=0 ); createCollation(db, "NOCASE", SQLITE_UTF8, 0, nocaseCollatingFunc, 0); db->pDfltColl->type = SQLITE_COLL_BINARY; pColl = sqlite3FindCollSeq(db, SQLITE_UTF8, "NOCASE", 6, 0); if( pColl ){ pColl->type = SQLITE_COLL_NOCASE; } db->openFlags = flags; rc = sqlite3BtreeFactory(db, zFilename, 0, SQLITE_DEFAULT_CACHE_SIZE, flags | SQLITE_OPEN_MAIN_DB, &db->aDb[0].pBt); if( rc!=SQLITE_OK ){ if( rc==SQLITE_IOERR_NOMEM ){ rc = SQLITE_NOMEM; } sqlite3Error(db, rc, 0); goto opendb_out; } db->aDb[0].pSchema = sqlite3SchemaGet(db, db->aDb[0].pBt); db->aDb[1].pSchema = sqlite3SchemaGet(db, 0); db->aDb[0].zName = "main"; db->aDb[0].safety_level = 3; 
#ifndef SQLITE_OMIT_TEMPDB 
 db->aDb[1].zName = "temp"; db->aDb[1].safety_level = 1; 
#endif 
 db->magic = SQLITE_MAGIC_OPEN; if( db->mallocFailed ){ goto opendb_out; } sqlite3Error(db, SQLITE_OK, 0); sqlite3RegisterBuiltinFunctions(db); (void)sqlite3AutoLoadExtensions(db); if( sqlite3_errcode(db)!=SQLITE_OK ){ goto opendb_out; } 
#ifdef SQLITE_ENABLE_FTS1 
 if( !db->mallocFailed ){ extern int sqlite3Fts1Init(sqlite3*); rc = sqlite3Fts1Init(db); } 
#endif 
#ifdef SQLITE_ENABLE_FTS2 
 if( !db->mallocFailed && rc==SQLITE_OK ){ extern int sqlite3Fts2Init(sqlite3*); rc = sqlite3Fts2Init(db); } 
#endif 
#ifdef SQLITE_ENABLE_FTS3 
 if( !db->mallocFailed && rc==SQLITE_OK ){ rc = sqlite3Fts3Init(db); } 
#endif 
#ifdef SQLITE_ENABLE_ICU 
 if( !db->mallocFailed && rc==SQLITE_OK ){ rc = sqlite3IcuInit(db); } 
#endif 
#ifdef SQLITE_ENABLE_RTREE 
 if( !db->mallocFailed && rc==SQLITE_OK){ rc = sqlite3RtreeInit(db); } 
#endif 
 sqlite3Error(db, rc, 0); 
#ifdef SQLITE_DEFAULT_LOCKING_MODE 
 db->dfltLockMode = SQLITE_DEFAULT_LOCKING_MODE; sqlite3PagerLockingMode(sqlite3BtreePager(db->aDb[0].pBt), SQLITE_DEFAULT_LOCKING_MODE); 
#endif 
 setupLookaside(db, 0, sqlite3GlobalConfig.szLookaside, sqlite3GlobalConfig.nLookaside); opendb_out: if( db ){ assert( db->mutex!=0 || isThreadsafe==0 || sqlite3GlobalConfig.bFullMutex==0 ); sqlite3_mutex_leave(db->mutex); } rc = sqlite3_errcode(db); if( rc==SQLITE_NOMEM ){ sqlite3_close(db); db = 0; }else if( rc!=SQLITE_OK ){ db->magic = SQLITE_MAGIC_SICK; } *ppDb = db; return sqlite3ApiExit(0, rc); } SQLITE_API int sqlite3_open( const char *zFilename, sqlite3 **ppDb ){ return openDatabase(zFilename, ppDb, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, 0); } SQLITE_API int sqlite3_open_v2( const char *filename, sqlite3 **ppDb, int flags, const char *zVfs ){ return openDatabase(filename, ppDb, flags, zVfs); } 
#ifndef SQLITE_OMIT_UTF16 
SQLITE_API int sqlite3_open16( const void *zFilename, sqlite3 **ppDb ){ char const *zFilename8; sqlite3_value *pVal; int rc; assert( zFilename ); assert( ppDb ); *ppDb = 0; 
#ifndef SQLITE_OMIT_AUTOINIT 
 rc = sqlite3_initialize(); if( rc ) return rc; 
#endif 
 pVal = sqlite3ValueNew(0); sqlite3ValueSetStr(pVal, -1, zFilename, SQLITE_UTF16NATIVE, SQLITE_STATIC); zFilename8 = sqlite3ValueText(pVal, SQLITE_UTF8); if( zFilename8 ){ rc = openDatabase(zFilename8, ppDb, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, 0); assert( *ppDb || rc==SQLITE_NOMEM ); if( rc==SQLITE_OK && !DbHasProperty(*ppDb, 0, DB_SchemaLoaded) ){ ENC(*ppDb) = SQLITE_UTF16NATIVE; } }else{ rc = SQLITE_NOMEM; } sqlite3ValueFree(pVal); return sqlite3ApiExit(0, rc); } 
#endif 
SQLITE_API int sqlite3_create_collation( sqlite3* db, const char *zName, int enc, void* pCtx, int(*xCompare)(void*,int,const void*,int,const void*) ){ int rc; sqlite3_mutex_enter(db->mutex); assert( !db->mallocFailed ); rc = createCollation(db, zName, enc, pCtx, xCompare, 0); rc = sqlite3ApiExit(db, rc); sqlite3_mutex_leave(db->mutex); return rc; } SQLITE_API int sqlite3_create_collation_v2( sqlite3* db, const char *zName, int enc, void* pCtx, int(*xCompare)(void*,int,const void*,int,const void*), void(*xDel)(void*) ){ int rc; sqlite3_mutex_enter(db->mutex); assert( !db->mallocFailed ); rc = createCollation(db, zName, enc, pCtx, xCompare, xDel); rc = sqlite3ApiExit(db, rc); sqlite3_mutex_leave(db->mutex); return rc; } 
#ifndef SQLITE_OMIT_UTF16 
SQLITE_API int sqlite3_create_collation16( sqlite3* db, const void *zName, int enc, void* pCtx, int(*xCompare)(void*,int,const void*,int,const void*) ){ int rc = SQLITE_OK; char *zName8; sqlite3_mutex_enter(db->mutex); assert( !db->mallocFailed ); zName8 = sqlite3Utf16to8(db, zName, -1); if( zName8 ){ rc = createCollation(db, zName8, enc, pCtx, xCompare, 0); sqlite3DbFree(db, zName8); } rc = sqlite3ApiExit(db, rc); sqlite3_mutex_leave(db->mutex); return rc; } 
#endif 
SQLITE_API int sqlite3_collation_needed( sqlite3 *db, void *pCollNeededArg, void(*xCollNeeded)(void*,sqlite3*,int eTextRep,const char*) ){ sqlite3_mutex_enter(db->mutex); db->xCollNeeded = xCollNeeded; db->xCollNeeded16 = 0; db->pCollNeededArg = pCollNeededArg; sqlite3_mutex_leave(db->mutex); return SQLITE_OK; } 
#ifndef SQLITE_OMIT_UTF16 
SQLITE_API int sqlite3_collation_needed16( sqlite3 *db, void *pCollNeededArg, void(*xCollNeeded16)(void*,sqlite3*,int eTextRep,const void*) ){ sqlite3_mutex_enter(db->mutex); db->xCollNeeded = 0; db->xCollNeeded16 = xCollNeeded16; db->pCollNeededArg = pCollNeededArg; sqlite3_mutex_leave(db->mutex); return SQLITE_OK; } 
#endif 
#ifndef SQLITE_OMIT_GLOBALRECOVER 
#ifndef SQLITE_OMIT_DEPRECATED 
SQLITE_API int sqlite3_global_recover(void){ return SQLITE_OK; } 
#endif 
#endif 
SQLITE_API int sqlite3_get_autocommit(sqlite3 *db){ return db->autoCommit; } 
#ifdef SQLITE_DEBUG 
SQLITE_PRIVATE int sqlite3Corrupt(void){ return SQLITE_CORRUPT; } 
#endif 
#ifndef SQLITE_OMIT_DEPRECATED 
SQLITE_API void sqlite3_thread_cleanup(void){ } 
#endif 
#ifdef SQLITE_ENABLE_COLUMN_METADATA 
SQLITE_API int sqlite3_table_column_metadata( sqlite3 *db, const char *zDbName, const char *zTableName, const char *zColumnName, char const **pzDataType, char const **pzCollSeq, int *pNotNull, int *pPrimaryKey, int *pAutoinc ){ int rc; char *zErrMsg = 0; Table *pTab = 0; Column *pCol = 0; int iCol; char const *zDataType = 0; char const *zCollSeq = 0; int notnull = 0; int primarykey = 0; int autoinc = 0; sqlite3_mutex_enter(db->mutex); (void)sqlite3SafetyOn(db); sqlite3BtreeEnterAll(db); rc = sqlite3Init(db, &zErrMsg); sqlite3BtreeLeaveAll(db); if( SQLITE_OK!=rc ){ goto error_out; } pTab = sqlite3FindTable(db, zTableName, zDbName); if( !pTab || pTab->pSelect ){ pTab = 0; goto error_out; } if( sqlite3IsRowid(zColumnName) ){ iCol = pTab->iPKey; if( iCol>=0 ){ pCol = &pTab->aCol[iCol]; } }else{ for(iCol=0; iCol<pTab->nCol; iCol++){ pCol = &pTab->aCol[iCol]; if( 0==sqlite3StrICmp(pCol->zName, zColumnName) ){ break; } } if( iCol==pTab->nCol ){ pTab = 0; goto error_out; } } if( pCol ){ zDataType = pCol->zType; zCollSeq = pCol->zColl; notnull = pCol->notNull!=0; primarykey = pCol->isPrimKey!=0; autoinc = pTab->iPKey==iCol && (pTab->tabFlags & TF_Autoincrement)!=0; }else{ zDataType = "INTEGER"; primarykey = 1; } if( !zCollSeq ){ zCollSeq = "BINARY"; } error_out: (void)sqlite3SafetyOff(db); if( pzDataType ) *pzDataType = zDataType; if( pzCollSeq ) *pzCollSeq = zCollSeq; if( pNotNull ) *pNotNull = notnull; if( pPrimaryKey ) *pPrimaryKey = primarykey; if( pAutoinc ) *pAutoinc = autoinc; if( SQLITE_OK==rc && !pTab ){ sqlite3DbFree(db, zErrMsg); zErrMsg = sqlite3MPrintf(db, "no such table column: %s.%s", zTableName, zColumnName); rc = SQLITE_ERROR; } sqlite3Error(db, rc, (zErrMsg?"%s":0), zErrMsg); sqlite3DbFree(db, zErrMsg); rc = sqlite3ApiExit(db, rc); sqlite3_mutex_leave(db->mutex); return rc; } 
#endif 
SQLITE_API int sqlite3_sleep(int ms){ sqlite3_vfs *pVfs; int rc; pVfs = sqlite3_vfs_find(0); if( pVfs==0 ) return 0; rc = (sqlite3OsSleep(pVfs, 1000*ms)/1000); return rc; } SQLITE_API int sqlite3_extended_result_codes(sqlite3 *db, int onoff){ sqlite3_mutex_enter(db->mutex); db->errMask = onoff ? 0xffffffff : 0xff; sqlite3_mutex_leave(db->mutex); return SQLITE_OK; } SQLITE_API int sqlite3_file_control(sqlite3 *db, const char *zDbName, int op, void *pArg){ int rc = SQLITE_ERROR; int iDb; sqlite3_mutex_enter(db->mutex); if( zDbName==0 ){ iDb = 0; }else{ for(iDb=0; iDb<db->nDb; iDb++){ if( strcmp(db->aDb[iDb].zName, zDbName)==0 ) break; } } if( iDb<db->nDb ){ Btree *pBtree = db->aDb[iDb].pBt; if( pBtree ){ Pager *pPager; sqlite3_file *fd; sqlite3BtreeEnter(pBtree); pPager = sqlite3BtreePager(pBtree); assert( pPager!=0 ); fd = sqlite3PagerFile(pPager); assert( fd!=0 ); if( fd->pMethods ){ rc = sqlite3OsFileControl(fd, op, pArg); } sqlite3BtreeLeave(pBtree); } } sqlite3_mutex_leave(db->mutex); return rc; } SQLITE_API int sqlite3_test_control(int op, ...){ int rc = 0; 
#ifndef SQLITE_OMIT_BUILTIN_TEST 
 va_list ap; va_start(ap, op); switch( op ){ case SQLITE_TESTCTRL_PRNG_SAVE: { sqlite3PrngSaveState(); break; } case SQLITE_TESTCTRL_PRNG_RESTORE: { sqlite3PrngRestoreState(); break; } case SQLITE_TESTCTRL_PRNG_RESET: { sqlite3PrngResetState(); break; } case SQLITE_TESTCTRL_BITVEC_TEST: { int sz = va_arg(ap, int); int *aProg = va_arg(ap, int*); rc = sqlite3BitvecBuiltinTest(sz, aProg); break; } case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS: { typedef void (*void_function)(void); void_function xBenignBegin; void_function xBenignEnd; xBenignBegin = va_arg(ap, void_function); xBenignEnd = va_arg(ap, void_function); sqlite3BenignMallocHooks(xBenignBegin, xBenignEnd); break; } } va_end(ap); 
#endif 
 return rc; } 
#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3) 
#if defined(SQLITE_ENABLE_FTS3) && !defined(SQLITE_CORE) 
#define SQLITE_CORE 1 
#endif 
#ifndef _FTS3_HASH_H_ 
#define _FTS3_HASH_H_ 
typedef struct fts3Hash fts3Hash; typedef struct fts3HashElem fts3HashElem; struct fts3Hash { char keyClass; char copyKey; int count; fts3HashElem *first; int htsize; struct _fts3ht { int count; fts3HashElem *chain; } *ht; }; struct fts3HashElem { fts3HashElem *next, *prev; void *data; void *pKey; int nKey; }; 
#define FTS3_HASH_STRING 1 
#define FTS3_HASH_BINARY 2 
SQLITE_PRIVATE void sqlite3Fts3HashInit(fts3Hash*, int keytype, int copyKey); SQLITE_PRIVATE void *sqlite3Fts3HashInsert(fts3Hash*, const void *pKey, int nKey, void *pData); SQLITE_PRIVATE void *sqlite3Fts3HashFind(const fts3Hash*, const void *pKey, int nKey); SQLITE_PRIVATE void sqlite3Fts3HashClear(fts3Hash*); 
#define fts3HashInit sqlite3Fts3HashInit 
#define fts3HashInsert sqlite3Fts3HashInsert 
#define fts3HashFind sqlite3Fts3HashFind 
#define fts3HashClear sqlite3Fts3HashClear 
#define fts3HashFirst(H) ((H)->first) 
#define fts3HashNext(E) ((E)->next) 
#define fts3HashData(E) ((E)->data) 
#define fts3HashKey(E) ((E)->pKey) 
#define fts3HashKeysize(E) ((E)->nKey) 
#define fts3HashCount(H) ((H)->count) 
#endif 
#ifndef _FTS3_TOKENIZER_H_ 
#define _FTS3_TOKENIZER_H_ 
typedef struct sqlite3_tokenizer_module sqlite3_tokenizer_module; typedef struct sqlite3_tokenizer sqlite3_tokenizer; typedef struct sqlite3_tokenizer_cursor sqlite3_tokenizer_cursor; struct sqlite3_tokenizer_module { int iVersion; int (*xCreate)( int argc, const char *const*argv, sqlite3_tokenizer **ppTokenizer ); int (*xDestroy)(sqlite3_tokenizer *pTokenizer); int (*xOpen)( sqlite3_tokenizer *pTokenizer, const char *pInput, int nBytes, sqlite3_tokenizer_cursor **ppCursor ); int (*xClose)(sqlite3_tokenizer_cursor *pCursor); int (*xNext)( sqlite3_tokenizer_cursor *pCursor, const char **ppToken, int *pnBytes, int *piStartOffset, int *piEndOffset, int *piPosition ); }; struct sqlite3_tokenizer { const sqlite3_tokenizer_module *pModule; }; struct sqlite3_tokenizer_cursor { sqlite3_tokenizer *pTokenizer; }; 
#endif 
#ifndef SQLITE_CORE 
 SQLITE_EXTENSION_INIT1 
#endif 
#if 0 
#define FTSTRACE(A) printf A; fflush(stdout) 
#else 
#define FTSTRACE(A) 
#endif 
#define SQLITE_FTS3_DEFAULT_NEAR_PARAM 10 
static int safe_isspace(char c){ return (c&0x80)==0 ? isspace(c) : 0; } static int safe_tolower(char c){ return (c&0x80)==0 ? tolower(c) : c; } static int safe_isalnum(char c){ return (c&0x80)==0 ? isalnum(c) : 0; } typedef enum DocListType { DL_DOCIDS, DL_POSITIONS, DL_POSITIONS_OFFSETS } DocListType; 
#ifndef DL_DEFAULT 
#define DL_DEFAULT DL_POSITIONS 
#endif 
enum { POS_END = 0, POS_COLUMN, POS_BASE }; 
#define MERGE_COUNT 16 
#define CLEAR(b) memset(b, '\0', sizeof(*(b))) 
#ifndef NDEBUG 
#define SCRAMBLE(b) memset(b, 0x55, sizeof(*(b))) 
#else 
#define SCRAMBLE(b) 
#endif 
#define VARINT_MAX 10 
static int fts3PutVarint(char *p, sqlite_int64 v){ unsigned char *q = (unsigned char *) p; sqlite_uint64 vu = v; do{ *q++ = (unsigned char) ((vu & 0x7f) | 0x80); vu >>= 7; }while( vu!=0 ); q[-1] &= 0x7f; assert( q - (unsigned char *)p <= VARINT_MAX ); return (int) (q - (unsigned char *)p); } static int fts3GetVarint(const char *p, sqlite_int64 *v){ const unsigned char *q = (const unsigned char *) p; sqlite_uint64 x = 0, y = 1; while( (*q & 0x80) == 0x80 ){ x += y * (*q++ & 0x7f); y <<= 7; if( q - (unsigned char *)p >= VARINT_MAX ){ assert( 0 ); return 0; } } x += y * (*q++); *v = (sqlite_int64) x; return (int) (q - (unsigned char *)p); } static int fts3GetVarint32(const char *p, int *pi){ sqlite_int64 i; int ret = fts3GetVarint(p, &i); *pi = (int) i; assert( *pi==i ); return ret; } typedef struct DataBuffer { char *pData; int nCapacity; int nData; } DataBuffer; static void dataBufferInit(DataBuffer *pBuffer, int nCapacity){ assert( nCapacity>=0 ); pBuffer->nData = 0; pBuffer->nCapacity = nCapacity; pBuffer->pData = nCapacity==0 ? NULL : sqlite3_malloc(nCapacity); } static void dataBufferReset(DataBuffer *pBuffer){ pBuffer->nData = 0; } static void dataBufferDestroy(DataBuffer *pBuffer){ if( pBuffer->pData!=NULL ) sqlite3_free(pBuffer->pData); SCRAMBLE(pBuffer); } static void dataBufferSwap(DataBuffer *pBuffer1, DataBuffer *pBuffer2){ DataBuffer tmp = *pBuffer1; *pBuffer1 = *pBuffer2; *pBuffer2 = tmp; } static void dataBufferExpand(DataBuffer *pBuffer, int nAddCapacity){ assert( nAddCapacity>0 ); if( pBuffer->nData+nAddCapacity>pBuffer->nCapacity ){ pBuffer->nCapacity = pBuffer->nData+nAddCapacity; pBuffer->pData = sqlite3_realloc(pBuffer->pData, pBuffer->nCapacity); } } static void dataBufferAppend(DataBuffer *pBuffer, const char *pSource, int nSource){ assert( nSource>0 && pSource!=NULL ); dataBufferExpand(pBuffer, nSource); memcpy(pBuffer->pData+pBuffer->nData, pSource, nSource); pBuffer->nData += nSource; } static void dataBufferAppend2(DataBuffer *pBuffer, const char *pSource1, int nSource1, const char *pSource2, int nSource2){ assert( nSource1>0 && pSource1!=NULL ); assert( nSource2>0 && pSource2!=NULL ); dataBufferExpand(pBuffer, nSource1+nSource2); memcpy(pBuffer->pData+pBuffer->nData, pSource1, nSource1); memcpy(pBuffer->pData+pBuffer->nData+nSource1, pSource2, nSource2); pBuffer->nData += nSource1+nSource2; } static void dataBufferReplace(DataBuffer *pBuffer, const char *pSource, int nSource){ dataBufferReset(pBuffer); dataBufferAppend(pBuffer, pSource, nSource); } typedef struct StringBuffer { DataBuffer b; } StringBuffer; static void initStringBuffer(StringBuffer *sb){ dataBufferInit(&sb->b, 100); dataBufferReplace(&sb->b, "", 1); } static int stringBufferLength(StringBuffer *sb){ return sb->b.nData-1; } static char *stringBufferData(StringBuffer *sb){ return sb->b.pData; } static void stringBufferDestroy(StringBuffer *sb){ dataBufferDestroy(&sb->b); } static void nappend(StringBuffer *sb, const char *zFrom, int nFrom){ assert( sb->b.nData>0 ); if( nFrom>0 ){ sb->b.nData--; dataBufferAppend2(&sb->b, zFrom, nFrom, "", 1); } } static void append(StringBuffer *sb, const char *zFrom){ nappend(sb, zFrom, strlen(zFrom)); } static void appendList(StringBuffer *sb, int nString, char **azString){ int i; for(i=0; i<nString; ++i){ if( i>0 ) append(sb, ", "); append(sb, azString[i]); } } static int endsInWhiteSpace(StringBuffer *p){ return stringBufferLength(p)>0 && safe_isspace(stringBufferData(p)[stringBufferLength(p)-1]); } static void appendWhiteSpace(StringBuffer *p){ if( stringBufferLength(p)==0 ) return; if( !endsInWhiteSpace(p) ) append(p, " "); } static void trimWhiteSpace(StringBuffer *p){ while( endsInWhiteSpace(p) ){ p->b.pData[--p->b.nData-1] = '\0'; } } typedef struct DLReader { DocListType iType; const char *pData; int nData; sqlite_int64 iDocid; int nElement; } DLReader; static int dlrAtEnd(DLReader *pReader){ assert( pReader->nData>=0 ); return pReader->nData==0; } static sqlite_int64 dlrDocid(DLReader *pReader){ assert( !dlrAtEnd(pReader) ); return pReader->iDocid; } static const char *dlrDocData(DLReader *pReader){ assert( !dlrAtEnd(pReader) ); return pReader->pData; } static int dlrDocDataBytes(DLReader *pReader){ assert( !dlrAtEnd(pReader) ); return pReader->nElement; } static int dlrAllDataBytes(DLReader *pReader){ assert( !dlrAtEnd(pReader) ); return pReader->nData; } static const char *dlrPosData(DLReader *pReader){ sqlite_int64 iDummy; int n = fts3GetVarint(pReader->pData, &iDummy); assert( !dlrAtEnd(pReader) ); return pReader->pData+n; } static int dlrPosDataLen(DLReader *pReader){ sqlite_int64 iDummy; int n = fts3GetVarint(pReader->pData, &iDummy); assert( !dlrAtEnd(pReader) ); return pReader->nElement-n; } static void dlrStep(DLReader *pReader){ assert( !dlrAtEnd(pReader) ); assert( pReader->nElement<=pReader->nData ); pReader->pData += pReader->nElement; pReader->nData -= pReader->nElement; if( pReader->nData!=0 ){ sqlite_int64 iDocidDelta; int iDummy, n = fts3GetVarint(pReader->pData, &iDocidDelta); pReader->iDocid += iDocidDelta; if( pReader->iType>=DL_POSITIONS ){ assert( n<pReader->nData ); while( 1 ){ n += fts3GetVarint32(pReader->pData+n, &iDummy); assert( n<=pReader->nData ); if( iDummy==POS_END ) break; if( iDummy==POS_COLUMN ){ n += fts3GetVarint32(pReader->pData+n, &iDummy); assert( n<pReader->nData ); }else if( pReader->iType==DL_POSITIONS_OFFSETS ){ n += fts3GetVarint32(pReader->pData+n, &iDummy); n += fts3GetVarint32(pReader->pData+n, &iDummy); assert( n<pReader->nData ); } } } pReader->nElement = n; assert( pReader->nElement<=pReader->nData ); } } static void dlrInit(DLReader *pReader, DocListType iType, const char *pData, int nData){ assert( pData!=NULL && nData!=0 ); pReader->iType = iType; pReader->pData = pData; pReader->nData = nData; pReader->nElement = 0; pReader->iDocid = 0; dlrStep(pReader); } static void dlrDestroy(DLReader *pReader){ SCRAMBLE(pReader); } 
#ifndef NDEBUG 
static void docListValidate(DocListType iType, const char *pData, int nData, sqlite_int64 *pLastDocid){ sqlite_int64 iPrevDocid = 0; assert( nData>0 ); assert( pData!=0 ); assert( pData+nData>pData ); while( nData!=0 ){ sqlite_int64 iDocidDelta; int n = fts3GetVarint(pData, &iDocidDelta); iPrevDocid += iDocidDelta; if( iType>DL_DOCIDS ){ int iDummy; while( 1 ){ n += fts3GetVarint32(pData+n, &iDummy); if( iDummy==POS_END ) break; if( iDummy==POS_COLUMN ){ n += fts3GetVarint32(pData+n, &iDummy); }else if( iType>DL_POSITIONS ){ n += fts3GetVarint32(pData+n, &iDummy); n += fts3GetVarint32(pData+n, &iDummy); } assert( n<=nData ); } } assert( n<=nData ); pData += n; nData -= n; } if( pLastDocid ) *pLastDocid = iPrevDocid; } 
#define ASSERT_VALID_DOCLIST(i, p, n, o) docListValidate(i, p, n, o) 
#else 
#define ASSERT_VALID_DOCLIST(i, p, n, o) assert( 1 ) 
#endif 
typedef struct DLWriter { DocListType iType; DataBuffer *b; sqlite_int64 iPrevDocid; 
#ifndef NDEBUG 
 int has_iPrevDocid; 
#endif 
} DLWriter; static void dlwInit(DLWriter *pWriter, DocListType iType, DataBuffer *b){ pWriter->b = b; pWriter->iType = iType; pWriter->iPrevDocid = 0; 
#ifndef NDEBUG 
 pWriter->has_iPrevDocid = 0; 
#endif 
} static void dlwDestroy(DLWriter *pWriter){ SCRAMBLE(pWriter); } static void dlwAppend(DLWriter *pWriter, const char *pData, int nData, sqlite_int64 iFirstDocid, sqlite_int64 iLastDocid){ sqlite_int64 iDocid = 0; char c[VARINT_MAX]; int nFirstOld, nFirstNew; 
#ifndef NDEBUG 
 sqlite_int64 iLastDocidDelta; 
#endif 
 nFirstOld = fts3GetVarint(pData, &iDocid); assert( nFirstOld<nData || (nFirstOld==nData && pWriter->iType==DL_DOCIDS) ); nFirstNew = fts3PutVarint(c, iFirstDocid-pWriter->iPrevDocid); ASSERT_VALID_DOCLIST(pWriter->iType, pData, nData, &iLastDocidDelta); assert( iLastDocid==iFirstDocid-iDocid+iLastDocidDelta ); if( nFirstOld<nData ){ dataBufferAppend2(pWriter->b, c, nFirstNew, pData+nFirstOld, nData-nFirstOld); }else{ dataBufferAppend(pWriter->b, c, nFirstNew); } pWriter->iPrevDocid = iLastDocid; } static void dlwCopy(DLWriter *pWriter, DLReader *pReader){ dlwAppend(pWriter, dlrDocData(pReader), dlrDocDataBytes(pReader), dlrDocid(pReader), dlrDocid(pReader)); } static void dlwAdd(DLWriter *pWriter, sqlite_int64 iDocid){ char c[VARINT_MAX]; int n = fts3PutVarint(c, iDocid-pWriter->iPrevDocid); assert( !pWriter->has_iPrevDocid || iDocid>pWriter->iPrevDocid ); assert( pWriter->iType==DL_DOCIDS ); dataBufferAppend(pWriter->b, c, n); pWriter->iPrevDocid = iDocid; 
#ifndef NDEBUG 
 pWriter->has_iPrevDocid = 1; 
#endif 
} typedef struct PLReader { const char *pData; int nData; DocListType iType; int iColumn; int iPosition; int iStartOffset; int iEndOffset; } PLReader; static int plrAtEnd(PLReader *pReader){ return pReader->pData==NULL; } static int plrColumn(PLReader *pReader){ assert( !plrAtEnd(pReader) ); return pReader->iColumn; } static int plrPosition(PLReader *pReader){ assert( !plrAtEnd(pReader) ); return pReader->iPosition; } static int plrStartOffset(PLReader *pReader){ assert( !plrAtEnd(pReader) ); return pReader->iStartOffset; } static int plrEndOffset(PLReader *pReader){ assert( !plrAtEnd(pReader) ); return pReader->iEndOffset; } static void plrStep(PLReader *pReader){ int i, n; assert( !plrAtEnd(pReader) ); if( pReader->nData==0 ){ pReader->pData = NULL; return; } n = fts3GetVarint32(pReader->pData, &i); if( i==POS_COLUMN ){ n += fts3GetVarint32(pReader->pData+n, &pReader->iColumn); pReader->iPosition = 0; pReader->iStartOffset = 0; n += fts3GetVarint32(pReader->pData+n, &i); } assert( i!=POS_COLUMN ); if( i==POS_END ){ pReader->nData = 0; pReader->pData = NULL; return; } pReader->iPosition += i-POS_BASE; if( pReader->iType==DL_POSITIONS_OFFSETS ){ n += fts3GetVarint32(pReader->pData+n, &i); pReader->iStartOffset += i; n += fts3GetVarint32(pReader->pData+n, &i); pReader->iEndOffset = pReader->iStartOffset+i; } assert( n<=pReader->nData ); pReader->pData += n; pReader->nData -= n; } static void plrInit(PLReader *pReader, DLReader *pDLReader){ pReader->pData = dlrPosData(pDLReader); pReader->nData = dlrPosDataLen(pDLReader); pReader->iType = pDLReader->iType; pReader->iColumn = 0; pReader->iPosition = 0; pReader->iStartOffset = 0; pReader->iEndOffset = 0; plrStep(pReader); } static void plrDestroy(PLReader *pReader){ SCRAMBLE(pReader); } typedef struct PLWriter { DLWriter *dlw; int iColumn; int iPos; int iOffset; } PLWriter; static void plwAdd(PLWriter *pWriter, int iColumn, int iPos, int iStartOffset, int iEndOffset){ char c[5*VARINT_MAX]; int n = 0; assert( pWriter->iPos!=-1 ); if( pWriter->dlw->iType==DL_DOCIDS ) return; if( iColumn!=pWriter->iColumn ){ n += fts3PutVarint(c+n, POS_COLUMN); n += fts3PutVarint(c+n, iColumn); pWriter->iColumn = iColumn; pWriter->iPos = 0; pWriter->iOffset = 0; } assert( iPos>=pWriter->iPos ); n += fts3PutVarint(c+n, POS_BASE+(iPos-pWriter->iPos)); pWriter->iPos = iPos; if( pWriter->dlw->iType==DL_POSITIONS_OFFSETS ){ assert( iStartOffset>=pWriter->iOffset ); n += fts3PutVarint(c+n, iStartOffset-pWriter->iOffset); pWriter->iOffset = iStartOffset; assert( iEndOffset>=iStartOffset ); n += fts3PutVarint(c+n, iEndOffset-iStartOffset); } dataBufferAppend(pWriter->dlw->b, c, n); } static void plwCopy(PLWriter *pWriter, PLReader *pReader){ plwAdd(pWriter, plrColumn(pReader), plrPosition(pReader), plrStartOffset(pReader), plrEndOffset(pReader)); } static void plwInit(PLWriter *pWriter, DLWriter *dlw, sqlite_int64 iDocid){ char c[VARINT_MAX]; int n; pWriter->dlw = dlw; assert( !pWriter->dlw->has_iPrevDocid || iDocid>pWriter->dlw->iPrevDocid ); n = fts3PutVarint(c, iDocid-pWriter->dlw->iPrevDocid); dataBufferAppend(pWriter->dlw->b, c, n); pWriter->dlw->iPrevDocid = iDocid; 
#ifndef NDEBUG 
 pWriter->dlw->has_iPrevDocid = 1; 
#endif 
 pWriter->iColumn = 0; pWriter->iPos = 0; pWriter->iOffset = 0; } static void plwTerminate(PLWriter *pWriter){ if( pWriter->dlw->iType>DL_DOCIDS ){ char c[VARINT_MAX]; int n = fts3PutVarint(c, POS_END); dataBufferAppend(pWriter->dlw->b, c, n); } 
#ifndef NDEBUG 
 pWriter->iPos = -1; 
#endif 
} static void plwDestroy(PLWriter *pWriter){ SCRAMBLE(pWriter); } typedef struct DLCollector { DataBuffer b; DLWriter dlw; PLWriter plw; } DLCollector; static void dlcAddDoclist(DLCollector *pCollector, DataBuffer *b){ if( pCollector->dlw.iType>DL_DOCIDS ){ char c[VARINT_MAX]; int n = fts3PutVarint(c, POS_END); dataBufferAppend2(b, pCollector->b.pData, pCollector->b.nData, c, n); }else{ dataBufferAppend(b, pCollector->b.pData, pCollector->b.nData); } } static void dlcNext(DLCollector *pCollector, sqlite_int64 iDocid){ plwTerminate(&pCollector->plw); plwDestroy(&pCollector->plw); plwInit(&pCollector->plw, &pCollector->dlw, iDocid); } static void dlcAddPos(DLCollector *pCollector, int iColumn, int iPos, int iStartOffset, int iEndOffset){ plwAdd(&pCollector->plw, iColumn, iPos, iStartOffset, iEndOffset); } static DLCollector *dlcNew(sqlite_int64 iDocid, DocListType iType){ DLCollector *pCollector = sqlite3_malloc(sizeof(DLCollector)); dataBufferInit(&pCollector->b, 0); dlwInit(&pCollector->dlw, iType, &pCollector->b); plwInit(&pCollector->plw, &pCollector->dlw, iDocid); return pCollector; } static void dlcDelete(DLCollector *pCollector){ plwDestroy(&pCollector->plw); dlwDestroy(&pCollector->dlw); dataBufferDestroy(&pCollector->b); SCRAMBLE(pCollector); sqlite3_free(pCollector); } static void docListTrim(DocListType iType, const char *pData, int nData, int iColumn, DocListType iOutType, DataBuffer *out){ DLReader dlReader; DLWriter dlWriter; assert( iOutType<=iType ); dlrInit(&dlReader, iType, pData, nData); dlwInit(&dlWriter, iOutType, out); while( !dlrAtEnd(&dlReader) ){ PLReader plReader; PLWriter plWriter; int match = 0; plrInit(&plReader, &dlReader); while( !plrAtEnd(&plReader) ){ if( iColumn==-1 || plrColumn(&plReader)==iColumn ){ if( !match ){ plwInit(&plWriter, &dlWriter, dlrDocid(&dlReader)); match = 1; } plwAdd(&plWriter, plrColumn(&plReader), plrPosition(&plReader), plrStartOffset(&plReader), plrEndOffset(&plReader)); } plrStep(&plReader); } if( match ){ plwTerminate(&plWriter); plwDestroy(&plWriter); } plrDestroy(&plReader); dlrStep(&dlReader); } dlwDestroy(&dlWriter); dlrDestroy(&dlReader); } typedef struct OrderedDLReader { DLReader *pReader; int idx; } OrderedDLReader; static int orderedDLReaderCmp(OrderedDLReader *r1, OrderedDLReader *r2){ if( dlrAtEnd(r1->pReader) ){ if( dlrAtEnd(r2->pReader) ) return 0; return 1; } if( dlrAtEnd(r2->pReader) ) return -1; if( dlrDocid(r1->pReader)<dlrDocid(r2->pReader) ) return -1; if( dlrDocid(r1->pReader)>dlrDocid(r2->pReader) ) return 1; return r2->idx-r1->idx; } static void orderedDLReaderReorder(OrderedDLReader *p, int n){ while( n>1 && orderedDLReaderCmp(p, p+1)>0 ){ OrderedDLReader tmp = p[0]; p[0] = p[1]; p[1] = tmp; n--; p++; } } static void docListMerge(DataBuffer *out, DLReader *pReaders, int nReaders){ OrderedDLReader readers[MERGE_COUNT]; DLWriter writer; int i, n; const char *pStart = 0; int nStart = 0; sqlite_int64 iFirstDocid = 0, iLastDocid = 0; assert( nReaders>0 ); if( nReaders==1 ){ dataBufferAppend(out, dlrDocData(pReaders), dlrAllDataBytes(pReaders)); return; } assert( nReaders<=MERGE_COUNT ); n = 0; for(i=0; i<nReaders; i++){ assert( pReaders[i].iType==pReaders[0].iType ); readers[i].pReader = pReaders+i; readers[i].idx = i; n += dlrAllDataBytes(&pReaders[i]); } dataBufferExpand(out, n); while( i-->0 ){ orderedDLReaderReorder(readers+i, nReaders-i); } dlwInit(&writer, pReaders[0].iType, out); while( !dlrAtEnd(readers[0].pReader) ){ sqlite_int64 iDocid = dlrDocid(readers[0].pReader); if( dlrDocData(readers[0].pReader)==pStart+nStart ){ nStart += dlrDocDataBytes(readers[0].pReader); }else{ if( pStart!=0 ){ dlwAppend(&writer, pStart, nStart, iFirstDocid, iLastDocid); } pStart = dlrDocData(readers[0].pReader); nStart = dlrDocDataBytes(readers[0].pReader); iFirstDocid = iDocid; } iLastDocid = iDocid; dlrStep(readers[0].pReader); for(i=1; i<nReaders && !dlrAtEnd(readers[i].pReader) && dlrDocid(readers[i].pReader)==iDocid; i++){ dlrStep(readers[i].pReader); } while( i-->0 ){ orderedDLReaderReorder(readers+i, nReaders-i); } } if( nStart>0 ) dlwAppend(&writer, pStart, nStart, iFirstDocid, iLastDocid); dlwDestroy(&writer); } static int posListCmp(PLReader *pLeft, PLReader *pRight){ assert( pLeft->iType==pRight->iType ); if( pLeft->iType==DL_DOCIDS ) return 0; if( plrAtEnd(pLeft) ) return plrAtEnd(pRight) ? 0 : 1; if( plrAtEnd(pRight) ) return -1; if( plrColumn(pLeft)<plrColumn(pRight) ) return -1; if( plrColumn(pLeft)>plrColumn(pRight) ) return 1; if( plrPosition(pLeft)<plrPosition(pRight) ) return -1; if( plrPosition(pLeft)>plrPosition(pRight) ) return 1; if( pLeft->iType==DL_POSITIONS ) return 0; if( plrStartOffset(pLeft)<plrStartOffset(pRight) ) return -1; if( plrStartOffset(pLeft)>plrStartOffset(pRight) ) return 1; if( plrEndOffset(pLeft)<plrEndOffset(pRight) ) return -1; if( plrEndOffset(pLeft)>plrEndOffset(pRight) ) return 1; return 0; } static void posListUnion(DLReader *pLeft, DLReader *pRight, DLWriter *pOut){ PLReader left, right; PLWriter writer; assert( dlrDocid(pLeft)==dlrDocid(pRight) ); assert( pLeft->iType==pRight->iType ); assert( pLeft->iType==pOut->iType ); plrInit(&left, pLeft); plrInit(&right, pRight); plwInit(&writer, pOut, dlrDocid(pLeft)); while( !plrAtEnd(&left) || !plrAtEnd(&right) ){ int c = posListCmp(&left, &right); if( c<0 ){ plwCopy(&writer, &left); plrStep(&left); }else if( c>0 ){ plwCopy(&writer, &right); plrStep(&right); }else{ plwCopy(&writer, &left); plrStep(&left); plrStep(&right); } } plwTerminate(&writer); plwDestroy(&writer); plrDestroy(&left); plrDestroy(&right); } static void docListUnion( const char *pLeft, int nLeft, const char *pRight, int nRight, DataBuffer *pOut ){ DLReader left, right; DLWriter writer; if( nLeft==0 ){ if( nRight!=0) dataBufferAppend(pOut, pRight, nRight); return; } if( nRight==0 ){ dataBufferAppend(pOut, pLeft, nLeft); return; } dlrInit(&left, DL_DEFAULT, pLeft, nLeft); dlrInit(&right, DL_DEFAULT, pRight, nRight); dlwInit(&writer, DL_DEFAULT, pOut); while( !dlrAtEnd(&left) || !dlrAtEnd(&right) ){ if( dlrAtEnd(&right) ){ dlwCopy(&writer, &left); dlrStep(&left); }else if( dlrAtEnd(&left) ){ dlwCopy(&writer, &right); dlrStep(&right); }else if( dlrDocid(&left)<dlrDocid(&right) ){ dlwCopy(&writer, &left); dlrStep(&left); }else if( dlrDocid(&left)>dlrDocid(&right) ){ dlwCopy(&writer, &right); dlrStep(&right); }else{ posListUnion(&left, &right, &writer); dlrStep(&left); dlrStep(&right); } } dlrDestroy(&left); dlrDestroy(&right); dlwDestroy(&writer); } static void posListPhraseMerge( DLReader *pLeft, DLReader *pRight, int nNear, int isSaveLeft, DLWriter *pOut ){ PLReader left, right; PLWriter writer; int match = 0; assert( dlrDocid(pLeft)==dlrDocid(pRight) ); assert( pOut->iType!=DL_POSITIONS_OFFSETS ); plrInit(&left, pLeft); plrInit(&right, pRight); while( !plrAtEnd(&left) && !plrAtEnd(&right) ){ if( plrColumn(&left)<plrColumn(&right) ){ plrStep(&left); }else if( plrColumn(&left)>plrColumn(&right) ){ plrStep(&right); }else if( plrPosition(&left)>=plrPosition(&right) ){ plrStep(&right); }else{ if( (plrPosition(&right)-plrPosition(&left))<=(nNear+1) ){ if( !match ){ plwInit(&writer, pOut, dlrDocid(pLeft)); match = 1; } if( !isSaveLeft ){ plwAdd(&writer, plrColumn(&right), plrPosition(&right), 0, 0); }else{ plwAdd(&writer, plrColumn(&left), plrPosition(&left), 0, 0); } plrStep(&right); }else{ plrStep(&left); } } } if( match ){ plwTerminate(&writer); plwDestroy(&writer); } plrDestroy(&left); plrDestroy(&right); } static int plrCompare(PLReader *pLeft, PLReader *pRight){ assert(!plrAtEnd(pLeft) || !plrAtEnd(pRight)); if( plrAtEnd(pRight) || plrAtEnd(pLeft) ){ return (plrAtEnd(pRight) ? -1 : 1); } if( plrColumn(pLeft)!=plrColumn(pRight) ){ return ((plrColumn(pLeft)<plrColumn(pRight)) ? -1 : 1); } if( plrPosition(pLeft)!=plrPosition(pRight) ){ return ((plrPosition(pLeft)<plrPosition(pRight)) ? -1 : 1); } return 0; } static void docListPhraseMerge( const char *pLeft, int nLeft, const char *pRight, int nRight, int nNear, int nPhrase, DocListType iType, DataBuffer *pOut ){ DLReader left, right; DLWriter writer; if( nLeft==0 || nRight==0 ) return; assert( iType!=DL_POSITIONS_OFFSETS ); dlrInit(&left, DL_POSITIONS, pLeft, nLeft); dlrInit(&right, DL_POSITIONS, pRight, nRight); dlwInit(&writer, iType, pOut); while( !dlrAtEnd(&left) && !dlrAtEnd(&right) ){ if( dlrDocid(&left)<dlrDocid(&right) ){ dlrStep(&left); }else if( dlrDocid(&right)<dlrDocid(&left) ){ dlrStep(&right); }else{ if( nNear==0 ){ posListPhraseMerge(&left, &right, 0, 0, &writer); }else{ DataBuffer one = {0, 0, 0}; DataBuffer two = {0, 0, 0}; DLWriter dlwriter2; DLReader dr1 = {0, 0, 0, 0, 0}; DLReader dr2 = {0, 0, 0, 0, 0}; dlwInit(&dlwriter2, iType, &one); posListPhraseMerge(&right, &left, nNear-3+nPhrase, 1, &dlwriter2); dlwInit(&dlwriter2, iType, &two); posListPhraseMerge(&left, &right, nNear-1, 0, &dlwriter2); if( one.nData) dlrInit(&dr1, iType, one.pData, one.nData); if( two.nData) dlrInit(&dr2, iType, two.pData, two.nData); if( !dlrAtEnd(&dr1) || !dlrAtEnd(&dr2) ){ PLReader pr1 = {0}; PLReader pr2 = {0}; PLWriter plwriter; plwInit(&plwriter, &writer, dlrDocid(dlrAtEnd(&dr1)?&dr2:&dr1)); if( one.nData ) plrInit(&pr1, &dr1); if( two.nData ) plrInit(&pr2, &dr2); while( !plrAtEnd(&pr1) || !plrAtEnd(&pr2) ){ int iCompare = plrCompare(&pr1, &pr2); switch( iCompare ){ case -1: plwCopy(&plwriter, &pr1); plrStep(&pr1); break; case 1: plwCopy(&plwriter, &pr2); plrStep(&pr2); break; case 0: plwCopy(&plwriter, &pr1); plrStep(&pr1); plrStep(&pr2); break; } } plwTerminate(&plwriter); } dataBufferDestroy(&one); dataBufferDestroy(&two); } dlrStep(&left); dlrStep(&right); } } dlrDestroy(&left); dlrDestroy(&right); dlwDestroy(&writer); } static void docListAndMerge( const char *pLeft, int nLeft, const char *pRight, int nRight, DataBuffer *pOut ){ DLReader left, right; DLWriter writer; if( nLeft==0 || nRight==0 ) return; dlrInit(&left, DL_DOCIDS, pLeft, nLeft); dlrInit(&right, DL_DOCIDS, pRight, nRight); dlwInit(&writer, DL_DOCIDS, pOut); while( !dlrAtEnd(&left) && !dlrAtEnd(&right) ){ if( dlrDocid(&left)<dlrDocid(&right) ){ dlrStep(&left); }else if( dlrDocid(&right)<dlrDocid(&left) ){ dlrStep(&right); }else{ dlwAdd(&writer, dlrDocid(&left)); dlrStep(&left); dlrStep(&right); } } dlrDestroy(&left); dlrDestroy(&right); dlwDestroy(&writer); } static void docListOrMerge( const char *pLeft, int nLeft, const char *pRight, int nRight, DataBuffer *pOut ){ DLReader left, right; DLWriter writer; if( nLeft==0 ){ if( nRight!=0 ) dataBufferAppend(pOut, pRight, nRight); return; } if( nRight==0 ){ dataBufferAppend(pOut, pLeft, nLeft); return; } dlrInit(&left, DL_DOCIDS, pLeft, nLeft); dlrInit(&right, DL_DOCIDS, pRight, nRight); dlwInit(&writer, DL_DOCIDS, pOut); while( !dlrAtEnd(&left) || !dlrAtEnd(&right) ){ if( dlrAtEnd(&right) ){ dlwAdd(&writer, dlrDocid(&left)); dlrStep(&left); }else if( dlrAtEnd(&left) ){ dlwAdd(&writer, dlrDocid(&right)); dlrStep(&right); }else if( dlrDocid(&left)<dlrDocid(&right) ){ dlwAdd(&writer, dlrDocid(&left)); dlrStep(&left); }else if( dlrDocid(&right)<dlrDocid(&left) ){ dlwAdd(&writer, dlrDocid(&right)); dlrStep(&right); }else{ dlwAdd(&writer, dlrDocid(&left)); dlrStep(&left); dlrStep(&right); } } dlrDestroy(&left); dlrDestroy(&right); dlwDestroy(&writer); } static void docListExceptMerge( const char *pLeft, int nLeft, const char *pRight, int nRight, DataBuffer *pOut ){ DLReader left, right; DLWriter writer; if( nLeft==0 ) return; if( nRight==0 ){ dataBufferAppend(pOut, pLeft, nLeft); return; } dlrInit(&left, DL_DOCIDS, pLeft, nLeft); dlrInit(&right, DL_DOCIDS, pRight, nRight); dlwInit(&writer, DL_DOCIDS, pOut); while( !dlrAtEnd(&left) ){ while( !dlrAtEnd(&right) && dlrDocid(&right)<dlrDocid(&left) ){ dlrStep(&right); } if( dlrAtEnd(&right) || dlrDocid(&left)<dlrDocid(&right) ){ dlwAdd(&writer, dlrDocid(&left)); } dlrStep(&left); } dlrDestroy(&left); dlrDestroy(&right); dlwDestroy(&writer); } static char *string_dup_n(const char *s, int n){ char *str = sqlite3_malloc(n + 1); memcpy(str, s, n); str[n] = '\0'; return str; } static char *string_dup(const char *s){ return string_dup_n(s, strlen(s)); } static char *string_format(const char *zFormat, const char *zDb, const char *zName){ const char *p; size_t len = 0; size_t nDb = strlen(zDb); size_t nName = strlen(zName); size_t nFullTableName = nDb+1+nName; char *result; char *r; for(p = zFormat ; *p ; ++p){ len += (*p=='%' ? nFullTableName : 1); } len += 1; r = result = sqlite3_malloc(len); for(p = zFormat; *p; ++p){ if( *p=='%' ){ memcpy(r, zDb, nDb); r += nDb; *r++ = '.'; memcpy(r, zName, nName); r += nName; } else { *r++ = *p; } } *r++ = '\0'; assert( r == result + len ); return result; } static int sql_exec(sqlite3 *db, const char *zDb, const char *zName, const char *zFormat){ char *zCommand = string_format(zFormat, zDb, zName); int rc; FTSTRACE(("FTS3 sql: %s\n", zCommand)); rc = sqlite3_exec(db, zCommand, NULL, 0, NULL); sqlite3_free(zCommand); return rc; } static int sql_prepare(sqlite3 *db, const char *zDb, const char *zName, sqlite3_stmt **ppStmt, const char *zFormat){ char *zCommand = string_format(zFormat, zDb, zName); int rc; FTSTRACE(("FTS3 prepare: %s\n", zCommand)); rc = sqlite3_prepare_v2(db, zCommand, -1, ppStmt, NULL); sqlite3_free(zCommand); return rc; } typedef struct fulltext_vtab fulltext_vtab; typedef struct QueryTerm { short int nPhrase; short int iPhrase; short int iColumn; short int nNear; signed char isOr; signed char isNot; signed char isPrefix; char *pTerm; int nTerm; } QueryTerm; typedef struct Query { fulltext_vtab *pFts; int nTerms; QueryTerm *pTerms; int nextIsOr; int nextIsNear; int nextColumn; int dfltColumn; } Query; typedef struct Snippet { int nMatch; int nAlloc; struct snippetMatch { char snStatus; short int iCol; short int iTerm; int iToken; short int nByte; int iStart; } *aMatch; char *zOffset; int nOffset; char *zSnippet; int nSnippet; } Snippet; typedef enum QueryType { QUERY_GENERIC, QUERY_DOCID, QUERY_FULLTEXT } QueryType; typedef enum fulltext_statement { CONTENT_INSERT_STMT, CONTENT_SELECT_STMT, CONTENT_UPDATE_STMT, CONTENT_DELETE_STMT, CONTENT_EXISTS_STMT, BLOCK_INSERT_STMT, BLOCK_SELECT_STMT, BLOCK_DELETE_STMT, BLOCK_DELETE_ALL_STMT, SEGDIR_MAX_INDEX_STMT, SEGDIR_SET_STMT, SEGDIR_SELECT_LEVEL_STMT, SEGDIR_SPAN_STMT, SEGDIR_DELETE_STMT, SEGDIR_SELECT_SEGMENT_STMT, SEGDIR_SELECT_ALL_STMT, SEGDIR_DELETE_ALL_STMT, SEGDIR_COUNT_STMT, MAX_STMT } fulltext_statement; static const char *const fulltext_zStatement[MAX_STMT] = { NULL, NULL, NULL, "delete from %_content where docid = ?", "select docid from %_content limit 1", "insert into %_segments (blockid, block) values (null, ?)", "select block from %_segments where blockid = ?", "delete from %_segments where blockid between ? and ?", "delete from %_segments", "select max(idx) from %_segdir where level = ?", "insert into %_segdir values (?, ?, ?, ?, ?, ?)", "select start_block, leaves_end_block, root from %_segdir " " where level = ? order by idx", "select min(start_block), max(end_block) from %_segdir " " where level = ? and start_block <> 0", "delete from %_segdir where level = ?", "select start_block, leaves_end_block, root from %_segdir " " where level = ? and idx = ?", "select start_block, leaves_end_block, root from %_segdir " " order by level desc, idx asc", "delete from %_segdir", "select count(*), ifnull(max(level),0) from %_segdir", }; struct fulltext_vtab { sqlite3_vtab base; sqlite3 *db; const char *zDb; const char *zName; int nColumn; char **azColumn; char **azContentColumn; sqlite3_tokenizer *pTokenizer; sqlite3_stmt *pFulltextStatements[MAX_STMT]; sqlite3_stmt *pLeafSelectStmts[MERGE_COUNT]; 
#define LEAF_SELECT "select block from %_segments where blockid between ? and ? order by blockid" 
 int nPendingData; 
#define kPendingThreshold (1*1024*1024) 
 sqlite_int64 iPrevDocid; fts3Hash pendingTerms; }; typedef struct fulltext_cursor { sqlite3_vtab_cursor base; QueryType iCursorType; sqlite3_stmt *pStmt; int eof; Query q; Snippet snippet; int iColumn; DataBuffer result; DLReader reader; } fulltext_cursor; static struct fulltext_vtab *cursor_vtab(fulltext_cursor *c){ return (fulltext_vtab *) c->base.pVtab; } static const sqlite3_module fts3Module; static const char *contentInsertStatement(fulltext_vtab *v){ StringBuffer sb; int i; initStringBuffer(&sb); append(&sb, "insert into %_content (docid, "); appendList(&sb, v->nColumn, v->azContentColumn); append(&sb, ") values (?"); for(i=0; i<v->nColumn; ++i) append(&sb, ", ?"); append(&sb, ")"); return stringBufferData(&sb); } static const char *contentSelectStatement(fulltext_vtab *v){ StringBuffer sb; initStringBuffer(&sb); append(&sb, "SELECT "); appendList(&sb, v->nColumn, v->azContentColumn); append(&sb, " FROM %_content WHERE docid = ?"); return stringBufferData(&sb); } static const char *contentUpdateStatement(fulltext_vtab *v){ StringBuffer sb; int i; initStringBuffer(&sb); append(&sb, "update %_content set "); for(i=0; i<v->nColumn; ++i) { if( i>0 ){ append(&sb, ", "); } append(&sb, v->azContentColumn[i]); append(&sb, " = ?"); } append(&sb, " where docid = ?"); return stringBufferData(&sb); } static int sql_get_statement(fulltext_vtab *v, fulltext_statement iStmt, sqlite3_stmt **ppStmt){ assert( iStmt<MAX_STMT ); if( v->pFulltextStatements[iStmt]==NULL ){ const char *zStmt; int rc; switch( iStmt ){ case CONTENT_INSERT_STMT: zStmt = contentInsertStatement(v); break; case CONTENT_SELECT_STMT: zStmt = contentSelectStatement(v); break; case CONTENT_UPDATE_STMT: zStmt = contentUpdateStatement(v); break; default: zStmt = fulltext_zStatement[iStmt]; } rc = sql_prepare(v->db, v->zDb, v->zName, &v->pFulltextStatements[iStmt], zStmt); if( zStmt != fulltext_zStatement[iStmt]) sqlite3_free((void *) zStmt); if( rc!=SQLITE_OK ) return rc; } else { int rc = sqlite3_reset(v->pFulltextStatements[iStmt]); if( rc!=SQLITE_OK ) return rc; } *ppStmt = v->pFulltextStatements[iStmt]; return SQLITE_OK; } static int sql_single_step(sqlite3_stmt *s){ int rc = sqlite3_step(s); return (rc==SQLITE_DONE) ? SQLITE_OK : rc; } static int sql_get_leaf_statement(fulltext_vtab *v, int idx, sqlite3_stmt **ppStmt){ assert( idx>=-1 && idx<MERGE_COUNT ); if( idx==-1 ){ return sql_prepare(v->db, v->zDb, v->zName, ppStmt, LEAF_SELECT); }else if( v->pLeafSelectStmts[idx]==NULL ){ int rc = sql_prepare(v->db, v->zDb, v->zName, &v->pLeafSelectStmts[idx], LEAF_SELECT); if( rc!=SQLITE_OK ) return rc; }else{ int rc = sqlite3_reset(v->pLeafSelectStmts[idx]); if( rc!=SQLITE_OK ) return rc; } *ppStmt = v->pLeafSelectStmts[idx]; return SQLITE_OK; } static int content_insert(fulltext_vtab *v, sqlite3_value *docid, sqlite3_value **pValues){ sqlite3_stmt *s; int i; int rc = sql_get_statement(v, CONTENT_INSERT_STMT, &s); if( rc!=SQLITE_OK ) return rc; rc = sqlite3_bind_value(s, 1, docid); if( rc!=SQLITE_OK ) return rc; for(i=0; i<v->nColumn; ++i){ rc = sqlite3_bind_value(s, 2+i, pValues[i]); if( rc!=SQLITE_OK ) return rc; } return sql_single_step(s); } static int content_update(fulltext_vtab *v, sqlite3_value **pValues, sqlite_int64 iDocid){ sqlite3_stmt *s; int i; int rc = sql_get_statement(v, CONTENT_UPDATE_STMT, &s); if( rc!=SQLITE_OK ) return rc; for(i=0; i<v->nColumn; ++i){ rc = sqlite3_bind_value(s, 1+i, pValues[i]); if( rc!=SQLITE_OK ) return rc; } rc = sqlite3_bind_int64(s, 1+v->nColumn, iDocid); if( rc!=SQLITE_OK ) return rc; return sql_single_step(s); } static void freeStringArray(int nString, const char **pString){ int i; for (i=0 ; i < nString ; ++i) { if( pString[i]!=NULL ) sqlite3_free((void *) pString[i]); } sqlite3_free((void *) pString); } static int content_select(fulltext_vtab *v, sqlite_int64 iDocid, const char ***pValues){ sqlite3_stmt *s; const char **values; int i; int rc; *pValues = NULL; rc = sql_get_statement(v, CONTENT_SELECT_STMT, &s); if( rc!=SQLITE_OK ) return rc; rc = sqlite3_bind_int64(s, 1, iDocid); if( rc!=SQLITE_OK ) return rc; rc = sqlite3_step(s); if( rc!=SQLITE_ROW ) return rc; values = (const char **) sqlite3_malloc(v->nColumn * sizeof(const char *)); for(i=0; i<v->nColumn; ++i){ if( sqlite3_column_type(s, i)==SQLITE_NULL ){ values[i] = NULL; }else{ values[i] = string_dup((char*)sqlite3_column_text(s, i)); } } rc = sqlite3_step(s); if( rc==SQLITE_DONE ){ *pValues = values; return SQLITE_OK; } freeStringArray(v->nColumn, values); return rc; } static int content_delete(fulltext_vtab *v, sqlite_int64 iDocid){ sqlite3_stmt *s; int rc = sql_get_statement(v, CONTENT_DELETE_STMT, &s); if( rc!=SQLITE_OK ) return rc; rc = sqlite3_bind_int64(s, 1, iDocid); if( rc!=SQLITE_OK ) return rc; return sql_single_step(s); } static int content_exists(fulltext_vtab *v){ sqlite3_stmt *s; int rc = sql_get_statement(v, CONTENT_EXISTS_STMT, &s); if( rc!=SQLITE_OK ) return rc; rc = sqlite3_step(s); if( rc!=SQLITE_ROW ) return rc; rc = sqlite3_step(s); if( rc==SQLITE_DONE ) return SQLITE_ROW; if( rc==SQLITE_ROW ) return SQLITE_ERROR; return rc; } static int block_insert(fulltext_vtab *v, const char *pData, int nData, sqlite_int64 *piBlockid){ sqlite3_stmt *s; int rc = sql_get_statement(v, BLOCK_INSERT_STMT, &s); if( rc!=SQLITE_OK ) return rc; rc = sqlite3_bind_blob(s, 1, pData, nData, SQLITE_STATIC); if( rc!=SQLITE_OK ) return rc; rc = sqlite3_step(s); if( rc==SQLITE_ROW ) return SQLITE_ERROR; if( rc!=SQLITE_DONE ) return rc; *piBlockid = sqlite3_last_insert_rowid(v->db); return SQLITE_OK; } static int block_delete(fulltext_vtab *v, sqlite_int64 iStartBlockid, sqlite_int64 iEndBlockid){ sqlite3_stmt *s; int rc = sql_get_statement(v, BLOCK_DELETE_STMT, &s); if( rc!=SQLITE_OK ) return rc; rc = sqlite3_bind_int64(s, 1, iStartBlockid); if( rc!=SQLITE_OK ) return rc; rc = sqlite3_bind_int64(s, 2, iEndBlockid); if( rc!=SQLITE_OK ) return rc; return sql_single_step(s); } static int segdir_max_index(fulltext_vtab *v, int iLevel, int *pidx){ sqlite3_stmt *s; int rc = sql_get_statement(v, SEGDIR_MAX_INDEX_STMT, &s); if( rc!=SQLITE_OK ) return rc; rc = sqlite3_bind_int(s, 1, iLevel); if( rc!=SQLITE_OK ) return rc; rc = sqlite3_step(s); if( rc==SQLITE_DONE ) return SQLITE_DONE; if( rc!=SQLITE_ROW ) return rc; if( SQLITE_NULL==sqlite3_column_type(s, 0) ){ rc = sqlite3_step(s); if( rc==SQLITE_ROW ) return SQLITE_ERROR; return rc; } *pidx = sqlite3_column_int(s, 0); rc = sqlite3_step(s); if( rc==SQLITE_ROW ) return SQLITE_ERROR; if( rc!=SQLITE_DONE ) return rc; return SQLITE_ROW; } static int segdir_set(fulltext_vtab *v, int iLevel, int idx, sqlite_int64 iStartBlockid, sqlite_int64 iLeavesEndBlockid, sqlite_int64 iEndBlockid, const char *pRootData, int nRootData){ sqlite3_stmt *s; int rc = sql_get_statement(v, SEGDIR_SET_STMT, &s); if( rc!=SQLITE_OK ) return rc; rc = sqlite3_bind_int(s, 1, iLevel); if( rc!=SQLITE_OK ) return rc; rc = sqlite3_bind_int(s, 2, idx); if( rc!=SQLITE_OK ) return rc; rc = sqlite3_bind_int64(s, 3, iStartBlockid); if( rc!=SQLITE_OK ) return rc; rc = sqlite3_bind_int64(s, 4, iLeavesEndBlockid); if( rc!=SQLITE_OK ) return rc; rc = sqlite3_bind_int64(s, 5, iEndBlockid); if( rc!=SQLITE_OK ) return rc; rc = sqlite3_bind_blob(s, 6, pRootData, nRootData, SQLITE_STATIC); if( rc!=SQLITE_OK ) return rc; return sql_single_step(s); } static int segdir_span(fulltext_vtab *v, int iLevel, sqlite_int64 *piStartBlockid, sqlite_int64 *piEndBlockid){ sqlite3_stmt *s; int rc = sql_get_statement(v, SEGDIR_SPAN_STMT, &s); if( rc!=SQLITE_OK ) return rc; rc = sqlite3_bind_int(s, 1, iLevel); if( rc!=SQLITE_OK ) return rc; rc = sqlite3_step(s); if( rc==SQLITE_DONE ) return SQLITE_DONE; if( rc!=SQLITE_ROW ) return rc; if( SQLITE_NULL==sqlite3_column_type(s, 0) ){ int rc2 = sqlite3_step(s); if( rc2==SQLITE_ROW ) return SQLITE_ERROR; return rc2; } *piStartBlockid = sqlite3_column_int64(s, 0); *piEndBlockid = sqlite3_column_int64(s, 1); rc = sqlite3_step(s); if( rc==SQLITE_ROW ) return SQLITE_ERROR; if( rc!=SQLITE_DONE ) return rc; return SQLITE_ROW; } static int segdir_delete(fulltext_vtab *v, int iLevel){ sqlite3_stmt *s; sqlite_int64 iStartBlockid, iEndBlockid; int rc = segdir_span(v, iLevel, &iStartBlockid, &iEndBlockid); if( rc!=SQLITE_ROW && rc!=SQLITE_DONE ) return rc; if( rc==SQLITE_ROW ){ rc = block_delete(v, iStartBlockid, iEndBlockid); if( rc!=SQLITE_OK ) return rc; } rc = sql_get_statement(v, SEGDIR_DELETE_STMT, &s); if( rc!=SQLITE_OK ) return rc; rc = sqlite3_bind_int64(s, 1, iLevel); if( rc!=SQLITE_OK ) return rc; return sql_single_step(s); } static int segdir_delete_all(fulltext_vtab *v){ sqlite3_stmt *s; int rc = sql_get_statement(v, SEGDIR_DELETE_ALL_STMT, &s); if( rc!=SQLITE_OK ) return rc; rc = sql_single_step(s); if( rc!=SQLITE_OK ) return rc; rc = sql_get_statement(v, BLOCK_DELETE_ALL_STMT, &s); if( rc!=SQLITE_OK ) return rc; return sql_single_step(s); } static int segdir_count(fulltext_vtab *v, int *pnSegments, int *piMaxLevel){ sqlite3_stmt *s; int rc = sql_get_statement(v, SEGDIR_COUNT_STMT, &s); if( rc!=SQLITE_OK ) return rc; rc = sqlite3_step(s); if( rc==SQLITE_DONE ){ *pnSegments = 0; *piMaxLevel = 0; return SQLITE_OK; } if( rc!=SQLITE_ROW ) return rc; *pnSegments = sqlite3_column_int(s, 0); *piMaxLevel = sqlite3_column_int(s, 1); rc = sqlite3_step(s); if( rc==SQLITE_DONE ) return SQLITE_OK; if( rc==SQLITE_ROW ) return SQLITE_ERROR; return rc; } static int clearPendingTerms(fulltext_vtab *v); static void fulltext_vtab_destroy(fulltext_vtab *v){ int iStmt, i; FTSTRACE(("FTS3 Destroy %p\n", v)); for( iStmt=0; iStmt<MAX_STMT; iStmt++ ){ if( v->pFulltextStatements[iStmt]!=NULL ){ sqlite3_finalize(v->pFulltextStatements[iStmt]); v->pFulltextStatements[iStmt] = NULL; } } for( i=0; i<MERGE_COUNT; i++ ){ if( v->pLeafSelectStmts[i]!=NULL ){ sqlite3_finalize(v->pLeafSelectStmts[i]); v->pLeafSelectStmts[i] = NULL; } } if( v->pTokenizer!=NULL ){ v->pTokenizer->pModule->xDestroy(v->pTokenizer); v->pTokenizer = NULL; } clearPendingTerms(v); sqlite3_free(v->azColumn); for(i = 0; i < v->nColumn; ++i) { sqlite3_free(v->azContentColumn[i]); } sqlite3_free(v->azContentColumn); sqlite3_free(v); } 
#define TOKEN_EOF 0 
#define TOKEN_SPACE 1 
#define TOKEN_ID 2 
#define TOKEN_STRING 3 
#define TOKEN_PUNCT 4 
static const char isFtsIdChar[] = { 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, }; 
#define ftsIdChar(C) (((c=C)&0x80)!=0 || (c>0x1f && isFtsIdChar[c-0x20])) 
static int ftsGetToken(const char *z, int *tokenType){ int i, c; switch( *z ){ case 0: { *tokenType = TOKEN_EOF; return 0; } case ' ': case '\t': case '\n': case '\f': case '\r': { for(i=1; safe_isspace(z[i]); i++){} *tokenType = TOKEN_SPACE; return i; } case '`': case '\'': case '"': { int delim = z[0]; for(i=1; (c=z[i])!=0; i++){ if( c==delim ){ if( z[i+1]==delim ){ i++; }else{ break; } } } *tokenType = TOKEN_STRING; return i + (c!=0); } case '[': { for(i=1, c=z[0]; c!=']' && (c=z[i])!=0; i++){} *tokenType = TOKEN_ID; return i; } default: { if( !ftsIdChar(*z) ){ break; } for(i=1; ftsIdChar(z[i]); i++){} *tokenType = TOKEN_ID; return i; } } *tokenType = TOKEN_PUNCT; return 1; } typedef struct FtsToken { const char *z; short int n; } FtsToken; static char **tokenizeString(const char *z, int *pnToken){ int nToken = 0; FtsToken *aToken = sqlite3_malloc( strlen(z) * sizeof(aToken[0]) ); int n = 1; int e, i; int totalSize = 0; char **azToken; char *zCopy; while( n>0 ){ n = ftsGetToken(z, &e); if( e!=TOKEN_SPACE ){ aToken[nToken].z = z; aToken[nToken].n = n; nToken++; totalSize += n+1; } z += n; } azToken = (char**)sqlite3_malloc( nToken*sizeof(char*) + totalSize ); zCopy = (char*)&azToken[nToken]; nToken--; for(i=0; i<nToken; i++){ azToken[i] = zCopy; n = aToken[i].n; memcpy(zCopy, aToken[i].z, n); zCopy[n] = 0; zCopy += n+1; } azToken[nToken] = 0; sqlite3_free(aToken); *pnToken = nToken; return azToken; } static void dequoteString(char *z){ int quote; int i, j; if( z==0 ) return; quote = z[0]; switch( quote ){ case '\'': break; case '"': break; case '`': break; case '[': quote = ']'; break; default: return; } for(i=1, j=0; z[i]; i++){ if( z[i]==quote ){ if( z[i+1]==quote ){ z[j++] = quote; i++; }else{ z[j++] = 0; break; } }else{ z[j++] = z[i]; } } } static void tokenListToIdList(char **azIn){ int i, j; if( azIn ){ for(i=0, j=-1; azIn[i]; i++){ if( safe_isalnum(azIn[i][0]) || azIn[i][1] ){ dequoteString(azIn[i]); if( j>=0 ){ azIn[j] = azIn[i]; } j++; } } azIn[j] = 0; } } static char *firstToken(char *zIn, char **pzTail){ int n, ttype; while(1){ n = ftsGetToken(zIn, &ttype); if( ttype==TOKEN_SPACE ){ zIn += n; }else if( ttype==TOKEN_EOF ){ *pzTail = zIn; return 0; }else{ zIn[n] = 0; *pzTail = &zIn[1]; dequoteString(zIn); return zIn; } } } static int startsWith(const char *s, const char *t){ while( safe_isspace(*s) ){ s++; } while( *t ){ if( safe_tolower(*s++)!=safe_tolower(*t++) ) return 0; } return *s!='_' && !safe_isalnum(*s); } typedef struct TableSpec { const char *zDb; const char *zName; int nColumn; char **azColumn; char **azContentColumn; char **azTokenizer; } TableSpec; static void clearTableSpec(TableSpec *p) { sqlite3_free(p->azColumn); sqlite3_free(p->azContentColumn); sqlite3_free(p->azTokenizer); } static int parseSpec(TableSpec *pSpec, int argc, const char *const*argv, char**pzErr){ int i, n; char *z, *zDummy; char **azArg; const char *zTokenizer = 0; assert( argc>=3 ); CLEAR(pSpec); for(i=n=0; i<argc; i++){ n += strlen(argv[i]) + 1; } azArg = sqlite3_malloc( sizeof(char*)*argc + n ); if( azArg==0 ){ return SQLITE_NOMEM; } z = (char*)&azArg[argc]; for(i=0; i<argc; i++){ azArg[i] = z; strcpy(z, argv[i]); z += strlen(z)+1; } pSpec->zDb = azArg[1]; pSpec->zName = azArg[2]; pSpec->nColumn = 0; pSpec->azColumn = azArg; zTokenizer = "tokenize simple"; for(i=3; i<argc; ++i){ if( startsWith(azArg[i],"tokenize") ){ zTokenizer = azArg[i]; }else{ z = azArg[pSpec->nColumn] = firstToken(azArg[i], &zDummy); pSpec->nColumn++; } } if( pSpec->nColumn==0 ){ azArg[0] = "content"; pSpec->nColumn = 1; } pSpec->azContentColumn = sqlite3_malloc( pSpec->nColumn * sizeof(char *) ); if( pSpec->azContentColumn==0 ){ clearTableSpec(pSpec); return SQLITE_NOMEM; } for(i=0; i<pSpec->nColumn; i++){ char *p; pSpec->azContentColumn[i] = sqlite3_mprintf("c%d%s", i, azArg[i]); for (p = pSpec->azContentColumn[i]; *p ; ++p) { if( !safe_isalnum(*p) ) *p = '_'; } } pSpec->azTokenizer = tokenizeString(zTokenizer, &n); tokenListToIdList(pSpec->azTokenizer); return SQLITE_OK; } static char *fulltextSchema( int nColumn, const char *const* azColumn, const char *zTableName ){ int i; char *zSchema, *zNext; const char *zSep = "("; zSchema = sqlite3_mprintf("CREATE TABLE x"); for(i=0; i<nColumn; i++){ zNext = sqlite3_mprintf("%s%s%Q", zSchema, zSep, azColumn[i]); sqlite3_free(zSchema); zSchema = zNext; zSep = ","; } zNext = sqlite3_mprintf("%s,%Q HIDDEN", zSchema, zTableName); sqlite3_free(zSchema); zSchema = zNext; zNext = sqlite3_mprintf("%s,docid HIDDEN)", zSchema); sqlite3_free(zSchema); return zNext; } static int constructVtab( sqlite3 *db, fts3Hash *pHash, TableSpec *spec, sqlite3_vtab **ppVTab, char **pzErr ){ int rc; int n; fulltext_vtab *v = 0; const sqlite3_tokenizer_module *m = NULL; char *schema; char const *zTok; int nTok; v = (fulltext_vtab *) sqlite3_malloc(sizeof(fulltext_vtab)); if( v==0 ) return SQLITE_NOMEM; CLEAR(v); v->db = db; v->zDb = spec->zDb; v->zName = spec->zName; v->nColumn = spec->nColumn; v->azContentColumn = spec->azContentColumn; spec->azContentColumn = 0; v->azColumn = spec->azColumn; spec->azColumn = 0; if( spec->azTokenizer==0 ){ return SQLITE_NOMEM; } zTok = spec->azTokenizer[0]; if( !zTok ){ zTok = "simple"; } nTok = strlen(zTok)+1; m = (sqlite3_tokenizer_module *)sqlite3Fts3HashFind(pHash, zTok, nTok); if( !m ){ *pzErr = sqlite3_mprintf("unknown tokenizer: %s", spec->azTokenizer[0]); rc = SQLITE_ERROR; goto err; } for(n=0; spec->azTokenizer[n]; n++){} if( n ){ rc = m->xCreate(n-1, (const char*const*)&spec->azTokenizer[1], &v->pTokenizer); }else{ rc = m->xCreate(0, 0, &v->pTokenizer); } if( rc!=SQLITE_OK ) goto err; v->pTokenizer->pModule = m; schema = fulltextSchema(v->nColumn, (const char*const*)v->azColumn, spec->zName); rc = sqlite3_declare_vtab(db, schema); sqlite3_free(schema); if( rc!=SQLITE_OK ) goto err; memset(v->pFulltextStatements, 0, sizeof(v->pFulltextStatements)); v->nPendingData = -1; *ppVTab = &v->base; FTSTRACE(("FTS3 Connect %p\n", v)); return rc; err: fulltext_vtab_destroy(v); return rc; } static int fulltextConnect( sqlite3 *db, void *pAux, int argc, const char *const*argv, sqlite3_vtab **ppVTab, char **pzErr ){ TableSpec spec; int rc = parseSpec(&spec, argc, argv, pzErr); if( rc!=SQLITE_OK ) return rc; rc = constructVtab(db, (fts3Hash *)pAux, &spec, ppVTab, pzErr); clearTableSpec(&spec); return rc; } static int fulltextCreate(sqlite3 *db, void *pAux, int argc, const char * const *argv, sqlite3_vtab **ppVTab, char **pzErr){ int rc; TableSpec spec; StringBuffer schema; FTSTRACE(("FTS3 Create\n")); rc = parseSpec(&spec, argc, argv, pzErr); if( rc!=SQLITE_OK ) return rc; initStringBuffer(&schema); append(&schema, "CREATE TABLE %_content("); append(&schema, " docid INTEGER PRIMARY KEY,"); appendList(&schema, spec.nColumn, spec.azContentColumn); append(&schema, ")"); rc = sql_exec(db, spec.zDb, spec.zName, stringBufferData(&schema)); stringBufferDestroy(&schema); if( rc!=SQLITE_OK ) goto out; rc = sql_exec(db, spec.zDb, spec.zName, "create table %_segments(" " blockid INTEGER PRIMARY KEY," " block blob" ");" ); if( rc!=SQLITE_OK ) goto out; rc = sql_exec(db, spec.zDb, spec.zName, "create table %_segdir(" " level integer," " idx integer," " start_block integer," " leaves_end_block integer," " end_block integer," " root blob," " primary key(level, idx)" ");"); if( rc!=SQLITE_OK ) goto out; rc = constructVtab(db, (fts3Hash *)pAux, &spec, ppVTab, pzErr); out: clearTableSpec(&spec); return rc; } static int fulltextBestIndex(sqlite3_vtab *pVTab, sqlite3_index_info *pInfo){ fulltext_vtab *v = (fulltext_vtab *)pVTab; int i; FTSTRACE(("FTS3 BestIndex\n")); for(i=0; i<pInfo->nConstraint; ++i){ const struct sqlite3_index_constraint *pConstraint; pConstraint = &pInfo->aConstraint[i]; if( pConstraint->usable ) { if( (pConstraint->iColumn==-1 || pConstraint->iColumn==v->nColumn+1) && pConstraint->op==SQLITE_INDEX_CONSTRAINT_EQ ){ pInfo->idxNum = QUERY_DOCID; FTSTRACE(("FTS3 QUERY_DOCID\n")); } else if( pConstraint->iColumn>=0 && pConstraint->iColumn<=v->nColumn && pConstraint->op==SQLITE_INDEX_CONSTRAINT_MATCH ){ pInfo->idxNum = QUERY_FULLTEXT + pConstraint->iColumn; FTSTRACE(("FTS3 QUERY_FULLTEXT %d\n", pConstraint->iColumn)); } else continue; pInfo->aConstraintUsage[i].argvIndex = 1; pInfo->aConstraintUsage[i].omit = 1; pInfo->estimatedCost = 1.0; return SQLITE_OK; } } pInfo->idxNum = QUERY_GENERIC; return SQLITE_OK; } static int fulltextDisconnect(sqlite3_vtab *pVTab){ FTSTRACE(("FTS3 Disconnect %p\n", pVTab)); fulltext_vtab_destroy((fulltext_vtab *)pVTab); return SQLITE_OK; } static int fulltextDestroy(sqlite3_vtab *pVTab){ fulltext_vtab *v = (fulltext_vtab *)pVTab; int rc; FTSTRACE(("FTS3 Destroy %p\n", pVTab)); rc = sql_exec(v->db, v->zDb, v->zName, "drop table if exists %_content;" "drop table if exists %_segments;" "drop table if exists %_segdir;" ); if( rc!=SQLITE_OK ) return rc; fulltext_vtab_destroy((fulltext_vtab *)pVTab); return SQLITE_OK; } static int fulltextOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){ fulltext_cursor *c; c = (fulltext_cursor *) sqlite3_malloc(sizeof(fulltext_cursor)); if( c ){ memset(c, 0, sizeof(fulltext_cursor)); *ppCursor = &c->base; FTSTRACE(("FTS3 Open %p: %p\n", pVTab, c)); return SQLITE_OK; }else{ return SQLITE_NOMEM; } } static void queryClear(Query *q){ int i; for(i = 0; i < q->nTerms; ++i){ sqlite3_free(q->pTerms[i].pTerm); } sqlite3_free(q->pTerms); CLEAR(q); } static void snippetClear(Snippet *p){ sqlite3_free(p->aMatch); sqlite3_free(p->zOffset); sqlite3_free(p->zSnippet); CLEAR(p); } static void snippetAppendMatch( Snippet *p, int iCol, int iTerm, int iToken, int iStart, int nByte ){ int i; struct snippetMatch *pMatch; if( p->nMatch+1>=p->nAlloc ){ p->nAlloc = p->nAlloc*2 + 10; p->aMatch = sqlite3_realloc(p->aMatch, p->nAlloc*sizeof(p->aMatch[0]) ); if( p->aMatch==0 ){ p->nMatch = 0; p->nAlloc = 0; return; } } i = p->nMatch++; pMatch = &p->aMatch[i]; pMatch->iCol = iCol; pMatch->iTerm = iTerm; pMatch->iToken = iToken; pMatch->iStart = iStart; pMatch->nByte = nByte; } 
#define FTS3_ROTOR_SZ (32) 
#define FTS3_ROTOR_MASK (FTS3_ROTOR_SZ-1) 
static void snippetOffsetsOfColumn( Query *pQuery, Snippet *pSnippet, int iColumn, const char *zDoc, int nDoc ){ const sqlite3_tokenizer_module *pTModule; sqlite3_tokenizer *pTokenizer; sqlite3_tokenizer_cursor *pTCursor; fulltext_vtab *pVtab; int nColumn; const QueryTerm *aTerm; int nTerm; int i, j; int rc; unsigned int match, prevMatch; const char *zToken; int nToken; int iBegin, iEnd, iPos; unsigned int iRotor = 0; int iRotorBegin[FTS3_ROTOR_SZ]; int iRotorLen[FTS3_ROTOR_SZ]; pVtab = pQuery->pFts; nColumn = pVtab->nColumn; pTokenizer = pVtab->pTokenizer; pTModule = pTokenizer->pModule; rc = pTModule->xOpen(pTokenizer, zDoc, nDoc, &pTCursor); if( rc ) return; pTCursor->pTokenizer = pTokenizer; aTerm = pQuery->pTerms; nTerm = pQuery->nTerms; if( nTerm>=FTS3_ROTOR_SZ ){ nTerm = FTS3_ROTOR_SZ - 1; } prevMatch = 0; while(1){ rc = pTModule->xNext(pTCursor, &zToken, &nToken, &iBegin, &iEnd, &iPos); if( rc ) break; iRotorBegin[iRotor&FTS3_ROTOR_MASK] = iBegin; iRotorLen[iRotor&FTS3_ROTOR_MASK] = iEnd-iBegin; match = 0; for(i=0; i<nTerm; i++){ int iCol; iCol = aTerm[i].iColumn; if( iCol>=0 && iCol<nColumn && iCol!=iColumn ) continue; if( aTerm[i].nTerm>nToken ) continue; if( !aTerm[i].isPrefix && aTerm[i].nTerm<nToken ) continue; assert( aTerm[i].nTerm<=nToken ); if( memcmp(aTerm[i].pTerm, zToken, aTerm[i].nTerm) ) continue; if( aTerm[i].iPhrase>1 && (prevMatch & (1<<i))==0 ) continue; match |= 1<<i; if( i==nTerm-1 || aTerm[i+1].iPhrase==1 ){ for(j=aTerm[i].iPhrase-1; j>=0; j--){ int k = (iRotor-j) & FTS3_ROTOR_MASK; snippetAppendMatch(pSnippet, iColumn, i-j, iPos-j, iRotorBegin[k], iRotorLen[k]); } } } prevMatch = match<<1; iRotor++; } pTModule->xClose(pTCursor); } static void trimSnippetOffsetsForNear(Query *pQuery, Snippet *pSnippet){ int ii; int iDir = 1; while(iDir>-2) { assert( iDir==1 || iDir==-1 ); for(ii=0; ii<pSnippet->nMatch; ii++){ int jj; int nNear; struct snippetMatch *pMatch = &pSnippet->aMatch[ii]; QueryTerm *pQueryTerm = &pQuery->pTerms[pMatch->iTerm]; if( (pMatch->iTerm+iDir)<0 || (pMatch->iTerm+iDir)>=pQuery->nTerms ){ continue; } nNear = pQueryTerm->nNear; if( iDir<0 ){ nNear = pQueryTerm[-1].nNear; } if( pMatch->iTerm>=0 && nNear ){ int isOk = 0; int iNextTerm = pMatch->iTerm+iDir; int iPrevTerm = iNextTerm; int iEndToken; int iStartToken; if( iDir<0 ){ int nPhrase = 1; iStartToken = pMatch->iToken; while( (pMatch->iTerm+nPhrase)<pQuery->nTerms && pQuery->pTerms[pMatch->iTerm+nPhrase].iPhrase>1 ){ nPhrase++; } iEndToken = iStartToken + nPhrase - 1; }else{ iEndToken = pMatch->iToken; iStartToken = pMatch->iToken+1-pQueryTerm->iPhrase; } while( pQuery->pTerms[iNextTerm].iPhrase>1 ){ iNextTerm--; } while( (iPrevTerm+1)<pQuery->nTerms && pQuery->pTerms[iPrevTerm+1].iPhrase>1 ){ iPrevTerm++; } for(jj=0; isOk==0 && jj<pSnippet->nMatch; jj++){ struct snippetMatch *p = &pSnippet->aMatch[jj]; if( p->iCol==pMatch->iCol && (( p->iTerm==iNextTerm && p->iToken>iEndToken && p->iToken<=iEndToken+nNear ) || ( p->iTerm==iPrevTerm && p->iToken<iStartToken && p->iToken>=iStartToken-nNear ))){ isOk = 1; } } if( !isOk ){ for(jj=1-pQueryTerm->iPhrase; jj<=0; jj++){ pMatch[jj].iTerm = -1; } ii = -1; iDir = 1; } } } iDir -= 2; } } static void snippetAllOffsets(fulltext_cursor *p){ int nColumn; int iColumn, i; int iFirst, iLast; fulltext_vtab *pFts; if( p->snippet.nMatch ) return; if( p->q.nTerms==0 ) return; pFts = p->q.pFts; nColumn = pFts->nColumn; iColumn = (p->iCursorType - QUERY_FULLTEXT); if( iColumn<0 || iColumn>=nColumn ){ iFirst = 0; iLast = nColumn-1; }else{ iFirst = iColumn; iLast = iColumn; } for(i=iFirst; i<=iLast; i++){ const char *zDoc; int nDoc; zDoc = (const char*)sqlite3_column_text(p->pStmt, i+1); nDoc = sqlite3_column_bytes(p->pStmt, i+1); snippetOffsetsOfColumn(&p->q, &p->snippet, i, zDoc, nDoc); } trimSnippetOffsetsForNear(&p->q, &p->snippet); } static void snippetOffsetText(Snippet *p){ int i; int cnt = 0; StringBuffer sb; char zBuf[200]; if( p->zOffset ) return; initStringBuffer(&sb); for(i=0; i<p->nMatch; i++){ struct snippetMatch *pMatch = &p->aMatch[i]; if( pMatch->iTerm>=0 ){ zBuf[0] = ' '; sqlite3_snprintf(sizeof(zBuf)-1, &zBuf[cnt>0], "%d %d %d %d", pMatch->iCol, pMatch->iTerm, pMatch->iStart, pMatch->nByte); append(&sb, zBuf); cnt++; } } p->zOffset = stringBufferData(&sb); p->nOffset = stringBufferLength(&sb); } static int wordBoundary( int iBreak, const char *zDoc, int nDoc, struct snippetMatch *aMatch, int nMatch, int iCol ){ int i; if( iBreak<=10 ){ return 0; } if( iBreak>=nDoc-10 ){ return nDoc; } for(i=0; i<nMatch && aMatch[i].iCol<iCol; i++){} while( i<nMatch && aMatch[i].iStart+aMatch[i].nByte<iBreak ){ i++; } if( i<nMatch ){ if( aMatch[i].iStart<iBreak+10 ){ return aMatch[i].iStart; } if( i>0 && aMatch[i-1].iStart+aMatch[i-1].nByte>=iBreak ){ return aMatch[i-1].iStart; } } for(i=1; i<=10; i++){ if( safe_isspace(zDoc[iBreak-i]) ){ return iBreak - i + 1; } if( safe_isspace(zDoc[iBreak+i]) ){ return iBreak + i + 1; } } return iBreak; } 
#define SNIPPET_IGNORE 0 
#define SNIPPET_DESIRED 1 
static void snippetText( fulltext_cursor *pCursor, const char *zStartMark, const char *zEndMark, const char *zEllipsis ){ int i, j; struct snippetMatch *aMatch; int nMatch; int nDesired; StringBuffer sb; int tailCol; int tailOffset; int iCol; int nDoc; const char *zDoc; int iStart, iEnd; int tailEllipsis = 0; int iMatch; sqlite3_free(pCursor->snippet.zSnippet); pCursor->snippet.zSnippet = 0; aMatch = pCursor->snippet.aMatch; nMatch = pCursor->snippet.nMatch; initStringBuffer(&sb); for(i=0; i<nMatch; i++){ aMatch[i].snStatus = SNIPPET_IGNORE; } nDesired = 0; for(i=0; i<pCursor->q.nTerms; i++){ for(j=0; j<nMatch; j++){ if( aMatch[j].iTerm==i ){ aMatch[j].snStatus = SNIPPET_DESIRED; nDesired++; break; } } } iMatch = 0; tailCol = -1; tailOffset = 0; for(i=0; i<nMatch && nDesired>0; i++){ if( aMatch[i].snStatus!=SNIPPET_DESIRED ) continue; nDesired--; iCol = aMatch[i].iCol; zDoc = (const char*)sqlite3_column_text(pCursor->pStmt, iCol+1); nDoc = sqlite3_column_bytes(pCursor->pStmt, iCol+1); iStart = aMatch[i].iStart - 40; iStart = wordBoundary(iStart, zDoc, nDoc, aMatch, nMatch, iCol); if( iStart<=10 ){ iStart = 0; } if( iCol==tailCol && iStart<=tailOffset+20 ){ iStart = tailOffset; } if( (iCol!=tailCol && tailCol>=0) || iStart!=tailOffset ){ trimWhiteSpace(&sb); appendWhiteSpace(&sb); append(&sb, zEllipsis); appendWhiteSpace(&sb); } iEnd = aMatch[i].iStart + aMatch[i].nByte + 40; iEnd = wordBoundary(iEnd, zDoc, nDoc, aMatch, nMatch, iCol); if( iEnd>=nDoc-10 ){ iEnd = nDoc; tailEllipsis = 0; }else{ tailEllipsis = 1; } while( iMatch<nMatch && aMatch[iMatch].iCol<iCol ){ iMatch++; } while( iStart<iEnd ){ while( iMatch<nMatch && aMatch[iMatch].iStart<iStart && aMatch[iMatch].iCol<=iCol ){ iMatch++; } if( iMatch<nMatch && aMatch[iMatch].iStart<iEnd && aMatch[iMatch].iCol==iCol ){ nappend(&sb, &zDoc[iStart], aMatch[iMatch].iStart - iStart); iStart = aMatch[iMatch].iStart; append(&sb, zStartMark); nappend(&sb, &zDoc[iStart], aMatch[iMatch].nByte); append(&sb, zEndMark); iStart += aMatch[iMatch].nByte; for(j=iMatch+1; j<nMatch; j++){ if( aMatch[j].iTerm==aMatch[iMatch].iTerm && aMatch[j].snStatus==SNIPPET_DESIRED ){ nDesired--; aMatch[j].snStatus = SNIPPET_IGNORE; } } }else{ nappend(&sb, &zDoc[iStart], iEnd - iStart); iStart = iEnd; } } tailCol = iCol; tailOffset = iEnd; } trimWhiteSpace(&sb); if( tailEllipsis ){ appendWhiteSpace(&sb); append(&sb, zEllipsis); } pCursor->snippet.zSnippet = stringBufferData(&sb); pCursor->snippet.nSnippet = stringBufferLength(&sb); } static int fulltextClose(sqlite3_vtab_cursor *pCursor){ fulltext_cursor *c = (fulltext_cursor *) pCursor; FTSTRACE(("FTS3 Close %p\n", c)); sqlite3_finalize(c->pStmt); queryClear(&c->q); snippetClear(&c->snippet); if( c->result.nData!=0 ) dlrDestroy(&c->reader); dataBufferDestroy(&c->result); sqlite3_free(c); return SQLITE_OK; } static int fulltextNext(sqlite3_vtab_cursor *pCursor){ fulltext_cursor *c = (fulltext_cursor *) pCursor; int rc; FTSTRACE(("FTS3 Next %p\n", pCursor)); snippetClear(&c->snippet); if( c->iCursorType < QUERY_FULLTEXT ){ rc = sqlite3_step(c->pStmt); switch( rc ){ case SQLITE_ROW: c->eof = 0; return SQLITE_OK; case SQLITE_DONE: c->eof = 1; return SQLITE_OK; default: c->eof = 1; return rc; } } else { rc = sqlite3_reset(c->pStmt); if( rc!=SQLITE_OK ) return rc; if( c->result.nData==0 || dlrAtEnd(&c->reader) ){ c->eof = 1; return SQLITE_OK; } rc = sqlite3_bind_int64(c->pStmt, 1, dlrDocid(&c->reader)); dlrStep(&c->reader); if( rc!=SQLITE_OK ) return rc; rc = sqlite3_step(c->pStmt); if( rc==SQLITE_ROW ){ c->eof = 0; return SQLITE_OK; } return rc==SQLITE_DONE ? SQLITE_ERROR : rc; } } static int termSelect(fulltext_vtab *v, int iColumn, const char *pTerm, int nTerm, int isPrefix, DocListType iType, DataBuffer *out); static int docListOfTerm( fulltext_vtab *v, int iColumn, QueryTerm *pQTerm, DataBuffer *pResult ){ DataBuffer left, right, new; int i, rc; assert( pQTerm->nPhrase==0 || DL_DEFAULT!=DL_DOCIDS ); assert( v->nPendingData<0 ); dataBufferInit(&left, 0); rc = termSelect(v, iColumn, pQTerm->pTerm, pQTerm->nTerm, pQTerm->isPrefix, (0<pQTerm->nPhrase ? DL_POSITIONS : DL_DOCIDS), &left); if( rc ) return rc; for(i=1; i<=pQTerm->nPhrase && left.nData>0; i++){ int nPhraseRight = 1; while( (i+nPhraseRight)<=pQTerm->nPhrase && pQTerm[i+nPhraseRight].nNear==0 ){ nPhraseRight++; } dataBufferInit(&right, 0); rc = termSelect(v, iColumn, pQTerm[i].pTerm, pQTerm[i].nTerm, pQTerm[i].isPrefix, DL_POSITIONS, &right); if( rc ){ dataBufferDestroy(&left); return rc; } dataBufferInit(&new, 0); docListPhraseMerge(left.pData, left.nData, right.pData, right.nData, pQTerm[i-1].nNear, pQTerm[i-1].iPhrase + nPhraseRight, ((i<pQTerm->nPhrase) ? DL_POSITIONS : DL_DOCIDS), &new); dataBufferDestroy(&left); dataBufferDestroy(&right); left = new; } *pResult = left; return SQLITE_OK; } static void queryAdd(Query *q, const char *pTerm, int nTerm){ QueryTerm *t; ++q->nTerms; q->pTerms = sqlite3_realloc(q->pTerms, q->nTerms * sizeof(q->pTerms[0])); if( q->pTerms==0 ){ q->nTerms = 0; return; } t = &q->pTerms[q->nTerms - 1]; CLEAR(t); t->pTerm = sqlite3_malloc(nTerm+1); memcpy(t->pTerm, pTerm, nTerm); t->pTerm[nTerm] = 0; t->nTerm = nTerm; t->isOr = q->nextIsOr; t->isPrefix = 0; q->nextIsOr = 0; t->iColumn = q->nextColumn; q->nextColumn = q->dfltColumn; } static int checkColumnSpecifier( fulltext_vtab *pVtab, const char *zToken, int nToken ){ int i; for(i=0; i<pVtab->nColumn; i++){ if( memcmp(pVtab->azColumn[i], zToken, nToken)==0 && pVtab->azColumn[i][nToken]==0 ){ return i; } } return -1; } static int tokenizeSegment( sqlite3_tokenizer *pTokenizer, const char *zSegment, int nSegment, int inPhrase, Query *pQuery ){ const sqlite3_tokenizer_module *pModule = pTokenizer->pModule; sqlite3_tokenizer_cursor *pCursor; int firstIndex = pQuery->nTerms; int iCol; int nTerm = 1; int rc = pModule->xOpen(pTokenizer, zSegment, nSegment, &pCursor); if( rc!=SQLITE_OK ) return rc; pCursor->pTokenizer = pTokenizer; while( 1 ){ const char *zToken; int nToken, iBegin, iEnd, iPos; rc = pModule->xNext(pCursor, &zToken, &nToken, &iBegin, &iEnd, &iPos); if( rc!=SQLITE_OK ) break; if( !inPhrase && zSegment[iEnd]==':' && (iCol = checkColumnSpecifier(pQuery->pFts, zToken, nToken))>=0 ){ pQuery->nextColumn = iCol; continue; } if( !inPhrase && pQuery->nTerms>0 && nToken==2 && zSegment[iBegin+0]=='O' && zSegment[iBegin+1]=='R' ){ pQuery->nextIsOr = 1; continue; } if( !inPhrase && pQuery->nTerms>0 && !pQuery->nextIsOr && nToken==4 && memcmp(&zSegment[iBegin], "NEAR", 4)==0 ){ QueryTerm *pTerm = &pQuery->pTerms[pQuery->nTerms-1]; if( (iBegin+6)<nSegment && zSegment[iBegin+4] == '/' && isdigit(zSegment[iBegin+5]) ){ int k; pTerm->nNear = 0; for(k=5; (iBegin+k)<=nSegment && isdigit(zSegment[iBegin+k]); k++){ pTerm->nNear = pTerm->nNear*10 + (zSegment[iBegin+k] - '0'); } pModule->xNext(pCursor, &zToken, &nToken, &iBegin, &iEnd, &iPos); } else { pTerm->nNear = SQLITE_FTS3_DEFAULT_NEAR_PARAM; } pTerm->nNear++; continue; } queryAdd(pQuery, zToken, nToken); if( !inPhrase && iBegin>0 && zSegment[iBegin-1]=='-' ){ pQuery->pTerms[pQuery->nTerms-1].isNot = 1; } if( iEnd<nSegment && zSegment[iEnd]=='*' ){ pQuery->pTerms[pQuery->nTerms-1].isPrefix = 1; } pQuery->pTerms[pQuery->nTerms-1].iPhrase = nTerm; if( inPhrase ){ nTerm++; } } if( inPhrase && pQuery->nTerms>firstIndex ){ pQuery->pTerms[firstIndex].nPhrase = pQuery->nTerms - firstIndex - 1; } return pModule->xClose(pCursor); } static int parseQuery( fulltext_vtab *v, const char *zInput, int nInput, int dfltColumn, Query *pQuery ){ int iInput, inPhrase = 0; int ii; QueryTerm *aTerm; if( zInput==0 ) nInput = 0; if( nInput<0 ) nInput = strlen(zInput); pQuery->nTerms = 0; pQuery->pTerms = NULL; pQuery->nextIsOr = 0; pQuery->nextColumn = dfltColumn; pQuery->dfltColumn = dfltColumn; pQuery->pFts = v; for(iInput=0; iInput<nInput; ++iInput){ int i; for(i=iInput; i<nInput && zInput[i]!='"'; ++i){} if( i>iInput ){ tokenizeSegment(v->pTokenizer, zInput+iInput, i-iInput, inPhrase, pQuery); } iInput = i; if( i<nInput ){ assert( zInput[i]=='"' ); inPhrase = !inPhrase; } } if( inPhrase ){ queryClear(pQuery); return SQLITE_ERROR; } aTerm = pQuery->pTerms; for(ii=0; ii<pQuery->nTerms; ii++){ if( aTerm[ii].nNear || aTerm[ii].nPhrase ){ while (aTerm[ii+aTerm[ii].nPhrase].nNear) { aTerm[ii].nPhrase += (1 + aTerm[ii+aTerm[ii].nPhrase+1].nPhrase); } } } return SQLITE_OK; } static int flushPendingTerms(fulltext_vtab *v); static int fulltextQuery( fulltext_vtab *v, int iColumn, const char *zInput, int nInput, DataBuffer *pResult, Query *pQuery ){ int i, iNext, rc; DataBuffer left, right, or, new; int nNot = 0; QueryTerm *aTerm; rc = flushPendingTerms(v); if( rc!=SQLITE_OK ) return rc; rc = parseQuery(v, zInput, nInput, iColumn, pQuery); if( rc!=SQLITE_OK ) return rc; if( pQuery->nTerms==0 ){ dataBufferInit(pResult, 0); return SQLITE_OK; } aTerm = pQuery->pTerms; for(i = 0; i<pQuery->nTerms; i=iNext){ if( aTerm[i].isNot ){ nNot++; iNext = i + aTerm[i].nPhrase+1; continue; } iNext = i + aTerm[i].nPhrase + 1; rc = docListOfTerm(v, aTerm[i].iColumn, &aTerm[i], &right); if( rc ){ if( i!=nNot ) dataBufferDestroy(&left); queryClear(pQuery); return rc; } while( iNext<pQuery->nTerms && aTerm[iNext].isOr ){ rc = docListOfTerm(v, aTerm[iNext].iColumn, &aTerm[iNext], &or); iNext += aTerm[iNext].nPhrase + 1; if( rc ){ if( i!=nNot ) dataBufferDestroy(&left); dataBufferDestroy(&right); queryClear(pQuery); return rc; } dataBufferInit(&new, 0); docListOrMerge(right.pData, right.nData, or.pData, or.nData, &new); dataBufferDestroy(&right); dataBufferDestroy(&or); right = new; } if( i==nNot ){ left = right; }else{ dataBufferInit(&new, 0); docListAndMerge(left.pData, left.nData, right.pData, right.nData, &new); dataBufferDestroy(&right); dataBufferDestroy(&left); left = new; } } if( nNot==pQuery->nTerms ){ return SQLITE_ERROR; } for(i=0; i<pQuery->nTerms; i += aTerm[i].nPhrase + 1){ if( !aTerm[i].isNot ) continue; rc = docListOfTerm(v, aTerm[i].iColumn, &aTerm[i], &right); if( rc ){ queryClear(pQuery); dataBufferDestroy(&left); return rc; } dataBufferInit(&new, 0); docListExceptMerge(left.pData, left.nData, right.pData, right.nData, &new); dataBufferDestroy(&right); dataBufferDestroy(&left); left = new; } *pResult = left; return rc; } static int fulltextFilter( sqlite3_vtab_cursor *pCursor, int idxNum, const char *idxStr, int argc, sqlite3_value **argv ){ fulltext_cursor *c = (fulltext_cursor *) pCursor; fulltext_vtab *v = cursor_vtab(c); int rc; FTSTRACE(("FTS3 Filter %p\n",pCursor)); if( c->pStmt && c->iCursorType!=idxNum ){ sqlite3_finalize(c->pStmt); c->pStmt = NULL; } if( !c->pStmt ){ StringBuffer sb; initStringBuffer(&sb); append(&sb, "SELECT docid, "); appendList(&sb, v->nColumn, v->azContentColumn); append(&sb, " FROM %_content"); if( idxNum!=QUERY_GENERIC ) append(&sb, " WHERE docid = ?"); rc = sql_prepare(v->db, v->zDb, v->zName, &c->pStmt, stringBufferData(&sb)); stringBufferDestroy(&sb); if( rc!=SQLITE_OK ) return rc; c->iCursorType = idxNum; }else{ sqlite3_reset(c->pStmt); assert( c->iCursorType==idxNum ); } switch( idxNum ){ case QUERY_GENERIC: break; case QUERY_DOCID: rc = sqlite3_bind_int64(c->pStmt, 1, sqlite3_value_int64(argv[0])); if( rc!=SQLITE_OK ) return rc; break; default: { const char *zQuery = (const char *)sqlite3_value_text(argv[0]); assert( idxNum<=QUERY_FULLTEXT+v->nColumn); assert( argc==1 ); queryClear(&c->q); if( c->result.nData!=0 ){ dlrDestroy(&c->reader); dataBufferReset(&c->result); }else{ dataBufferInit(&c->result, 0); } rc = fulltextQuery(v, idxNum-QUERY_FULLTEXT, zQuery, -1, &c->result, &c->q); if( rc!=SQLITE_OK ) return rc; if( c->result.nData!=0 ){ dlrInit(&c->reader, DL_DOCIDS, c->result.pData, c->result.nData); } break; } } return fulltextNext(pCursor); } static int fulltextEof(sqlite3_vtab_cursor *pCursor){ fulltext_cursor *c = (fulltext_cursor *) pCursor; return c->eof; } static int fulltextColumn(sqlite3_vtab_cursor *pCursor, sqlite3_context *pContext, int idxCol){ fulltext_cursor *c = (fulltext_cursor *) pCursor; fulltext_vtab *v = cursor_vtab(c); if( idxCol<v->nColumn ){ sqlite3_value *pVal = sqlite3_column_value(c->pStmt, idxCol+1); sqlite3_result_value(pContext, pVal); }else if( idxCol==v->nColumn ){ sqlite3_result_blob(pContext, &c, sizeof(c), SQLITE_TRANSIENT); }else if( idxCol==v->nColumn+1 ){ sqlite3_value *pVal = sqlite3_column_value(c->pStmt, 0); sqlite3_result_value(pContext, pVal); } return SQLITE_OK; } static int fulltextRowid(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid){ fulltext_cursor *c = (fulltext_cursor *) pCursor; *pRowid = sqlite3_column_int64(c->pStmt, 0); return SQLITE_OK; } static int buildTerms(fulltext_vtab *v, sqlite_int64 iDocid, const char *zText, int iColumn){ sqlite3_tokenizer *pTokenizer = v->pTokenizer; sqlite3_tokenizer_cursor *pCursor; const char *pToken; int nTokenBytes; int iStartOffset, iEndOffset, iPosition; int rc; rc = pTokenizer->pModule->xOpen(pTokenizer, zText, -1, &pCursor); if( rc!=SQLITE_OK ) return rc; pCursor->pTokenizer = pTokenizer; while( SQLITE_OK==(rc=pTokenizer->pModule->xNext(pCursor, &pToken, &nTokenBytes, &iStartOffset, &iEndOffset, &iPosition)) ){ DLCollector *p; int nData; if( iPosition<0 || pToken == NULL || nTokenBytes == 0 ){ rc = SQLITE_ERROR; break; } p = fts3HashFind(&v->pendingTerms, pToken, nTokenBytes); if( p==NULL ){ nData = 0; p = dlcNew(iDocid, DL_DEFAULT); fts3HashInsert(&v->pendingTerms, pToken, nTokenBytes, p); v->nPendingData += sizeof(struct fts3HashElem)+sizeof(*p)+nTokenBytes; }else{ nData = p->b.nData; if( p->dlw.iPrevDocid!=iDocid ) dlcNext(p, iDocid); } if( iColumn>=0 ){ dlcAddPos(p, iColumn, iPosition, iStartOffset, iEndOffset); } v->nPendingData += p->b.nData-nData; } pTokenizer->pModule->xClose(pCursor); if( SQLITE_DONE == rc ) return SQLITE_OK; return rc; } static int insertTerms(fulltext_vtab *v, sqlite_int64 iDocid, sqlite3_value **pValues){ int i; for(i = 0; i < v->nColumn ; ++i){ char *zText = (char*)sqlite3_value_text(pValues[i]); int rc = buildTerms(v, iDocid, zText, i); if( rc!=SQLITE_OK ) return rc; } return SQLITE_OK; } static int deleteTerms(fulltext_vtab *v, sqlite_int64 iDocid){ const char **pValues; int i, rc; if( DL_DEFAULT==DL_DOCIDS ) return SQLITE_ERROR; rc = content_select(v, iDocid, &pValues); if( rc!=SQLITE_OK ) return rc; for(i = 0 ; i < v->nColumn; ++i) { rc = buildTerms(v, iDocid, pValues[i], -1); if( rc!=SQLITE_OK ) break; } freeStringArray(v->nColumn, pValues); return SQLITE_OK; } static int initPendingTerms(fulltext_vtab *v, sqlite_int64 iDocid); static int index_insert(fulltext_vtab *v, sqlite3_value *pRequestDocid, sqlite3_value **pValues, sqlite_int64 *piDocid){ int rc; rc = content_insert(v, pRequestDocid, pValues); if( rc!=SQLITE_OK ) return rc; *piDocid = sqlite3_last_insert_rowid(v->db); rc = initPendingTerms(v, *piDocid); if( rc!=SQLITE_OK ) return rc; return insertTerms(v, *piDocid, pValues); } static int index_delete(fulltext_vtab *v, sqlite_int64 iRow){ int rc = initPendingTerms(v, iRow); if( rc!=SQLITE_OK ) return rc; rc = deleteTerms(v, iRow); if( rc!=SQLITE_OK ) return rc; return content_delete(v, iRow); } static int index_update(fulltext_vtab *v, sqlite_int64 iRow, sqlite3_value **pValues){ int rc = initPendingTerms(v, iRow); if( rc!=SQLITE_OK ) return rc; rc = deleteTerms(v, iRow); if( rc!=SQLITE_OK ) return rc; rc = content_update(v, pValues, iRow); if( rc!=SQLITE_OK ) return rc; return insertTerms(v, iRow, pValues); } 
#define INTERIOR_MAX 2048 
#define INTERIOR_MIN_TERMS 7 
#if INTERIOR_MIN_TERMS<1 
#error INTERIOR_MIN_TERMS must be greater than 0. 
#endif 
#define ROOT_MAX 1024 
#if ROOT_MAX<VARINT_MAX*2 
#error ROOT_MAX must have enough space for a header. 
#endif 
typedef struct InteriorBlock { DataBuffer term; DataBuffer data; struct InteriorBlock *next; } InteriorBlock; static InteriorBlock *interiorBlockNew(int iHeight, sqlite_int64 iChildBlock, const char *pTerm, int nTerm){ InteriorBlock *block = sqlite3_malloc(sizeof(InteriorBlock)); char c[VARINT_MAX+VARINT_MAX]; int n; if( block ){ memset(block, 0, sizeof(*block)); dataBufferInit(&block->term, 0); dataBufferReplace(&block->term, pTerm, nTerm); n = fts3PutVarint(c, iHeight); n += fts3PutVarint(c+n, iChildBlock); dataBufferInit(&block->data, INTERIOR_MAX); dataBufferReplace(&block->data, c, n); } return block; } 
#ifndef NDEBUG 
static void interiorBlockValidate(InteriorBlock *pBlock){ const char *pData = pBlock->data.pData; int nData = pBlock->data.nData; int n, iDummy; sqlite_int64 iBlockid; assert( nData>0 ); assert( pData!=0 ); assert( pData+nData>pData ); n = fts3GetVarint32(pData, &iDummy); assert( n>0 ); assert( iDummy>0 ); assert( n<nData ); pData += n; nData -= n; n = fts3GetVarint(pData, &iBlockid); assert( n>0 ); assert( n<=nData ); pData += n; nData -= n; if( nData!=0 ){ n = fts3GetVarint32(pData, &iDummy); assert( n>0 ); assert( iDummy>0 ); assert( n+iDummy>0); assert( n+iDummy<=nData ); pData += n+iDummy; nData -= n+iDummy; while( nData!=0 ){ n = fts3GetVarint32(pData, &iDummy); assert( n>0 ); assert( iDummy>=0 ); assert( n<nData ); pData += n; nData -= n; n = fts3GetVarint32(pData, &iDummy); assert( n>0 ); assert( iDummy>0 ); assert( n+iDummy>0); assert( n+iDummy<=nData ); pData += n+iDummy; nData -= n+iDummy; } } } 
#define ASSERT_VALID_INTERIOR_BLOCK(x) interiorBlockValidate(x) 
#else 
#define ASSERT_VALID_INTERIOR_BLOCK(x) assert( 1 ) 
#endif 
typedef struct InteriorWriter { int iHeight; InteriorBlock *first, *last; struct InteriorWriter *parentWriter; DataBuffer term; sqlite_int64 iOpeningChildBlock; 
#ifndef NDEBUG 
 sqlite_int64 iLastChildBlock; 
#endif 
} InteriorWriter; static void interiorWriterInit(int iHeight, const char *pTerm, int nTerm, sqlite_int64 iChildBlock, InteriorWriter *pWriter){ InteriorBlock *block; assert( iHeight>0 ); CLEAR(pWriter); pWriter->iHeight = iHeight; pWriter->iOpeningChildBlock = iChildBlock; 
#ifndef NDEBUG 
 pWriter->iLastChildBlock = iChildBlock; 
#endif 
 block = interiorBlockNew(iHeight, iChildBlock, pTerm, nTerm); pWriter->last = pWriter->first = block; ASSERT_VALID_INTERIOR_BLOCK(pWriter->last); dataBufferInit(&pWriter->term, 0); } static void interiorWriterAppend(InteriorWriter *pWriter, const char *pTerm, int nTerm, sqlite_int64 iChildBlock){ char c[VARINT_MAX+VARINT_MAX]; int n, nPrefix = 0; ASSERT_VALID_INTERIOR_BLOCK(pWriter->last); if( pWriter->term.nData==0 ){ n = fts3PutVarint(c, nTerm); }else{ while( nPrefix<pWriter->term.nData && pTerm[nPrefix]==pWriter->term.pData[nPrefix] ){ nPrefix++; } n = fts3PutVarint(c, nPrefix); n += fts3PutVarint(c+n, nTerm-nPrefix); } 
#ifndef NDEBUG 
 pWriter->iLastChildBlock++; 
#endif 
 assert( pWriter->iLastChildBlock==iChildBlock ); if( pWriter->last->data.nData+n+nTerm-nPrefix>INTERIOR_MAX && iChildBlock-pWriter->iOpeningChildBlock>INTERIOR_MIN_TERMS ){ pWriter->last->next = interiorBlockNew(pWriter->iHeight, iChildBlock, pTerm, nTerm); pWriter->last = pWriter->last->next; pWriter->iOpeningChildBlock = iChildBlock; dataBufferReset(&pWriter->term); }else{ dataBufferAppend2(&pWriter->last->data, c, n, pTerm+nPrefix, nTerm-nPrefix); dataBufferReplace(&pWriter->term, pTerm, nTerm); } ASSERT_VALID_INTERIOR_BLOCK(pWriter->last); } static int interiorWriterDestroy(InteriorWriter *pWriter){ InteriorBlock *block = pWriter->first; while( block!=NULL ){ InteriorBlock *b = block; block = block->next; dataBufferDestroy(&b->term); dataBufferDestroy(&b->data); sqlite3_free(b); } if( pWriter->parentWriter!=NULL ){ interiorWriterDestroy(pWriter->parentWriter); sqlite3_free(pWriter->parentWriter); } dataBufferDestroy(&pWriter->term); SCRAMBLE(pWriter); return SQLITE_OK; } static int interiorWriterRootInfo(fulltext_vtab *v, InteriorWriter *pWriter, char **ppRootInfo, int *pnRootInfo, sqlite_int64 *piEndBlockid){ InteriorBlock *block = pWriter->first; sqlite_int64 iBlockid = 0; int rc; if( block==pWriter->last && block->data.nData<ROOT_MAX ){ *ppRootInfo = block->data.pData; *pnRootInfo = block->data.nData; return SQLITE_OK; } ASSERT_VALID_INTERIOR_BLOCK(block); rc = block_insert(v, block->data.pData, block->data.nData, &iBlockid); if( rc!=SQLITE_OK ) return rc; *piEndBlockid = iBlockid; pWriter->parentWriter = sqlite3_malloc(sizeof(*pWriter->parentWriter)); interiorWriterInit(pWriter->iHeight+1, block->term.pData, block->term.nData, iBlockid, pWriter->parentWriter); for(block=block->next; block!=NULL; block=block->next){ ASSERT_VALID_INTERIOR_BLOCK(block); rc = block_insert(v, block->data.pData, block->data.nData, &iBlockid); if( rc!=SQLITE_OK ) return rc; *piEndBlockid = iBlockid; interiorWriterAppend(pWriter->parentWriter, block->term.pData, block->term.nData, iBlockid); } return interiorWriterRootInfo(v, pWriter->parentWriter, ppRootInfo, pnRootInfo, piEndBlockid); } typedef struct InteriorReader { const char *pData; int nData; DataBuffer term; sqlite_int64 iBlockid; } InteriorReader; static void interiorReaderDestroy(InteriorReader *pReader){ dataBufferDestroy(&pReader->term); SCRAMBLE(pReader); } static void interiorReaderInit(const char *pData, int nData, InteriorReader *pReader){ int n, nTerm; assert( nData>0 ); assert( pData[0]!='\0' ); CLEAR(pReader); n = fts3GetVarint(pData+1, &pReader->iBlockid); assert( 1+n<=nData ); pReader->pData = pData+1+n; pReader->nData = nData-(1+n); if( pReader->nData==0 ){ dataBufferInit(&pReader->term, 0); }else{ n = fts3GetVarint32(pReader->pData, &nTerm); dataBufferInit(&pReader->term, nTerm); dataBufferReplace(&pReader->term, pReader->pData+n, nTerm); assert( n+nTerm<=pReader->nData ); pReader->pData += n+nTerm; pReader->nData -= n+nTerm; } } static int interiorReaderAtEnd(InteriorReader *pReader){ return pReader->term.nData==0; } static sqlite_int64 interiorReaderCurrentBlockid(InteriorReader *pReader){ return pReader->iBlockid; } static int interiorReaderTermBytes(InteriorReader *pReader){ assert( !interiorReaderAtEnd(pReader) ); return pReader->term.nData; } static const char *interiorReaderTerm(InteriorReader *pReader){ assert( !interiorReaderAtEnd(pReader) ); return pReader->term.pData; } static void interiorReaderStep(InteriorReader *pReader){ assert( !interiorReaderAtEnd(pReader) ); if( pReader->nData==0 ){ dataBufferReset(&pReader->term); }else{ int n, nPrefix, nSuffix; n = fts3GetVarint32(pReader->pData, &nPrefix); n += fts3GetVarint32(pReader->pData+n, &nSuffix); pReader->term.nData = nPrefix; dataBufferAppend(&pReader->term, pReader->pData+n, nSuffix); assert( n+nSuffix<=pReader->nData ); pReader->pData += n+nSuffix; pReader->nData -= n+nSuffix; } pReader->iBlockid++; } static int interiorReaderTermCmp(InteriorReader *pReader, const char *pTerm, int nTerm, int isPrefix){ const char *pReaderTerm = interiorReaderTerm(pReader); int nReaderTerm = interiorReaderTermBytes(pReader); int c, n = nReaderTerm<nTerm ? nReaderTerm : nTerm; if( n==0 ){ if( nReaderTerm>0 ) return -1; if( nTerm>0 ) return 1; return 0; } c = memcmp(pReaderTerm, pTerm, n); if( c!=0 ) return c; if( isPrefix && n==nTerm ) return 0; return nReaderTerm - nTerm; } 
#define STANDALONE_MIN 1024 
#define LEAF_MAX 2048 
typedef struct LeafWriter { int iLevel; int idx; sqlite_int64 iStartBlockid; sqlite_int64 iEndBlockid; DataBuffer term; DataBuffer data; int nTermDistinct; InteriorWriter parentWriter; int has_parent; } LeafWriter; static void leafWriterInit(int iLevel, int idx, LeafWriter *pWriter){ CLEAR(pWriter); pWriter->iLevel = iLevel; pWriter->idx = idx; dataBufferInit(&pWriter->term, 32); dataBufferInit(&pWriter->data, LEAF_MAX); } 
#ifndef NDEBUG 
static void leafNodeValidate(const char *pData, int nData){ int n, iDummy; if( nData==0 ) return; assert( nData>0 ); assert( pData!=0 ); assert( pData+nData>pData ); n = fts3GetVarint32(pData, &iDummy); assert( iDummy==0 ); assert( n>0 ); assert( n<nData ); pData += n; nData -= n; n = fts3GetVarint32(pData, &iDummy); assert( n>0 ); assert( iDummy>0 ); assert( n+iDummy>0 ); assert( n+iDummy<nData ); pData += n+iDummy; nData -= n+iDummy; n = fts3GetVarint32(pData, &iDummy); assert( n>0 ); assert( iDummy>0 ); assert( n+iDummy>0 ); assert( n+iDummy<=nData ); ASSERT_VALID_DOCLIST(DL_DEFAULT, pData+n, iDummy, NULL); pData += n+iDummy; nData -= n+iDummy; while( nData!=0 ){ n = fts3GetVarint32(pData, &iDummy); assert( n>0 ); assert( iDummy>=0 ); assert( n<nData ); pData += n; nData -= n; n = fts3GetVarint32(pData, &iDummy); assert( n>0 ); assert( iDummy>0 ); assert( n+iDummy>0 ); assert( n+iDummy<nData ); pData += n+iDummy; nData -= n+iDummy; n = fts3GetVarint32(pData, &iDummy); assert( n>0 ); assert( iDummy>0 ); assert( n+iDummy>0 ); assert( n+iDummy<=nData ); ASSERT_VALID_DOCLIST(DL_DEFAULT, pData+n, iDummy, NULL); pData += n+iDummy; nData -= n+iDummy; } } 
#define ASSERT_VALID_LEAF_NODE(p, n) leafNodeValidate(p, n) 
#else 
#define ASSERT_VALID_LEAF_NODE(p, n) assert( 1 ) 
#endif 
static int leafWriterInternalFlush(fulltext_vtab *v, LeafWriter *pWriter, int iData, int nData){ sqlite_int64 iBlockid = 0; const char *pStartingTerm; int nStartingTerm, rc, n; assert( nData>2 ); assert( iData>=0 ); assert( iData+nData<=pWriter->data.nData ); ASSERT_VALID_LEAF_NODE(pWriter->data.pData+iData, nData); rc = block_insert(v, pWriter->data.pData+iData, nData, &iBlockid); if( rc!=SQLITE_OK ) return rc; assert( iBlockid!=0 ); n = fts3GetVarint32(pWriter->data.pData+iData+1, &nStartingTerm); pStartingTerm = pWriter->data.pData+iData+1+n; assert( pWriter->data.nData>iData+1+n+nStartingTerm ); assert( pWriter->nTermDistinct>0 ); assert( pWriter->nTermDistinct<=nStartingTerm ); nStartingTerm = pWriter->nTermDistinct; if( pWriter->has_parent ){ interiorWriterAppend(&pWriter->parentWriter, pStartingTerm, nStartingTerm, iBlockid); }else{ interiorWriterInit(1, pStartingTerm, nStartingTerm, iBlockid, &pWriter->parentWriter); pWriter->has_parent = 1; } if( pWriter->iEndBlockid==0 ){ pWriter->iEndBlockid = pWriter->iStartBlockid = iBlockid; }else{ pWriter->iEndBlockid++; assert( iBlockid==pWriter->iEndBlockid ); } return SQLITE_OK; } static int leafWriterFlush(fulltext_vtab *v, LeafWriter *pWriter){ int rc = leafWriterInternalFlush(v, pWriter, 0, pWriter->data.nData); if( rc!=SQLITE_OK ) return rc; dataBufferReset(&pWriter->data); return SQLITE_OK; } static int leafWriterRootInfo(fulltext_vtab *v, LeafWriter *pWriter, char **ppRootInfo, int *pnRootInfo, sqlite_int64 *piEndBlockid){ if( !pWriter->has_parent && pWriter->data.nData<ROOT_MAX ){ *ppRootInfo = pWriter->data.pData; *pnRootInfo = pWriter->data.nData; *piEndBlockid = 0; return SQLITE_OK; } if( pWriter->data.nData>0 ){ int rc = leafWriterFlush(v, pWriter); if( rc!=SQLITE_OK ) return rc; } assert( pWriter->has_parent ); *piEndBlockid = pWriter->iEndBlockid; return interiorWriterRootInfo(v, &pWriter->parentWriter, ppRootInfo, pnRootInfo, piEndBlockid); } static int leafWriterFinalize(fulltext_vtab *v, LeafWriter *pWriter){ sqlite_int64 iEndBlockid; char *pRootInfo; int rc, nRootInfo; rc = leafWriterRootInfo(v, pWriter, &pRootInfo, &nRootInfo, &iEndBlockid); if( rc!=SQLITE_OK ) return rc; if( iEndBlockid==0 && nRootInfo==0 ) return SQLITE_OK; return segdir_set(v, pWriter->iLevel, pWriter->idx, pWriter->iStartBlockid, pWriter->iEndBlockid, iEndBlockid, pRootInfo, nRootInfo); } static void leafWriterDestroy(LeafWriter *pWriter){ if( pWriter->has_parent ) interiorWriterDestroy(&pWriter->parentWriter); dataBufferDestroy(&pWriter->term); dataBufferDestroy(&pWriter->data); } static int leafWriterEncodeTerm(LeafWriter *pWriter, const char *pTerm, int nTerm){ char c[VARINT_MAX+VARINT_MAX]; int n, nPrefix = 0; assert( nTerm>0 ); while( nPrefix<pWriter->term.nData && pTerm[nPrefix]==pWriter->term.pData[nPrefix] ){ nPrefix++; assert( nPrefix<nTerm ); } if( pWriter->data.nData==0 ){ n = fts3PutVarint(c, '\0'); n += fts3PutVarint(c+n, nTerm); dataBufferAppend2(&pWriter->data, c, n, pTerm, nTerm); }else{ n = fts3PutVarint(c, nPrefix); n += fts3PutVarint(c+n, nTerm-nPrefix); dataBufferAppend2(&pWriter->data, c, n, pTerm+nPrefix, nTerm-nPrefix); } dataBufferReplace(&pWriter->term, pTerm, nTerm); return nPrefix+1; } static int leafWriterInlineFlush(fulltext_vtab *v, LeafWriter *pWriter, const char *pTerm, int nTerm, int iDoclistData){ char c[VARINT_MAX+VARINT_MAX]; int iData, n = fts3PutVarint(c, 0); n += fts3PutVarint(c+n, nTerm); assert( iDoclistData>=n+nTerm ); iData = iDoclistData-(n+nTerm); memcpy(pWriter->data.pData+iData, c, n); memcpy(pWriter->data.pData+iData+n, pTerm, nTerm); return leafWriterInternalFlush(v, pWriter, iData, pWriter->data.nData-iData); } static int leafWriterStepMerge(fulltext_vtab *v, LeafWriter *pWriter, const char *pTerm, int nTerm, DLReader *pReaders, int nReaders){ char c[VARINT_MAX+VARINT_MAX]; int iTermData = pWriter->data.nData, iDoclistData; int i, nData, n, nActualData, nActual, rc, nTermDistinct; ASSERT_VALID_LEAF_NODE(pWriter->data.pData, pWriter->data.nData); nTermDistinct = leafWriterEncodeTerm(pWriter, pTerm, nTerm); if( iTermData==0 ) pWriter->nTermDistinct = nTermDistinct; iDoclistData = pWriter->data.nData; for(i=0, nData=0; i<nReaders; i++){ nData += dlrAllDataBytes(&pReaders[i]); } n = fts3PutVarint(c, nData); dataBufferAppend(&pWriter->data, c, n); docListMerge(&pWriter->data, pReaders, nReaders); ASSERT_VALID_DOCLIST(DL_DEFAULT, pWriter->data.pData+iDoclistData+n, pWriter->data.nData-iDoclistData-n, NULL); nActualData = pWriter->data.nData-(iDoclistData+n); nActual = fts3PutVarint(c, nActualData); assert( nActualData<=nData ); assert( nActual<=n ); if( nTerm+nActualData>STANDALONE_MIN ){ if( iTermData>0 ){ rc = leafWriterInternalFlush(v, pWriter, 0, iTermData); if( rc!=SQLITE_OK ) return rc; pWriter->nTermDistinct = nTermDistinct; } iDoclistData += n - nActual; memcpy(pWriter->data.pData+iDoclistData, c, nActual); rc = leafWriterInlineFlush(v, pWriter, pTerm, nTerm, iDoclistData); if( rc!=SQLITE_OK ) return rc; dataBufferReset(&pWriter->data); return rc; } if( nActual<n ){ memmove(pWriter->data.pData+iDoclistData+nActual, pWriter->data.pData+iDoclistData+n, pWriter->data.nData-(iDoclistData+n)); pWriter->data.nData -= n-nActual; } memcpy(pWriter->data.pData+iDoclistData, c, nActual); if( iTermData+nTerm+nActualData>LEAF_MAX ){ rc = leafWriterInternalFlush(v, pWriter, 0, iTermData); if( rc!=SQLITE_OK ) return rc; pWriter->nTermDistinct = nTermDistinct; n = fts3PutVarint(pWriter->data.pData, 0); n += fts3PutVarint(pWriter->data.pData+n, nTerm); memcpy(pWriter->data.pData+n, pTerm, nTerm); n += nTerm; assert( n<iDoclistData ); assert( 2*STANDALONE_MIN<=LEAF_MAX ); assert( n+pWriter->data.nData-iDoclistData<iDoclistData ); memcpy(pWriter->data.pData+n, pWriter->data.pData+iDoclistData, pWriter->data.nData-iDoclistData); pWriter->data.nData -= iDoclistData-n; } ASSERT_VALID_LEAF_NODE(pWriter->data.pData, pWriter->data.nData); return SQLITE_OK; } static int leafWriterStep(fulltext_vtab *v, LeafWriter *pWriter, const char *pTerm, int nTerm, const char *pData, int nData){ int rc; DLReader reader; dlrInit(&reader, DL_DEFAULT, pData, nData); rc = leafWriterStepMerge(v, pWriter, pTerm, nTerm, &reader, 1); dlrDestroy(&reader); return rc; } typedef struct LeafReader { DataBuffer term; const char *pData; int nData; } LeafReader; static void leafReaderDestroy(LeafReader *pReader){ dataBufferDestroy(&pReader->term); SCRAMBLE(pReader); } static int leafReaderAtEnd(LeafReader *pReader){ return pReader->nData<=0; } static int leafReaderTermBytes(LeafReader *pReader){ return pReader->term.nData; } static const char *leafReaderTerm(LeafReader *pReader){ assert( pReader->term.nData>0 ); return pReader->term.pData; } static int leafReaderDataBytes(LeafReader *pReader){ int nData; assert( pReader->term.nData>0 ); fts3GetVarint32(pReader->pData, &nData); return nData; } static const char *leafReaderData(LeafReader *pReader){ int n, nData; assert( pReader->term.nData>0 ); n = fts3GetVarint32(pReader->pData, &nData); return pReader->pData+n; } static void leafReaderInit(const char *pData, int nData, LeafReader *pReader){ int nTerm, n; assert( nData>0 ); assert( pData[0]=='\0' ); CLEAR(pReader); n = fts3GetVarint32(pData+1, &nTerm); dataBufferInit(&pReader->term, nTerm); dataBufferReplace(&pReader->term, pData+1+n, nTerm); assert( 1+n+nTerm<nData ); pReader->pData = pData+1+n+nTerm; pReader->nData = nData-1-n-nTerm; } static void leafReaderStep(LeafReader *pReader){ int n, nData, nPrefix, nSuffix; assert( !leafReaderAtEnd(pReader) ); n = fts3GetVarint32(pReader->pData, &nData); assert( n+nData<=pReader->nData ); pReader->pData += n+nData; pReader->nData -= n+nData; if( !leafReaderAtEnd(pReader) ){ n = fts3GetVarint32(pReader->pData, &nPrefix); n += fts3GetVarint32(pReader->pData+n, &nSuffix); assert( n+nSuffix<pReader->nData ); pReader->term.nData = nPrefix; dataBufferAppend(&pReader->term, pReader->pData+n, nSuffix); pReader->pData += n+nSuffix; pReader->nData -= n+nSuffix; } } static int leafReaderTermCmp(LeafReader *pReader, const char *pTerm, int nTerm, int isPrefix){ int c, n = pReader->term.nData<nTerm ? pReader->term.nData : nTerm; if( n==0 ){ if( pReader->term.nData>0 ) return -1; if(nTerm>0 ) return 1; return 0; } c = memcmp(pReader->term.pData, pTerm, n); if( c!=0 ) return c; if( isPrefix && n==nTerm ) return 0; return pReader->term.nData - nTerm; } typedef struct LeavesReader { int idx; sqlite3_stmt *pStmt; int eof; LeafReader leafReader; DataBuffer rootData; } LeavesReader; static int leavesReaderTermBytes(LeavesReader *pReader){ assert( !pReader->eof ); return leafReaderTermBytes(&pReader->leafReader); } static const char *leavesReaderTerm(LeavesReader *pReader){ assert( !pReader->eof ); return leafReaderTerm(&pReader->leafReader); } static int leavesReaderDataBytes(LeavesReader *pReader){ assert( !pReader->eof ); return leafReaderDataBytes(&pReader->leafReader); } static const char *leavesReaderData(LeavesReader *pReader){ assert( !pReader->eof ); return leafReaderData(&pReader->leafReader); } static int leavesReaderAtEnd(LeavesReader *pReader){ return pReader->eof; } static int leavesReaderReset(LeavesReader *pReader){ return sqlite3_reset(pReader->pStmt); } static void leavesReaderDestroy(LeavesReader *pReader){ if( pReader->pStmt!=NULL && pReader->idx==-1 ){ sqlite3_finalize(pReader->pStmt); } leafReaderDestroy(&pReader->leafReader); dataBufferDestroy(&pReader->rootData); SCRAMBLE(pReader); } static int leavesReaderInit(fulltext_vtab *v, int idx, sqlite_int64 iStartBlockid, sqlite_int64 iEndBlockid, const char *pRootData, int nRootData, LeavesReader *pReader){ CLEAR(pReader); pReader->idx = idx; dataBufferInit(&pReader->rootData, 0); if( iStartBlockid==0 ){ dataBufferReplace(&pReader->rootData, pRootData, nRootData); leafReaderInit(pReader->rootData.pData, pReader->rootData.nData, &pReader->leafReader); }else{ sqlite3_stmt *s; int rc = sql_get_leaf_statement(v, idx, &s); if( rc!=SQLITE_OK ) return rc; rc = sqlite3_bind_int64(s, 1, iStartBlockid); if( rc!=SQLITE_OK ) return rc; rc = sqlite3_bind_int64(s, 2, iEndBlockid); if( rc!=SQLITE_OK ) return rc; rc = sqlite3_step(s); if( rc==SQLITE_DONE ){ pReader->eof = 1; return SQLITE_OK; } if( rc!=SQLITE_ROW ) return rc; pReader->pStmt = s; leafReaderInit(sqlite3_column_blob(pReader->pStmt, 0), sqlite3_column_bytes(pReader->pStmt, 0), &pReader->leafReader); } return SQLITE_OK; } static int leavesReaderStep(fulltext_vtab *v, LeavesReader *pReader){ assert( !leavesReaderAtEnd(pReader) ); leafReaderStep(&pReader->leafReader); if( leafReaderAtEnd(&pReader->leafReader) ){ int rc; if( pReader->rootData.pData ){ pReader->eof = 1; return SQLITE_OK; } rc = sqlite3_step(pReader->pStmt); if( rc!=SQLITE_ROW ){ pReader->eof = 1; return rc==SQLITE_DONE ? SQLITE_OK : rc; } leafReaderDestroy(&pReader->leafReader); leafReaderInit(sqlite3_column_blob(pReader->pStmt, 0), sqlite3_column_bytes(pReader->pStmt, 0), &pReader->leafReader); } return SQLITE_OK; } static int leavesReaderTermCmp(LeavesReader *lr1, LeavesReader *lr2){ if( leavesReaderAtEnd(lr1) ){ if( leavesReaderAtEnd(lr2) ) return 0; return 1; } if( leavesReaderAtEnd(lr2) ) return -1; return leafReaderTermCmp(&lr1->leafReader, leavesReaderTerm(lr2), leavesReaderTermBytes(lr2), 0); } static int leavesReaderCmp(LeavesReader *lr1, LeavesReader *lr2){ int c = leavesReaderTermCmp(lr1, lr2); if( c!=0 ) return c; return lr1->idx-lr2->idx; } static void leavesReaderReorder(LeavesReader *pLr, int nLr){ while( nLr>1 && leavesReaderCmp(pLr, pLr+1)>0 ){ LeavesReader tmp = pLr[0]; pLr[0] = pLr[1]; pLr[1] = tmp; nLr--; pLr++; } } static int leavesReadersInit(fulltext_vtab *v, int iLevel, LeavesReader *pReaders, int *piReaders){ sqlite3_stmt *s; int i, rc = sql_get_statement(v, SEGDIR_SELECT_LEVEL_STMT, &s); if( rc!=SQLITE_OK ) return rc; rc = sqlite3_bind_int(s, 1, iLevel); if( rc!=SQLITE_OK ) return rc; i = 0; while( (rc = sqlite3_step(s))==SQLITE_ROW ){ sqlite_int64 iStart = sqlite3_column_int64(s, 0); sqlite_int64 iEnd = sqlite3_column_int64(s, 1); const char *pRootData = sqlite3_column_blob(s, 2); int nRootData = sqlite3_column_bytes(s, 2); assert( i<MERGE_COUNT ); rc = leavesReaderInit(v, i, iStart, iEnd, pRootData, nRootData, &pReaders[i]); if( rc!=SQLITE_OK ) break; i++; } if( rc!=SQLITE_DONE ){ while( i-->0 ){ leavesReaderDestroy(&pReaders[i]); } return rc; } *piReaders = i; while( i-- ){ leavesReaderReorder(pReaders+i, *piReaders-i); } return SQLITE_OK; } static int leavesReadersMerge(fulltext_vtab *v, LeavesReader *pReaders, int nReaders, LeafWriter *pWriter){ DLReader dlReaders[MERGE_COUNT]; const char *pTerm = leavesReaderTerm(pReaders); int i, nTerm = leavesReaderTermBytes(pReaders); assert( nReaders<=MERGE_COUNT ); for(i=0; i<nReaders; i++){ dlrInit(&dlReaders[i], DL_DEFAULT, leavesReaderData(pReaders+i), leavesReaderDataBytes(pReaders+i)); } return leafWriterStepMerge(v, pWriter, pTerm, nTerm, dlReaders, nReaders); } static int segmentMerge(fulltext_vtab *v, int iLevel); static int segdirNextIndex(fulltext_vtab *v, int iLevel, int *pidx){ int rc = segdir_max_index(v, iLevel, pidx); if( rc==SQLITE_DONE ){ *pidx = 0; }else if( rc==SQLITE_ROW ){ if( *pidx==(MERGE_COUNT-1) ){ rc = segmentMerge(v, iLevel); if( rc!=SQLITE_OK ) return rc; *pidx = 0; }else{ (*pidx)++; } }else{ return rc; } return SQLITE_OK; } static int segmentMerge(fulltext_vtab *v, int iLevel){ LeafWriter writer; LeavesReader lrs[MERGE_COUNT]; int i, rc, idx = 0; rc = segdirNextIndex(v, iLevel+1, &idx); if( rc!=SQLITE_OK ) return rc; memset(&lrs, '\0', sizeof(lrs)); rc = leavesReadersInit(v, iLevel, lrs, &i); if( rc!=SQLITE_OK ) return rc; assert( i==MERGE_COUNT ); leafWriterInit(iLevel+1, idx, &writer); while( !leavesReaderAtEnd(lrs) ){ for(i=1; i<MERGE_COUNT && !leavesReaderAtEnd(lrs+i); i++){ if( 0!=leavesReaderTermCmp(lrs, lrs+i) ) break; } rc = leavesReadersMerge(v, lrs, i, &writer); if( rc!=SQLITE_OK ) goto err; while( i-->0 ){ rc = leavesReaderStep(v, lrs+i); if( rc!=SQLITE_OK ) goto err; leavesReaderReorder(lrs+i, MERGE_COUNT-i); } } for(i=0; i<MERGE_COUNT; i++){ leavesReaderDestroy(&lrs[i]); } rc = leafWriterFinalize(v, &writer); leafWriterDestroy(&writer); if( rc!=SQLITE_OK ) return rc; return segdir_delete(v, iLevel); err: for(i=0; i<MERGE_COUNT; i++){ leavesReaderDestroy(&lrs[i]); } leafWriterDestroy(&writer); return rc; } static void docListAccumulateUnion(DataBuffer *acc, const char *pData, int nData) { DataBuffer tmp = *acc; dataBufferInit(acc, tmp.nData+nData); docListUnion(tmp.pData, tmp.nData, pData, nData, acc); dataBufferDestroy(&tmp); } static int loadSegmentLeavesInt(fulltext_vtab *v, LeavesReader *pReader, const char *pTerm, int nTerm, int isPrefix, DataBuffer *out){ DataBuffer *pBuffers = NULL; int nBuffers = 0, nMaxBuffers = 0, rc; assert( nTerm>0 ); for(rc=SQLITE_OK; rc==SQLITE_OK && !leavesReaderAtEnd(pReader); rc=leavesReaderStep(v, pReader)){ int c = leafReaderTermCmp(&pReader->leafReader, pTerm, nTerm, isPrefix); if( c>0 ) break; if( c==0 ){ const char *pData = leavesReaderData(pReader); int iBuffer, nData = leavesReaderDataBytes(pReader); for(iBuffer=0; iBuffer<nBuffers; ++iBuffer){ if( 0==pBuffers[iBuffer].nData ) break; } if( iBuffer==nBuffers ){ if( nBuffers==nMaxBuffers ){ DataBuffer *p; nMaxBuffers += 20; p = sqlite3_malloc(nMaxBuffers*sizeof(*pBuffers)); if( p==NULL ){ rc = SQLITE_NOMEM; break; } if( nBuffers>0 ){ assert(pBuffers!=NULL); memcpy(p, pBuffers, nBuffers*sizeof(*pBuffers)); sqlite3_free(pBuffers); } pBuffers = p; } dataBufferInit(&(pBuffers[nBuffers]), 0); nBuffers++; } assert(iBuffer<nBuffers && pBuffers[iBuffer].nData==0); if( iBuffer==0 ){ dataBufferReplace(&(pBuffers[0]), pData, nData); }else{ DataBuffer *pAcc = &(pBuffers[iBuffer]); DataBuffer *p = &(pBuffers[0]); dataBufferSwap(p, pAcc); docListAccumulateUnion(pAcc, pData, nData); for(++p; p<pAcc; ++p){ docListAccumulateUnion(pAcc, p->pData, p->nData); if( p->nCapacity<1024 ){ dataBufferReset(p); }else{ dataBufferDestroy(p); dataBufferInit(p, 0); } } } } } if( rc==SQLITE_OK && nBuffers>0 ){ int iBuffer; for(iBuffer=0; iBuffer<nBuffers; ++iBuffer){ if( pBuffers[iBuffer].nData>0 ){ if( out->nData==0 ){ dataBufferSwap(out, &(pBuffers[iBuffer])); }else{ docListAccumulateUnion(out, pBuffers[iBuffer].pData, pBuffers[iBuffer].nData); } } } } while( nBuffers-- ){ dataBufferDestroy(&(pBuffers[nBuffers])); } if( pBuffers!=NULL ) sqlite3_free(pBuffers); return rc; } static int loadSegmentLeaf(fulltext_vtab *v, const char *pData, int nData, const char *pTerm, int nTerm, int isPrefix, DataBuffer *out){ LeavesReader reader; int rc; assert( nData>1 ); assert( *pData=='\0' ); rc = leavesReaderInit(v, 0, 0, 0, pData, nData, &reader); if( rc!=SQLITE_OK ) return rc; rc = loadSegmentLeavesInt(v, &reader, pTerm, nTerm, isPrefix, out); leavesReaderReset(&reader); leavesReaderDestroy(&reader); return rc; } static int loadSegmentLeaves(fulltext_vtab *v, sqlite_int64 iStartLeaf, sqlite_int64 iEndLeaf, const char *pTerm, int nTerm, int isPrefix, DataBuffer *out){ int rc; LeavesReader reader; assert( iStartLeaf<=iEndLeaf ); rc = leavesReaderInit(v, 0, iStartLeaf, iEndLeaf, NULL, 0, &reader); if( rc!=SQLITE_OK ) return rc; rc = loadSegmentLeavesInt(v, &reader, pTerm, nTerm, isPrefix, out); leavesReaderReset(&reader); leavesReaderDestroy(&reader); return rc; } static void getChildrenContaining(const char *pData, int nData, const char *pTerm, int nTerm, int isPrefix, sqlite_int64 *piStartChild, sqlite_int64 *piEndChild){ InteriorReader reader; assert( nData>1 ); assert( *pData!='\0' ); interiorReaderInit(pData, nData, &reader); while( !interiorReaderAtEnd(&reader) ){ if( interiorReaderTermCmp(&reader, pTerm, nTerm, 0)>0 ) break; interiorReaderStep(&reader); } *piStartChild = interiorReaderCurrentBlockid(&reader); while( !interiorReaderAtEnd(&reader) ){ if( interiorReaderTermCmp(&reader, pTerm, nTerm, isPrefix)>0 ) break; interiorReaderStep(&reader); } *piEndChild = interiorReaderCurrentBlockid(&reader); interiorReaderDestroy(&reader); assert( *piEndChild>=*piStartChild ); assert( isPrefix || *piStartChild==*piEndChild ); } static int loadAndGetChildrenContaining( fulltext_vtab *v, sqlite_int64 iBlockid, const char *pTerm, int nTerm, int isPrefix, sqlite_int64 *piStartChild, sqlite_int64 *piEndChild ){ sqlite3_stmt *s = NULL; int rc; assert( iBlockid!=0 ); assert( pTerm!=NULL ); assert( nTerm!=0 ); assert( piStartChild!=NULL ); assert( piEndChild!=NULL ); rc = sql_get_statement(v, BLOCK_SELECT_STMT, &s); if( rc!=SQLITE_OK ) return rc; rc = sqlite3_bind_int64(s, 1, iBlockid); if( rc!=SQLITE_OK ) return rc; rc = sqlite3_step(s); if( rc==SQLITE_DONE ) return SQLITE_ERROR; if( rc!=SQLITE_ROW ) return rc; getChildrenContaining(sqlite3_column_blob(s, 0), sqlite3_column_bytes(s, 0), pTerm, nTerm, isPrefix, piStartChild, piEndChild); rc = sqlite3_step(s); if( rc==SQLITE_ROW ) return SQLITE_ERROR; if( rc!=SQLITE_DONE ) return rc; return SQLITE_OK; } static int loadSegmentInt(fulltext_vtab *v, const char *pData, int nData, sqlite_int64 iLeavesEnd, const char *pTerm, int nTerm, int isPrefix, DataBuffer *out){ if( *pData=='\0' ){ return loadSegmentLeaf(v, pData, nData, pTerm, nTerm, isPrefix, out); }else{ int rc; sqlite_int64 iStartChild, iEndChild; getChildrenContaining(pData, nData, pTerm, nTerm, isPrefix, &iStartChild, &iEndChild); while( iStartChild>iLeavesEnd ){ sqlite_int64 iNextStart, iNextEnd; rc = loadAndGetChildrenContaining(v, iStartChild, pTerm, nTerm, isPrefix, &iNextStart, &iNextEnd); if( rc!=SQLITE_OK ) return rc; if( iStartChild!=iEndChild ){ sqlite_int64 iDummy; rc = loadAndGetChildrenContaining(v, iEndChild, pTerm, nTerm, isPrefix, &iDummy, &iNextEnd); if( rc!=SQLITE_OK ) return rc; } assert( iNextStart<=iNextEnd ); iStartChild = iNextStart; iEndChild = iNextEnd; } assert( iStartChild<=iLeavesEnd ); assert( iEndChild<=iLeavesEnd ); return loadSegmentLeaves(v, iStartChild, iEndChild, pTerm, nTerm, isPrefix, out); } } static int loadSegment(fulltext_vtab *v, const char *pData, int nData, sqlite_int64 iLeavesEnd, const char *pTerm, int nTerm, int isPrefix, DataBuffer *out){ DataBuffer result; int rc; assert( nData>1 ); assert( v->nPendingData<0 ); dataBufferInit(&result, 0); rc = loadSegmentInt(v, pData, nData, iLeavesEnd, pTerm, nTerm, isPrefix, &result); if( rc==SQLITE_OK && result.nData>0 ){ if( out->nData==0 ){ DataBuffer tmp = *out; *out = result; result = tmp; }else{ DataBuffer merged; DLReader readers[2]; dlrInit(&readers[0], DL_DEFAULT, out->pData, out->nData); dlrInit(&readers[1], DL_DEFAULT, result.pData, result.nData); dataBufferInit(&merged, out->nData+result.nData); docListMerge(&merged, readers, 2); dataBufferDestroy(out); *out = merged; dlrDestroy(&readers[0]); dlrDestroy(&readers[1]); } } dataBufferDestroy(&result); return rc; } static int termSelect(fulltext_vtab *v, int iColumn, const char *pTerm, int nTerm, int isPrefix, DocListType iType, DataBuffer *out){ DataBuffer doclist; sqlite3_stmt *s; int rc = sql_get_statement(v, SEGDIR_SELECT_ALL_STMT, &s); if( rc!=SQLITE_OK ) return rc; assert( v->nPendingData<0 ); dataBufferInit(&doclist, 0); while( (rc = sqlite3_step(s))==SQLITE_ROW ){ const char *pData = sqlite3_column_blob(s, 2); const int nData = sqlite3_column_bytes(s, 2); const sqlite_int64 iLeavesEnd = sqlite3_column_int64(s, 1); rc = loadSegment(v, pData, nData, iLeavesEnd, pTerm, nTerm, isPrefix, &doclist); if( rc!=SQLITE_OK ) goto err; } if( rc==SQLITE_DONE ){ if( doclist.nData!=0 ){ if( iColumn==v->nColumn) iColumn = -1; docListTrim(DL_DEFAULT, doclist.pData, doclist.nData, iColumn, iType, out); } rc = SQLITE_OK; } err: dataBufferDestroy(&doclist); return rc; } typedef struct TermData { const char *pTerm; int nTerm; DLCollector *pCollector; } TermData; static int termDataCmp(const void *av, const void *bv){ const TermData *a = (const TermData *)av; const TermData *b = (const TermData *)bv; int n = a->nTerm<b->nTerm ? a->nTerm : b->nTerm; int c = memcmp(a->pTerm, b->pTerm, n); if( c!=0 ) return c; return a->nTerm-b->nTerm; } static int writeZeroSegment(fulltext_vtab *v, fts3Hash *pTerms){ fts3HashElem *e; int idx, rc, i, n; TermData *pData; LeafWriter writer; DataBuffer dl; rc = segdirNextIndex(v, 0, &idx); if( rc!=SQLITE_OK ) return rc; n = fts3HashCount(pTerms); pData = sqlite3_malloc(n*sizeof(TermData)); for(i = 0, e = fts3HashFirst(pTerms); e; i++, e = fts3HashNext(e)){ assert( i<n ); pData[i].pTerm = fts3HashKey(e); pData[i].nTerm = fts3HashKeysize(e); pData[i].pCollector = fts3HashData(e); } assert( i==n ); if( n>1 ) qsort(pData, n, sizeof(*pData), termDataCmp); leafWriterInit(0, idx, &writer); dataBufferInit(&dl, 0); for(i=0; i<n; i++){ dataBufferReset(&dl); dlcAddDoclist(pData[i].pCollector, &dl); rc = leafWriterStep(v, &writer, pData[i].pTerm, pData[i].nTerm, dl.pData, dl.nData); if( rc!=SQLITE_OK ) goto err; } rc = leafWriterFinalize(v, &writer); err: dataBufferDestroy(&dl); sqlite3_free(pData); leafWriterDestroy(&writer); return rc; } static int clearPendingTerms(fulltext_vtab *v){ if( v->nPendingData>=0 ){ fts3HashElem *e; for(e=fts3HashFirst(&v->pendingTerms); e; e=fts3HashNext(e)){ dlcDelete(fts3HashData(e)); } fts3HashClear(&v->pendingTerms); v->nPendingData = -1; } return SQLITE_OK; } static int flushPendingTerms(fulltext_vtab *v){ if( v->nPendingData>=0 ){ int rc = writeZeroSegment(v, &v->pendingTerms); if( rc==SQLITE_OK ) clearPendingTerms(v); return rc; } return SQLITE_OK; } static int initPendingTerms(fulltext_vtab *v, sqlite_int64 iDocid){ if( iDocid<=v->iPrevDocid || v->nPendingData>kPendingThreshold ){ int rc = flushPendingTerms(v); if( rc!=SQLITE_OK ) return rc; } if( v->nPendingData<0 ){ fts3HashInit(&v->pendingTerms, FTS3_HASH_STRING, 1); v->nPendingData = 0; } v->iPrevDocid = iDocid; return SQLITE_OK; } static int fulltextUpdate(sqlite3_vtab *pVtab, int nArg, sqlite3_value **ppArg, sqlite_int64 *pRowid){ fulltext_vtab *v = (fulltext_vtab *) pVtab; int rc; FTSTRACE(("FTS3 Update %p\n", pVtab)); if( nArg<2 ){ rc = index_delete(v, sqlite3_value_int64(ppArg[0])); if( rc==SQLITE_OK ){ rc = content_exists(v); if( rc==SQLITE_ROW ){ rc = SQLITE_OK; }else if( rc==SQLITE_DONE ){ rc = clearPendingTerms(v); if( rc==SQLITE_OK ){ rc = segdir_delete_all(v); } } } } else if( sqlite3_value_type(ppArg[0]) != SQLITE_NULL ){ sqlite_int64 rowid = sqlite3_value_int64(ppArg[0]); if( sqlite3_value_type(ppArg[1]) != SQLITE_INTEGER || sqlite3_value_int64(ppArg[1]) != rowid ){ rc = SQLITE_ERROR; }else if( sqlite3_value_type(ppArg[2+v->nColumn+1]) != SQLITE_INTEGER || sqlite3_value_int64(ppArg[2+v->nColumn+1]) != rowid ){ rc = SQLITE_ERROR; }else{ assert( nArg==2+v->nColumn+2); rc = index_update(v, rowid, &ppArg[2]); } } else { sqlite3_value *pRequestDocid = ppArg[2+v->nColumn+1]; assert( nArg==2+v->nColumn+2); if( SQLITE_NULL != sqlite3_value_type(pRequestDocid) && SQLITE_NULL != sqlite3_value_type(ppArg[1]) ){ rc = SQLITE_ERROR; }else{ if( SQLITE_NULL == sqlite3_value_type(pRequestDocid) ){ pRequestDocid = ppArg[1]; } rc = index_insert(v, pRequestDocid, &ppArg[2], pRowid); } } return rc; } static int fulltextSync(sqlite3_vtab *pVtab){ FTSTRACE(("FTS3 xSync()\n")); return flushPendingTerms((fulltext_vtab *)pVtab); } static int fulltextBegin(sqlite3_vtab *pVtab){ fulltext_vtab *v = (fulltext_vtab *) pVtab; FTSTRACE(("FTS3 xBegin()\n")); assert( v->nPendingData<0 ); return clearPendingTerms(v); } static int fulltextCommit(sqlite3_vtab *pVtab){ fulltext_vtab *v = (fulltext_vtab *) pVtab; FTSTRACE(("FTS3 xCommit()\n")); assert( v->nPendingData<0 ); return clearPendingTerms(v); } static int fulltextRollback(sqlite3_vtab *pVtab){ FTSTRACE(("FTS3 xRollback()\n")); return clearPendingTerms((fulltext_vtab *)pVtab); } static void snippetFunc( sqlite3_context *pContext, int argc, sqlite3_value **argv ){ fulltext_cursor *pCursor; if( argc<1 ) return; if( sqlite3_value_type(argv[0])!=SQLITE_BLOB || sqlite3_value_bytes(argv[0])!=sizeof(pCursor) ){ sqlite3_result_error(pContext, "illegal first argument to html_snippet",-1); }else{ const char *zStart = "<b>"; const char *zEnd = "</b>"; const char *zEllipsis = "<b>...</b>"; memcpy(&pCursor, sqlite3_value_blob(argv[0]), sizeof(pCursor)); if( argc>=2 ){ zStart = (const char*)sqlite3_value_text(argv[1]); if( argc>=3 ){ zEnd = (const char*)sqlite3_value_text(argv[2]); if( argc>=4 ){ zEllipsis = (const char*)sqlite3_value_text(argv[3]); } } } snippetAllOffsets(pCursor); snippetText(pCursor, zStart, zEnd, zEllipsis); sqlite3_result_text(pContext, pCursor->snippet.zSnippet, pCursor->snippet.nSnippet, SQLITE_STATIC); } } static void snippetOffsetsFunc( sqlite3_context *pContext, int argc, sqlite3_value **argv ){ fulltext_cursor *pCursor; if( argc<1 ) return; if( sqlite3_value_type(argv[0])!=SQLITE_BLOB || sqlite3_value_bytes(argv[0])!=sizeof(pCursor) ){ sqlite3_result_error(pContext, "illegal first argument to offsets",-1); }else{ memcpy(&pCursor, sqlite3_value_blob(argv[0]), sizeof(pCursor)); snippetAllOffsets(pCursor); snippetOffsetText(&pCursor->snippet); sqlite3_result_text(pContext, pCursor->snippet.zOffset, pCursor->snippet.nOffset, SQLITE_STATIC); } } typedef struct OptLeavesReader { int segment; LeavesReader reader; } OptLeavesReader; static int optLeavesReaderAtEnd(OptLeavesReader *pReader){ return leavesReaderAtEnd(&pReader->reader); } static int optLeavesReaderTermBytes(OptLeavesReader *pReader){ return leavesReaderTermBytes(&pReader->reader); } static const char *optLeavesReaderData(OptLeavesReader *pReader){ return leavesReaderData(&pReader->reader); } static int optLeavesReaderDataBytes(OptLeavesReader *pReader){ return leavesReaderDataBytes(&pReader->reader); } static const char *optLeavesReaderTerm(OptLeavesReader *pReader){ return leavesReaderTerm(&pReader->reader); } static int optLeavesReaderStep(fulltext_vtab *v, OptLeavesReader *pReader){ return leavesReaderStep(v, &pReader->reader); } static int optLeavesReaderTermCmp(OptLeavesReader *lr1, OptLeavesReader *lr2){ return leavesReaderTermCmp(&lr1->reader, &lr2->reader); } static int optLeavesReaderCmp(OptLeavesReader *lr1, OptLeavesReader *lr2){ int c = optLeavesReaderTermCmp(lr1, lr2); if( c!=0 ) return c; return lr1->segment-lr2->segment; } static void optLeavesReaderReorder(OptLeavesReader *pLr, int nLr){ while( nLr>1 && optLeavesReaderCmp(pLr, pLr+1)>0 ){ OptLeavesReader tmp = pLr[0]; pLr[0] = pLr[1]; pLr[1] = tmp; nLr--; pLr++; } } static int optimizeInternal(fulltext_vtab *v, OptLeavesReader *readers, int nReaders, LeafWriter *pWriter){ int i, rc = SQLITE_OK; DataBuffer doclist, merged, tmp; i = nReaders; while( i-- > 0 ){ optLeavesReaderReorder(&readers[i], nReaders-i); } dataBufferInit(&doclist, LEAF_MAX); dataBufferInit(&merged, LEAF_MAX); while( !optLeavesReaderAtEnd(&readers[0]) ){ for(i=1; i<nReaders && !optLeavesReaderAtEnd(&readers[i]); i++){ if( 0!=optLeavesReaderTermCmp(&readers[0], &readers[i]) ) break; } if( i==1 ){ dataBufferReset(&merged); docListTrim(DL_DEFAULT, optLeavesReaderData(&readers[0]), optLeavesReaderDataBytes(&readers[0]), -1, DL_DEFAULT, &merged); }else{ DLReader dlReaders[MERGE_COUNT]; int iReader, nReaders; dlrInit(&dlReaders[0], DL_DEFAULT, optLeavesReaderData(&readers[0]), optLeavesReaderDataBytes(&readers[0])); iReader = 1; assert( iReader<i ); while( iReader<i ){ for( nReaders=1; iReader<i && nReaders<MERGE_COUNT; iReader++, nReaders++ ){ dlrInit(&dlReaders[nReaders], DL_DEFAULT, optLeavesReaderData(&readers[iReader]), optLeavesReaderDataBytes(&readers[iReader])); } dataBufferReset(&merged); docListMerge(&merged, dlReaders, nReaders); tmp = merged; merged = doclist; doclist = tmp; while( nReaders-- > 0 ){ dlrDestroy(&dlReaders[nReaders]); } dlrInit(&dlReaders[0], DL_DEFAULT, doclist.pData, doclist.nData); } dlrDestroy(&dlReaders[0]); dataBufferReset(&merged); docListTrim(DL_DEFAULT, doclist.pData, doclist.nData, -1, DL_DEFAULT, &merged); } if( merged.nData>0 ){ rc = leafWriterStep(v, pWriter, optLeavesReaderTerm(&readers[0]), optLeavesReaderTermBytes(&readers[0]), merged.pData, merged.nData); if( rc!=SQLITE_OK ) goto err; } while( i-- > 0 ){ rc = optLeavesReaderStep(v, &readers[i]); if( rc!=SQLITE_OK ) goto err; optLeavesReaderReorder(&readers[i], nReaders-i); } } err: dataBufferDestroy(&doclist); dataBufferDestroy(&merged); return rc; } static void optimizeFunc(sqlite3_context *pContext, int argc, sqlite3_value **argv){ fulltext_cursor *pCursor; if( argc>1 ){ sqlite3_result_error(pContext, "excess arguments to optimize()",-1); }else if( sqlite3_value_type(argv[0])!=SQLITE_BLOB || sqlite3_value_bytes(argv[0])!=sizeof(pCursor) ){ sqlite3_result_error(pContext, "illegal first argument to optimize",-1); }else{ fulltext_vtab *v; int i, rc, iMaxLevel; OptLeavesReader *readers; int nReaders; LeafWriter writer; sqlite3_stmt *s; memcpy(&pCursor, sqlite3_value_blob(argv[0]), sizeof(pCursor)); v = cursor_vtab(pCursor); rc = flushPendingTerms(v); if( rc!=SQLITE_OK ) goto err; rc = segdir_count(v, &nReaders, &iMaxLevel); if( rc!=SQLITE_OK ) goto err; if( nReaders==0 || nReaders==1 ){ sqlite3_result_text(pContext, "Index already optimal", -1, SQLITE_STATIC); return; } rc = sql_get_statement(v, SEGDIR_SELECT_ALL_STMT, &s); if( rc!=SQLITE_OK ) goto err; readers = sqlite3_malloc(nReaders*sizeof(readers[0])); if( readers==NULL ) goto err; leafWriterInit(iMaxLevel, 0, &writer); i = 0; while( (rc = sqlite3_step(s))==SQLITE_ROW ){ sqlite_int64 iStart = sqlite3_column_int64(s, 0); sqlite_int64 iEnd = sqlite3_column_int64(s, 1); const char *pRootData = sqlite3_column_blob(s, 2); int nRootData = sqlite3_column_bytes(s, 2); assert( i<nReaders ); rc = leavesReaderInit(v, -1, iStart, iEnd, pRootData, nRootData, &readers[i].reader); if( rc!=SQLITE_OK ) break; readers[i].segment = i; i++; } if( rc==SQLITE_DONE ){ assert( i==nReaders ); rc = optimizeInternal(v, readers, nReaders, &writer); } while( i-- > 0 ){ leavesReaderDestroy(&readers[i].reader); } sqlite3_free(readers); if( rc==SQLITE_OK ){ for( i=0; i<=iMaxLevel; i++ ){ rc = segdir_delete(v, i); if( rc!=SQLITE_OK ) break; } if( rc==SQLITE_OK ) rc = leafWriterFinalize(v, &writer); } leafWriterDestroy(&writer); if( rc!=SQLITE_OK ) goto err; sqlite3_result_text(pContext, "Index optimized", -1, SQLITE_STATIC); return; err: { char buf[512]; sqlite3_snprintf(sizeof(buf), buf, "Error in optimize: %s", sqlite3_errmsg(sqlite3_context_db_handle(pContext))); sqlite3_result_error(pContext, buf, -1); } } } 
#ifdef SQLITE_TEST 
static void generateError(sqlite3_context *pContext, const char *prefix, const char *msg){ char buf[512]; if( msg==NULL ) msg = sqlite3_errmsg(sqlite3_context_db_handle(pContext)); sqlite3_snprintf(sizeof(buf), buf, "%s: %s", prefix, msg); sqlite3_result_error(pContext, buf, -1); } static int collectSegmentTerms(fulltext_vtab *v, sqlite3_stmt *s, fts3Hash *pTerms){ const sqlite_int64 iStartBlockid = sqlite3_column_int64(s, 0); const sqlite_int64 iEndBlockid = sqlite3_column_int64(s, 1); const char *pRootData = sqlite3_column_blob(s, 2); const int nRootData = sqlite3_column_bytes(s, 2); LeavesReader reader; int rc = leavesReaderInit(v, 0, iStartBlockid, iEndBlockid, pRootData, nRootData, &reader); if( rc!=SQLITE_OK ) return rc; while( rc==SQLITE_OK && !leavesReaderAtEnd(&reader) ){ const char *pTerm = leavesReaderTerm(&reader); const int nTerm = leavesReaderTermBytes(&reader); void *oldValue = sqlite3Fts3HashFind(pTerms, pTerm, nTerm); void *newValue = (void *)((char *)oldValue+1); if( newValue==sqlite3Fts3HashInsert(pTerms, pTerm, nTerm, newValue) ){ rc = SQLITE_NOMEM; }else{ rc = leavesReaderStep(v, &reader); } } leavesReaderDestroy(&reader); return rc; } static int generateTermsResult(sqlite3_context *pContext, fts3Hash *pTerms){ int iTerm, nTerms, nResultBytes, iByte; char *result; TermData *pData; fts3HashElem *e; nTerms = fts3HashCount(pTerms); assert( nTerms>0 ); pData = sqlite3_malloc(nTerms*sizeof(TermData)); if( pData==NULL ) return SQLITE_NOMEM; nResultBytes = 0; for(iTerm = 0, e = fts3HashFirst(pTerms); e; iTerm++, e = fts3HashNext(e)){ nResultBytes += fts3HashKeysize(e)+1; assert( iTerm<nTerms ); pData[iTerm].pTerm = fts3HashKey(e); pData[iTerm].nTerm = fts3HashKeysize(e); pData[iTerm].pCollector = fts3HashData(e); } assert( iTerm==nTerms ); assert( nResultBytes>0 ); result = sqlite3_malloc(nResultBytes); if( result==NULL ){ sqlite3_free(pData); return SQLITE_NOMEM; } if( nTerms>1 ) qsort(pData, nTerms, sizeof(*pData), termDataCmp); iByte = 0; for(iTerm=0; iTerm<nTerms; ++iTerm){ memcpy(result+iByte, pData[iTerm].pTerm, pData[iTerm].nTerm); iByte += pData[iTerm].nTerm; result[iByte++] = ' '; } assert( iByte==nResultBytes ); assert( result[nResultBytes-1]==' ' ); result[nResultBytes-1] = '\0'; sqlite3_result_text(pContext, result, nResultBytes-1, sqlite3_free); sqlite3_free(pData); return SQLITE_OK; } static void dumpTermsFunc( sqlite3_context *pContext, int argc, sqlite3_value **argv ){ fulltext_cursor *pCursor; if( argc!=3 && argc!=1 ){ generateError(pContext, "dump_terms", "incorrect arguments"); }else if( sqlite3_value_type(argv[0])!=SQLITE_BLOB || sqlite3_value_bytes(argv[0])!=sizeof(pCursor) ){ generateError(pContext, "dump_terms", "illegal first argument"); }else{ fulltext_vtab *v; fts3Hash terms; sqlite3_stmt *s = NULL; int rc; memcpy(&pCursor, sqlite3_value_blob(argv[0]), sizeof(pCursor)); v = cursor_vtab(pCursor); if( argc==1 ){ rc = sql_get_statement(v, SEGDIR_SELECT_ALL_STMT, &s); }else{ rc = sql_get_statement(v, SEGDIR_SELECT_SEGMENT_STMT, &s); if( rc==SQLITE_OK ){ rc = sqlite3_bind_int(s, 1, sqlite3_value_int(argv[1])); if( rc==SQLITE_OK ){ rc = sqlite3_bind_int(s, 2, sqlite3_value_int(argv[2])); } } } if( rc!=SQLITE_OK ){ generateError(pContext, "dump_terms", NULL); return; } sqlite3Fts3HashInit(&terms, FTS3_HASH_STRING, 1); while( (rc = sqlite3_step(s))==SQLITE_ROW ){ rc = collectSegmentTerms(v, s, &terms); if( rc!=SQLITE_OK ) break; } if( rc!=SQLITE_DONE ){ sqlite3_reset(s); generateError(pContext, "dump_terms", NULL); }else{ const int nTerms = fts3HashCount(&terms); if( nTerms>0 ){ rc = generateTermsResult(pContext, &terms); if( rc==SQLITE_NOMEM ){ generateError(pContext, "dump_terms", "out of memory"); }else{ assert( rc==SQLITE_OK ); } }else if( argc==3 ){ generateError(pContext, "dump_terms", "segment not found"); }else{ sqlite3_result_null(pContext); } } sqlite3Fts3HashClear(&terms); } } static void createDoclistResult(sqlite3_context *pContext, const char *pData, int nData){ DataBuffer dump; DLReader dlReader; assert( pData!=NULL && nData>0 ); dataBufferInit(&dump, 0); dlrInit(&dlReader, DL_DEFAULT, pData, nData); for( ; !dlrAtEnd(&dlReader); dlrStep(&dlReader) ){ char buf[256]; PLReader plReader; plrInit(&plReader, &dlReader); if( DL_DEFAULT==DL_DOCIDS || plrAtEnd(&plReader) ){ sqlite3_snprintf(sizeof(buf), buf, "[%lld] ", dlrDocid(&dlReader)); dataBufferAppend(&dump, buf, strlen(buf)); }else{ int iColumn = plrColumn(&plReader); sqlite3_snprintf(sizeof(buf), buf, "[%lld %d[", dlrDocid(&dlReader), iColumn); dataBufferAppend(&dump, buf, strlen(buf)); for( ; !plrAtEnd(&plReader); plrStep(&plReader) ){ if( plrColumn(&plReader)!=iColumn ){ iColumn = plrColumn(&plReader); sqlite3_snprintf(sizeof(buf), buf, "] %d[", iColumn); assert( dump.nData>0 ); dump.nData--; assert( dump.pData[dump.nData]==' '); dataBufferAppend(&dump, buf, strlen(buf)); } if( DL_DEFAULT==DL_POSITIONS_OFFSETS ){ sqlite3_snprintf(sizeof(buf), buf, "%d,%d,%d ", plrPosition(&plReader), plrStartOffset(&plReader), plrEndOffset(&plReader)); }else if( DL_DEFAULT==DL_POSITIONS ){ sqlite3_snprintf(sizeof(buf), buf, "%d ", plrPosition(&plReader)); }else{ assert( NULL=="Unhandled DL_DEFAULT value"); } dataBufferAppend(&dump, buf, strlen(buf)); } plrDestroy(&plReader); assert( dump.nData>0 ); dump.nData--; assert( dump.pData[dump.nData]==' '); dataBufferAppend(&dump, "]] ", 3); } } dlrDestroy(&dlReader); assert( dump.nData>0 ); dump.nData--; assert( dump.pData[dump.nData]==' '); dump.pData[dump.nData] = '\0'; assert( dump.nData>0 ); sqlite3_result_text(pContext, dump.pData, dump.nData, sqlite3_free); dump.pData = NULL; dump.nData = dump.nCapacity = 0; } static void dumpDoclistFunc( sqlite3_context *pContext, int argc, sqlite3_value **argv ){ fulltext_cursor *pCursor; if( argc!=2 && argc!=4 ){ generateError(pContext, "dump_doclist", "incorrect arguments"); }else if( sqlite3_value_type(argv[0])!=SQLITE_BLOB || sqlite3_value_bytes(argv[0])!=sizeof(pCursor) ){ generateError(pContext, "dump_doclist", "illegal first argument"); }else if( sqlite3_value_text(argv[1])==NULL || sqlite3_value_text(argv[1])[0]=='\0' ){ generateError(pContext, "dump_doclist", "empty second argument"); }else{ const char *pTerm = (const char *)sqlite3_value_text(argv[1]); const int nTerm = strlen(pTerm); fulltext_vtab *v; int rc; DataBuffer doclist; memcpy(&pCursor, sqlite3_value_blob(argv[0]), sizeof(pCursor)); v = cursor_vtab(pCursor); dataBufferInit(&doclist, 0); if( argc==2 ){ rc = termSelect(v, v->nColumn, pTerm, nTerm, 0, DL_DEFAULT, &doclist); }else{ sqlite3_stmt *s = NULL; rc = sql_get_statement(v, SEGDIR_SELECT_SEGMENT_STMT, &s); if( rc==SQLITE_OK ){ rc = sqlite3_bind_int(s, 1, sqlite3_value_int(argv[2])); if( rc==SQLITE_OK ){ rc = sqlite3_bind_int(s, 2, sqlite3_value_int(argv[3])); } } if( rc==SQLITE_OK ){ rc = sqlite3_step(s); if( rc==SQLITE_DONE ){ dataBufferDestroy(&doclist); generateError(pContext, "dump_doclist", "segment not found"); return; } if( rc==SQLITE_ROW ){ const sqlite_int64 iLeavesEnd = sqlite3_column_int64(s, 1); const char *pData = sqlite3_column_blob(s, 2); const int nData = sqlite3_column_bytes(s, 2); rc = loadSegment(v, pData, nData, iLeavesEnd, pTerm, nTerm, 0, &doclist); if( rc==SQLITE_OK ){ rc = sqlite3_step(s); if( rc!=SQLITE_DONE ){ sqlite3_reset(s); dataBufferDestroy(&doclist); generateError(pContext, "dump_doclist", "invalid segdir"); return; } rc = SQLITE_OK; } } } sqlite3_reset(s); } if( rc==SQLITE_OK ){ if( doclist.nData>0 ){ createDoclistResult(pContext, doclist.pData, doclist.nData); }else{ sqlite3_result_text(pContext, "", 0, SQLITE_STATIC); } }else if( rc==SQLITE_NOMEM ){ generateError(pContext, "dump_doclist", "out of memory"); }else{ generateError(pContext, "dump_doclist", NULL); } dataBufferDestroy(&doclist); } } 
#endif 
static int fulltextFindFunction( sqlite3_vtab *pVtab, int nArg, const char *zName, void (**pxFunc)(sqlite3_context*,int,sqlite3_value**), void **ppArg ){ if( strcmp(zName,"snippet")==0 ){ *pxFunc = snippetFunc; return 1; }else if( strcmp(zName,"offsets")==0 ){ *pxFunc = snippetOffsetsFunc; return 1; }else if( strcmp(zName,"optimize")==0 ){ *pxFunc = optimizeFunc; return 1; 
#ifdef SQLITE_TEST 
 }else if( strcmp(zName,"dump_terms")==0 ){ *pxFunc = dumpTermsFunc; return 1; }else if( strcmp(zName,"dump_doclist")==0 ){ *pxFunc = dumpDoclistFunc; return 1; 
#endif 
 } return 0; } static int fulltextRename( sqlite3_vtab *pVtab, const char *zName ){ fulltext_vtab *p = (fulltext_vtab *)pVtab; int rc = SQLITE_NOMEM; char *zSql = sqlite3_mprintf( "ALTER TABLE %Q.'%q_content' RENAME TO '%q_content';" "ALTER TABLE %Q.'%q_segments' RENAME TO '%q_segments';" "ALTER TABLE %Q.'%q_segdir' RENAME TO '%q_segdir';" , p->zDb, p->zName, zName , p->zDb, p->zName, zName , p->zDb, p->zName, zName ); if( zSql ){ rc = sqlite3_exec(p->db, zSql, 0, 0, 0); sqlite3_free(zSql); } return rc; } static const sqlite3_module fts3Module = { 0, fulltextCreate, fulltextConnect, fulltextBestIndex, fulltextDisconnect, fulltextDestroy, fulltextOpen, fulltextClose, fulltextFilter, fulltextNext, fulltextEof, fulltextColumn, fulltextRowid, fulltextUpdate, fulltextBegin, fulltextSync, fulltextCommit, fulltextRollback, fulltextFindFunction, fulltextRename, }; static void hashDestroy(void *p){ fts3Hash *pHash = (fts3Hash *)p; sqlite3Fts3HashClear(pHash); sqlite3_free(pHash); } SQLITE_PRIVATE void sqlite3Fts3SimpleTokenizerModule(sqlite3_tokenizer_module const**ppModule); SQLITE_PRIVATE void sqlite3Fts3PorterTokenizerModule(sqlite3_tokenizer_module const**ppModule); SQLITE_PRIVATE void sqlite3Fts3IcuTokenizerModule(sqlite3_tokenizer_module const**ppModule); SQLITE_PRIVATE int sqlite3Fts3InitHashTable(sqlite3 *, fts3Hash *, const char *); SQLITE_PRIVATE int sqlite3Fts3Init(sqlite3 *db){ int rc = SQLITE_OK; fts3Hash *pHash = 0; const sqlite3_tokenizer_module *pSimple = 0; const sqlite3_tokenizer_module *pPorter = 0; const sqlite3_tokenizer_module *pIcu = 0; sqlite3Fts3SimpleTokenizerModule(&pSimple); sqlite3Fts3PorterTokenizerModule(&pPorter); 
#ifdef SQLITE_ENABLE_ICU 
 sqlite3Fts3IcuTokenizerModule(&pIcu); 
#endif 
 pHash = sqlite3_malloc(sizeof(fts3Hash)); if( !pHash ){ rc = SQLITE_NOMEM; }else{ sqlite3Fts3HashInit(pHash, FTS3_HASH_STRING, 1); } if( rc==SQLITE_OK ){ if( sqlite3Fts3HashInsert(pHash, "simple", 7, (void *)pSimple) || sqlite3Fts3HashInsert(pHash, "porter", 7, (void *)pPorter) || (pIcu && sqlite3Fts3HashInsert(pHash, "icu", 4, (void *)pIcu)) ){ rc = SQLITE_NOMEM; } } if( SQLITE_OK==rc && SQLITE_OK==(rc = sqlite3Fts3InitHashTable(db, pHash, "fts3_tokenizer")) && SQLITE_OK==(rc = sqlite3_overload_function(db, "snippet", -1)) && SQLITE_OK==(rc = sqlite3_overload_function(db, "offsets", -1)) && SQLITE_OK==(rc = sqlite3_overload_function(db, "optimize", -1)) 
#ifdef SQLITE_TEST 
 && SQLITE_OK==(rc = sqlite3_overload_function(db, "dump_terms", -1)) && SQLITE_OK==(rc = sqlite3_overload_function(db, "dump_doclist", -1)) 
#endif 
 ){ return sqlite3_create_module_v2( db, "fts3", &fts3Module, (void *)pHash, hashDestroy ); } assert( rc!=SQLITE_OK ); if( pHash ){ sqlite3Fts3HashClear(pHash); sqlite3_free(pHash); } return rc; } 
#if !SQLITE_CORE 
SQLITE_API int sqlite3_extension_init( sqlite3 *db, char **pzErrMsg, const sqlite3_api_routines *pApi ){ SQLITE_EXTENSION_INIT2(pApi) return sqlite3Fts3Init(db); } 
#endif 
#endif 
#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3) 
static void *fts3HashMalloc(int n){ void *p = sqlite3_malloc(n); if( p ){ memset(p, 0, n); } return p; } static void fts3HashFree(void *p){ sqlite3_free(p); } SQLITE_PRIVATE void sqlite3Fts3HashInit(fts3Hash *pNew, int keyClass, int copyKey){ assert( pNew!=0 ); assert( keyClass>=FTS3_HASH_STRING && keyClass<=FTS3_HASH_BINARY ); pNew->keyClass = keyClass; pNew->copyKey = copyKey; pNew->first = 0; pNew->count = 0; pNew->htsize = 0; pNew->ht = 0; } SQLITE_PRIVATE void sqlite3Fts3HashClear(fts3Hash *pH){ fts3HashElem *elem; assert( pH!=0 ); elem = pH->first; pH->first = 0; fts3HashFree(pH->ht); pH->ht = 0; pH->htsize = 0; while( elem ){ fts3HashElem *next_elem = elem->next; if( pH->copyKey && elem->pKey ){ fts3HashFree(elem->pKey); } fts3HashFree(elem); elem = next_elem; } pH->count = 0; } static int fts3StrHash(const void *pKey, int nKey){ const char *z = (const char *)pKey; int h = 0; if( nKey<=0 ) nKey = (int) strlen(z); while( nKey > 0 ){ h = (h<<3) ^ h ^ *z++; nKey--; } return h & 0x7fffffff; } static int fts3StrCompare(const void *pKey1, int n1, const void *pKey2, int n2){ if( n1!=n2 ) return 1; return strncmp((const char*)pKey1,(const char*)pKey2,n1); } static int fts3BinHash(const void *pKey, int nKey){ int h = 0; const char *z = (const char *)pKey; while( nKey-- > 0 ){ h = (h<<3) ^ h ^ *(z++); } return h & 0x7fffffff; } static int fts3BinCompare(const void *pKey1, int n1, const void *pKey2, int n2){ if( n1!=n2 ) return 1; return memcmp(pKey1,pKey2,n1); } static int (*ftsHashFunction(int keyClass))(const void*,int){ if( keyClass==FTS3_HASH_STRING ){ return &fts3StrHash; }else{ assert( keyClass==FTS3_HASH_BINARY ); return &fts3BinHash; } } static int (*ftsCompareFunction(int keyClass))(const void*,int,const void*,int){ if( keyClass==FTS3_HASH_STRING ){ return &fts3StrCompare; }else{ assert( keyClass==FTS3_HASH_BINARY ); return &fts3BinCompare; } } static void fts3HashInsertElement( fts3Hash *pH, struct _fts3ht *pEntry, fts3HashElem *pNew ){ fts3HashElem *pHead; pHead = pEntry->chain; if( pHead ){ pNew->next = pHead; pNew->prev = pHead->prev; if( pHead->prev ){ pHead->prev->next = pNew; } else { pH->first = pNew; } pHead->prev = pNew; }else{ pNew->next = pH->first; if( pH->first ){ pH->first->prev = pNew; } pNew->prev = 0; pH->first = pNew; } pEntry->count++; pEntry->chain = pNew; } static void fts3Rehash(fts3Hash *pH, int new_size){ struct _fts3ht *new_ht; fts3HashElem *elem, *next_elem; int (*xHash)(const void*,int); assert( (new_size & (new_size-1))==0 ); new_ht = (struct _fts3ht *)fts3HashMalloc( new_size*sizeof(struct _fts3ht) ); if( new_ht==0 ) return; fts3HashFree(pH->ht); pH->ht = new_ht; pH->htsize = new_size; xHash = ftsHashFunction(pH->keyClass); for(elem=pH->first, pH->first=0; elem; elem = next_elem){ int h = (*xHash)(elem->pKey, elem->nKey) & (new_size-1); next_elem = elem->next; fts3HashInsertElement(pH, &new_ht[h], elem); } } static fts3HashElem *fts3FindElementByHash( const fts3Hash *pH, const void *pKey, int nKey, int h ){ fts3HashElem *elem; int count; int (*xCompare)(const void*,int,const void*,int); if( pH->ht ){ struct _fts3ht *pEntry = &pH->ht[h]; elem = pEntry->chain; count = pEntry->count; xCompare = ftsCompareFunction(pH->keyClass); while( count-- && elem ){ if( (*xCompare)(elem->pKey,elem->nKey,pKey,nKey)==0 ){ return elem; } elem = elem->next; } } return 0; } static void fts3RemoveElementByHash( fts3Hash *pH, fts3HashElem* elem, int h ){ struct _fts3ht *pEntry; if( elem->prev ){ elem->prev->next = elem->next; }else{ pH->first = elem->next; } if( elem->next ){ elem->next->prev = elem->prev; } pEntry = &pH->ht[h]; if( pEntry->chain==elem ){ pEntry->chain = elem->next; } pEntry->count--; if( pEntry->count<=0 ){ pEntry->chain = 0; } if( pH->copyKey && elem->pKey ){ fts3HashFree(elem->pKey); } fts3HashFree( elem ); pH->count--; if( pH->count<=0 ){ assert( pH->first==0 ); assert( pH->count==0 ); fts3HashClear(pH); } } SQLITE_PRIVATE void *sqlite3Fts3HashFind(const fts3Hash *pH, const void *pKey, int nKey){ int h; fts3HashElem *elem; int (*xHash)(const void*,int); if( pH==0 || pH->ht==0 ) return 0; xHash = ftsHashFunction(pH->keyClass); assert( xHash!=0 ); h = (*xHash)(pKey,nKey); assert( (pH->htsize & (pH->htsize-1))==0 ); elem = fts3FindElementByHash(pH,pKey,nKey, h & (pH->htsize-1)); return elem ? elem->data : 0; } SQLITE_PRIVATE void *sqlite3Fts3HashInsert( fts3Hash *pH, const void *pKey, int nKey, void *data ){ int hraw; int h; fts3HashElem *elem; fts3HashElem *new_elem; int (*xHash)(const void*,int); assert( pH!=0 ); xHash = ftsHashFunction(pH->keyClass); assert( xHash!=0 ); hraw = (*xHash)(pKey, nKey); assert( (pH->htsize & (pH->htsize-1))==0 ); h = hraw & (pH->htsize-1); elem = fts3FindElementByHash(pH,pKey,nKey,h); if( elem ){ void *old_data = elem->data; if( data==0 ){ fts3RemoveElementByHash(pH,elem,h); }else{ elem->data = data; } return old_data; } if( data==0 ) return 0; if( pH->htsize==0 ){ fts3Rehash(pH,8); if( pH->htsize==0 ){ pH->count = 0; return data; } } new_elem = (fts3HashElem*)fts3HashMalloc( sizeof(fts3HashElem) ); if( new_elem==0 ) return data; if( pH->copyKey && pKey!=0 ){ new_elem->pKey = fts3HashMalloc( nKey ); if( new_elem->pKey==0 ){ fts3HashFree(new_elem); return data; } memcpy((void*)new_elem->pKey, pKey, nKey); }else{ new_elem->pKey = (void*)pKey; } new_elem->nKey = nKey; pH->count++; if( pH->count > pH->htsize ){ fts3Rehash(pH,pH->htsize*2); } assert( pH->htsize>0 ); assert( (pH->htsize & (pH->htsize-1))==0 ); h = hraw & (pH->htsize-1); fts3HashInsertElement(pH, &pH->ht[h], new_elem); new_elem->data = data; return 0; } 
#endif 
#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3) 
typedef struct porter_tokenizer { sqlite3_tokenizer base; } porter_tokenizer; typedef struct porter_tokenizer_cursor { sqlite3_tokenizer_cursor base; const char *zInput; int nInput; int iOffset; int iToken; char *zToken; int nAllocated; } porter_tokenizer_cursor; static const sqlite3_tokenizer_module porterTokenizerModule; static int porterCreate( int argc, const char * const *argv, sqlite3_tokenizer **ppTokenizer ){ porter_tokenizer *t; t = (porter_tokenizer *) sqlite3_malloc(sizeof(*t)); if( t==NULL ) return SQLITE_NOMEM; memset(t, 0, sizeof(*t)); *ppTokenizer = &t->base; return SQLITE_OK; } static int porterDestroy(sqlite3_tokenizer *pTokenizer){ sqlite3_free(pTokenizer); return SQLITE_OK; } static int porterOpen( sqlite3_tokenizer *pTokenizer, const char *zInput, int nInput, sqlite3_tokenizer_cursor **ppCursor ){ porter_tokenizer_cursor *c; c = (porter_tokenizer_cursor *) sqlite3_malloc(sizeof(*c)); if( c==NULL ) return SQLITE_NOMEM; c->zInput = zInput; if( zInput==0 ){ c->nInput = 0; }else if( nInput<0 ){ c->nInput = (int)strlen(zInput); }else{ c->nInput = nInput; } c->iOffset = 0; c->iToken = 0; c->zToken = NULL; c->nAllocated = 0; *ppCursor = &c->base; return SQLITE_OK; } static int porterClose(sqlite3_tokenizer_cursor *pCursor){ porter_tokenizer_cursor *c = (porter_tokenizer_cursor *) pCursor; sqlite3_free(c->zToken); sqlite3_free(c); return SQLITE_OK; } static const char cType[] = { 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 2, 1 }; static int isVowel(const char*); static int isConsonant(const char *z){ int j; char x = *z; if( x==0 ) return 0; assert( x>='a' && x<='z' ); j = cType[x-'a']; if( j<2 ) return j; return z[1]==0 || isVowel(z + 1); } static int isVowel(const char *z){ int j; char x = *z; if( x==0 ) return 0; assert( x>='a' && x<='z' ); j = cType[x-'a']; if( j<2 ) return 1-j; return isConsonant(z + 1); } static int m_gt_0(const char *z){ while( isVowel(z) ){ z++; } if( *z==0 ) return 0; while( isConsonant(z) ){ z++; } return *z!=0; } static int m_eq_1(const char *z){ while( isVowel(z) ){ z++; } if( *z==0 ) return 0; while( isConsonant(z) ){ z++; } if( *z==0 ) return 0; while( isVowel(z) ){ z++; } if( *z==0 ) return 1; while( isConsonant(z) ){ z++; } return *z==0; } static int m_gt_1(const char *z){ while( isVowel(z) ){ z++; } if( *z==0 ) return 0; while( isConsonant(z) ){ z++; } if( *z==0 ) return 0; while( isVowel(z) ){ z++; } if( *z==0 ) return 0; while( isConsonant(z) ){ z++; } return *z!=0; } static int hasVowel(const char *z){ while( isConsonant(z) ){ z++; } return *z!=0; } static int doubleConsonant(const char *z){ return isConsonant(z) && z[0]==z[1] && isConsonant(z+1); } static int star_oh(const char *z){ return z[0]!=0 && isConsonant(z) && z[0]!='w' && z[0]!='x' && z[0]!='y' && z[1]!=0 && isVowel(z+1) && z[2]!=0 && isConsonant(z+2); } static int stem( char **pz, const char *zFrom, const char *zTo, int (*xCond)(const char*) ){ char *z = *pz; while( *zFrom && *zFrom==*z ){ z++; zFrom++; } if( *zFrom!=0 ) return 0; if( xCond && !xCond(z) ) return 1; while( *zTo ){ *(--z) = *(zTo++); } *pz = z; return 1; } static void copy_stemmer(const char *zIn, int nIn, char *zOut, int *pnOut){ int i, mx, j; int hasDigit = 0; for(i=0; i<nIn; i++){ int c = zIn[i]; if( c>='A' && c<='Z' ){ zOut[i] = c - 'A' + 'a'; }else{ if( c>='0' && c<='9' ) hasDigit = 1; zOut[i] = c; } } mx = hasDigit ? 3 : 10; if( nIn>mx*2 ){ for(j=mx, i=nIn-mx; i<nIn; i++, j++){ zOut[j] = zOut[i]; } i = j; } zOut[i] = 0; *pnOut = i; } static void porter_stemmer(const char *zIn, int nIn, char *zOut, int *pnOut){ int i, j, c; char zReverse[28]; char *z, *z2; if( nIn<3 || nIn>=sizeof(zReverse)-7 ){ copy_stemmer(zIn, nIn, zOut, pnOut); return; } for(i=0, j=sizeof(zReverse)-6; i<nIn; i++, j--){ c = zIn[i]; if( c>='A' && c<='Z' ){ zReverse[j] = c + 'a' - 'A'; }else if( c>='a' && c<='z' ){ zReverse[j] = c; }else{ copy_stemmer(zIn, nIn, zOut, pnOut); return; } } memset(&zReverse[sizeof(zReverse)-5], 0, 5); z = &zReverse[j+1]; if( z[0]=='s' ){ if( !stem(&z, "sess", "ss", 0) && !stem(&z, "sei", "i", 0) && !stem(&z, "ss", "ss", 0) ){ z++; } } z2 = z; if( stem(&z, "dee", "ee", m_gt_0) ){ }else if( (stem(&z, "gni", "", hasVowel) || stem(&z, "de", "", hasVowel)) && z!=z2 ){ if( stem(&z, "ta", "ate", 0) || stem(&z, "lb", "ble", 0) || stem(&z, "zi", "ize", 0) ){ }else if( doubleConsonant(z) && (*z!='l' && *z!='s' && *z!='z') ){ z++; }else if( m_eq_1(z) && star_oh(z) ){ *(--z) = 'e'; } } if( z[0]=='y' && hasVowel(z+1) ){ z[0] = 'i'; } switch( z[1] ){ case 'a': stem(&z, "lanoita", "ate", m_gt_0) || stem(&z, "lanoit", "tion", m_gt_0); break; case 'c': stem(&z, "icne", "ence", m_gt_0) || stem(&z, "icna", "ance", m_gt_0); break; case 'e': stem(&z, "rezi", "ize", m_gt_0); break; case 'g': stem(&z, "igol", "log", m_gt_0); break; case 'l': stem(&z, "ilb", "ble", m_gt_0) || stem(&z, "illa", "al", m_gt_0) || stem(&z, "iltne", "ent", m_gt_0) || stem(&z, "ile", "e", m_gt_0) || stem(&z, "ilsuo", "ous", m_gt_0); break; case 'o': stem(&z, "noitazi", "ize", m_gt_0) || stem(&z, "noita", "ate", m_gt_0) || stem(&z, "rota", "ate", m_gt_0); break; case 's': stem(&z, "msila", "al", m_gt_0) || stem(&z, "ssenevi", "ive", m_gt_0) || stem(&z, "ssenluf", "ful", m_gt_0) || stem(&z, "ssensuo", "ous", m_gt_0); break; case 't': stem(&z, "itila", "al", m_gt_0) || stem(&z, "itivi", "ive", m_gt_0) || stem(&z, "itilib", "ble", m_gt_0); break; } switch( z[0] ){ case 'e': stem(&z, "etaci", "ic", m_gt_0) || stem(&z, "evita", "", m_gt_0) || stem(&z, "ezila", "al", m_gt_0); break; case 'i': stem(&z, "itici", "ic", m_gt_0); break; case 'l': stem(&z, "laci", "ic", m_gt_0) || stem(&z, "luf", "", m_gt_0); break; case 's': stem(&z, "ssen", "", m_gt_0); break; } switch( z[1] ){ case 'a': if( z[0]=='l' && m_gt_1(z+2) ){ z += 2; } break; case 'c': if( z[0]=='e' && z[2]=='n' && (z[3]=='a' || z[3]=='e') && m_gt_1(z+4) ){ z += 4; } break; case 'e': if( z[0]=='r' && m_gt_1(z+2) ){ z += 2; } break; case 'i': if( z[0]=='c' && m_gt_1(z+2) ){ z += 2; } break; case 'l': if( z[0]=='e' && z[2]=='b' && (z[3]=='a' || z[3]=='i') && m_gt_1(z+4) ){ z += 4; } break; case 'n': if( z[0]=='t' ){ if( z[2]=='a' ){ if( m_gt_1(z+3) ){ z += 3; } }else if( z[2]=='e' ){ stem(&z, "tneme", "", m_gt_1) || stem(&z, "tnem", "", m_gt_1) || stem(&z, "tne", "", m_gt_1); } } break; case 'o': if( z[0]=='u' ){ if( m_gt_1(z+2) ){ z += 2; } }else if( z[3]=='s' || z[3]=='t' ){ stem(&z, "noi", "", m_gt_1); } break; case 's': if( z[0]=='m' && z[2]=='i' && m_gt_1(z+3) ){ z += 3; } break; case 't': stem(&z, "eta", "", m_gt_1) || stem(&z, "iti", "", m_gt_1); break; case 'u': if( z[0]=='s' && z[2]=='o' && m_gt_1(z+3) ){ z += 3; } break; case 'v': case 'z': if( z[0]=='e' && z[2]=='i' && m_gt_1(z+3) ){ z += 3; } break; } if( z[0]=='e' ){ if( m_gt_1(z+1) ){ z++; }else if( m_eq_1(z+1) && !star_oh(z+1) ){ z++; } } if( m_gt_1(z) && z[0]=='l' && z[1]=='l' ){ z++; } *pnOut = i = strlen(z); zOut[i] = 0; while( *z ){ zOut[--i] = *(z++); } } static const char porterIdChar[] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, }; 
#define isDelim(C) (((ch=C)&0x80)==0 && (ch<0x30 || !porterIdChar[ch-0x30])) 
static int porterNext( sqlite3_tokenizer_cursor *pCursor, const char **pzToken, int *pnBytes, int *piStartOffset, int *piEndOffset, int *piPosition ){ porter_tokenizer_cursor *c = (porter_tokenizer_cursor *) pCursor; const char *z = c->zInput; while( c->iOffset<c->nInput ){ int iStartOffset, ch; while( c->iOffset<c->nInput && isDelim(z[c->iOffset]) ){ c->iOffset++; } iStartOffset = c->iOffset; while( c->iOffset<c->nInput && !isDelim(z[c->iOffset]) ){ c->iOffset++; } if( c->iOffset>iStartOffset ){ int n = c->iOffset-iStartOffset; if( n>c->nAllocated ){ c->nAllocated = n+20; c->zToken = sqlite3_realloc(c->zToken, c->nAllocated); if( c->zToken==NULL ) return SQLITE_NOMEM; } porter_stemmer(&z[iStartOffset], n, c->zToken, pnBytes); *pzToken = c->zToken; *piStartOffset = iStartOffset; *piEndOffset = c->iOffset; *piPosition = c->iToken++; return SQLITE_OK; } } return SQLITE_DONE; } static const sqlite3_tokenizer_module porterTokenizerModule = { 0, porterCreate, porterDestroy, porterOpen, porterClose, porterNext, }; SQLITE_PRIVATE void sqlite3Fts3PorterTokenizerModule( sqlite3_tokenizer_module const**ppModule ){ *ppModule = &porterTokenizerModule; } 
#endif 
#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3) 
#ifndef SQLITE_CORE 
 SQLITE_EXTENSION_INIT1 
#endif 
static void scalarFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){ fts3Hash *pHash; void *pPtr = 0; const unsigned char *zName; int nName; assert( argc==1 || argc==2 ); pHash = (fts3Hash *)sqlite3_user_data(context); zName = sqlite3_value_text(argv[0]); nName = sqlite3_value_bytes(argv[0])+1; if( argc==2 ){ void *pOld; int n = sqlite3_value_bytes(argv[1]); if( n!=sizeof(pPtr) ){ sqlite3_result_error(context, "argument type mismatch", -1); return; } pPtr = *(void **)sqlite3_value_blob(argv[1]); pOld = sqlite3Fts3HashInsert(pHash, (void *)zName, nName, pPtr); if( pOld==pPtr ){ sqlite3_result_error(context, "out of memory", -1); return; } }else{ pPtr = sqlite3Fts3HashFind(pHash, zName, nName); if( !pPtr ){ char *zErr = sqlite3_mprintf("unknown tokenizer: %s", zName); sqlite3_result_error(context, zErr, -1); sqlite3_free(zErr); return; } } sqlite3_result_blob(context, (void *)&pPtr, sizeof(pPtr), SQLITE_TRANSIENT); } 
#ifdef SQLITE_TEST 
static void testFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){ fts3Hash *pHash; sqlite3_tokenizer_module *p; sqlite3_tokenizer *pTokenizer = 0; sqlite3_tokenizer_cursor *pCsr = 0; const char *zErr = 0; const char *zName; int nName; const char *zInput; int nInput; const char *zArg = 0; const char *zToken; int nToken; int iStart; int iEnd; int iPos; Tcl_Obj *pRet; assert( argc==2 || argc==3 ); nName = sqlite3_value_bytes(argv[0]); zName = (const char *)sqlite3_value_text(argv[0]); nInput = sqlite3_value_bytes(argv[argc-1]); zInput = (const char *)sqlite3_value_text(argv[argc-1]); if( argc==3 ){ zArg = (const char *)sqlite3_value_text(argv[1]); } pHash = (fts3Hash *)sqlite3_user_data(context); p = (sqlite3_tokenizer_module *)sqlite3Fts3HashFind(pHash, zName, nName+1); if( !p ){ char *zErr = sqlite3_mprintf("unknown tokenizer: %s", zName); sqlite3_result_error(context, zErr, -1); sqlite3_free(zErr); return; } pRet = Tcl_NewObj(); Tcl_IncrRefCount(pRet); if( SQLITE_OK!=p->xCreate(zArg ? 1 : 0, &zArg, &pTokenizer) ){ zErr = "error in xCreate()"; goto finish; } pTokenizer->pModule = p; if( SQLITE_OK!=p->xOpen(pTokenizer, zInput, nInput, &pCsr) ){ zErr = "error in xOpen()"; goto finish; } pCsr->pTokenizer = pTokenizer; while( SQLITE_OK==p->xNext(pCsr, &zToken, &nToken, &iStart, &iEnd, &iPos) ){ Tcl_ListObjAppendElement(0, pRet, Tcl_NewIntObj(iPos)); Tcl_ListObjAppendElement(0, pRet, Tcl_NewStringObj(zToken, nToken)); zToken = &zInput[iStart]; nToken = iEnd-iStart; Tcl_ListObjAppendElement(0, pRet, Tcl_NewStringObj(zToken, nToken)); } if( SQLITE_OK!=p->xClose(pCsr) ){ zErr = "error in xClose()"; goto finish; } if( SQLITE_OK!=p->xDestroy(pTokenizer) ){ zErr = "error in xDestroy()"; goto finish; } finish: if( zErr ){ sqlite3_result_error(context, zErr, -1); }else{ sqlite3_result_text(context, Tcl_GetString(pRet), -1, SQLITE_TRANSIENT); } Tcl_DecrRefCount(pRet); } static int registerTokenizer( sqlite3 *db, char *zName, const sqlite3_tokenizer_module *p ){ int rc; sqlite3_stmt *pStmt; const char zSql[] = "SELECT fts3_tokenizer(?, ?)"; rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0); if( rc!=SQLITE_OK ){ return rc; } sqlite3_bind_text(pStmt, 1, zName, -1, SQLITE_STATIC); sqlite3_bind_blob(pStmt, 2, &p, sizeof(p), SQLITE_STATIC); sqlite3_step(pStmt); return sqlite3_finalize(pStmt); } static int queryTokenizer( sqlite3 *db, char *zName, const sqlite3_tokenizer_module **pp ){ int rc; sqlite3_stmt *pStmt; const char zSql[] = "SELECT fts3_tokenizer(?)"; *pp = 0; rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0); if( rc!=SQLITE_OK ){ return rc; } sqlite3_bind_text(pStmt, 1, zName, -1, SQLITE_STATIC); if( SQLITE_ROW==sqlite3_step(pStmt) ){ if( sqlite3_column_type(pStmt, 0)==SQLITE_BLOB ){ memcpy(pp, sqlite3_column_blob(pStmt, 0), sizeof(*pp)); } } return sqlite3_finalize(pStmt); } SQLITE_PRIVATE void sqlite3Fts3SimpleTokenizerModule(sqlite3_tokenizer_module const**ppModule); static void intTestFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){ int rc; const sqlite3_tokenizer_module *p1; const sqlite3_tokenizer_module *p2; sqlite3 *db = (sqlite3 *)sqlite3_user_data(context); sqlite3Fts3SimpleTokenizerModule(&p1); rc = queryTokenizer(db, "simple", &p2); assert( rc==SQLITE_OK ); assert( p1==p2 ); rc = queryTokenizer(db, "nosuchtokenizer", &p2); assert( rc==SQLITE_ERROR ); assert( p2==0 ); assert( 0==strcmp(sqlite3_errmsg(db), "unknown tokenizer: nosuchtokenizer") ); rc = registerTokenizer(db, "nosuchtokenizer", p1); assert( rc==SQLITE_OK ); rc = queryTokenizer(db, "nosuchtokenizer", &p2); assert( rc==SQLITE_OK ); assert( p2==p1 ); sqlite3_result_text(context, "ok", -1, SQLITE_STATIC); } 
#endif 
SQLITE_PRIVATE int sqlite3Fts3InitHashTable( sqlite3 *db, fts3Hash *pHash, const char *zName ){ int rc = SQLITE_OK; void *p = (void *)pHash; const int any = SQLITE_ANY; char *zTest = 0; char *zTest2 = 0; 
#ifdef SQLITE_TEST 
 void *pdb = (void *)db; zTest = sqlite3_mprintf("%s_test", zName); zTest2 = sqlite3_mprintf("%s_internal_test", zName); if( !zTest || !zTest2 ){ rc = SQLITE_NOMEM; } 
#endif 
 if( rc!=SQLITE_OK || (rc = sqlite3_create_function(db, zName, 1, any, p, scalarFunc, 0, 0)) || (rc = sqlite3_create_function(db, zName, 2, any, p, scalarFunc, 0, 0)) 
#ifdef SQLITE_TEST 
 || (rc = sqlite3_create_function(db, zTest, 2, any, p, testFunc, 0, 0)) || (rc = sqlite3_create_function(db, zTest, 3, any, p, testFunc, 0, 0)) || (rc = sqlite3_create_function(db, zTest2, 0, any, pdb, intTestFunc, 0, 0)) 
#endif 
 ); sqlite3_free(zTest); sqlite3_free(zTest2); return rc; } 
#endif 
#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3) 
typedef struct simple_tokenizer { sqlite3_tokenizer base; char delim[128]; } simple_tokenizer; typedef struct simple_tokenizer_cursor { sqlite3_tokenizer_cursor base; const char *pInput; int nBytes; int iOffset; int iToken; char *pToken; int nTokenAllocated; } simple_tokenizer_cursor; static const sqlite3_tokenizer_module simpleTokenizerModule; static int simpleDelim(simple_tokenizer *t, unsigned char c){ return c<0x80 && t->delim[c]; } static int simpleCreate( int argc, const char * const *argv, sqlite3_tokenizer **ppTokenizer ){ simple_tokenizer *t; t = (simple_tokenizer *) sqlite3_malloc(sizeof(*t)); if( t==NULL ) return SQLITE_NOMEM; memset(t, 0, sizeof(*t)); if( argc>1 ){ int i, n = strlen(argv[1]); for(i=0; i<n; i++){ unsigned char ch = argv[1][i]; if( ch>=0x80 ){ sqlite3_free(t); return SQLITE_ERROR; } t->delim[ch] = 1; } } else { int i; for(i=1; i<0x80; i++){ t->delim[i] = !isalnum(i); } } *ppTokenizer = &t->base; return SQLITE_OK; } static int simpleDestroy(sqlite3_tokenizer *pTokenizer){ sqlite3_free(pTokenizer); return SQLITE_OK; } static int simpleOpen( sqlite3_tokenizer *pTokenizer, const char *pInput, int nBytes, sqlite3_tokenizer_cursor **ppCursor ){ simple_tokenizer_cursor *c; c = (simple_tokenizer_cursor *) sqlite3_malloc(sizeof(*c)); if( c==NULL ) return SQLITE_NOMEM; c->pInput = pInput; if( pInput==0 ){ c->nBytes = 0; }else if( nBytes<0 ){ c->nBytes = (int)strlen(pInput); }else{ c->nBytes = nBytes; } c->iOffset = 0; c->iToken = 0; c->pToken = NULL; c->nTokenAllocated = 0; *ppCursor = &c->base; return SQLITE_OK; } static int simpleClose(sqlite3_tokenizer_cursor *pCursor){ simple_tokenizer_cursor *c = (simple_tokenizer_cursor *) pCursor; sqlite3_free(c->pToken); sqlite3_free(c); return SQLITE_OK; } static int simpleNext( sqlite3_tokenizer_cursor *pCursor, const char **ppToken, int *pnBytes, int *piStartOffset, int *piEndOffset, int *piPosition ){ simple_tokenizer_cursor *c = (simple_tokenizer_cursor *) pCursor; simple_tokenizer *t = (simple_tokenizer *) pCursor->pTokenizer; unsigned char *p = (unsigned char *)c->pInput; while( c->iOffset<c->nBytes ){ int iStartOffset; while( c->iOffset<c->nBytes && simpleDelim(t, p[c->iOffset]) ){ c->iOffset++; } iStartOffset = c->iOffset; while( c->iOffset<c->nBytes && !simpleDelim(t, p[c->iOffset]) ){ c->iOffset++; } if( c->iOffset>iStartOffset ){ int i, n = c->iOffset-iStartOffset; if( n>c->nTokenAllocated ){ c->nTokenAllocated = n+20; c->pToken = sqlite3_realloc(c->pToken, c->nTokenAllocated); if( c->pToken==NULL ) return SQLITE_NOMEM; } for(i=0; i<n; i++){ unsigned char ch = p[iStartOffset+i]; c->pToken[i] = ch<0x80 ? tolower(ch) : ch; } *ppToken = c->pToken; *pnBytes = n; *piStartOffset = iStartOffset; *piEndOffset = c->iOffset; *piPosition = c->iToken++; return SQLITE_OK; } } return SQLITE_DONE; } static const sqlite3_tokenizer_module simpleTokenizerModule = { 0, simpleCreate, simpleDestroy, simpleOpen, simpleClose, simpleNext, }; SQLITE_PRIVATE void sqlite3Fts3SimpleTokenizerModule( sqlite3_tokenizer_module const**ppModule ){ *ppModule = &simpleTokenizerModule; } 
#endif 
#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_RTREE) 
#define VARIANT_RSTARTREE_CHOOSESUBTREE 0 
#define VARIANT_RSTARTREE_REINSERT 1 
#define VARIANT_GUTTMAN_QUADRATIC_SPLIT 0 
#define VARIANT_GUTTMAN_LINEAR_SPLIT 0 
#define VARIANT_RSTARTREE_SPLIT 1 
#define VARIANT_GUTTMAN_SPLIT (VARIANT_GUTTMAN_LINEAR_SPLIT||VARIANT_GUTTMAN_QUADRATIC_SPLIT) 
#if VARIANT_GUTTMAN_QUADRATIC_SPLIT 
#define PickNext QuadraticPickNext 
#define PickSeeds QuadraticPickSeeds 
#define AssignCells splitNodeGuttman 
#endif 
#if VARIANT_GUTTMAN_LINEAR_SPLIT 
#define PickNext LinearPickNext 
#define PickSeeds LinearPickSeeds 
#define AssignCells splitNodeGuttman 
#endif 
#if VARIANT_RSTARTREE_SPLIT 
#define AssignCells splitNodeStartree 
#endif 
#ifndef SQLITE_CORE 
 SQLITE_EXTENSION_INIT1 
#else 
#endif 
#ifndef SQLITE_AMALGAMATION 
typedef sqlite3_int64 i64; typedef unsigned char u8; typedef unsigned int u32; 
#endif 
typedef struct Rtree Rtree; typedef struct RtreeCursor RtreeCursor; typedef struct RtreeNode RtreeNode; typedef struct RtreeCell RtreeCell; typedef struct RtreeConstraint RtreeConstraint; typedef union RtreeCoord RtreeCoord; 
#define RTREE_MAX_DIMENSIONS 5 
#define HASHSIZE 128 
struct Rtree { sqlite3_vtab base; sqlite3 *db; int iNodeSize; int nDim; int nBytesPerCell; int iDepth; char *zDb; char *zName; RtreeNode *aHash[HASHSIZE]; int nBusy; RtreeNode *pDeleted; int iReinsertHeight; sqlite3_stmt *pReadNode; sqlite3_stmt *pWriteNode; sqlite3_stmt *pDeleteNode; sqlite3_stmt *pReadRowid; sqlite3_stmt *pWriteRowid; sqlite3_stmt *pDeleteRowid; sqlite3_stmt *pReadParent; sqlite3_stmt *pWriteParent; sqlite3_stmt *pDeleteParent; int eCoordType; }; 
#define RTREE_COORD_REAL32 0 
#define RTREE_COORD_INT32 1 
#define RTREE_MINCELLS(p) ((((p)->iNodeSize-4)/(p)->nBytesPerCell)/3) 
#define RTREE_REINSERT(p) RTREE_MINCELLS(p) 
#define RTREE_MAXCELLS 51 
struct RtreeCursor { sqlite3_vtab_cursor base; RtreeNode *pNode; int iCell; int iStrategy; int nConstraint; RtreeConstraint *aConstraint; }; union RtreeCoord { float f; int i; }; 
#define DCOORD(coord) ( (pRtree->eCoordType==RTREE_COORD_REAL32) ? ((double)coord.f) : ((double)coord.i) ) 
struct RtreeConstraint { int iCoord; int op; double rValue; }; 
#define RTREE_EQ 0x41 
#define RTREE_LE 0x42 
#define RTREE_LT 0x43 
#define RTREE_GE 0x44 
#define RTREE_GT 0x45 
struct RtreeNode { RtreeNode *pParent; i64 iNode; int nRef; int isDirty; u8 *zData; RtreeNode *pNext; }; 
#define NCELL(pNode) readInt16(&(pNode)->zData[2]) 
struct RtreeCell { i64 iRowid; RtreeCoord aCoord[RTREE_MAX_DIMENSIONS*2]; }; 
#ifndef MAX 
#define MAX(x,y) ((x) < (y) ? (y) : (x)) 
#endif 
#ifndef MIN 
#define MIN(x,y) ((x) > (y) ? (y) : (x)) 
#endif 
static int readInt16(u8 *p){ return (p[0]<<8) + p[1]; } static void readCoord(u8 *p, RtreeCoord *pCoord){ u32 i = ( (((u32)p[0]) << 24) + (((u32)p[1]) << 16) + (((u32)p[2]) << 8) + (((u32)p[3]) << 0) ); *(u32 *)pCoord = i; } static i64 readInt64(u8 *p){ return ( (((i64)p[0]) << 56) + (((i64)p[1]) << 48) + (((i64)p[2]) << 40) + (((i64)p[3]) << 32) + (((i64)p[4]) << 24) + (((i64)p[5]) << 16) + (((i64)p[6]) << 8) + (((i64)p[7]) << 0) ); } static int writeInt16(u8 *p, int i){ p[0] = (i>> 8)&0xFF; p[1] = (i>> 0)&0xFF; return 2; } static int writeCoord(u8 *p, RtreeCoord *pCoord){ u32 i; assert( sizeof(RtreeCoord)==4 ); assert( sizeof(u32)==4 ); i = *(u32 *)pCoord; p[0] = (i>>24)&0xFF; p[1] = (i>>16)&0xFF; p[2] = (i>> 8)&0xFF; p[3] = (i>> 0)&0xFF; return 4; } static int writeInt64(u8 *p, i64 i){ p[0] = (i>>56)&0xFF; p[1] = (i>>48)&0xFF; p[2] = (i>>40)&0xFF; p[3] = (i>>32)&0xFF; p[4] = (i>>24)&0xFF; p[5] = (i>>16)&0xFF; p[6] = (i>> 8)&0xFF; p[7] = (i>> 0)&0xFF; return 8; } static void nodeReference(RtreeNode *p){ if( p ){ p->nRef++; } } static void nodeZero(Rtree *pRtree, RtreeNode *p){ if( p ){ memset(&p->zData[2], 0, pRtree->iNodeSize-2); p->isDirty = 1; } } static int nodeHash(i64 iNode){ return ( (iNode>>56) ^ (iNode>>48) ^ (iNode>>40) ^ (iNode>>32) ^ (iNode>>24) ^ (iNode>>16) ^ (iNode>> 8) ^ (iNode>> 0) ) % HASHSIZE; } static RtreeNode *nodeHashLookup(Rtree *pRtree, i64 iNode){ RtreeNode *p; assert( iNode!=0 ); for(p=pRtree->aHash[nodeHash(iNode)]; p && p->iNode!=iNode; p=p->pNext); return p; } static void nodeHashInsert(Rtree *pRtree, RtreeNode *pNode){ if( pNode ){ int iHash; assert( pNode->pNext==0 ); iHash = nodeHash(pNode->iNode); pNode->pNext = pRtree->aHash[iHash]; pRtree->aHash[iHash] = pNode; } } static void nodeHashDelete(Rtree *pRtree, RtreeNode *pNode){ RtreeNode **pp; if( pNode->iNode!=0 ){ pp = &pRtree->aHash[nodeHash(pNode->iNode)]; for( ; (*pp)!=pNode; pp = &(*pp)->pNext){ assert(*pp); } *pp = pNode->pNext; pNode->pNext = 0; } } static RtreeNode *nodeNew(Rtree *pRtree, RtreeNode *pParent, int zero){ RtreeNode *pNode; pNode = (RtreeNode *)sqlite3_malloc(sizeof(RtreeNode) + pRtree->iNodeSize); if( pNode ){ memset(pNode, 0, sizeof(RtreeNode) + (zero?pRtree->iNodeSize:0)); pNode->zData = (u8 *)&pNode[1]; pNode->nRef = 1; pNode->pParent = pParent; pNode->isDirty = 1; nodeReference(pParent); } return pNode; } static int nodeAcquire( Rtree *pRtree, i64 iNode, RtreeNode *pParent, RtreeNode **ppNode ){ int rc; RtreeNode *pNode; if( (pNode = nodeHashLookup(pRtree, iNode)) ){ assert( !pParent || !pNode->pParent || pNode->pParent==pParent ); if( pParent ){ pNode->pParent = pParent; } pNode->nRef++; *ppNode = pNode; return SQLITE_OK; } pNode = (RtreeNode *)sqlite3_malloc(sizeof(RtreeNode) + pRtree->iNodeSize); if( !pNode ){ *ppNode = 0; return SQLITE_NOMEM; } pNode->pParent = pParent; pNode->zData = (u8 *)&pNode[1]; pNode->nRef = 1; pNode->iNode = iNode; pNode->isDirty = 0; pNode->pNext = 0; sqlite3_bind_int64(pRtree->pReadNode, 1, iNode); rc = sqlite3_step(pRtree->pReadNode); if( rc==SQLITE_ROW ){ const u8 *zBlob = sqlite3_column_blob(pRtree->pReadNode, 0); memcpy(pNode->zData, zBlob, pRtree->iNodeSize); nodeReference(pParent); }else{ sqlite3_free(pNode); pNode = 0; } *ppNode = pNode; rc = sqlite3_reset(pRtree->pReadNode); if( rc==SQLITE_OK && iNode==1 ){ pRtree->iDepth = readInt16(pNode->zData); } assert( (rc==SQLITE_OK && pNode) || (pNode==0 && rc!=SQLITE_OK) ); nodeHashInsert(pRtree, pNode); return rc; } static void nodeOverwriteCell( Rtree *pRtree, RtreeNode *pNode, RtreeCell *pCell, int iCell ){ int ii; u8 *p = &pNode->zData[4 + pRtree->nBytesPerCell*iCell]; p += writeInt64(p, pCell->iRowid); for(ii=0; ii<(pRtree->nDim*2); ii++){ p += writeCoord(p, &pCell->aCoord[ii]); } pNode->isDirty = 1; } static void nodeDeleteCell(Rtree *pRtree, RtreeNode *pNode, int iCell){ u8 *pDst = &pNode->zData[4 + pRtree->nBytesPerCell*iCell]; u8 *pSrc = &pDst[pRtree->nBytesPerCell]; int nByte = (NCELL(pNode) - iCell - 1) * pRtree->nBytesPerCell; memmove(pDst, pSrc, nByte); writeInt16(&pNode->zData[2], NCELL(pNode)-1); pNode->isDirty = 1; } static int nodeInsertCell( Rtree *pRtree, RtreeNode *pNode, RtreeCell *pCell ){ int nCell; int nMaxCell; nMaxCell = (pRtree->iNodeSize-4)/pRtree->nBytesPerCell; nCell = NCELL(pNode); assert(nCell<=nMaxCell); if( nCell<nMaxCell ){ nodeOverwriteCell(pRtree, pNode, pCell, nCell); writeInt16(&pNode->zData[2], nCell+1); pNode->isDirty = 1; } return (nCell==nMaxCell); } static int nodeWrite(Rtree *pRtree, RtreeNode *pNode){ int rc = SQLITE_OK; if( pNode->isDirty ){ sqlite3_stmt *p = pRtree->pWriteNode; if( pNode->iNode ){ sqlite3_bind_int64(p, 1, pNode->iNode); }else{ sqlite3_bind_null(p, 1); } sqlite3_bind_blob(p, 2, pNode->zData, pRtree->iNodeSize, SQLITE_STATIC); sqlite3_step(p); pNode->isDirty = 0; rc = sqlite3_reset(p); if( pNode->iNode==0 && rc==SQLITE_OK ){ pNode->iNode = sqlite3_last_insert_rowid(pRtree->db); nodeHashInsert(pRtree, pNode); } } return rc; } static int nodeRelease(Rtree *pRtree, RtreeNode *pNode){ int rc = SQLITE_OK; if( pNode ){ assert( pNode->nRef>0 ); pNode->nRef--; if( pNode->nRef==0 ){ if( pNode->iNode==1 ){ pRtree->iDepth = -1; } if( pNode->pParent ){ rc = nodeRelease(pRtree, pNode->pParent); } if( rc==SQLITE_OK ){ rc = nodeWrite(pRtree, pNode); } nodeHashDelete(pRtree, pNode); sqlite3_free(pNode); } } return rc; } static i64 nodeGetRowid( Rtree *pRtree, RtreeNode *pNode, int iCell ){ assert( iCell<NCELL(pNode) ); return readInt64(&pNode->zData[4 + pRtree->nBytesPerCell*iCell]); } static void nodeGetCoord( Rtree *pRtree, RtreeNode *pNode, int iCell, int iCoord, RtreeCoord *pCoord ){ readCoord(&pNode->zData[12 + pRtree->nBytesPerCell*iCell + 4*iCoord], pCoord); } static void nodeGetCell( Rtree *pRtree, RtreeNode *pNode, int iCell, RtreeCell *pCell ){ int ii; pCell->iRowid = nodeGetRowid(pRtree, pNode, iCell); for(ii=0; ii<pRtree->nDim*2; ii++){ nodeGetCoord(pRtree, pNode, iCell, ii, &pCell->aCoord[ii]); } } static int rtreeInit( sqlite3 *, void *, int, const char *const*, sqlite3_vtab **, char **, int ); static int rtreeCreate( sqlite3 *db, void *pAux, int argc, const char *const*argv, sqlite3_vtab **ppVtab, char **pzErr ){ return rtreeInit(db, pAux, argc, argv, ppVtab, pzErr, 1); } static int rtreeConnect( sqlite3 *db, void *pAux, int argc, const char *const*argv, sqlite3_vtab **ppVtab, char **pzErr ){ return rtreeInit(db, pAux, argc, argv, ppVtab, pzErr, 0); } static void rtreeReference(Rtree *pRtree){ pRtree->nBusy++; } static void rtreeRelease(Rtree *pRtree){ pRtree->nBusy--; if( pRtree->nBusy==0 ){ sqlite3_finalize(pRtree->pReadNode); sqlite3_finalize(pRtree->pWriteNode); sqlite3_finalize(pRtree->pDeleteNode); sqlite3_finalize(pRtree->pReadRowid); sqlite3_finalize(pRtree->pWriteRowid); sqlite3_finalize(pRtree->pDeleteRowid); sqlite3_finalize(pRtree->pReadParent); sqlite3_finalize(pRtree->pWriteParent); sqlite3_finalize(pRtree->pDeleteParent); sqlite3_free(pRtree); } } static int rtreeDisconnect(sqlite3_vtab *pVtab){ rtreeRelease((Rtree *)pVtab); return SQLITE_OK; } static int rtreeDestroy(sqlite3_vtab *pVtab){ Rtree *pRtree = (Rtree *)pVtab; int rc; char *zCreate = sqlite3_mprintf( "DROP TABLE '%q'.'%q_node';" "DROP TABLE '%q'.'%q_rowid';" "DROP TABLE '%q'.'%q_parent';", pRtree->zDb, pRtree->zName, pRtree->zDb, pRtree->zName, pRtree->zDb, pRtree->zName ); if( !zCreate ){ rc = SQLITE_NOMEM; }else{ rc = sqlite3_exec(pRtree->db, zCreate, 0, 0, 0); sqlite3_free(zCreate); } if( rc==SQLITE_OK ){ rtreeRelease(pRtree); } return rc; } static int rtreeOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){ int rc = SQLITE_NOMEM; RtreeCursor *pCsr; pCsr = (RtreeCursor *)sqlite3_malloc(sizeof(RtreeCursor)); if( pCsr ){ memset(pCsr, 0, sizeof(RtreeCursor)); pCsr->base.pVtab = pVTab; rc = SQLITE_OK; } *ppCursor = (sqlite3_vtab_cursor *)pCsr; return rc; } static int rtreeClose(sqlite3_vtab_cursor *cur){ Rtree *pRtree = (Rtree *)(cur->pVtab); int rc; RtreeCursor *pCsr = (RtreeCursor *)cur; sqlite3_free(pCsr->aConstraint); rc = nodeRelease(pRtree, pCsr->pNode); sqlite3_free(pCsr); return rc; } static int rtreeEof(sqlite3_vtab_cursor *cur){ RtreeCursor *pCsr = (RtreeCursor *)cur; return (pCsr->pNode==0); } static int testRtreeCell(Rtree *pRtree, RtreeCursor *pCursor){ RtreeCell cell; int ii; int bRes = 0; nodeGetCell(pRtree, pCursor->pNode, pCursor->iCell, &cell); for(ii=0; bRes==0 && ii<pCursor->nConstraint; ii++){ RtreeConstraint *p = &pCursor->aConstraint[ii]; double cell_min = DCOORD(cell.aCoord[(p->iCoord>>1)*2]); double cell_max = DCOORD(cell.aCoord[(p->iCoord>>1)*2+1]); assert(p->op==RTREE_LE || p->op==RTREE_LT || p->op==RTREE_GE || p->op==RTREE_GT || p->op==RTREE_EQ ); switch( p->op ){ case RTREE_LE: case RTREE_LT: bRes = p->rValue<cell_min; break; case RTREE_GE: case RTREE_GT: bRes = p->rValue>cell_max; break; case RTREE_EQ: bRes = (p->rValue>cell_max || p->rValue<cell_min); break; } } return bRes; } static int testRtreeEntry(Rtree *pRtree, RtreeCursor *pCursor){ RtreeCell cell; int ii; nodeGetCell(pRtree, pCursor->pNode, pCursor->iCell, &cell); for(ii=0; ii<pCursor->nConstraint; ii++){ RtreeConstraint *p = &pCursor->aConstraint[ii]; double coord = DCOORD(cell.aCoord[p->iCoord]); int res; assert(p->op==RTREE_LE || p->op==RTREE_LT || p->op==RTREE_GE || p->op==RTREE_GT || p->op==RTREE_EQ ); switch( p->op ){ case RTREE_LE: res = (coord<=p->rValue); break; case RTREE_LT: res = (coord<p->rValue); break; case RTREE_GE: res = (coord>=p->rValue); break; case RTREE_GT: res = (coord>p->rValue); break; case RTREE_EQ: res = (coord==p->rValue); break; } if( !res ) return 1; } return 0; } static int descendToCell( Rtree *pRtree, RtreeCursor *pCursor, int iHeight, int *pEof ){ int isEof; int rc; int ii; RtreeNode *pChild; sqlite3_int64 iRowid; RtreeNode *pSavedNode = pCursor->pNode; int iSavedCell = pCursor->iCell; assert( iHeight>=0 ); if( iHeight==0 ){ isEof = testRtreeEntry(pRtree, pCursor); }else{ isEof = testRtreeCell(pRtree, pCursor); } if( isEof || iHeight==0 ){ *pEof = isEof; return SQLITE_OK; } iRowid = nodeGetRowid(pRtree, pCursor->pNode, pCursor->iCell); rc = nodeAcquire(pRtree, iRowid, pCursor->pNode, &pChild); if( rc!=SQLITE_OK ){ return rc; } nodeRelease(pRtree, pCursor->pNode); pCursor->pNode = pChild; isEof = 1; for(ii=0; isEof && ii<NCELL(pChild); ii++){ pCursor->iCell = ii; rc = descendToCell(pRtree, pCursor, iHeight-1, &isEof); if( rc!=SQLITE_OK ){ return rc; } } if( isEof ){ assert( pCursor->pNode==pChild ); nodeReference(pSavedNode); nodeRelease(pRtree, pChild); pCursor->pNode = pSavedNode; pCursor->iCell = iSavedCell; } *pEof = isEof; return SQLITE_OK; } static int nodeRowidIndex(Rtree *pRtree, RtreeNode *pNode, i64 iRowid){ int ii; for(ii=0; nodeGetRowid(pRtree, pNode, ii)!=iRowid; ii++){ assert( ii<(NCELL(pNode)-1) ); } return ii; } static int nodeParentIndex(Rtree *pRtree, RtreeNode *pNode){ RtreeNode *pParent = pNode->pParent; if( pParent ){ return nodeRowidIndex(pRtree, pParent, pNode->iNode); } return -1; } static int rtreeNext(sqlite3_vtab_cursor *pVtabCursor){ Rtree *pRtree = (Rtree *)(pVtabCursor->pVtab); RtreeCursor *pCsr = (RtreeCursor *)pVtabCursor; int rc = SQLITE_OK; if( pCsr->iStrategy==1 ){ nodeRelease(pRtree, pCsr->pNode); pCsr->pNode = 0; } else if( pCsr->pNode ){ int iHeight = 0; while( pCsr->pNode ){ RtreeNode *pNode = pCsr->pNode; int nCell = NCELL(pNode); for(pCsr->iCell++; pCsr->iCell<nCell; pCsr->iCell++){ int isEof; rc = descendToCell(pRtree, pCsr, iHeight, &isEof); if( rc!=SQLITE_OK || !isEof ){ return rc; } } pCsr->pNode = pNode->pParent; pCsr->iCell = nodeParentIndex(pRtree, pNode); nodeReference(pCsr->pNode); nodeRelease(pRtree, pNode); iHeight++; } } return rc; } static int rtreeRowid(sqlite3_vtab_cursor *pVtabCursor, sqlite_int64 *pRowid){ Rtree *pRtree = (Rtree *)pVtabCursor->pVtab; RtreeCursor *pCsr = (RtreeCursor *)pVtabCursor; assert(pCsr->pNode); *pRowid = nodeGetRowid(pRtree, pCsr->pNode, pCsr->iCell); return SQLITE_OK; } static int rtreeColumn(sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i){ Rtree *pRtree = (Rtree *)cur->pVtab; RtreeCursor *pCsr = (RtreeCursor *)cur; if( i==0 ){ i64 iRowid = nodeGetRowid(pRtree, pCsr->pNode, pCsr->iCell); sqlite3_result_int64(ctx, iRowid); }else{ RtreeCoord c; nodeGetCoord(pRtree, pCsr->pNode, pCsr->iCell, i-1, &c); if( pRtree->eCoordType==RTREE_COORD_REAL32 ){ sqlite3_result_double(ctx, c.f); }else{ assert( pRtree->eCoordType==RTREE_COORD_INT32 ); sqlite3_result_int(ctx, c.i); } } return SQLITE_OK; } static int findLeafNode(Rtree *pRtree, i64 iRowid, RtreeNode **ppLeaf){ int rc; *ppLeaf = 0; sqlite3_bind_int64(pRtree->pReadRowid, 1, iRowid); if( sqlite3_step(pRtree->pReadRowid)==SQLITE_ROW ){ i64 iNode = sqlite3_column_int64(pRtree->pReadRowid, 0); rc = nodeAcquire(pRtree, iNode, 0, ppLeaf); sqlite3_reset(pRtree->pReadRowid); }else{ rc = sqlite3_reset(pRtree->pReadRowid); } return rc; } static int rtreeFilter( sqlite3_vtab_cursor *pVtabCursor, int idxNum, const char *idxStr, int argc, sqlite3_value **argv ){ Rtree *pRtree = (Rtree *)pVtabCursor->pVtab; RtreeCursor *pCsr = (RtreeCursor *)pVtabCursor; RtreeNode *pRoot = 0; int ii; int rc = SQLITE_OK; rtreeReference(pRtree); sqlite3_free(pCsr->aConstraint); pCsr->aConstraint = 0; pCsr->iStrategy = idxNum; if( idxNum==1 ){ RtreeNode *pLeaf; i64 iRowid = sqlite3_value_int64(argv[0]); rc = findLeafNode(pRtree, iRowid, &pLeaf); pCsr->pNode = pLeaf; if( pLeaf && rc==SQLITE_OK ){ pCsr->iCell = nodeRowidIndex(pRtree, pLeaf, iRowid); } }else{ if( argc>0 ){ pCsr->aConstraint = sqlite3_malloc(sizeof(RtreeConstraint)*argc); pCsr->nConstraint = argc; if( !pCsr->aConstraint ){ rc = SQLITE_NOMEM; }else{ assert( (idxStr==0 && argc==0) || strlen(idxStr)==argc*2 ); for(ii=0; ii<argc; ii++){ RtreeConstraint *p = &pCsr->aConstraint[ii]; p->op = idxStr[ii*2]; p->iCoord = idxStr[ii*2+1]-'a'; p->rValue = sqlite3_value_double(argv[ii]); } } } if( rc==SQLITE_OK ){ pCsr->pNode = 0; rc = nodeAcquire(pRtree, 1, 0, &pRoot); } if( rc==SQLITE_OK ){ int isEof = 1; int nCell = NCELL(pRoot); pCsr->pNode = pRoot; for(pCsr->iCell=0; rc==SQLITE_OK && pCsr->iCell<nCell; pCsr->iCell++){ assert( pCsr->pNode==pRoot ); rc = descendToCell(pRtree, pCsr, pRtree->iDepth, &isEof); if( !isEof ){ break; } } if( rc==SQLITE_OK && isEof ){ assert( pCsr->pNode==pRoot ); nodeRelease(pRtree, pRoot); pCsr->pNode = 0; } assert( rc!=SQLITE_OK || !pCsr->pNode || pCsr->iCell<NCELL(pCsr->pNode) ); } } rtreeRelease(pRtree); return rc; } static int rtreeBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){ int rc = SQLITE_OK; int ii, cCol; int iIdx = 0; char zIdxStr[RTREE_MAX_DIMENSIONS*8+1]; memset(zIdxStr, 0, sizeof(zIdxStr)); assert( pIdxInfo->idxStr==0 ); for(ii=0; ii<pIdxInfo->nConstraint; ii++){ struct sqlite3_index_constraint *p = &pIdxInfo->aConstraint[ii]; if( p->usable && p->iColumn==0 && p->op==SQLITE_INDEX_CONSTRAINT_EQ ){ int jj; for(jj=0; jj<ii; jj++){ pIdxInfo->aConstraintUsage[jj].argvIndex = 0; pIdxInfo->aConstraintUsage[jj].omit = 0; } pIdxInfo->idxNum = 1; pIdxInfo->aConstraintUsage[ii].argvIndex = 1; pIdxInfo->aConstraintUsage[jj].omit = 1; pIdxInfo->estimatedCost = 10.0; return SQLITE_OK; } if( p->usable && p->iColumn>0 ){ u8 op = 0; switch( p->op ){ case SQLITE_INDEX_CONSTRAINT_EQ: op = RTREE_EQ; break; case SQLITE_INDEX_CONSTRAINT_GT: op = RTREE_GT; break; case SQLITE_INDEX_CONSTRAINT_LE: op = RTREE_LE; break; case SQLITE_INDEX_CONSTRAINT_LT: op = RTREE_LT; break; case SQLITE_INDEX_CONSTRAINT_GE: op = RTREE_GE; break; } if( op ){ int j, opmsk; static const unsigned char compatible[] = { 0, 0, 1, 1, 2, 2 }; assert( compatible[RTREE_EQ & 7]==0 ); assert( compatible[RTREE_LT & 7]==1 ); assert( compatible[RTREE_LE & 7]==1 ); assert( compatible[RTREE_GT & 7]==2 ); assert( compatible[RTREE_GE & 7]==2 ); cCol = p->iColumn - 1 + 'a'; opmsk = compatible[op & 7]; for(j=0; j<iIdx; j+=2){ if( zIdxStr[j+1]==cCol && (compatible[zIdxStr[j] & 7] & opmsk)!=0 ){ op = 0; break; } } } if( op ){ assert( iIdx<sizeof(zIdxStr)-1 ); zIdxStr[iIdx++] = op; zIdxStr[iIdx++] = cCol; pIdxInfo->aConstraintUsage[ii].argvIndex = (iIdx/2); pIdxInfo->aConstraintUsage[ii].omit = 1; } } } pIdxInfo->idxNum = 2; pIdxInfo->needToFreeIdxStr = 1; if( iIdx>0 && 0==(pIdxInfo->idxStr = sqlite3_mprintf("%s", zIdxStr)) ){ return SQLITE_NOMEM; } assert( iIdx>=0 ); pIdxInfo->estimatedCost = (2000000.0 / (double)(iIdx + 1)); return rc; } static float cellArea(Rtree *pRtree, RtreeCell *p){ float area = 1.0; int ii; for(ii=0; ii<(pRtree->nDim*2); ii+=2){ area = area * (DCOORD(p->aCoord[ii+1]) - DCOORD(p->aCoord[ii])); } return area; } static float cellMargin(Rtree *pRtree, RtreeCell *p){ float margin = 0.0; int ii; for(ii=0; ii<(pRtree->nDim*2); ii+=2){ margin += (DCOORD(p->aCoord[ii+1]) - DCOORD(p->aCoord[ii])); } return margin; } static void cellUnion(Rtree *pRtree, RtreeCell *p1, RtreeCell *p2){ int ii; if( pRtree->eCoordType==RTREE_COORD_REAL32 ){ for(ii=0; ii<(pRtree->nDim*2); ii+=2){ p1->aCoord[ii].f = MIN(p1->aCoord[ii].f, p2->aCoord[ii].f); p1->aCoord[ii+1].f = MAX(p1->aCoord[ii+1].f, p2->aCoord[ii+1].f); } }else{ for(ii=0; ii<(pRtree->nDim*2); ii+=2){ p1->aCoord[ii].i = MIN(p1->aCoord[ii].i, p2->aCoord[ii].i); p1->aCoord[ii+1].i = MAX(p1->aCoord[ii+1].i, p2->aCoord[ii+1].i); } } } static int cellContains(Rtree *pRtree, RtreeCell *p1, RtreeCell *p2){ int ii; int isInt = (pRtree->eCoordType==RTREE_COORD_INT32); for(ii=0; ii<(pRtree->nDim*2); ii+=2){ RtreeCoord *a1 = &p1->aCoord[ii]; RtreeCoord *a2 = &p2->aCoord[ii]; if( (!isInt && (a2[0].f<a1[0].f || a2[1].f>a1[1].f)) || ( isInt && (a2[0].i<a1[0].i || a2[1].i>a1[1].i)) ){ return 0; } } return 1; } static float cellGrowth(Rtree *pRtree, RtreeCell *p, RtreeCell *pCell){ float area; RtreeCell cell; memcpy(&cell, p, sizeof(RtreeCell)); area = cellArea(pRtree, &cell); cellUnion(pRtree, &cell, pCell); return (cellArea(pRtree, &cell)-area); } 
#if VARIANT_RSTARTREE_CHOOSESUBTREE || VARIANT_RSTARTREE_SPLIT 
static float cellOverlap( Rtree *pRtree, RtreeCell *p, RtreeCell *aCell, int nCell, int iExclude ){ int ii; float overlap = 0.0; for(ii=0; ii<nCell; ii++){ if( ii!=iExclude ){ int jj; float o = 1.0; for(jj=0; jj<(pRtree->nDim*2); jj+=2){ double x1; double x2; x1 = MAX(DCOORD(p->aCoord[jj]), DCOORD(aCell[ii].aCoord[jj])); x2 = MIN(DCOORD(p->aCoord[jj+1]), DCOORD(aCell[ii].aCoord[jj+1])); if( x2<x1 ){ o = 0.0; break; }else{ o = o * (x2-x1); } } overlap += o; } } return overlap; } 
#endif 
#if VARIANT_RSTARTREE_CHOOSESUBTREE 
static float cellOverlapEnlargement( Rtree *pRtree, RtreeCell *p, RtreeCell *pInsert, RtreeCell *aCell, int nCell, int iExclude ){ float before; float after; before = cellOverlap(pRtree, p, aCell, nCell, iExclude); cellUnion(pRtree, p, pInsert); after = cellOverlap(pRtree, p, aCell, nCell, iExclude); return after-before; } 
#endif 
static int ChooseLeaf( Rtree *pRtree, RtreeCell *pCell, int iHeight, RtreeNode **ppLeaf ){ int rc; int ii; RtreeNode *pNode; rc = nodeAcquire(pRtree, 1, 0, &pNode); for(ii=0; rc==SQLITE_OK && ii<(pRtree->iDepth-iHeight); ii++){ int iCell; sqlite3_int64 iBest; float fMinGrowth; float fMinArea; float fMinOverlap; int nCell = NCELL(pNode); RtreeCell cell; RtreeNode *pChild; RtreeCell *aCell = 0; 
#if VARIANT_RSTARTREE_CHOOSESUBTREE 
 if( ii==(pRtree->iDepth-1) ){ int jj; aCell = sqlite3_malloc(sizeof(RtreeCell)*nCell); if( !aCell ){ rc = SQLITE_NOMEM; nodeRelease(pRtree, pNode); pNode = 0; continue; } for(jj=0; jj<nCell; jj++){ nodeGetCell(pRtree, pNode, jj, &aCell[jj]); } } 
#endif 
 for(iCell=0; iCell<nCell; iCell++){ float growth; float area; float overlap = 0.0; nodeGetCell(pRtree, pNode, iCell, &cell); growth = cellGrowth(pRtree, &cell, pCell); area = cellArea(pRtree, &cell); 
#if VARIANT_RSTARTREE_CHOOSESUBTREE 
 if( ii==(pRtree->iDepth-1) ){ overlap = cellOverlapEnlargement(pRtree,&cell,pCell,aCell,nCell,iCell); } 
#endif 
 if( (iCell==0) || (overlap<fMinOverlap) || (overlap==fMinOverlap && growth<fMinGrowth) || (overlap==fMinOverlap && growth==fMinGrowth && area<fMinArea) ){ fMinOverlap = overlap; fMinGrowth = growth; fMinArea = area; iBest = cell.iRowid; } } sqlite3_free(aCell); rc = nodeAcquire(pRtree, iBest, pNode, &pChild); nodeRelease(pRtree, pNode); pNode = pChild; } *ppLeaf = pNode; return rc; } static void AdjustTree( Rtree *pRtree, RtreeNode *pNode, RtreeCell *pCell ){ RtreeNode *p = pNode; while( p->pParent ){ RtreeCell cell; RtreeNode *pParent = p->pParent; int iCell = nodeParentIndex(pRtree, p); nodeGetCell(pRtree, pParent, iCell, &cell); if( !cellContains(pRtree, &cell, pCell) ){ cellUnion(pRtree, &cell, pCell); nodeOverwriteCell(pRtree, pParent, &cell, iCell); } p = pParent; } } static int rowidWrite(Rtree *pRtree, sqlite3_int64 iRowid, sqlite3_int64 iNode){ sqlite3_bind_int64(pRtree->pWriteRowid, 1, iRowid); sqlite3_bind_int64(pRtree->pWriteRowid, 2, iNode); sqlite3_step(pRtree->pWriteRowid); return sqlite3_reset(pRtree->pWriteRowid); } static int parentWrite(Rtree *pRtree, sqlite3_int64 iNode, sqlite3_int64 iPar){ sqlite3_bind_int64(pRtree->pWriteParent, 1, iNode); sqlite3_bind_int64(pRtree->pWriteParent, 2, iPar); sqlite3_step(pRtree->pWriteParent); return sqlite3_reset(pRtree->pWriteParent); } static int rtreeInsertCell(Rtree *, RtreeNode *, RtreeCell *, int); 
#if VARIANT_GUTTMAN_LINEAR_SPLIT 
static RtreeCell *LinearPickNext( Rtree *pRtree, RtreeCell *aCell, int nCell, RtreeCell *pLeftBox, RtreeCell *pRightBox, int *aiUsed ){ int ii; for(ii=0; aiUsed[ii]; ii++); aiUsed[ii] = 1; return &aCell[ii]; } static void LinearPickSeeds( Rtree *pRtree, RtreeCell *aCell, int nCell, int *piLeftSeed, int *piRightSeed ){ int i; int iLeftSeed = 0; int iRightSeed = 1; float maxNormalInnerWidth = 0.0; for(i=0; i<pRtree->nDim; i++){ float x1 = aCell[0].aCoord[i*2]; float x2 = aCell[0].aCoord[i*2+1]; float x3 = x1; float x4 = x2; int jj; int iCellLeft = 0; int iCellRight = 0; for(jj=1; jj<nCell; jj++){ float left = aCell[jj].aCoord[i*2]; float right = aCell[jj].aCoord[i*2+1]; if( left<x1 ) x1 = left; if( right>x4 ) x4 = right; if( left>x3 ){ x3 = left; iCellRight = jj; } if( right<x2 ){ x2 = right; iCellLeft = jj; } } if( x4!=x1 ){ float normalwidth = (x3 - x2) / (x4 - x1); if( normalwidth>maxNormalInnerWidth ){ iLeftSeed = iCellLeft; iRightSeed = iCellRight; } } } *piLeftSeed = iLeftSeed; *piRightSeed = iRightSeed; } 
#endif 
#if VARIANT_GUTTMAN_QUADRATIC_SPLIT 
static RtreeCell *QuadraticPickNext( Rtree *pRtree, RtreeCell *aCell, int nCell, RtreeCell *pLeftBox, RtreeCell *pRightBox, int *aiUsed ){ 
#define FABS(a) ((a)<0.0?-1.0*(a):(a)) 
 int iSelect = -1; float fDiff; int ii; for(ii=0; ii<nCell; ii++){ if( aiUsed[ii]==0 ){ float left = cellGrowth(pRtree, pLeftBox, &aCell[ii]); float right = cellGrowth(pRtree, pLeftBox, &aCell[ii]); float diff = FABS(right-left); if( iSelect<0 || diff>fDiff ){ fDiff = diff; iSelect = ii; } } } aiUsed[iSelect] = 1; return &aCell[iSelect]; } static void QuadraticPickSeeds( Rtree *pRtree, RtreeCell *aCell, int nCell, int *piLeftSeed, int *piRightSeed ){ int ii; int jj; int iLeftSeed = 0; int iRightSeed = 1; float fWaste = 0.0; for(ii=0; ii<nCell; ii++){ for(jj=ii+1; jj<nCell; jj++){ float right = cellArea(pRtree, &aCell[jj]); float growth = cellGrowth(pRtree, &aCell[ii], &aCell[jj]); float waste = growth - right; if( waste>fWaste ){ iLeftSeed = ii; iRightSeed = jj; fWaste = waste; } } } *piLeftSeed = iLeftSeed; *piRightSeed = iRightSeed; } 
#endif 
static void SortByDistance( int *aIdx, int nIdx, float *aDistance, int *aSpare ){ if( nIdx>1 ){ int iLeft = 0; int iRight = 0; int nLeft = nIdx/2; int nRight = nIdx-nLeft; int *aLeft = aIdx; int *aRight = &aIdx[nLeft]; SortByDistance(aLeft, nLeft, aDistance, aSpare); SortByDistance(aRight, nRight, aDistance, aSpare); memcpy(aSpare, aLeft, sizeof(int)*nLeft); aLeft = aSpare; while( iLeft<nLeft || iRight<nRight ){ if( iLeft==nLeft ){ aIdx[iLeft+iRight] = aRight[iRight]; iRight++; }else if( iRight==nRight ){ aIdx[iLeft+iRight] = aLeft[iLeft]; iLeft++; }else{ float fLeft = aDistance[aLeft[iLeft]]; float fRight = aDistance[aRight[iRight]]; if( fLeft<fRight ){ aIdx[iLeft+iRight] = aLeft[iLeft]; iLeft++; }else{ aIdx[iLeft+iRight] = aRight[iRight]; iRight++; } } } 
#if 0 
 { int jj; for(jj=1; jj<nIdx; jj++){ float left = aDistance[aIdx[jj-1]]; float right = aDistance[aIdx[jj]]; assert( left<=right ); } } 
#endif 
 } } static void SortByDimension( Rtree *pRtree, int *aIdx, int nIdx, int iDim, RtreeCell *aCell, int *aSpare ){ if( nIdx>1 ){ int iLeft = 0; int iRight = 0; int nLeft = nIdx/2; int nRight = nIdx-nLeft; int *aLeft = aIdx; int *aRight = &aIdx[nLeft]; SortByDimension(pRtree, aLeft, nLeft, iDim, aCell, aSpare); SortByDimension(pRtree, aRight, nRight, iDim, aCell, aSpare); memcpy(aSpare, aLeft, sizeof(int)*nLeft); aLeft = aSpare; while( iLeft<nLeft || iRight<nRight ){ double xleft1 = DCOORD(aCell[aLeft[iLeft]].aCoord[iDim*2]); double xleft2 = DCOORD(aCell[aLeft[iLeft]].aCoord[iDim*2+1]); double xright1 = DCOORD(aCell[aRight[iRight]].aCoord[iDim*2]); double xright2 = DCOORD(aCell[aRight[iRight]].aCoord[iDim*2+1]); if( (iLeft!=nLeft) && ((iRight==nRight) || (xleft1<xright1) || (xleft1==xright1 && xleft2<xright2) )){ aIdx[iLeft+iRight] = aLeft[iLeft]; iLeft++; }else{ aIdx[iLeft+iRight] = aRight[iRight]; iRight++; } } 
#if 0 
 { int jj; for(jj=1; jj<nIdx; jj++){ float xleft1 = aCell[aIdx[jj-1]].aCoord[iDim*2]; float xleft2 = aCell[aIdx[jj-1]].aCoord[iDim*2+1]; float xright1 = aCell[aIdx[jj]].aCoord[iDim*2]; float xright2 = aCell[aIdx[jj]].aCoord[iDim*2+1]; assert( xleft1<=xright1 && (xleft1<xright1 || xleft2<=xright2) ); } } 
#endif 
 } } 
#if VARIANT_RSTARTREE_SPLIT 
static int splitNodeStartree( Rtree *pRtree, RtreeCell *aCell, int nCell, RtreeNode *pLeft, RtreeNode *pRight, RtreeCell *pBboxLeft, RtreeCell *pBboxRight ){ int **aaSorted; int *aSpare; int ii; int iBestDim; int iBestSplit; float fBestMargin; int nByte = (pRtree->nDim+1)*(sizeof(int*)+nCell*sizeof(int)); aaSorted = (int **)sqlite3_malloc(nByte); if( !aaSorted ){ return SQLITE_NOMEM; } aSpare = &((int *)&aaSorted[pRtree->nDim])[pRtree->nDim*nCell]; memset(aaSorted, 0, nByte); for(ii=0; ii<pRtree->nDim; ii++){ int jj; aaSorted[ii] = &((int *)&aaSorted[pRtree->nDim])[ii*nCell]; for(jj=0; jj<nCell; jj++){ aaSorted[ii][jj] = jj; } SortByDimension(pRtree, aaSorted[ii], nCell, ii, aCell, aSpare); } for(ii=0; ii<pRtree->nDim; ii++){ float margin = 0.0; float fBestOverlap; float fBestArea; int iBestLeft; int nLeft; for( nLeft=RTREE_MINCELLS(pRtree); nLeft<=(nCell-RTREE_MINCELLS(pRtree)); nLeft++ ){ RtreeCell left; RtreeCell right; int kk; float overlap; float area; memcpy(&left, &aCell[aaSorted[ii][0]], sizeof(RtreeCell)); memcpy(&right, &aCell[aaSorted[ii][nCell-1]], sizeof(RtreeCell)); for(kk=1; kk<(nCell-1); kk++){ if( kk<nLeft ){ cellUnion(pRtree, &left, &aCell[aaSorted[ii][kk]]); }else{ cellUnion(pRtree, &right, &aCell[aaSorted[ii][kk]]); } } margin += cellMargin(pRtree, &left); margin += cellMargin(pRtree, &right); overlap = cellOverlap(pRtree, &left, &right, 1, -1); area = cellArea(pRtree, &left) + cellArea(pRtree, &right); if( (nLeft==RTREE_MINCELLS(pRtree)) || (overlap<fBestOverlap) || (overlap==fBestOverlap && area<fBestArea) ){ iBestLeft = nLeft; fBestOverlap = overlap; fBestArea = area; } } if( ii==0 || margin<fBestMargin ){ iBestDim = ii; fBestMargin = margin; iBestSplit = iBestLeft; } } memcpy(pBboxLeft, &aCell[aaSorted[iBestDim][0]], sizeof(RtreeCell)); memcpy(pBboxRight, &aCell[aaSorted[iBestDim][iBestSplit]], sizeof(RtreeCell)); for(ii=0; ii<nCell; ii++){ RtreeNode *pTarget = (ii<iBestSplit)?pLeft:pRight; RtreeCell *pBbox = (ii<iBestSplit)?pBboxLeft:pBboxRight; RtreeCell *pCell = &aCell[aaSorted[iBestDim][ii]]; nodeInsertCell(pRtree, pTarget, pCell); cellUnion(pRtree, pBbox, pCell); } sqlite3_free(aaSorted); return SQLITE_OK; } 
#endif 
#if VARIANT_GUTTMAN_SPLIT 
static int splitNodeGuttman( Rtree *pRtree, RtreeCell *aCell, int nCell, RtreeNode *pLeft, RtreeNode *pRight, RtreeCell *pBboxLeft, RtreeCell *pBboxRight ){ int iLeftSeed = 0; int iRightSeed = 1; int *aiUsed; int i; aiUsed = sqlite3_malloc(sizeof(int)*nCell); memset(aiUsed, 0, sizeof(int)*nCell); PickSeeds(pRtree, aCell, nCell, &iLeftSeed, &iRightSeed); memcpy(pBboxLeft, &aCell[iLeftSeed], sizeof(RtreeCell)); memcpy(pBboxRight, &aCell[iRightSeed], sizeof(RtreeCell)); nodeInsertCell(pRtree, pLeft, &aCell[iLeftSeed]); nodeInsertCell(pRtree, pRight, &aCell[iRightSeed]); aiUsed[iLeftSeed] = 1; aiUsed[iRightSeed] = 1; for(i=nCell-2; i>0; i--){ RtreeCell *pNext; pNext = PickNext(pRtree, aCell, nCell, pBboxLeft, pBboxRight, aiUsed); float diff = cellGrowth(pRtree, pBboxLeft, pNext) - cellGrowth(pRtree, pBboxRight, pNext) ; if( (RTREE_MINCELLS(pRtree)-NCELL(pRight)==i) || (diff>0.0 && (RTREE_MINCELLS(pRtree)-NCELL(pLeft)!=i)) ){ nodeInsertCell(pRtree, pRight, pNext); cellUnion(pRtree, pBboxRight, pNext); }else{ nodeInsertCell(pRtree, pLeft, pNext); cellUnion(pRtree, pBboxLeft, pNext); } } sqlite3_free(aiUsed); return SQLITE_OK; } 
#endif 
static int updateMapping( Rtree *pRtree, i64 iRowid, RtreeNode *pNode, int iHeight ){ int (*xSetMapping)(Rtree *, sqlite3_int64, sqlite3_int64); xSetMapping = ((iHeight==0)?rowidWrite:parentWrite); if( iHeight>0 ){ RtreeNode *pChild = nodeHashLookup(pRtree, iRowid); if( pChild ){ nodeRelease(pRtree, pChild->pParent); nodeReference(pNode); pChild->pParent = pNode; } } return xSetMapping(pRtree, iRowid, pNode->iNode); } static int SplitNode( Rtree *pRtree, RtreeNode *pNode, RtreeCell *pCell, int iHeight ){ int i; int newCellIsRight = 0; int rc = SQLITE_OK; int nCell = NCELL(pNode); RtreeCell *aCell; int *aiUsed; RtreeNode *pLeft = 0; RtreeNode *pRight = 0; RtreeCell leftbbox; RtreeCell rightbbox; aCell = sqlite3_malloc((sizeof(RtreeCell)+sizeof(int))*(nCell+1)); if( !aCell ){ rc = SQLITE_NOMEM; goto splitnode_out; } aiUsed = (int *)&aCell[nCell+1]; memset(aiUsed, 0, sizeof(int)*(nCell+1)); for(i=0; i<nCell; i++){ nodeGetCell(pRtree, pNode, i, &aCell[i]); } nodeZero(pRtree, pNode); memcpy(&aCell[nCell], pCell, sizeof(RtreeCell)); nCell++; if( pNode->iNode==1 ){ pRight = nodeNew(pRtree, pNode, 1); pLeft = nodeNew(pRtree, pNode, 1); pRtree->iDepth++; pNode->isDirty = 1; writeInt16(pNode->zData, pRtree->iDepth); }else{ pLeft = pNode; pRight = nodeNew(pRtree, pLeft->pParent, 1); nodeReference(pLeft); } if( !pLeft || !pRight ){ rc = SQLITE_NOMEM; goto splitnode_out; } memset(pLeft->zData, 0, pRtree->iNodeSize); memset(pRight->zData, 0, pRtree->iNodeSize); rc = AssignCells(pRtree, aCell, nCell, pLeft, pRight, &leftbbox, &rightbbox); if( rc!=SQLITE_OK ){ goto splitnode_out; } if( (0==pRight->iNode && SQLITE_OK!=(rc = nodeWrite(pRtree, pRight))) || (0==pLeft->iNode && SQLITE_OK!=(rc = nodeWrite(pRtree, pLeft))) ){ goto splitnode_out; } rightbbox.iRowid = pRight->iNode; leftbbox.iRowid = pLeft->iNode; if( pNode->iNode==1 ){ rc = rtreeInsertCell(pRtree, pLeft->pParent, &leftbbox, iHeight+1); if( rc!=SQLITE_OK ){ goto splitnode_out; } }else{ RtreeNode *pParent = pLeft->pParent; int iCell = nodeParentIndex(pRtree, pLeft); nodeOverwriteCell(pRtree, pParent, &leftbbox, iCell); AdjustTree(pRtree, pParent, &leftbbox); } if( (rc = rtreeInsertCell(pRtree, pRight->pParent, &rightbbox, iHeight+1)) ){ goto splitnode_out; } for(i=0; i<NCELL(pRight); i++){ i64 iRowid = nodeGetRowid(pRtree, pRight, i); rc = updateMapping(pRtree, iRowid, pRight, iHeight); if( iRowid==pCell->iRowid ){ newCellIsRight = 1; } if( rc!=SQLITE_OK ){ goto splitnode_out; } } if( pNode->iNode==1 ){ for(i=0; i<NCELL(pLeft); i++){ i64 iRowid = nodeGetRowid(pRtree, pLeft, i); rc = updateMapping(pRtree, iRowid, pLeft, iHeight); if( rc!=SQLITE_OK ){ goto splitnode_out; } } }else if( newCellIsRight==0 ){ rc = updateMapping(pRtree, pCell->iRowid, pLeft, iHeight); } if( rc==SQLITE_OK ){ rc = nodeRelease(pRtree, pRight); pRight = 0; } if( rc==SQLITE_OK ){ rc = nodeRelease(pRtree, pLeft); pLeft = 0; } splitnode_out: nodeRelease(pRtree, pRight); nodeRelease(pRtree, pLeft); sqlite3_free(aCell); return rc; } static int fixLeafParent(Rtree *pRtree, RtreeNode *pLeaf){ int rc = SQLITE_OK; if( pLeaf->iNode!=1 && pLeaf->pParent==0 ){ sqlite3_bind_int64(pRtree->pReadParent, 1, pLeaf->iNode); if( sqlite3_step(pRtree->pReadParent)==SQLITE_ROW ){ i64 iNode = sqlite3_column_int64(pRtree->pReadParent, 0); rc = nodeAcquire(pRtree, iNode, 0, &pLeaf->pParent); }else{ rc = SQLITE_ERROR; } sqlite3_reset(pRtree->pReadParent); if( rc==SQLITE_OK ){ rc = fixLeafParent(pRtree, pLeaf->pParent); } } return rc; } static int deleteCell(Rtree *, RtreeNode *, int, int); static int removeNode(Rtree *pRtree, RtreeNode *pNode, int iHeight){ int rc; RtreeNode *pParent; int iCell; assert( pNode->nRef==1 ); iCell = nodeParentIndex(pRtree, pNode); pParent = pNode->pParent; pNode->pParent = 0; if( SQLITE_OK!=(rc = deleteCell(pRtree, pParent, iCell, iHeight+1)) || SQLITE_OK!=(rc = nodeRelease(pRtree, pParent)) ){ return rc; } sqlite3_bind_int64(pRtree->pDeleteNode, 1, pNode->iNode); sqlite3_step(pRtree->pDeleteNode); if( SQLITE_OK!=(rc = sqlite3_reset(pRtree->pDeleteNode)) ){ return rc; } sqlite3_bind_int64(pRtree->pDeleteParent, 1, pNode->iNode); sqlite3_step(pRtree->pDeleteParent); if( SQLITE_OK!=(rc = sqlite3_reset(pRtree->pDeleteParent)) ){ return rc; } nodeHashDelete(pRtree, pNode); pNode->iNode = iHeight; pNode->pNext = pRtree->pDeleted; pNode->nRef++; pRtree->pDeleted = pNode; return SQLITE_OK; } static void fixBoundingBox(Rtree *pRtree, RtreeNode *pNode){ RtreeNode *pParent = pNode->pParent; if( pParent ){ int ii; int nCell = NCELL(pNode); RtreeCell box; nodeGetCell(pRtree, pNode, 0, &box); for(ii=1; ii<nCell; ii++){ RtreeCell cell; nodeGetCell(pRtree, pNode, ii, &cell); cellUnion(pRtree, &box, &cell); } box.iRowid = pNode->iNode; ii = nodeParentIndex(pRtree, pNode); nodeOverwriteCell(pRtree, pParent, &box, ii); fixBoundingBox(pRtree, pParent); } } static int deleteCell(Rtree *pRtree, RtreeNode *pNode, int iCell, int iHeight){ int rc; if( SQLITE_OK!=(rc = fixLeafParent(pRtree, pNode)) ){ return rc; } nodeDeleteCell(pRtree, pNode, iCell); if( pNode->iNode!=1 ){ RtreeNode *pParent = pNode->pParent; if( (pParent->iNode!=1 || NCELL(pParent)!=1) && (NCELL(pNode)<RTREE_MINCELLS(pRtree)) ){ rc = removeNode(pRtree, pNode, iHeight); }else{ fixBoundingBox(pRtree, pNode); } } return rc; } static int Reinsert( Rtree *pRtree, RtreeNode *pNode, RtreeCell *pCell, int iHeight ){ int *aOrder; int *aSpare; RtreeCell *aCell; float *aDistance; int nCell; float aCenterCoord[RTREE_MAX_DIMENSIONS]; int iDim; int ii; int rc = SQLITE_OK; memset(aCenterCoord, 0, sizeof(float)*RTREE_MAX_DIMENSIONS); nCell = NCELL(pNode)+1; aCell = (RtreeCell *)sqlite3_malloc(nCell * ( sizeof(RtreeCell) + sizeof(int) + sizeof(int) + sizeof(float) )); if( !aCell ){ return SQLITE_NOMEM; } aOrder = (int *)&aCell[nCell]; aSpare = (int *)&aOrder[nCell]; aDistance = (float *)&aSpare[nCell]; for(ii=0; ii<nCell; ii++){ if( ii==(nCell-1) ){ memcpy(&aCell[ii], pCell, sizeof(RtreeCell)); }else{ nodeGetCell(pRtree, pNode, ii, &aCell[ii]); } aOrder[ii] = ii; for(iDim=0; iDim<pRtree->nDim; iDim++){ aCenterCoord[iDim] += DCOORD(aCell[ii].aCoord[iDim*2]); aCenterCoord[iDim] += DCOORD(aCell[ii].aCoord[iDim*2+1]); } } for(iDim=0; iDim<pRtree->nDim; iDim++){ aCenterCoord[iDim] = aCenterCoord[iDim]/((float)nCell*2.0); } for(ii=0; ii<nCell; ii++){ aDistance[ii] = 0.0; for(iDim=0; iDim<pRtree->nDim; iDim++){ float coord = DCOORD(aCell[ii].aCoord[iDim*2+1]) - DCOORD(aCell[ii].aCoord[iDim*2]); aDistance[ii] += (coord-aCenterCoord[iDim])*(coord-aCenterCoord[iDim]); } } SortByDistance(aOrder, nCell, aDistance, aSpare); nodeZero(pRtree, pNode); for(ii=0; rc==SQLITE_OK && ii<(nCell-(RTREE_MINCELLS(pRtree)+1)); ii++){ RtreeCell *p = &aCell[aOrder[ii]]; nodeInsertCell(pRtree, pNode, p); if( p->iRowid==pCell->iRowid ){ if( iHeight==0 ){ rc = rowidWrite(pRtree, p->iRowid, pNode->iNode); }else{ rc = parentWrite(pRtree, p->iRowid, pNode->iNode); } } } if( rc==SQLITE_OK ){ fixBoundingBox(pRtree, pNode); } for(; rc==SQLITE_OK && ii<nCell; ii++){ RtreeNode *pInsert; RtreeCell *p = &aCell[aOrder[ii]]; rc = ChooseLeaf(pRtree, p, iHeight, &pInsert); if( rc==SQLITE_OK ){ int rc2; rc = rtreeInsertCell(pRtree, pInsert, p, iHeight); rc2 = nodeRelease(pRtree, pInsert); if( rc==SQLITE_OK ){ rc = rc2; } } } sqlite3_free(aCell); return rc; } static int rtreeInsertCell( Rtree *pRtree, RtreeNode *pNode, RtreeCell *pCell, int iHeight ){ int rc = SQLITE_OK; if( iHeight>0 ){ RtreeNode *pChild = nodeHashLookup(pRtree, pCell->iRowid); if( pChild ){ nodeRelease(pRtree, pChild->pParent); nodeReference(pNode); pChild->pParent = pNode; } } if( nodeInsertCell(pRtree, pNode, pCell) ){ 
#if VARIANT_RSTARTREE_REINSERT 
 if( iHeight<=pRtree->iReinsertHeight || pNode->iNode==1){ rc = SplitNode(pRtree, pNode, pCell, iHeight); }else{ pRtree->iReinsertHeight = iHeight; rc = Reinsert(pRtree, pNode, pCell, iHeight); } 
#else 
 rc = SplitNode(pRtree, pNode, pCell, iHeight); 
#endif 
 }else{ AdjustTree(pRtree, pNode, pCell); if( iHeight==0 ){ rc = rowidWrite(pRtree, pCell->iRowid, pNode->iNode); }else{ rc = parentWrite(pRtree, pCell->iRowid, pNode->iNode); } } return rc; } static int reinsertNodeContent(Rtree *pRtree, RtreeNode *pNode){ int ii; int rc = SQLITE_OK; int nCell = NCELL(pNode); for(ii=0; rc==SQLITE_OK && ii<nCell; ii++){ RtreeNode *pInsert; RtreeCell cell; nodeGetCell(pRtree, pNode, ii, &cell); rc = ChooseLeaf(pRtree, &cell, pNode->iNode, &pInsert); if( rc==SQLITE_OK ){ int rc2; rc = rtreeInsertCell(pRtree, pInsert, &cell, pNode->iNode); rc2 = nodeRelease(pRtree, pInsert); if( rc==SQLITE_OK ){ rc = rc2; } } } return rc; } static int newRowid(Rtree *pRtree, i64 *piRowid){ int rc; sqlite3_bind_null(pRtree->pWriteRowid, 1); sqlite3_bind_null(pRtree->pWriteRowid, 2); sqlite3_step(pRtree->pWriteRowid); rc = sqlite3_reset(pRtree->pWriteRowid); *piRowid = sqlite3_last_insert_rowid(pRtree->db); return rc; } 
#ifndef NDEBUG 
static int hashIsEmpty(Rtree *pRtree){ int ii; for(ii=0; ii<HASHSIZE; ii++){ assert( !pRtree->aHash[ii] ); } return 1; } 
#endif 
int rtreeUpdate( sqlite3_vtab *pVtab, int nData, sqlite3_value **azData, sqlite_int64 *pRowid ){ Rtree *pRtree = (Rtree *)pVtab; int rc = SQLITE_OK; rtreeReference(pRtree); assert(nData>=1); assert(hashIsEmpty(pRtree)); if( sqlite3_value_type(azData[0])!=SQLITE_NULL ){ i64 iDelete; RtreeNode *pLeaf; int iCell; RtreeNode *pRoot; rc = nodeAcquire(pRtree, 1, 0, &pRoot); if( rc==SQLITE_OK ){ iDelete = sqlite3_value_int64(azData[0]); rc = findLeafNode(pRtree, iDelete, &pLeaf); } if( rc==SQLITE_OK ){ int rc2; iCell = nodeRowidIndex(pRtree, pLeaf, iDelete); rc = deleteCell(pRtree, pLeaf, iCell, 0); rc2 = nodeRelease(pRtree, pLeaf); if( rc==SQLITE_OK ){ rc = rc2; } } if( rc==SQLITE_OK ){ sqlite3_bind_int64(pRtree->pDeleteRowid, 1, iDelete); sqlite3_step(pRtree->pDeleteRowid); rc = sqlite3_reset(pRtree->pDeleteRowid); } if( rc==SQLITE_OK && pRtree->iDepth>0 ){ if( rc==SQLITE_OK && NCELL(pRoot)==1 ){ RtreeNode *pChild; i64 iChild = nodeGetRowid(pRtree, pRoot, 0); rc = nodeAcquire(pRtree, iChild, pRoot, &pChild); if( rc==SQLITE_OK ){ rc = removeNode(pRtree, pChild, pRtree->iDepth-1); } if( rc==SQLITE_OK ){ pRtree->iDepth--; writeInt16(pRoot->zData, pRtree->iDepth); pRoot->isDirty = 1; } } } for(pLeaf=pRtree->pDeleted; pLeaf; pLeaf=pRtree->pDeleted){ if( rc==SQLITE_OK ){ rc = reinsertNodeContent(pRtree, pLeaf); } pRtree->pDeleted = pLeaf->pNext; sqlite3_free(pLeaf); } if( rc==SQLITE_OK ){ rc = nodeRelease(pRtree, pRoot); }else{ nodeRelease(pRtree, pRoot); } } if( rc==SQLITE_OK && nData>1 ){ RtreeCell cell; int ii; RtreeNode *pLeaf; assert( nData==(pRtree->nDim*2 + 3) ); if( pRtree->eCoordType==RTREE_COORD_REAL32 ){ for(ii=0; ii<(pRtree->nDim*2); ii+=2){ cell.aCoord[ii].f = (float)sqlite3_value_double(azData[ii+3]); cell.aCoord[ii+1].f = (float)sqlite3_value_double(azData[ii+4]); if( cell.aCoord[ii].f>cell.aCoord[ii+1].f ){ rc = SQLITE_CONSTRAINT; goto constraint; } } }else{ for(ii=0; ii<(pRtree->nDim*2); ii+=2){ cell.aCoord[ii].i = sqlite3_value_int(azData[ii+3]); cell.aCoord[ii+1].i = sqlite3_value_int(azData[ii+4]); if( cell.aCoord[ii].i>cell.aCoord[ii+1].i ){ rc = SQLITE_CONSTRAINT; goto constraint; } } } if( sqlite3_value_type(azData[2])==SQLITE_NULL ){ rc = newRowid(pRtree, &cell.iRowid); }else{ cell.iRowid = sqlite3_value_int64(azData[2]); sqlite3_bind_int64(pRtree->pReadRowid, 1, cell.iRowid); if( SQLITE_ROW==sqlite3_step(pRtree->pReadRowid) ){ sqlite3_reset(pRtree->pReadRowid); rc = SQLITE_CONSTRAINT; goto constraint; } rc = sqlite3_reset(pRtree->pReadRowid); } if( rc==SQLITE_OK ){ rc = ChooseLeaf(pRtree, &cell, 0, &pLeaf); } if( rc==SQLITE_OK ){ int rc2; pRtree->iReinsertHeight = -1; rc = rtreeInsertCell(pRtree, pLeaf, &cell, 0); rc2 = nodeRelease(pRtree, pLeaf); if( rc==SQLITE_OK ){ rc = rc2; } } } constraint: rtreeRelease(pRtree); return rc; } static int rtreeRename(sqlite3_vtab *pVtab, const char *zNewName){ Rtree *pRtree = (Rtree *)pVtab; int rc = SQLITE_NOMEM; char *zSql = sqlite3_mprintf( "ALTER TABLE %Q.'%q_node' RENAME TO \"%w_node\";" "ALTER TABLE %Q.'%q_parent' RENAME TO \"%w_parent\";" "ALTER TABLE %Q.'%q_rowid' RENAME TO \"%w_rowid\";" , pRtree->zDb, pRtree->zName, zNewName , pRtree->zDb, pRtree->zName, zNewName , pRtree->zDb, pRtree->zName, zNewName ); if( zSql ){ rc = sqlite3_exec(pRtree->db, zSql, 0, 0, 0); sqlite3_free(zSql); } return rc; } static sqlite3_module rtreeModule = { 0, rtreeCreate, rtreeConnect, rtreeBestIndex, rtreeDisconnect, rtreeDestroy, rtreeOpen, rtreeClose, rtreeFilter, rtreeNext, rtreeEof, rtreeColumn, rtreeRowid, rtreeUpdate, 0, 0, 0, 0, 0, rtreeRename }; static int rtreeSqlInit( Rtree *pRtree, sqlite3 *db, const char *zDb, const char *zPrefix, int isCreate ){ int rc = SQLITE_OK; 
#define N_STATEMENT 9 
 static const char *azSql[N_STATEMENT] = { "SELECT data FROM '%q'.'%q_node' WHERE nodeno = :1", "INSERT OR REPLACE INTO '%q'.'%q_node' VALUES(:1, :2)", "DELETE FROM '%q'.'%q_node' WHERE nodeno = :1", "SELECT nodeno FROM '%q'.'%q_rowid' WHERE rowid = :1", "INSERT OR REPLACE INTO '%q'.'%q_rowid' VALUES(:1, :2)", "DELETE FROM '%q'.'%q_rowid' WHERE rowid = :1", "SELECT parentnode FROM '%q'.'%q_parent' WHERE nodeno = :1", "INSERT OR REPLACE INTO '%q'.'%q_parent' VALUES(:1, :2)", "DELETE FROM '%q'.'%q_parent' WHERE nodeno = :1" }; sqlite3_stmt **appStmt[N_STATEMENT]; int i; pRtree->db = db; if( isCreate ){ char *zCreate = sqlite3_mprintf( "CREATE TABLE \"%w\".\"%w_node\"(nodeno INTEGER PRIMARY KEY, data BLOB);" "CREATE TABLE \"%w\".\"%w_rowid\"(rowid INTEGER PRIMARY KEY, nodeno INTEGER);" "CREATE TABLE \"%w\".\"%w_parent\"(nodeno INTEGER PRIMARY KEY, parentnode INTEGER);" "INSERT INTO '%q'.'%q_node' VALUES(1, zeroblob(%d))", zDb, zPrefix, zDb, zPrefix, zDb, zPrefix, zDb, zPrefix, pRtree->iNodeSize ); if( !zCreate ){ return SQLITE_NOMEM; } rc = sqlite3_exec(db, zCreate, 0, 0, 0); sqlite3_free(zCreate); if( rc!=SQLITE_OK ){ return rc; } } appStmt[0] = &pRtree->pReadNode; appStmt[1] = &pRtree->pWriteNode; appStmt[2] = &pRtree->pDeleteNode; appStmt[3] = &pRtree->pReadRowid; appStmt[4] = &pRtree->pWriteRowid; appStmt[5] = &pRtree->pDeleteRowid; appStmt[6] = &pRtree->pReadParent; appStmt[7] = &pRtree->pWriteParent; appStmt[8] = &pRtree->pDeleteParent; for(i=0; i<N_STATEMENT && rc==SQLITE_OK; i++){ char *zSql = sqlite3_mprintf(azSql[i], zDb, zPrefix); if( zSql ){ rc = sqlite3_prepare_v2(db, zSql, -1, appStmt[i], 0); }else{ rc = SQLITE_NOMEM; } sqlite3_free(zSql); } return rc; } static int getPageSize(sqlite3 *db, const char *zDb, int *piPageSize){ int rc = SQLITE_NOMEM; char *zSql; sqlite3_stmt *pStmt = 0; zSql = sqlite3_mprintf("PRAGMA %Q.page_size", zDb); if( !zSql ){ return SQLITE_NOMEM; } rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0); sqlite3_free(zSql); if( rc!=SQLITE_OK ){ return rc; } if( SQLITE_ROW==sqlite3_step(pStmt) ){ *piPageSize = sqlite3_column_int(pStmt, 0); } return sqlite3_finalize(pStmt); } static int rtreeInit( sqlite3 *db, void *pAux, int argc, const char *const*argv, sqlite3_vtab **ppVtab, char **pzErr, int isCreate ){ int rc = SQLITE_OK; int iPageSize = 0; Rtree *pRtree; int nDb; int nName; int eCoordType = (int)pAux; const char *aErrMsg[] = { 0, "Wrong number of columns for an rtree table", "Too few columns for an rtree table", "Too many columns for an rtree table" }; int iErr = (argc<6) ? 2 : argc>(RTREE_MAX_DIMENSIONS*2+4) ? 3 : argc%2; if( aErrMsg[iErr] ){ *pzErr = sqlite3_mprintf("%s", aErrMsg[iErr]); return SQLITE_ERROR; } rc = getPageSize(db, argv[1], &iPageSize); if( rc!=SQLITE_OK ){ return rc; } nDb = strlen(argv[1]); nName = strlen(argv[2]); pRtree = (Rtree *)sqlite3_malloc(sizeof(Rtree)+nDb+nName+2); if( !pRtree ){ return SQLITE_NOMEM; } memset(pRtree, 0, sizeof(Rtree)+nDb+nName+2); pRtree->nBusy = 1; pRtree->base.pModule = &rtreeModule; pRtree->zDb = (char *)&pRtree[1]; pRtree->zName = &pRtree->zDb[nDb+1]; pRtree->nDim = (argc-4)/2; pRtree->nBytesPerCell = 8 + pRtree->nDim*4*2; pRtree->eCoordType = eCoordType; memcpy(pRtree->zDb, argv[1], nDb); memcpy(pRtree->zName, argv[2], nName); pRtree->iNodeSize = iPageSize-64; if( (4+pRtree->nBytesPerCell*RTREE_MAXCELLS)<pRtree->iNodeSize ){ pRtree->iNodeSize = 4+pRtree->nBytesPerCell*RTREE_MAXCELLS; } if( (rc = rtreeSqlInit(pRtree, db, argv[1], argv[2], isCreate)) ){ *pzErr = sqlite3_mprintf("%s", sqlite3_errmsg(db)); }else{ char *zSql = sqlite3_mprintf("CREATE TABLE x(%s", argv[3]); char *zTmp; int ii; for(ii=4; zSql && ii<argc; ii++){ zTmp = zSql; zSql = sqlite3_mprintf("%s, %s", zTmp, argv[ii]); sqlite3_free(zTmp); } if( zSql ){ zTmp = zSql; zSql = sqlite3_mprintf("%s);", zTmp); sqlite3_free(zTmp); } if( !zSql || sqlite3_declare_vtab(db, zSql) ){ rc = SQLITE_NOMEM; } sqlite3_free(zSql); } if( rc==SQLITE_OK ){ *ppVtab = (sqlite3_vtab *)pRtree; }else{ rtreeRelease(pRtree); } return rc; } static void rtreenode(sqlite3_context *ctx, int nArg, sqlite3_value **apArg){ char *zText = 0; RtreeNode node; Rtree tree; int ii; memset(&node, 0, sizeof(RtreeNode)); memset(&tree, 0, sizeof(Rtree)); tree.nDim = sqlite3_value_int(apArg[0]); tree.nBytesPerCell = 8 + 8 * tree.nDim; node.zData = (u8 *)sqlite3_value_blob(apArg[1]); for(ii=0; ii<NCELL(&node); ii++){ char zCell[512]; int nCell = 0; RtreeCell cell; int jj; nodeGetCell(&tree, &node, ii, &cell); sqlite3_snprintf(512-nCell,&zCell[nCell],"%d", cell.iRowid); nCell = strlen(zCell); for(jj=0; jj<tree.nDim*2; jj++){ sqlite3_snprintf(512-nCell,&zCell[nCell]," %f",(double)cell.aCoord[jj].f); nCell = strlen(zCell); } if( zText ){ char *zTextNew = sqlite3_mprintf("%s {%s}", zText, zCell); sqlite3_free(zText); zText = zTextNew; }else{ zText = sqlite3_mprintf("{%s}", zCell); } } sqlite3_result_text(ctx, zText, -1, sqlite3_free); } static void rtreedepth(sqlite3_context *ctx, int nArg, sqlite3_value **apArg){ if( sqlite3_value_type(apArg[0])!=SQLITE_BLOB || sqlite3_value_bytes(apArg[0])<2 ){ sqlite3_result_error(ctx, "Invalid argument to rtreedepth()", -1); }else{ u8 *zBlob = (u8 *)sqlite3_value_blob(apArg[0]); sqlite3_result_int(ctx, readInt16(zBlob)); } } SQLITE_PRIVATE int sqlite3RtreeInit(sqlite3 *db){ int rc = SQLITE_OK; if( rc==SQLITE_OK ){ int utf8 = SQLITE_UTF8; rc = sqlite3_create_function(db, "rtreenode", 2, utf8, 0, rtreenode, 0, 0); } if( rc==SQLITE_OK ){ int utf8 = SQLITE_UTF8; rc = sqlite3_create_function(db, "rtreedepth", 1, utf8, 0,rtreedepth, 0, 0); } if( rc==SQLITE_OK ){ void *c = (void *)RTREE_COORD_REAL32; rc = sqlite3_create_module_v2(db, "rtree", &rtreeModule, c, 0); } if( rc==SQLITE_OK ){ void *c = (void *)RTREE_COORD_INT32; rc = sqlite3_create_module_v2(db, "rtree_i32", &rtreeModule, c, 0); } return rc; } 
#if !SQLITE_CORE 
SQLITE_API int sqlite3_extension_init( sqlite3 *db, char **pzErrMsg, const sqlite3_api_routines *pApi ){ SQLITE_EXTENSION_INIT2(pApi) return sqlite3RtreeInit(db); } 
#endif 
#endif 
#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_ICU) 
#include <unicode/utypes.h> 
#include <unicode/uregex.h> 
#include <unicode/ustring.h> 
#include <unicode/ucol.h> 
#ifndef SQLITE_CORE 
 SQLITE_EXTENSION_INIT1 
#else 
#endif 
#ifndef SQLITE_MAX_LIKE_PATTERN_LENGTH 
#define SQLITE_MAX_LIKE_PATTERN_LENGTH 50000 
#endif 
static void xFree(void *p){ sqlite3_free(p); } static int icuLikeCompare( const uint8_t *zPattern, const uint8_t *zString, const UChar32 uEsc ){ static const int MATCH_ONE = (UChar32)'_'; static const int MATCH_ALL = (UChar32)'%'; int iPattern = 0; int iString = 0; int prevEscape = 0; while( zPattern[iPattern]!=0 ){ UChar32 uPattern; U8_NEXT_UNSAFE(zPattern, iPattern, uPattern); assert(uPattern!=0); if( !prevEscape && uPattern==MATCH_ALL ){ uint8_t c; while( (c=zPattern[iPattern]) == MATCH_ALL || c == MATCH_ONE ){ if( c==MATCH_ONE ){ if( zString[iString]==0 ) return 0; U8_FWD_1_UNSAFE(zString, iString); } iPattern++; } if( zPattern[iPattern]==0 ) return 1; while( zString[iString] ){ if( icuLikeCompare(&zPattern[iPattern], &zString[iString], uEsc) ){ return 1; } U8_FWD_1_UNSAFE(zString, iString); } return 0; }else if( !prevEscape && uPattern==MATCH_ONE ){ if( zString[iString]==0 ) return 0; U8_FWD_1_UNSAFE(zString, iString); }else if( !prevEscape && uPattern==uEsc){ prevEscape = 1; }else{ UChar32 uString; U8_NEXT_UNSAFE(zString, iString, uString); uString = u_foldCase(uString, U_FOLD_CASE_DEFAULT); uPattern = u_foldCase(uPattern, U_FOLD_CASE_DEFAULT); if( uString!=uPattern ){ return 0; } prevEscape = 0; } } return zString[iString]==0; } static void icuLikeFunc( sqlite3_context *context, int argc, sqlite3_value **argv ){ const unsigned char *zA = sqlite3_value_text(argv[0]); const unsigned char *zB = sqlite3_value_text(argv[1]); UChar32 uEsc = 0; if( sqlite3_value_bytes(argv[0])>SQLITE_MAX_LIKE_PATTERN_LENGTH ){ sqlite3_result_error(context, "LIKE or GLOB pattern too complex", -1); return; } if( argc==3 ){ int nE= sqlite3_value_bytes(argv[2]); const unsigned char *zE = sqlite3_value_text(argv[2]); int i = 0; if( zE==0 ) return; U8_NEXT(zE, i, nE, uEsc); if( i!=nE){ sqlite3_result_error(context, "ESCAPE expression must be a single character", -1); return; } } if( zA && zB ){ sqlite3_result_int(context, icuLikeCompare(zA, zB, uEsc)); } } static void icuFunctionError( sqlite3_context *pCtx, const char *zName, UErrorCode e ){ char zBuf[128]; sqlite3_snprintf(128, zBuf, "ICU error: %s(): %s", zName, u_errorName(e)); zBuf[127] = '\0'; sqlite3_result_error(pCtx, zBuf, -1); } static void icuRegexpDelete(void *p){ URegularExpression *pExpr = (URegularExpression *)p; uregex_close(pExpr); } static void icuRegexpFunc(sqlite3_context *p, int nArg, sqlite3_value **apArg){ UErrorCode status = U_ZERO_ERROR; URegularExpression *pExpr; UBool res; const UChar *zString = sqlite3_value_text16(apArg[1]); if( !zString ){ return; } pExpr = sqlite3_get_auxdata(p, 0); if( !pExpr ){ const UChar *zPattern = sqlite3_value_text16(apArg[0]); if( !zPattern ){ return; } pExpr = uregex_open(zPattern, -1, 0, 0, &status); if( U_SUCCESS(status) ){ sqlite3_set_auxdata(p, 0, pExpr, icuRegexpDelete); }else{ assert(!pExpr); icuFunctionError(p, "uregex_open", status); return; } } uregex_setText(pExpr, zString, -1, &status); if( !U_SUCCESS(status) ){ icuFunctionError(p, "uregex_setText", status); return; } res = uregex_matches(pExpr, 0, &status); if( !U_SUCCESS(status) ){ icuFunctionError(p, "uregex_matches", status); return; } uregex_setText(pExpr, 0, 0, &status); sqlite3_result_int(p, res ? 1 : 0); } static void icuCaseFunc16(sqlite3_context *p, int nArg, sqlite3_value **apArg){ const UChar *zInput; UChar *zOutput; int nInput; int nOutput; UErrorCode status = U_ZERO_ERROR; const char *zLocale = 0; assert(nArg==1 || nArg==2); if( nArg==2 ){ zLocale = (const char *)sqlite3_value_text(apArg[1]); } zInput = sqlite3_value_text16(apArg[0]); if( !zInput ){ return; } nInput = sqlite3_value_bytes16(apArg[0]); nOutput = nInput * 2 + 2; zOutput = sqlite3_malloc(nOutput); if( !zOutput ){ return; } if( sqlite3_user_data(p) ){ u_strToUpper(zOutput, nOutput/2, zInput, nInput/2, zLocale, &status); }else{ u_strToLower(zOutput, nOutput/2, zInput, nInput/2, zLocale, &status); } if( !U_SUCCESS(status) ){ icuFunctionError(p, "u_strToLower()/u_strToUpper", status); return; } sqlite3_result_text16(p, zOutput, -1, xFree); } static void icuCollationDel(void *pCtx){ UCollator *p = (UCollator *)pCtx; ucol_close(p); } static int icuCollationColl( void *pCtx, int nLeft, const void *zLeft, int nRight, const void *zRight ){ UCollationResult res; UCollator *p = (UCollator *)pCtx; res = ucol_strcoll(p, (UChar *)zLeft, nLeft/2, (UChar *)zRight, nRight/2); switch( res ){ case UCOL_LESS: return -1; case UCOL_GREATER: return +1; case UCOL_EQUAL: return 0; } assert(!"Unexpected return value from ucol_strcoll()"); return 0; } static void icuLoadCollation( sqlite3_context *p, int nArg, sqlite3_value **apArg ){ sqlite3 *db = (sqlite3 *)sqlite3_user_data(p); UErrorCode status = U_ZERO_ERROR; const char *zLocale; const char *zName; UCollator *pUCollator; int rc; assert(nArg==2); zLocale = (const char *)sqlite3_value_text(apArg[0]); zName = (const char *)sqlite3_value_text(apArg[1]); if( !zLocale || !zName ){ return; } pUCollator = ucol_open(zLocale, &status); if( !U_SUCCESS(status) ){ icuFunctionError(p, "ucol_open", status); return; } assert(p); rc = sqlite3_create_collation_v2(db, zName, SQLITE_UTF16, (void *)pUCollator, icuCollationColl, icuCollationDel ); if( rc!=SQLITE_OK ){ ucol_close(pUCollator); sqlite3_result_error(p, "Error registering collation function", -1); } } SQLITE_PRIVATE int sqlite3IcuInit(sqlite3 *db){ struct IcuScalar { const char *zName; int nArg; int enc; void *pContext; void (*xFunc)(sqlite3_context*,int,sqlite3_value**); } scalars[] = { {"regexp",-1, SQLITE_ANY, 0, icuRegexpFunc}, {"lower", 1, SQLITE_UTF16, 0, icuCaseFunc16}, {"lower", 2, SQLITE_UTF16, 0, icuCaseFunc16}, {"upper", 1, SQLITE_UTF16, (void*)1, icuCaseFunc16}, {"upper", 2, SQLITE_UTF16, (void*)1, icuCaseFunc16}, {"lower", 1, SQLITE_UTF8, 0, icuCaseFunc16}, {"lower", 2, SQLITE_UTF8, 0, icuCaseFunc16}, {"upper", 1, SQLITE_UTF8, (void*)1, icuCaseFunc16}, {"upper", 2, SQLITE_UTF8, (void*)1, icuCaseFunc16}, {"like", 2, SQLITE_UTF8, 0, icuLikeFunc}, {"like", 3, SQLITE_UTF8, 0, icuLikeFunc}, {"icu_load_collation", 2, SQLITE_UTF8, (void*)db, icuLoadCollation}, }; int rc = SQLITE_OK; int i; for(i=0; rc==SQLITE_OK && i<(sizeof(scalars)/sizeof(struct IcuScalar)); i++){ struct IcuScalar *p = &scalars[i]; rc = sqlite3_create_function( db, p->zName, p->nArg, p->enc, p->pContext, p->xFunc, 0, 0 ); } return rc; } 
#if !SQLITE_CORE 
SQLITE_API int sqlite3_extension_init( sqlite3 *db, char **pzErrMsg, const sqlite3_api_routines *pApi ){ SQLITE_EXTENSION_INIT2(pApi) return sqlite3IcuInit(db); } 
#endif 
#endif 
#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3) 
#ifdef SQLITE_ENABLE_ICU 
#include <unicode/ubrk.h> 
#include <unicode/utf16.h> 
typedef struct IcuTokenizer IcuTokenizer; typedef struct IcuCursor IcuCursor; struct IcuTokenizer { sqlite3_tokenizer base; char *zLocale; }; struct IcuCursor { sqlite3_tokenizer_cursor base; UBreakIterator *pIter; int nChar; UChar *aChar; int *aOffset; int nBuffer; char *zBuffer; int iToken; }; static int icuCreate( int argc, const char * const *argv, sqlite3_tokenizer **ppTokenizer ){ IcuTokenizer *p; int n = 0; if( argc>0 ){ n = strlen(argv[0])+1; } p = (IcuTokenizer *)sqlite3_malloc(sizeof(IcuTokenizer)+n); if( !p ){ return SQLITE_NOMEM; } memset(p, 0, sizeof(IcuTokenizer)); if( n ){ p->zLocale = (char *)&p[1]; memcpy(p->zLocale, argv[0], n); } *ppTokenizer = (sqlite3_tokenizer *)p; return SQLITE_OK; } static int icuDestroy(sqlite3_tokenizer *pTokenizer){ IcuTokenizer *p = (IcuTokenizer *)pTokenizer; sqlite3_free(p); return SQLITE_OK; } static int icuOpen( sqlite3_tokenizer *pTokenizer, const char *zInput, int nInput, sqlite3_tokenizer_cursor **ppCursor ){ IcuTokenizer *p = (IcuTokenizer *)pTokenizer; IcuCursor *pCsr; const int32_t opt = U_FOLD_CASE_DEFAULT; UErrorCode status = U_ZERO_ERROR; int nChar; UChar32 c; int iInput = 0; int iOut = 0; *ppCursor = 0; if( nInput<0 ){ nInput = strlen(zInput); } nChar = nInput+1; pCsr = (IcuCursor *)sqlite3_malloc( sizeof(IcuCursor) + nChar * sizeof(UChar) + (nChar+1) * sizeof(int) ); if( !pCsr ){ return SQLITE_NOMEM; } memset(pCsr, 0, sizeof(IcuCursor)); pCsr->aChar = (UChar *)&pCsr[1]; pCsr->aOffset = (int *)&pCsr->aChar[nChar]; pCsr->aOffset[iOut] = iInput; U8_NEXT(zInput, iInput, nInput, c); while( c>0 ){ int isError = 0; c = u_foldCase(c, opt); U16_APPEND(pCsr->aChar, iOut, nChar, c, isError); if( isError ){ sqlite3_free(pCsr); return SQLITE_ERROR; } pCsr->aOffset[iOut] = iInput; if( iInput<nInput ){ U8_NEXT(zInput, iInput, nInput, c); }else{ c = 0; } } pCsr->pIter = ubrk_open(UBRK_WORD, p->zLocale, pCsr->aChar, iOut, &status); if( !U_SUCCESS(status) ){ sqlite3_free(pCsr); return SQLITE_ERROR; } pCsr->nChar = iOut; ubrk_first(pCsr->pIter); *ppCursor = (sqlite3_tokenizer_cursor *)pCsr; return SQLITE_OK; } static int icuClose(sqlite3_tokenizer_cursor *pCursor){ IcuCursor *pCsr = (IcuCursor *)pCursor; ubrk_close(pCsr->pIter); sqlite3_free(pCsr->zBuffer); sqlite3_free(pCsr); return SQLITE_OK; } static int icuNext( sqlite3_tokenizer_cursor *pCursor, const char **ppToken, int *pnBytes, int *piStartOffset, int *piEndOffset, int *piPosition ){ IcuCursor *pCsr = (IcuCursor *)pCursor; int iStart = 0; int iEnd = 0; int nByte = 0; while( iStart==iEnd ){ UChar32 c; iStart = ubrk_current(pCsr->pIter); iEnd = ubrk_next(pCsr->pIter); if( iEnd==UBRK_DONE ){ return SQLITE_DONE; } while( iStart<iEnd ){ int iWhite = iStart; U8_NEXT(pCsr->aChar, iWhite, pCsr->nChar, c); if( u_isspace(c) ){ iStart = iWhite; }else{ break; } } assert(iStart<=iEnd); } do { UErrorCode status = U_ZERO_ERROR; if( nByte ){ char *zNew = sqlite3_realloc(pCsr->zBuffer, nByte); if( !zNew ){ return SQLITE_NOMEM; } pCsr->zBuffer = zNew; pCsr->nBuffer = nByte; } u_strToUTF8( pCsr->zBuffer, pCsr->nBuffer, &nByte, &pCsr->aChar[iStart], iEnd-iStart, &status ); } while( nByte>pCsr->nBuffer ); *ppToken = pCsr->zBuffer; *pnBytes = nByte; *piStartOffset = pCsr->aOffset[iStart]; *piEndOffset = pCsr->aOffset[iEnd]; *piPosition = pCsr->iToken++; return SQLITE_OK; } static const sqlite3_tokenizer_module icuTokenizerModule = { 0, icuCreate, icuDestroy, icuOpen, icuClose, icuNext, }; SQLITE_PRIVATE void sqlite3Fts3IcuTokenizerModule( sqlite3_tokenizer_module const**ppModule ){ *ppModule = &icuTokenizerModule; } 
#endif 
#endif 
